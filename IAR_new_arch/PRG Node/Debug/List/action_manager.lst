###############################################################################
#
# IAR C/C++ Compiler V10.10.1.4655 for 8051               17/Feb/2020  14:47:36
# Copyright 2004-2017 IAR Systems AB.
# PC-locked license - IAR Embedded Workbench for 8051
#
#    Core               =  plain
#    Code model         =  banked
#    Data model         =  large
#    Calling convention =  xdata reentrant
#    Constant location  =  data
#    Dptr setup         =  1,16
#                          
#    Source file        =  E:\WMNU\IAR_NEW_ARCH\STACK_CORE_SRC\action_manager.c
#    Command line       =  
#        -f C:\Users\08A4~1\AppData\Local\Temp\EWA18A.tmp
#        (E:\WMNU\IAR_NEW_ARCH\STACK_CORE_SRC\action_manager.c -lc
#        "E:\WMNU\IAR_new_arch\PRG Node\Debug\List" -o
#        "E:\WMNU\IAR_new_arch\PRG Node\Debug\Obj" -e --debug --core=plain
#        --dptr=16,1 --data_model=large --code_model=banked
#        --calling_convention=xdata_reentrant --place_constants=data
#        --nr_virtual_regs 8 --dlib_config "C:\Program Files (x86)\IAR
#        Systems\Embedded Workbench 8.0\8051\LIB\DLIB\dl8051Normal.h"
#        --no_path_in_file_macros -I E:\WMNU\IAR_new_arch\Stack_core_src\ -On
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_cross_call --mfc
#        E:\WMNU\IAR_NEW_ARCH\STACK_CORE_SRC\alarm_timer.c
#        E:\WMNU\IAR_NEW_ARCH\STACK_CORE_SRC\buffer.c
#        E:\WMNU\IAR_NEW_ARCH\STACK_CORE_SRC\coder.c
#        E:\WMNU\IAR_new_arch\Stack_core_src\cpu.c
#        E:\WMNU\IAR_NEW_ARCH\STACK_CORE_SRC\debug.c
#        E:\WMNU\IAR_new_arch\Stack_core_src\dma.c
#        E:\WMNU\IAR_NEW_ARCH\STACK_CORE_SRC\frame.c
#        E:\WMNU\IAR_new_arch\Stack_core_src\led.c
#        E:\WMNU\IAR_NEW_ARCH\STACK_CORE_SRC\llc.c
#        E:\WMNU\IAR_new_arch\Stack_core_src\mac.c "E:\WMNU\IAR_NEW_ARCH\PRG
#        Node\main.c" E:\WMNU\IAR_NEW_ARCH\STACK_CORE_SRC\mem_slots.c
#        E:\WMNU\IAR_NEW_ARCH\STACK_CORE_SRC\mem_utils.c
#        E:\WMNU\IAR_new_arch\Stack_core_src\model.c
#        E:\WMNU\IAR_NEW_ARCH\STACK_CORE_SRC\radio.c
#        E:\WMNU\IAR_new_arch\Stack_core_src\rtc.c
#        E:\WMNU\IAR_NEW_ARCH\STACK_CORE_SRC\sync.c
#        E:\WMNU\IAR_NEW_ARCH\STACK_CORE_SRC\time_manager.c
#        E:\WMNU\IAR_NEW_ARCH\STACK_CORE_SRC\ustimer.c)
#    Locale             =  Russian_Russia.1251
#    List file          =  
#        E:\WMNU\IAR_new_arch\PRG Node\Debug\List\action_manager.lst
#    Object file        =  
#        E:\WMNU\IAR_new_arch\PRG Node\Debug\Obj\action_manager.r51
#
###############################################################################

E:\WMNU\IAR_NEW_ARCH\STACK_CORE_SRC\action_manager.c
      1          #include "action_manager.h"
      2          #include "modules_list.h"
      3          #include "model.h"
      4          #include "debug.h"
      5          
      6          /**
      7          @file
      8          */
      9          
     10          /* Определения */
     11          #define ITEMS_COUNT(name) (sizeof(name)/sizeof(module_s*))
     12          #define RUNNER(array, fun) {\
     13          for (char i = 0; i < ITEMS_COUNT(array); i++){\
     14              ASSERT(array[i]->fun != NULL);\
     15              array[i]->fun();\
     16              }\
     17          };
     18          
     19          
     20          /* Локальные переменные */
     21          static module_s* COLD_MOD[] = COLD_MOD_DEF;
     22          static module_s* HOT_MOD[] = HOT_MOD_DEF;
     23          static module_s* HW_MOD[] = HW_MOD_DEF;
     24          static module_s* SW_MOD[] = SW_MOD_DEF;
     25          static module_s* IRQ_MOD[] = IRQ_MOD_DEF;
     26          
     27          static void (*CALLBACK)(void);
     28          
     29          void AM_set_callback(void (*fn)(void)){
     30            ASSERT(fn);
     31            CALLBACK = fn;
     32          }
     33          
     34          void AM_Callback(void){
     35            ASSERT(CALLBACK);
     36            CALLBACK();
     37          }
     38          
     39          void AM_Cold_start(void){
     40            RUNNER(COLD_MOD, Cold_Start);
     41          }
     42          
     43          void AM_Hot_start(void){
     44            RUNNER(HOT_MOD, Hot_Start);  
     45          }
     46          
     47          void AM_HW_Init(void){
     48            RUNNER(HW_MOD, HW_Init);      
     49          }
     50          
     51          void AM_SW_Init(void){
     52            RUNNER(SW_MOD, SW_Init);
     53          }
     54          
     55          void AM_IRQ_Init(void){
     56            RUNNER(IRQ_MOD, IRQ_Init);
     57          }
     58          
     59          
E:\WMNU\IAR_NEW_ARCH\STACK_CORE_SRC\alarm_timer.c
      1          #include "alarm_timer.h"
      2          #include "time_manager.h"
      3          #include "action_manager.h"
      4          #include "ioCC2530.h"
      5          #include "stdbool.h"
      6          #include "stdint.h"
      7          #include "debug.h"
      8          #include "cpu.h"
      9          
     10          /**
     11          @file
     12          */
     13          
     14          #define MAX_NWTIME (nwtime_t)32767
     15          
     16          static void HW_Init(void);  
     17          static inline void IRQEnable(bool state);
     18          static uint32_t ReadTimer(void);
     19          static inline bool isIRQEnable(void);
     20          static inline uint32_t calcCompareTime(nwtime_t time);
     21          static void loadTimerCompare(uint32_t ticks);
     22          
     23          module_s AT_MODULE = {ALIAS(HW_Init)};
     24          static nwtime_t TOFFSET; 
     25          static uint32_t COMPARE_TIME; //!< Значение в регистре compare
     26          
     27          
     28          static void HW_Init(void){
     29            TOFFSET = 0;
     30            COMPARE_TIME = 0;
     31            IRQEnable(false);
     32          };
     33          
     34          static void SW_Init(void){
     35            TOFFSET = 0;
     36            COMPARE_TIME = 0;
     37            IRQEnable(false);
     38          }; 
     39          
     40          void AT_enable(bool state){
     41            ATOMIC_BLOCK_RESTORE{
     42              IRQEnable(state);
     43            }
     44          };
     45          
     46          nwtime_t AT_interval(nwtime_t beg, nwtime_t end){
     47            return (beg > end) ? (beg - end) : (MAX_NWTIME - beg + end);
     48          }
     49          
     50          void AT_set_time(nwtime_t time){
     51            ASSERT(time <= MAX_NWTIME);
     52            nwtime_t timer = ReadTimer();
     53            TOFFSET = time - timer;
     54            TOFFSET &= 0x7FFF;
     55            // После установки времени нужно изменить compare time в таймере
     56            // Но только в случаи если прерывание активно
     57            if (isIRQEnable())
     58              AT_set_alarm(COMPARE_TIME);
     59          }
     60          
     61          nwtime_t AT_time(void){
     62            uint32_t val = ReadTimer();
     63            // TOFFSET = NETWORK TIME - TIMER
     64            // NETWORK TIME = TIMER + TOFFSET
     65            val +=TOFFSET;
     66            val &= 0x7FFF; // Приводим значения таймера к 0-32767
     67            return val;
     68          }
     69          
     70          /**
     71          @brief Ждем наступления определенного момента времени
     72          */
     73          void AT_wait(nwtime_t time){
     74            ASSERT(time <= MAX_NWTIME);  
     75            static union 
     76            {
     77              uint32_t val;
     78              uint8_t fild[4];
     79            } val;
     80            val.val = 0;
     81            // TOFFSET = NETWORK TIME - TIMER
     82            // NETWORK TIME = TIMER + TOFFSET
     83            // Ждем синхронизацию таймера после пробуждения
     84            while (!(SLEEPSTA & 0x01));
     85            do{
     86              // Соблюдаем порядок чтения регисторов ST  
     87              val.fild[0] = ST0;
     88              val.fild[1] = ST1;
     89              val.fild[2] = ST2;
     90              val.val +=TOFFSET;
     91              val.val &= 0x7FFF; // Приводим значения таймера к 0-32767    
     92            } while (val.val < time);
     93          }
     94          
     95          /**
     96          @brief Разрешение прерываний таймера сна
     97          @params[in] state = true - разрешить обработку прерываний
     98          */
     99          static inline void IRQEnable(bool state){
    100            if (state)
    101              STIE = 1;
    102            else
    103              STIE = 0;
    104          }
    105          
    106          /**
    107          @brief Устанавливает время прерывания
    108          @details Время прерывания устанавливается относительно времени сети
    109          ,к примеру, что бы проснуться в таймслот номер 0, нужно установить ticks = 0.
    110          Процедура учитывает текущее значение таймера и перерасчитывает значение ticks. 
    111          @params[in] ticks время сети в тиках когда нужно проснуться
    112          */
    113          void AT_set_alarm(nwtime_t alarm){
    114            ASSERT(alarm <= MAX_NWTIME);
    115            COMPARE_TIME = alarm; // Сохраняем установленное значение
    116            uint32_t compare_time = calcCompareTime(alarm);
    117            loadTimerCompare(compare_time);
    118            IRQEnable(true);
    119          }
    120          
    121          /**
    122          @brief Вычисляет значение, которое нужно установить в регистр compare таймера.
    123          @params[in] time время сети в тикак
    124          */
    125          static inline uint32_t calcCompareTime(nwtime_t time){   
    126              uint32_t timer = ReadTimer(); // Текущее значение счетчика
    127              //NETWORK TIME = TIMER + TOFFSET  
    128              // Приводим такты к тактам таймера
    129              uint16_t ticks_offset = (time - TOFFSET) & 0x7FFF;
    130              uint32_t cmp_time = timer & ~0x7FFF; // Убираем младшие 15 бит
    131              cmp_time |= ticks_offset; // Вычисляем новое время
    132              if (cmp_time <= timer){
    133                cmp_time += 0x8000;
    134                cmp_time &=0xFFFFFF;
    135              }
    136               LOG_OFF("Timer = %lu, Ticks = %d,CMP = %lu \r\n",
    137                    timer, ticks, cmp_time );
    138              return cmp_time;
    139          }
    140          
    141          /**
    142          @brief Возвращает текущее значение таймера
    143          @return Текущие ticks
    144          */
    145          static uint32_t ReadTimer(void){
    146            static union 
    147            {
    148              uint32_t val;
    149              uint8_t fild[4];
    150            } ret_val;
    151            ret_val.val = 0;
    152            // Ждем синхронизацию таймера после пробуждения
    153            while (!(SLEEPSTA & 0x01));
    154            // Соблюдаем порядок чтения регисторов ST  
    155            ret_val.fild[0] = ST0;
    156            ret_val.fild[1] = ST1;
    157            ret_val.fild[2] = ST2;
    158            return ret_val.val;
    159          }
    160          
    161          /**
    162          @brief Устанавливает время пробуждения микроконтролера
    163          @params[in] ticks 24 битное значение времени пробуждения в ticks
    164          */
    165          static void loadTimerCompare(uint32_t ticks){
    166            union 
    167            {
    168              uint32_t val;
    169              uint8_t fild[4];
    170            } value;
    171            value.val = ticks;
    172            // Ждем разрешения на запись нового значения
    173            while (!(STLOAD & 0x01));
    174            // Регистр ST0 должен быть записан в последнию очередь
    175            ST2 = value.fild[2];
    176            ST1 = value.fild[1];
    177            ST0 = value.fild[0];
    178          }
    179          
    180          /**
    181          @brief Проверка активности прерывания таймера
    182          @return true если прерывание установленно
    183          */
    184          static inline bool isIRQEnable(void){
    185            return STIE;
    186          }
    187          
    188          /**
    189          @brief Обработчик прерывания таймера сна
    190          */
    191          #pragma vector=ST_VECTOR
    192          __interrupt void TimerCompareInterrupt(void){ 
    193            nwtime_t time = AT_time();
    194            // Отключаем прерывание таймера. Забота пользователя его включить
    195            IRQEnable(false); 
    196            TM_IRQ(time); // Передаем управление менеджеру времени
    197            STIF = 0; // Очищаем флаг прерывания
    198          }
E:\WMNU\IAR_NEW_ARCH\STACK_CORE_SRC\buffer.c
      1          #include "debug.h"
      2          #include "macros.h"
      3          #include "frame.h"
      4          #include "stdbool.h"
      5          #include "cpu.h"
      6          #include "list.h"
      7          
      8          #include "action_manager.h"
      9          static void SW_Init(void);
     10          static void IRQ_Init(void);
     11          module_s BF_MODULE = {ALIAS(SW_Init),ALIAS(IRQ_Init)};
     12          
     13          struct node {
     14            struct frame *frame;
     15            struct list_head list ;
     16          };
     17          
     18          static struct node NODE_LIST[MAX_TXRX_BUFF_SIZE];
     19          LIST_HEAD(TX_LIST_HEAD);
     20          LIST_HEAD(RX_LIST_HEAD);
     21          static int TX_BUFF_FRAME_COUNT;
     22          static int RX_BUFF_FRAME_COUNT;
     23          
     24          static void IRQ_Init(void){};
     25          
     26          static void SW_Init(void){
     27            TX_BUFF_FRAME_COUNT = 0;
     28            RX_BUFF_FRAME_COUNT = 0;
     29            INIT_LIST_HEAD(&TX_LIST_HEAD);
     30            INIT_LIST_HEAD(&RX_LIST_HEAD);
     31            
     32            for_each_type(struct node, NODE_LIST, node){
     33              node->frame = NULL;
     34              INIT_LIST_HEAD(&node->list);
     35            }
     36          };
     37          
     38          int BF_rx_busy(){
     39            return RX_BUFF_FRAME_COUNT;
     40          };
     41          
     42          int BF_tx_busy(){
     43            return TX_BUFF_FRAME_COUNT;
     44          }
     45          
     46          int BF_available(){
     47            int summ = RX_BUFF_FRAME_COUNT + TX_BUFF_FRAME_COUNT;
     48            ASSERT(summ <= MAX_TXRX_BUFF_SIZE);
     49            return MAX_TXRX_BUFF_SIZE - summ;
     50          }
     51          
     52          static inline struct node* find_free_node(void){
     53            for_each_type(struct node, NODE_LIST, node)
     54              if (node->frame == NULL){
     55                INIT_LIST_HEAD(&node->list);
     56                return node;
     57              }
     58            return NULL;
     59          };
     60          
     61          static inline bool _push(struct list_head *list, struct frame *frame){
     62            ASSERT(frame != NULL);
     63            struct node *node = find_free_node();
     64            if (!node) // Нет свободных мест
     65              return false;
     66            node->frame = frame;
     67            list_add(&node->list , list);
     68            return true;
     69          };
     70          
     71          bool BF_push_tx(struct frame *frame){
     72            bool res;
     73            ATOMIC_BLOCK_RESTORE{
     74              res = _push(&TX_LIST_HEAD, frame);
     75              if (res)
     76                TX_BUFF_FRAME_COUNT++;
     77            };
     78            return res;
     79          };
     80          
     81          bool BF_push_rx(struct frame *frame){
     82            bool res;
     83            ATOMIC_BLOCK_RESTORE{
     84              res = _push(&RX_LIST_HEAD, frame);
     85              if (res)
     86                RX_BUFF_FRAME_COUNT++;
     87            };
     88            return res;
     89          };
     90          
     91          void* BF_cursor_rx(void){
     92            if (list_empty(&RX_LIST_HEAD)) 
     93              return NULL;
     94            void *ret_val;
     95            ATOMIC_BLOCK_RESTORE{   
     96              struct node *node = list_first_entry(&RX_LIST_HEAD, struct node, list);
     97              ret_val =  node;
     98            }
     99            return ret_val;
    100          }
    101          
    102          void* BF_cursor_tx(void){
    103            if (list_empty(&TX_LIST_HEAD)) 
    104              return NULL;
    105            void *ret_val;
    106            ATOMIC_BLOCK_RESTORE{   
    107              struct node *node = list_first_entry(&TX_LIST_HEAD, struct node, list);
    108              ret_val =  node;
    109            }
    110            return ret_val;
    111          }  
    112          
    113          void* BF_cursor_next(void* cursor){
    114            if (!cursor)
    115              return NULL;
    116            void *ret_val;
    117            ATOMIC_BLOCK_RESTORE{  
    118              struct node *node = (struct node*)(cursor);
    119              struct node *next = list_next_entry(node, struct node, list);
    120              if (node == next)
    121                ret_val = NULL;
    122              else 
    123                ret_val = next;
    124            }
    125            return ret_val;
    126          }
    127          
    128          bool BF_remove(void *cursor){
    129            if (!cursor)
    130              return false;
    131            ATOMIC_BLOCK_RESTORE{
    132              struct node *node = (struct node*)(cursor);    
    133              node->frame = NULL;
    134              list_del(&node->list);    
    135              TX_BUFF_FRAME_COUNT--; 
    136            };  
    137            return true;
    138          }
    139          
    140          struct frame* BF_content(void* cursor){
    141            if (!cursor)
    142              return NULL;
    143            struct node *node = (struct node*)(cursor);
    144            return node->frame;
    145          }
E:\WMNU\IAR_NEW_ARCH\STACK_CORE_SRC\coder.c
      1          #include "coder.h"
      2          #include "ioCC2530.h"
      3          #include "string.h"
      4          #include "ustimer.h" // Для профилирования, Отладка
      5          #include "dma.h"
      6          #include "action_manager.h"
      7          #include "model.h"
      8          #include "mem_utils.h"
      9          
     10          static void HW_Init(void);
     11          module_s CODER_MODULE = {ALIAS(HW_Init)};
     12          
     13          #define AES_START()  {ENCCS |= 0x01;} //!< Запуск выполнения команды  
     14          #define AES_SET_MODE(mode) {ENCCS &= ~0x70; ENCCS |= mode;} //!< Установка режима
     15          #define AES_SET_OPERATION(op) {ENCCS = (ENCCS & ~0x07) | op;} 
     16          #define AES_RDY() (ENCCS & 8) //!< Состояние модуля
     17          
     18          #define BV(n)                   (1 << (n))
     19          #define MIC_2_MICLEN(m)         (BV((m&3)+1) & ~3)
     20          
     21          // Режимы шифрования
     22          #define AES_MODE_CBC            0x00
     23          #define AES_MODE_CFB            0x10
     24          #define AES_MODE_OFB            0x20
     25          #define AES_MODE_CTR            0x30
     26          #define AES_MODE_ECB            0x40
     27          #define AES_MODE_CBCMAC         0x50
     28          
     29          // Операции 
     30          #define AES_ENCRYPT             0x00
     31          #define AES_DECRYPT             0x02
     32          #define AES_LOAD_KEY            0x04
     33          #define AES_LOAD_IV             0x06
     34          
     35          #define ENC_DW 29 // DMA AES тригер запрос загрузки
     36          #define ENC_UP 30 // DMA AES тригер запрос выгрузки
     37          
     38          #define STREAM_ENC_MODE     AES_MODE_OFB //!< Метод шифрования потока данных
     39          
     40          
     41          // Приватные функции
     42          static inline uint8_t generateAuthData(uint8_t *src, uint8_t *nonce, uint8_t c,
     43                                                 uint8_t f, uint8_t lm);
     44          static void CBCMAC_buf_encrypt(uint8_t len, uint8_t *key, uint8_t *mac);
     45          
     46          /**
     47          @brief Локальный буфер для работы режима CCM
     48          @detail 128 длина сообщения. 18 длинна блока B0 и строки состояния.
     49           16 длина дополнения нулями
     50          */
     51          static uint8_t buf[128+18+16]; 
     52          
     53          
     54          typedef struct //!< Структура блока B0 для режима CCM
     55          {
     56            struct 
     57            {
     58              uint8_t L:3;
     59              uint8_t M:3;
     60              uint8_t A_Data:1;
     61            } flag;
     62            uint16_t nonce[9];
     63            uint8_t L_M[6];
     64          } __attribute__((packed)) B0_s;
     65          
     66          typedef struct //!< Структура блока A0 для режима CCM
     67          {
     68            struct 
     69            {
     70              uint8_t L:3;
     71            } flag;
     72            uint8_t nonce[11];
     73            uint8_t ctr;
     74          } __attribute__((packed)) A0_s;
     75          
     76          
     77          
     78          /**
     79          @brief Иницилизация модуля
     80          @detail Модуль использует DMA каналы 0 и 1
     81          */
     82          void HW_Init(void)
     83          {
     84            char STREAM_KEY[16] = DEFAULT_STREAM_KEY;
     85            char STREAM_IV[16] = DEFAULT_STREAM_IV;
     86            char CCM_KEY[16] = DEFAULT_CCM_KEY;
     87            char CCM_IV[16] = DEFAULT_CCM_IV;
     88            MEMCPY(MODEL.AES.STREAM_KEY, STREAM_KEY, 16);
     89            MEMCPY(MODEL.AES.STREAM_IV, STREAM_IV, 16);
     90            MEMCPY(MODEL.AES.CCM_KEY, CCM_KEY, 16);
     91            MEMCPY(MODEL.AES.CCM_IV, CCM_IV, 16);
     92            
     93            //DMA_AES_s DMA_CH[0]; //!< DMA на запись будет DMA[0]
     94            //DMA_AES_s DMA_CH[1]; //!< DMA на чтение DMA_CH[1]
     95            
     96            ST_DEF(DMA_CH[0], DSTADDRH, 0x70); // Пишем данные XENCDI = 0xB1 
     97            ST_DEF(DMA_CH[0], DSTADDRL, 0xB1); //  
     98            ST_DEF(DMA_CH[0], PRIORITY, 0x00); // Низкий приоритет
     99            ST_DEF(DMA_CH[0], M8, 0x00); // Используем 8 бит для счетика длинны
    100            ST_DEF(DMA_CH[0], IRQMASK, 0x00); // Запрещаем генерировать перывания
    101            ST_DEF(DMA_CH[0], DESTINC, 0x00); // Не увеличиваем адресс назначения
    102            ST_DEF(DMA_CH[0], SRCINC, 0x01); // Увеличиваем адресс источника
    103            ST_DEF(DMA_CH[0], TRIG, ENC_DW); // Тригер по загрузке
    104            ST_DEF(DMA_CH[0], WORDSIZE, 0x00); // Копируем по 1 байту
    105            ST_DEF(DMA_CH[0], TMODE, 0x01); //  Блочное копирование по тригеру
    106            ST_DEF(DMA_CH[0], VLEN, 0x00); //  Количество байт определяет поле LEN  
    107            ST_DEF(DMA_CH[0], LENH, 0x00); 
    108            
    109            ST_DEF(DMA_CH[1], SRCADDRH, 0x70); // Читаем данные из X_ENCDO  
    110            ST_DEF(DMA_CH[1], SRCADDRL, 0xB2);  
    111            ST_DEF(DMA_CH[1], PRIORITY, 0x00); // Низкий приоритет
    112            ST_DEF(DMA_CH[1], M8, 0x00); // Используем 8 бит для счетика длинны
    113            ST_DEF(DMA_CH[1], IRQMASK, 0x00); // Запрещаем генерировать перывания
    114            ST_DEF(DMA_CH[1], DESTINC, 0x01); // Увеличиваем адресс назначения
    115            ST_DEF(DMA_CH[1], SRCINC, 0x00); // Не увеличиваем адресс источника
    116            ST_DEF(DMA_CH[1], TRIG, ENC_UP); // Тригер по выгрузке
    117            ST_DEF(DMA_CH[1], WORDSIZE, 0x00); // Копируем по 1 байту
    118            ST_DEF(DMA_CH[1], TMODE, 0x01); //  Блочное копирование по тригеру
    119            ST_DEF(DMA_CH[1], VLEN, 0x00); //  Количество байт определяет поле LEN  
    120            ST_DEF(DMA_CH[1], LENH, 0x00); 
    121          }
    122          
    123          /**
    124          @brief Шифрует/дешифрует поток данных во время радиопередачи. Без проверки MIC
    125          @param[in] enc_mode Режим работы процедуры. true - шифрование.
    126          @param[in] src Указатель на данные подлежащии шифрованию
    127          @param[in] dst Указтель куда будут помещены зашифрованные данные
    128          @param[in] key Указатье на ключ. 16 байт
    129          @param[in] iv  Указатель на вектор иницилизации. 16 байт 
    130          @param[in] len Длинна данных
    131          */
    132          void AES_StreamCoder(bool enc_mode, char *src, char *dst, uint8_t len)
    133          {
    134            // Установим метод кодироваения
    135            AES_SET_MODE(STREAM_ENC_MODE);
    136            uint8_t *key = (uint8_t*)MODEL.AES.STREAM_KEY;  
    137            uint8_t *iv = (uint8_t*)MODEL.AES.STREAM_IV; 
    138            // Загружаем ключ
    139            AES_SET_OPERATION(AES_LOAD_KEY);
    140            ST_DEF(DMA_CH[0], SRCADDRL, LADDR(key));
    141            ST_DEF(DMA_CH[0], SRCADDRH, HADDR(key));
    142            ST_DEF(DMA_CH[0], LENL, 16);
    143            DMAARM |= 0x01;
    144            while(!AES_RDY());
    145            AES_START();
    146            while (DMAARM&0x01);
    147          
    148            // Загружаем IV
    149            AES_SET_OPERATION(AES_LOAD_IV);
    150            ST_DEF(DMA_CH[0], SRCADDRL, LADDR(iv));
    151            ST_DEF(DMA_CH[0], SRCADDRH, HADDR(iv));
    152            ST_DEF(DMA_CH[0], LENL, 16);
    153            DMAARM |= 0x01;
    154            while(!AES_RDY());
    155            AES_START();
    156            while (DMAARM&0x01);
    157          
    158            // Установим необходимую операцию AES
    159            if (enc_mode) 
    160              AES_SET_OPERATION(AES_ENCRYPT)
    161            else 
    162              AES_SET_OPERATION(AES_DECRYPT)
    163            
    164            switch(STREAM_ENC_MODE) 
    165            {
    166            case AES_MODE_ECB: // ECB, CBC не реализованы
    167            case AES_MODE_CBC:
    168              break;
    169            case AES_MODE_CFB:
    170            case AES_MODE_OFB:
    171            case AES_MODE_CTR:
    172              {
    173                // Загрузка блоками по 128 бит с разделением на под-блоки по 32 бита
    174                uint8_t nbrBlocks = len / 16; // Количество целых блоков по 128 бит
    175                uint8_t ptr, sub_ptr; // Смещение
    176                char *download, *upload;
    177                
    178                // Для этих типов шифрования длина блоков по 4 байта
    179                ST_DEF(DMA_CH[0], LENL, 4);
    180                ST_DEF(DMA_CH[1], LENL, 4);
    181                
    182                // Шифруем все целые блоки
    183                for (uint8_t block = 0; block < nbrBlocks; block ++)
    184                {
    185                  ptr = 16 * block;
    186                  while(!AES_RDY());
    187                  AES_START();
    188                  for (uint8_t j = 0; j < 4; j++)
    189                  {
    190                    sub_ptr = ptr + 4*j;
    191                    download = &src[sub_ptr];
    192                    upload = &dst[sub_ptr];
    193                    // Указываем адресс DMA откуда читать данные
    194                    ST_DEF(DMA_CH[0], SRCADDRL, LADDR(download));
    195                    ST_DEF(DMA_CH[0], SRCADDRH, HADDR(download));
    196                    // Указываем адрес DMA куда записывать данные          
    197                    ST_DEF(DMA_CH[1], DSTADDRL, LADDR(upload));
    198                    ST_DEF(DMA_CH[1], DSTADDRH, HADDR(upload));
    199                    // Активируем DMA
    200                    DMAARM |= 0x03;  
    201                    DMAREQ |= 0x01;
    202                    while (DMAARM&0x03);          
    203                  }
    204                }     
    205                // Шифруем последний блок
    206                uint8_t block_len = len % 16; // Размер последнего блока
    207                
    208                // Завершаем работу если блок пустой
    209                if (!block_len)
    210                  return;
    211                
    212                char padding_block[16]; // Блок заполненый нулями
    213                ptr = 16*nbrBlocks; // Смещение на первый байт последнего блока в src
    214                memset(padding_block, 0x00, sizeof(padding_block)); // Заполняем нулями
    215                memcpy(padding_block, &src[ptr], block_len); // Копируем данные
    216                
    217                while(!AES_RDY());
    218                AES_START();
    219                for (uint8_t j = 0; j < 4; j++)
    220                  {
    221                    sub_ptr = 4*j;
    222                    download = &padding_block[sub_ptr];
    223                    // Указываем адресс DMA откуда читать данные
    224                    ST_DEF(DMA_CH[0], SRCADDRL, LADDR(download));
    225                    ST_DEF(DMA_CH[0], SRCADDRH, HADDR(download));
    226                    // Указываем аддрес DMA куда записывать данные          
    227                    ST_DEF(DMA_CH[1], DSTADDRL, LADDR(download));
    228                    ST_DEF(DMA_CH[1], DSTADDRH, HADDR(download));
    229                    // Активируем DMA
    230                    DMAARM |= 0x03;  
    231                    DMAREQ |= 0x01;
    232                    while (DMAARM&0x03);
    233                  }
    234                memcpy(&dst[ptr], padding_block, block_len); // Копируем в src
    235                
    236              } //CASE
    237              
    238              break;
    239            } 
    240          }
    241          
    242          /**
    243          @brief Шифрует/дешифрует поток данных во время радиопередачи. Без проверки MIC
    244          @param[in] enc_mode Режим работы процедуры. true - шифрование.
    245          @param[in] src Указатель на данные подлежащии шифрованию
    246          @param[in] dst Указтель куда будут помещены зашифрованные данные
    247          @param[in] key Указатье на ключ. 16 байт
    248          @param[in] iv  Указатель на вектор иницилизации. 16 байт 
    249          @param[in] len Длинна данных
    250          */
    251          static void CTR_enc_decrypt(bool enc_mode, uint8_t *src, uint8_t *dst, uint8_t *key,
    252                                   uint8_t *iv, uint8_t len)
    253          {
    254            // Установим метод кодироваения
    255            AES_SET_MODE(AES_MODE_CTR);
    256            
    257            // Загружаем ключ
    258            AES_SET_OPERATION(AES_LOAD_KEY);
    259            ST_DEF(DMA_CH[0], SRCADDRL, LADDR(key));
    260            ST_DEF(DMA_CH[0], SRCADDRH, HADDR(key));
    261            ST_DEF(DMA_CH[0], LENL, 16);
    262            DMAARM |= 0x01;
    263            while(!AES_RDY());
    264            AES_START();
    265            while (DMAARM&0x01);
    266          
    267            // Загружаем IV
    268            AES_SET_OPERATION(AES_LOAD_IV);
    269            ST_DEF(DMA_CH[0], SRCADDRL, LADDR(iv));
    270            ST_DEF(DMA_CH[0], SRCADDRH, HADDR(iv));
    271            ST_DEF(DMA_CH[0], LENL, 16);
    272            DMAARM |= 0x01;
    273            while(!AES_RDY());
    274            AES_START();
    275            while (DMAARM&0x01);
    276          
    277            // Установим необходимую операцию AES
    278            if (enc_mode) 
    279              AES_SET_OPERATION(AES_ENCRYPT)
    280            else 
    281              AES_SET_OPERATION(AES_DECRYPT)
    282            
    283            // Загрузка блоками по 128 бит с разделением на под-блоки по 32 бита
    284            uint8_t nbrBlocks = len / 16; // Количество целых блоков по 128 бит
    285            uint8_t ptr, sub_ptr; // Смещение
    286            uint8_t *download, *upload;
    287                
    288            // Для этих типов шифрования длина блоков по 4 байта
    289            ST_DEF(DMA_CH[0], LENL, 4);
    290            ST_DEF(DMA_CH[1], LENL, 4);
    291                
    292            // Шифруем все целые блоки
    293            for (uint8_t block = 0; block < nbrBlocks; block ++)
    294              {
    295                ptr = 16 * block;
    296                while(!AES_RDY());
    297                AES_START();
    298                for (uint8_t j = 0; j < 4; j++)
    299                  {
    300                    sub_ptr = ptr + 4*j;
    301                    download = &src[sub_ptr];
    302                    upload = &dst[sub_ptr];
    303                    // Указываем адресс DMA откуда читать данные
    304                    ST_DEF(DMA_CH[0], SRCADDRL, LADDR(download));
    305                    ST_DEF(DMA_CH[0], SRCADDRH, HADDR(download));
    306                    // Указываем адрес DMA куда записывать данные          
    307                    ST_DEF(DMA_CH[1], DSTADDRL, LADDR(upload));
    308                    ST_DEF(DMA_CH[1], DSTADDRH, HADDR(upload));
    309                    // Активируем DMA
    310                    DMAARM |= 0x03;  
    311                    DMAREQ |= 0x01;
    312                    while (DMAARM&0x03);          
    313                  }
    314              }     
    315              // Шифруем последний блок
    316              uint8_t block_len = len % 16; // Размер последнего блока
    317                
    318              // Завершаем работу если блок пустой
    319              if (!block_len)
    320                return;
    321                
    322              uint8_t padding_block[16]; // Блок заполненый нулями
    323              ptr = 16*nbrBlocks; // Смещение на первый байт последнего блока в src
    324              memset(padding_block, 0x00, sizeof(padding_block)); // Заполняем нулями
    325              memcpy(padding_block, &src[ptr], block_len); // Копируем данные
    326              
    327              while(!AES_RDY());
    328              AES_START();
    329              for (uint8_t j = 0; j < 4; j++)
    330                {
    331                  sub_ptr = 4*j;
    332                  download = &padding_block[sub_ptr];
    333                  // Указываем адресс DMA откуда читать данные
    334                  ST_DEF(DMA_CH[0], SRCADDRL, LADDR(download));
    335                  ST_DEF(DMA_CH[0], SRCADDRH, HADDR(download));
    336                  // Указываем аддрес DMA куда записывать данные          
    337                  ST_DEF(DMA_CH[1], DSTADDRL, LADDR(download));
    338                  ST_DEF(DMA_CH[1], DSTADDRH, HADDR(download));
    339                  // Активируем DMA
    340                  DMAARM |= 0x03;  
    341                  DMAREQ |= 0x01;
    342                  while (DMAARM&0x03);
    343                }
    344              memcpy(&dst[ptr], padding_block, block_len); // Копируем в src
    345          }
    346          
    347          /**
    348          @brief Зашифровывает buf в режиме CBC-MAC с IV = 0
    349          @param[in] len улинна последовательности для вычисления MAC
    350          @param[out] mac указатель на память куда будет записан mac (до 16 байт)
    351          */
    352          static void CBCMAC_buf_encrypt(uint8_t len, uint8_t *key, uint8_t *mac)
    353          {
    354            uint8_t IV[16];
    355            
    356            // Заполняем вектор нулями
    357            memset(IV, 0x00, sizeof(IV));
    358            
    359            // Установим метод кодироваения
    360            AES_SET_MODE(AES_MODE_CBCMAC);  
    361            
    362            { // Сворачиваем код для улучшения чтения
    363            // Загружаем ключ
    364            AES_SET_OPERATION(AES_LOAD_KEY);
    365            ST_DEF(DMA_CH[0], SRCADDRL, LADDR(key));
    366            ST_DEF(DMA_CH[0], SRCADDRH, HADDR(key));
    367            ST_DEF(DMA_CH[0], LENL, 16);
    368            DMAARM |= 0x01;
    369            while(!AES_RDY());
    370            AES_START();
    371            while (DMAARM&0x01);
    372          
    373            // Загружаем IV
    374            AES_SET_OPERATION(AES_LOAD_IV);
    375            ST_DEF(DMA_CH[0], SRCADDRL, LADDR(IV));
    376            ST_DEF(DMA_CH[0], SRCADDRH, HADDR(IV));
    377            ST_DEF(DMA_CH[0], LENL, 16);
    378            DMAARM |= 0x01;
    379            while(!AES_RDY());
    380            AES_START();
    381            while (DMAARM&0x01);
    382            };
    383            
    384            // Устанавливаем операцию шифрования
    385            AES_SET_OPERATION(AES_ENCRYPT);
    386            
    387            // Загрузка блоками по 128 бит
    388            uint8_t nbrBlocks = len / 16; // Количество целых блоков по 128 бит
    389            uint8_t block_len = len % 16; // Размер последнего блока
    390            uint8_t ptr; // Смещение
    391                
    392            // Для этого типа шифрования длина блоков по 16 байт
    393            ST_DEF(DMA_CH[0], LENL, 16);
    394            // Устанавливаем куда будем выгружать вычисленный MAC
    395            ST_DEF(DMA_CH[1], DSTADDRL, LADDR(mac));
    396            ST_DEF(DMA_CH[1], DSTADDRH, HADDR(mac));
    397            ST_DEF(DMA_CH[1], LENL, 16);
    398            
    399            // Шифруем все целые блоки
    400            for (uint8_t block = 0; block < nbrBlocks; block ++)
    401              {
    402                // Последний блок шифруем в режиме CBC при условии что нет блок не 
    403                // кратного 16 байтам.
    404                if (!block_len && (block == nbrBlocks - 1))
    405                  AES_SET_MODE(AES_MODE_CBC);
    406                    
    407                ptr = 16 * block;
    408                while(!AES_RDY());
    409                AES_START();
    410                // Указываем адресс DMA откуда читать данные
    411                ST_DEF(DMA_CH[0], SRCADDRL, LADDR(buf[ptr]));
    412                ST_DEF(DMA_CH[0], SRCADDRH, HADDR(buf[ptr]));
    413                // Активируем DMA
    414                DMAARM |= 0x01;  
    415                // Активируем выгрузку только последнего блока
    416                if (!block_len && (block == nbrBlocks - 1))
    417                  DMAARM |= 0x03;
    418                
    419                DMAREQ |= 0x01;
    420                while (DMAARM&0x03);          
    421               }
    422                 
    423            // Шифруем последний блок в режиме CBC
    424            AES_SET_MODE(AES_MODE_CBC);
    425                    
    426            // Завершаем работу если блок пустой
    427            if (!block_len)
    428              return;
    429                
    430            uint8_t padding_block[16]; // Блок заполненый нулями
    431            ptr = 16*nbrBlocks; // Смещение на первый байт последнего блока в src
    432            memset(padding_block, 0x00, sizeof(padding_block)); // Заполняем нулями
    433            memcpy(padding_block, &buf[ptr], block_len); // Копируем данные
    434                
    435            while(!AES_RDY());
    436            AES_START();
    437            // Указываем адресс DMA откуда читать данные
    438            ST_DEF(DMA_CH[0], SRCADDRL, LADDR(padding_block));
    439            ST_DEF(DMA_CH[0], SRCADDRH, HADDR(padding_block));
    440            // Активируем DMA и выгрузку MAC
    441            DMAARM |= 0x03;  
    442            DMAREQ |= 0x01;
    443            while (DMAARM&0x03);
    444          }
    445          
    446          static inline uint8_t generateAuthData(uint8_t *src, uint8_t *nonce, uint8_t c,
    447                                                 uint8_t f, uint8_t lm)
    448          {
    449            memcpy(buf, nonce,16);
    450            
    451            // Буфер от 0 до 15 байта специальный блок B0
    452            // Настраиваем флаг. У нас длинна 2 байта. nonce 13 байт => L_M = L-1=0x01
    453            buf[0]=  0x01;  
    454            // Если есть данные для авторизации установим A_Data 
    455            if (f > 0)
    456              buf[0] |= 0x40;
    457            
    458            buf[0] |= ((lm - 2) / 2 ) << 3;   // см. документацию M'= (lm-2) / 2;
    459            
    460            // Устанавливаем длинну сообщения
    461            buf[14] = 0x00;
    462            buf[15] = c;
    463            
    464            // Добавляем строку авторизации L(a). если данных нет, то она пустая. f=0
    465            buf[16]= 0;
    466            buf[17]= f;
    467            
    468            // Копируем данные авторизации в буфер
    469            memcpy(&buf[18], src, f);
    470            
    471            // Смещение на следующий байт после данных авторизации.
    472            // Данные авторизации занимают положение в буфере [18, 18+f]
    473            uint8_t ptr_end= 18 + f;
    474            // Заполняем нулями до границы 16 байт  
    475            while (ptr_end & 0x0f)
    476              buf[ptr_end++] = 0x00;
    477            
    478            // Копируем данные для шифрования в буфер после нулей
    479            memcpy(&buf[ptr_end], &src[f], c);
    480            
    481            // Возвращаем размер данных в буфере
    482            return ptr_end+c;
    483          };
    484          
    485          /**
    486          @brief Шифрует/дешифрует данные с проверкой MIC
    487          @param[in] src Указатель на данные подлежащии шифрованию
    488          @param[in] len Размер данных
    489          @param[in] с Количество байт для шифрования
    490          @param[in] f Количество байт для авторизации
    491          @param[in] m Размер MIC (m=1,2,3 l(m) = 4,8,16 байт)
    492          @param[in] iv  Указатель на вектор иницилизации. 16 байт 
    493          @param[in] len Длинна данных
    494          @param[in,out] MIC Указатель на массив соответсвующий длинне (4,8,16 байт)
    495          */
    496          void AES_CCMEncrypt( uint8_t *src, uint8_t c, uint8_t f, uint8_t m, uint8_t *MIC)
    497          {
    498            uint8_t *key = (uint8_t*)MODEL.AES.CCM_KEY;  
    499            uint8_t *nonce = (uint8_t*)MODEL.AES.CCM_IV; 
    500            uint8_t lm = MIC_2_MICLEN(m);
    501            
    502            // Генерируем данные для авторизации
    503            uint8_t dlen = generateAuthData(src, nonce, c, f, lm);
    504            
    505            uint8_t mac[16]; // Сюда пишем мак
    506            CBCMAC_buf_encrypt(dlen, key, mac);
    507            
    508            // Шифруем MAC
    509            uint8_t CTR_IV[16];
    510            memcpy(CTR_IV, nonce, 16);
    511            CTR_IV[0] = 0x01; // Флаг режима CTR
    512            CTR_IV[15] = 0;   // Значение счетчика
    513            CTR_enc_decrypt(true, mac, mac, key, CTR_IV, 16);
    514            
    515            // Шифруем текст. он имеет размер 'c' и находится в буфере начиная с
    516            // dlen-c, dlen
    517            uint8_t ds = dlen - c; // Начало данных для шифрования
    518            
    519            // 0x0F & (16 - (dlen & 0x0f)) оставляет числа от 0 до 15  
    520            memset(buf+dlen, 0x00, 0x0F & (16 - (dlen & 0x0f)) ); // Дополняем нулями
    521            CTR_IV[15] = 1; // Счетчик CTR
    522            CTR_enc_decrypt(true, &buf[ds], &buf[ds], key, CTR_IV, c); // Шифруем
    523            
    524            // Заполняем буфер буфер src. src[0,f] это данные авторизации. 
    525            // src[f, f+c] это шифрованные данные.
    526            memcpy(&src[f], &buf[ds], c); 
    527            memcpy(MIC, mac, lm);
    528            
    529            //https://github.com/zhaohengyi/CC2530Example/blob/
    530            //master/source/components/radios/cc2530/hal_rf_security.c
    531          }
    532          
    533          /**
    534          @brief Дешифрует данные с проверкой MIC
    535          @param[in] src Указатель на данные подлежащии шифрованию
    536          @param[in] len Размер данных
    537          @param[in] с Количество байт для шифрования
    538          @param[in] f Количество байт для авторизации
    539          @param[in] m Размер MIC (m=1,2,3 l(m) = 4,8,16 байт)
    540          @param[in] iv  Указатель на вектор иницилизации. 16 байт 
    541          @param[in] len Длинна данных
    542          @param[in,out] MIC Указатель на массив соответсвующий длинне (4,8,16 байт)
    543          */
    544          bool AES_CCMDecrypt( uint8_t *src, uint8_t c, uint8_t f, uint8_t m, uint8_t *MIC)
    545          {
    546            uint8_t *key = (uint8_t*)MODEL.AES.CCM_KEY;  
    547            uint8_t *nonce = (uint8_t*)MODEL.AES.CCM_IV;  
    548            uint8_t lm = MIC_2_MICLEN(m);
    549            
    550            // Расшифровываем MAC
    551            uint8_t mac[16]; // Расшифрованый мак
    552            uint8_t CTR_IV[16];
    553            memcpy(CTR_IV, nonce, 16);
    554            CTR_IV[0] = 0x01; // Флаг режима CTR
    555            CTR_IV[15] = 0;   // Значение счетчика
    556            CTR_enc_decrypt(false, MIC, mac, key, CTR_IV, lm);  
    557            
    558            // Генерируем данные для авторизации
    559            uint8_t dlen = generateAuthData(src, nonce, c, f, lm);
    560            
    561            // Дешифруем текст. он имеет размер 'c' и находится в буфере начиная с
    562            // dlen-c, dlen
    563            uint8_t ds = dlen - c; // Начало данных для дешифрования
    564            
    565            // 0x0F & (16 - (dlen & 0x0f)) оставляет числа от 0 до 15  
    566            memset(buf+dlen, 0x00, 0x0F & (16 - (dlen & 0x0f)) ); // Дополняем нулями
    567            CTR_IV[15] = 1; // Счетчик CTR
    568            CTR_enc_decrypt(false, &buf[ds], &buf[ds], key, CTR_IV, c); // Дешифруем
    569            
    570            uint8_t new_mac[16]; // мак полученный в ходе рашифровки сообщения
    571            CBCMAC_buf_encrypt(dlen, key, new_mac);
    572            
    573            // Проверяем что маки совпадают, значит дешифровано верно
    574            bool mac_equal = true;
    575            for (uint8_t i = 0 ; i < lm ; i++)
    576            {
    577              if (mac[i] != new_mac[i])
    578              mac_equal = false;
    579              break;
    580            }
    581            
    582            // Выходим если MACи не совпали  
    583            if (!mac_equal)
    584              return false;
    585            
    586            // Копируем  расшифрованные данные
    587            memcpy(&src[f], &buf[ds], c); 
    588            return true;
    589          }
E:\WMNU\IAR_new_arch\Stack_core_src\cpu.c
      1          #include "action_manager.h"
      2          #include "ioCC2530.h"
      3          
      4          /**
      5          @file
      6          */
      7          
      8          static void HW_Init(void);   
      9           
     10          module_s CPU_MODULE = {ALIAS(HW_Init)};
     11          
     12          static void HW_Init(void){
     13            /* Сбрасываем бит OSC32K, будет выбран 32.768 кварц */
     14            CLKCONCMD &= ~(1<<7); 
     15            /* Ждем пока бит не станет 0 */
     16            while (CLKCONSTA & (1<<7)); 
     17            /* Переходим на 32 Мгц */
     18            CLKCONCMD = 0;// (1<<3);
     19            while (CLKCONSTA&(1<<6));
     20            EA = 1;
     21          };  
E:\WMNU\IAR_NEW_ARCH\STACK_CORE_SRC\debug.c
      1          #include "debug.h"
      2          #include "action_manager.h"
      3          
      4          /**
      5          @file
      6          */
      7          
      8          static void HW_Init(void);  
      9          static void uart_init(void);
     10           
     11          module_s DBG_MODULE = {ALIAS(HW_Init)};
     12          
     13          static void HW_Init(void){
     14          #ifndef DEBUG
     15            return;
     16          #endif
     17          #ifdef PRINT_TO_TERMINAL  
     18            uart_init();
     19          #endif
     20          #ifdef SIG_DEBUG
     21            P1DIR |=0x01;
     22            P1_0 |= 0x01;  
     23          #endif
     24          };  
     25          
     26          
     27          void DBG_CORE_HALT(void){
     28            while(1);
     29          }
     30          
     31          void DBG_CORE_FAULT(void){
     32            while(1);
     33          }
     34          
     35          // Настройка порта uart для отладки
     36          static void uart_init(void){
     37            // Выбор расположения UART на выводах
     38            char U0CFG = 0; // 0={TX=P0_3, RX=P0_2
     39            PERCFG |= (U0CFG<<0); 
     40            // U0UCR регистр настройки режима uart. меня устраивает по умолчанию
     41            U0CSR = (1<<7); // Выбираем режим uart  
     42            // Настройка скорости передачи данных на 2М  
     43            U0BAUD = 0;  // табличные значения из pdf
     44            U0GCR =  16;
     45            // Включаем альтернативные функции выводов
     46            P0SEL = (1<<2)|(1<<3);
     47            U0CSR |= (1<<6);
     48          }
     49          
     50          #ifdef PRINT_TO_TERMINAL 
     51          #include <yfuns.h>
     52          _STD_BEGIN
     53          #pragma module_name = "?__write"
     54          
     55          int MyLowLevelPutchar(int x){
     56            while( U0CSR&(1<<0));
     57            U0DBUF = x;
     58            return x;
     59          }
     60          
     61          size_t __write(int handle, const unsigned char * buffer, size_t size){
     62            /* Remove the #if #endif pair to enable the implementation */
     63            size_t nChars = 0;
     64            if (buffer == 0)  {
     65              return 0;
     66            }
     67            /* This template only writes to "standard out" and "standard err",
     68             * for all other file handles it returns failure. */
     69            if (handle != _LLIO_STDOUT && handle != _LLIO_STDERR)  {
     70              return _LLIO_ERROR;
     71            }
     72          
     73            for (/* Empty */; size != 0; --size){
     74              if (MyLowLevelPutchar(*buffer++) < 0){
     75                return _LLIO_ERROR;
     76              }
     77              ++nChars;
     78            }
     79            return nChars;
     80          }
     81          _STD_END
     82          
     83          #endif
     84          
E:\WMNU\IAR_new_arch\Stack_core_src\dma.c
      1          #include "dma.h"
      2          #include "ioCC2530.h"
      3          #include "action_manager.h"
      4          
      5          static void HW_Init(void);
      6          module_s DMA_MODULE = {ALIAS(HW_Init)};
      7          
      8            
      9          DMA_s DMA_CH[5];
     10          
     11          /**
     12          @brief Настройка DMA каналов.
     13          @detail Согласно документации каналы 1-4 идут последовательно
     14          */
     15          static void HW_Init(void){
     16              // Настроим канал 0 DMA для загрузки данных в AES
     17            uint16_t CONF_ADDR = (uint16_t)&DMA_CH[0];
     18            DMA0CFGH = CONF_ADDR >> 8;
     19            DMA0CFGL = CONF_ADDR & 0xFF;
     20            
     21            // Настроим канал 1 DMA для выгрузки данных из AES
     22            CONF_ADDR = (uint16_t)&DMA_CH[1];
     23            DMA1CFGH = CONF_ADDR >> 8;
     24            DMA1CFGL = CONF_ADDR & 0xFF;
     25          }
E:\WMNU\IAR_NEW_ARCH\STACK_CORE_SRC\frame.c
      1          #include "action_manager.h"
      2          #include "frame.h"
      3          #include "debug.h"
      4          #include "global.h"
      5          #include "mem_utils.h"
      6          #include "mem_slots.h"
      7          
      8          /**
      9          @file Статическое хранение принятых пакетов
     10          */
     11          
     12          static void SW_Init(void); 
     13          
     14          module_s FR_MODULE = {ALIAS(SW_Init)};
     15          
     16          static void SW_Init(void){ 
     17          }; 
     18          
     19          struct frame* FR_create(){
     20            return (struct frame*)SL_alloc();
     21          };
     22          
     23          bool FR_delete(struct frame *frame){
     24            return SL_free((char*)frame);
     25          }
     26          
     27          bool FR_add_header(struct frame* frame ,void *head, char len){
     28            int new_len = frame->len + len;
     29            if (!(new_len < MAX_PAYLOAD_SIZE))
     30              return false;
     31            
     32            // Сдвинем данные на размер вставки при необходимости
     33            if (frame->len != 0)
     34              MEMCPY(&frame->payload[len], frame->payload, len);
     35            
     36            // Скопируем новые данные
     37            MEMCPY(frame->payload, head, len);
     38            frame->len = new_len;
     39            return true;
     40          };
     41          
     42          bool FR_del_header(struct frame* frame, char len){
     43            if (len == 0 || len > frame->len )
     44              return false;
     45            MEMCPY(frame->payload, &frame->payload[len], len);
     46            
     47            #ifdef FRAME_FOOTER_DEL
     48            MEMSET(&frame->payload[len], 0, len);
     49            #endif
     50            
     51            frame->len = frame->len - len;;
     52            return true;
     53          }
     54          
     55          int FR_busy(){
     56            return SL_busy();
     57          }
     58          
     59          int FR_available(){
     60            return SL_available();
     61          };
E:\WMNU\IAR_new_arch\Stack_core_src\led.c
      1          #include "action_manager.h"
      2          
      3          static void HW_Init(void);
      4          static void SW_Init(void);
      5          static void Cold_Start(void);
      6          static void Hot_Start(void);
      7          
      8          module_s LED_MODULE = {ALIAS(SW_Init), ALIAS(Cold_Start), 
      9            ALIAS(Hot_Start), ALIAS(HW_Init)};
     10          
     11          static void HW_Init(void){};
     12          static void SW_Init(void){};
     13          static void Cold_Start(void){};
     14          static void Hot_Start(void){};
E:\WMNU\IAR_NEW_ARCH\STACK_CORE_SRC\llc.c
      1          #include "action_manager.h"
      2          #include "buffer.h"
      3          #include "stddef.h"
      4          #include "macros.h"
      5          #include "model.h"
      6          #include "debug.h"
      7          #include "radio.h"
      8          
      9          #define MAX_SLOTS 50
     10          
     11          static void SW_Init(void);
     12          static void Cold_Start(void);
     13          static void Hot_Start(void);
     14          
     15          module_s LLC_MODULE = {ALIAS(SW_Init), ALIAS(Cold_Start), 
     16            ALIAS(Hot_Start)};
     17          
     18          static channel_t OPENSLOTS[MAX_SLOTS];
     19          
     20          static void SW_Init(void){
     21            for_each_type(channel_t, OPENSLOTS, slot)
     22              *slot = 0;
     23          };
     24          
     25          void LLC_open_slot(timeslot_t ts, channel_t ch){
     26            ASSERT(ts > 1 && ts < MAX_SLOTS);
     27            ASSERT(ch >= MIN_CH && ch <= MAX_CH);
     28            OPENSLOTS[ts] = ch;
     29          }
     30          
     31          void LLC_close_slot(timeslot_t ts){
     32            ASSERT(ts > 1 && ts < MAX_SLOTS);
     33            OPENSLOTS[ts] = 0;
     34          }
     35          
     36          static void scheduler_tx(void){
     37            void *cursor = BF_cursor_tx();
     38            if (!cursor)
     39              return;
     40            
     41            struct frame *frame = NULL;
     42            while(!cursor){
     43              frame = BF_content(cursor);
     44              ASSERT(frame->meta.TS != 0);
     45              TM_SetAlarm(frame->meta.TS, 1);  
     46              cursor = BF_cursor_next(cursor);
     47            }
     48          }
     49          
     50          static void scheduler_rx(void){
     51            ASSERT(OPENSLOTS[0] == 0);
     52            for (char i = 1; i < MAX_SLOTS; i++)
     53              if (OPENSLOTS[i])
     54                TM_SetAlarm(i, 1);
     55              else
     56                TM_ClrAlarm(i, 1);
     57          }
     58          
     59          static void Cold_Start(void){
     60          // Планировщик планирует на один суперфрейм в начале ts0
     61            if (MODEL.TM.timeslot != 0)
     62              return;
     63            
     64            scheduler_tx();
     65            scheduler_rx();
     66          };
     67          
     68          static inline bool scan_tx_buffer_by_ts(struct frame *frame, timeslot_t ts){
     69            frame = NULL;
     70            void *cursor = BF_cursor_tx();
     71            if (!cursor)
     72              return false;
     73            do{
     74              frame = BF_content(cursor);
     75              if (frame->meta.TS == 0)
     76                HALT("Depricated slot 0");
     77              if (frame->meta.TS == ts)
     78                return true;
     79              cursor = BF_cursor_next(cursor);
     80            } while(cursor);
     81            return false;
     82          }
     83          
     84          static void receive(void){
     85            // MAC получить
     86            // OPENSLOTS содержит номер канала.0 - слот закрыт
     87            struct frame *frame = NULL;
     88            if (!BF_push_rx(frame))
     89                HALT("BF_push_rx");
     90          }
     91          
     92          static void transmite(void){
     93            timeslot_t ts = MODEL.TM.timeslot;
     94            struct frame *frame = NULL;
     95            if (!scan_tx_buffer_by_ts(frame, ts))
     96              return;
     97            // MAC передать
     98            // void TM_ClrAlarm(timeslot_t slot, alarm_t alarm);
     99            // Нужно как то учитывать неудачных кол-во передач
    100            // frame->tx_attempts
    101          }
    102          
    103          static void Hot_Start(void){
    104            timeslot_t ts = MODEL.TM.timeslot;
    105            if (ts == 0)
    106              return;
    107            
    108            if (OPENSLOTS[ts])
    109              receive();
    110            else 
    111              transmite();
    112          };
E:\WMNU\IAR_new_arch\Stack_core_src\mac.c
      1          #include "action_manager.h"
      2          #include "frame.h"
      3          #include "coder.h"
      4          
      5          static void SW_Init(void);
      6          
      7          
      8          module_s MAC_MODULE = {ALIAS(SW_Init)};
      9          
     10          struct ack{ // Формат структуры пакета ACK
     11            char CRC8;
     12          } __attribute__((packed));
     13          
     14          static void SW_Init(void){};
     15          
     16          void MAC_Send(){
     17          }
     18          
     19          void MAC_Receive(){
     20          }
     21          
     22          static char xor_calc(struct frame *fr){
     23            char crc = 0x34; // Начальное значение
     24            char *val = fr->payload;
     25            for (char i = 0; i < fr->len; i++)
     26              crc ^= val[i];
     27            return crc;
     28          }
     29          // AES_StreamCoder(false, src, src, KEY, IV, size); BitRawDecrypt
     30          // AES_StreamCoder(true, src, src, KEY, IV, size);
E:\WMNU\IAR_NEW_ARCH\PRG Node\main.c
      1          #include "action_manager.h"
      2          #include "time_manager.h"
      3          #include "debug.h"
      4          #include "model.h"
      5          #include "sync.h"
      6          #include "action_manager.h"
      7          
      8          static void callback(void){
      9          }
     10                        
     11          static void pre_init(void){
     12            AM_HW_Init();
     13            AM_SW_Init();
     14            LOG_ON("Hardware inited");
     15            MODEL.SYNC.mode = 1;
     16            MODEL.TM.MODE = 1;
     17            AM_set_callback(callback);
     18          }
     19          
     20          void main(void){
     21            pre_init();
     22            LOG_ON("Node started");
     23            
     24            while (1){
     25              MODEL.SYNC.mode = 1;
     26              MODEL.TM.MODE = 1;
     27              while (!network_sync(1000000U));
     28              LOG_ON("Synced");
     29              Neocore_start();
     30              AM_SW_Init();
     31              LOG_ON("START RESYNC");
     32            }
     33          };
E:\WMNU\IAR_NEW_ARCH\STACK_CORE_SRC\mem_slots.c
      1          #include "debug.h"
      2          #include "global.h"
      3          #include "macros.h"
      4          #include "stdbool.h"
      5          #include "action_manager.h"
      6          #include "mem_utils.h"  
      7          #include "cpu.h"
      8          
      9          //!< Максимальный размер данных в одном слоте
     10          #define SLOT_BUFFER_SIZE 150
     11          #define RED_ZONE_CODE 0x73
     12          
     13          typedef char red_zone_t;
     14          
     15          static void SW_Init(void);
     16          module_s MS_MODULE = {ALIAS(SW_Init)};
     17          
     18          struct property{
     19            char taken: 1;
     20          };
     21          
     22          struct slot{
     23            struct property property;
     24            red_zone_t red_zone_1;
     25            char buffer[SLOT_BUFFER_SIZE];
     26            red_zone_t red_zone_2;
     27          };
     28          
     29          //!< Хранилище слотов
     30          static struct slot SLOT_POOL[SLOT_POOL_ITEMS];
     31          //!< Количество занятых слотов
     32          static int slot_busy;
     33          
     34          void SW_Init(void){
     35            slot_busy = 0;
     36            for_each_type(struct slot, SLOT_POOL, slot){
     37              slot->property.taken = false;
     38              #ifdef FILL_SLOT_ZERO
     39                MEMSET(slot->buffer, 0, SLOT_BUFFER_SIZE);
     40              #endif    
     41              slot->red_zone_1 = RED_ZONE_CODE;
     42              slot->red_zone_2 = RED_ZONE_CODE;
     43            }
     44          };
     45          
     46          /**
     47          @brief Возвращает указатель на буфер или NULL. Буфер заполнен 0
     48          @detail 
     49          */
     50          char* SL_alloc(void){  
     51            char *ret_ptr = NULL;
     52            ATOMIC_BLOCK_RESTORE{
     53              for_each_type(struct slot, SLOT_POOL, slot){
     54                if (!slot->property.taken){
     55                  slot->property.taken = true;
     56                  slot_busy++;
     57                  #ifdef FILL_SLOT_ZERO
     58                    MEMSET(slot->buffer, 0, SLOT_BUFFER_SIZE);
     59                  #endif
     60                  ret_ptr = slot->buffer;
     61                  break;
     62                };
     63              };  
     64            };
     65            return ret_ptr;
     66          };
     67          
     68          static bool _free(char *buff){
     69            struct slot *slot = container_of(buff, struct slot, buffer);
     70            
     71            if (!is_array_ptr(SLOT_POOL, slot, sizeof(struct slot)))
     72              return false;
     73            
     74            size_t index = array_index(SLOT_POOL, slot, sizeof(struct slot));
     75            if (!(index < SLOT_BUFFER_SIZE))
     76              return false;
     77            
     78            if (slot->property.taken != true)
     79              return false;
     80              
     81            slot->property.taken = false;
     82            slot_busy--;
     83            return true;
     84          }
     85          
     86          bool SL_free(char *buff){
     87            bool res;
     88            ATOMIC_BLOCK_RESTORE{
     89              res = _free(buff);
     90            }
     91            return res;
     92          };
     93          
     94          
     95          int SL_busy(){
     96            ASSERT(slot_busy <= SLOT_POOL_ITEMS);
     97            return slot_busy;
     98          };
     99          
    100          int SL_available(){
    101            ASSERT(slot_busy <= SLOT_POOL_ITEMS);  
    102            return SLOT_POOL_ITEMS - slot_busy;
    103          };
    104          
    105          int SL_zone_check(){
    106            int index = 0;
    107            for_each_type(struct slot, SLOT_POOL, slot){
    108              if (!(slot->red_zone_1 == RED_ZONE_CODE &&
    109                    slot->red_zone_2 == RED_ZONE_CODE))
    110                return index;
    111              index++;
    112            }
    113            return -1;
    114          };
    115          
E:\WMNU\IAR_NEW_ARCH\STACK_CORE_SRC\mem_utils.c
      1          #include "mem_utils.h"
      2          #include "debug.h"
      3          
      4          /**
      5          @file Реентерабельное копирование
      6          */
      7          
      8          void MEM_memcpy(struct memcpy *memcpy){
      9            while (memcpy->len > 0){
     10              *memcpy->dst = *memcpy->src;
     11              memcpy->dst++;
     12              memcpy->src++;
     13              memcpy->len--;
     14            }
     15          };
     16          
     17          void MEM_memset(struct memset *memset){
     18            while (memset->len > 0){
     19              *memset->dst = memset->val;
     20              memset->dst++;
     21              memset->len--;
     22            }  
     23          };
     24          
     25          
E:\WMNU\IAR_new_arch\Stack_core_src\model.c
      1          #include "model.h"
      2          #include "action_manager.h"
      3          
      4          /**
      5          @file
      6          */
      7          
      8          MODEL_s MODEL;
      9          
     10            
     11          static void SW_Init(void); 
     12          
     13          module_s MD_MODULE = {ALIAS(SW_Init)};
     14          
     15           
     16          static void SW_Init(void){}; 
     17          
     18          
E:\WMNU\IAR_NEW_ARCH\STACK_CORE_SRC\radio.c
      1          #include "radio.h"
      2          #include "mem_utils.h"
      3          #include "debug.h"
      4          #include "radio_defs.h"
      5          #include "ustimer.h"
      6          #include "frame.h"
      7          #include "string.h"
      8          #include "alarm_timer.h"
      9          #include "model.h"
     10          #include "action_manager.h"
     11          #include "frame.h"
     12          #include "macros.h"
     13          #include "stdlib.h"
     14          
     15          static void HW_Init(void);
     16          static void SW_Init(void);
     17          module_s RADIO_MODULE = {ALIAS(SW_Init), ALIAS(HW_Init)};
     18          
     19          static void random_core_init(void);
     20          static char RXBUFF[128];
     21          
     22          #define IEEE_MODE 0     //!< Режимы фазы сигнала
     23          #define NOT_IEEE_MODE 1 //!< Режимы фазы сигнала
     24          #define RSSI_OFFSET -76 //!< Константа для вычисления реальной мощности
     25          /*!
     26          \details 
     27           Расчет качества связи. Коэффициенты получаются эксперементально.
     28           Есть предположение, что количество ошибок будет пропорционально квадрату
     29           коеффициента корреляции сигнала.
     30           LIQ = 255 передача 1000 пакетов без ошибок CRC
     31           LIQ = 127 передача 1000 пакетов с 50% ошибок CRC
     32           LIQ = 0   передача 1000 пакетов с 100% ошибок CRC
     33          */ 
     34          
     35          #define CONST_A (int8_t)0 //!< Коэффициент A
     36          #define CONST_B (int8_t)1 //!< Коэффициент B
     37          #define LIQ_CALC(corr) ((corr-CONST_A)*CONST_B) //!< Формула вычисление LIQ 
     38          #define FRQ_CALC(x) (11+5*(x-11)) //!< Формул вычисления частоты сигнала
     39          
     40          #ifdef RADIO_DEBUG
     41            #define WRITE_TIME_DBG(where) (where) = AT_time()
     42            #define WRITE_PARA_DBG(where,val) (where) = (val) 
     43          #else
     44            #define WRITE_TIME_DBG(where) {}
     45            #define WRITE_PARA_DBG(where,val)
     46          #endif
     47          
     48          static void SW_Init(void){
     49            // Настройки поумолчанию
     50            MODEL.RADIO.CRCError = 0;
     51            MODEL.RADIO.CCAReject = 0;
     52            MODEL.RADIO.channel = CH11;
     53            MODEL.RADIO.power_tx = m0x5;
     54            // Пост действия с радио
     55            random_core_init();
     56          }
     57          
     58          static void HW_Init(void){
     59            FRMFILT0 = 0x00; // Отключаем фильтрацию пакетов
     60            MDMTEST1_u MDM1; // Устанавливаем режим модуляции
     61            MDM1.value = MDMTEST1;
     62            MDM1.bits.MODULATION_MODE = IEEE_MODE;
     63            MDMTEST1 = MDM1.value;   
     64          }
     65          
     66          static inline void setFreq(channel_t ch)
     67          {
     68            ASSERT( (ch >= MIN_CH) && (ch <= MAX_CH));
     69            // Устанавливаем частоту радиопередатчика
     70            FREQCTRL_u FRQ;
     71            FRQ.value = FRQ_CALC(MODEL.RADIO.channel);
     72            FREQCTRL = FRQ.value;  
     73          }
     74          
     75          static inline void pre_config(void){
     76            setFreq(MODEL.RADIO.channel); 
     77            TXPOWER = MODEL.RADIO.power_tx;
     78          }
     79          
     80          bool RI_SetChannel(channel_t channel){
     81            if (!(channel >= MIN_CH) && (channel <= MAX_CH))
     82              return false;
     83            MODEL.RADIO.channel = channel;
     84            return true;
     85          }
     86          
     87          static void LoadTXData(char *src, size_t len){
     88            ISFLUSHTX(); // Очищаем буфер передатчика
     89            RFD = len + 2; // Поле LEN на два байта больше
     90            for (size_t i = 0 ; i < len; i++)
     91              RFD = src[i];
     92            RFD = 0x00; // Добавляем CRC1,2
     93            RFD = 0x00;
     94          };
     95          
     96          static bool SendData(struct frame *fr){
     97            LoadTXData(fr->payload, fr->len);
     98            
     99            // Прежде чем включать радио нужно подождать
    100            if (fr->meta.SEND_TIME != 0) 
    101                AT_wait(fr->meta.SEND_TIME - 29);
    102            
    103            ISRXON();
    104            WRITE_TIME_DBG(MODEL.RADIO.DEBUG_TX.isrxon);
    105            RFIRQF1 &= ~RFIRQF1_TXDONE;
    106            RFIRQF0 &= ~RFIRQF0_SFD; 
    107            bool result = true;
    108            while(!RSSISTAT);
    109            WRITE_TIME_DBG(MODEL.RADIO.DEBUG_TX.rssistat);
    110            TRY{
    111              if (fr->meta.SEND_TIME != 0) // Отправка в определеное время
    112                AT_wait(fr->meta.SEND_TIME - 13); 
    113              ISTXONCCA();
    114              WRITE_TIME_DBG(MODEL.RADIO.DEBUG_TX.istxoncca);
    115              if (!(FSMSTAT1 & 1<<3)) //SAMPLED_CCA == 0
    116                THROW(1);
    117              // Ждем отправки SFD
    118              while (!(RFIRQF0 & RFIRQF0_SFD));
    119              fr->meta.TIMESTAMP = AT_time();
    120              WRITE_TIME_DBG(MODEL.RADIO.DEBUG_TX.sfd);
    121              // Ждем завершения отправки сообщения
    122              while (!(RFIRQF1 & RFIRQF1_TXDONE));
    123              WRITE_TIME_DBG(MODEL.RADIO.DEBUG_TX.txdone);
    124              
    125            }
    126            CATCH(1){ //SAMPLED_CCA == 0
    127              result = false;
    128            }
    129            FINALLY{
    130              ISRFOFF();
    131            }
    132            ETRY;  
    133            return result;
    134          }
    135          
    136          /*!
    137          \brief Передает данные в эфир
    138          */
    139          bool RI_Send(struct frame *fr){
    140            ASSERT(fr != NULL);
    141            pre_config();
    142            stamp_t start = UST_now();
    143            bool send_res = SendData(fr);
    144            stamp_t stop = UST_now();
    145            //TODO Неверно считает интервал так как при отправке
    146            // sync пакета мы ждем
    147            ustime_t tx_time = UST_interval(start, stop); 
    148            WRITE_PARA_DBG(MODEL.RADIO.DEBUG_TX.fulltime, tx_time);
    149            MODEL.RADIO.UptimeTX += tx_time;
    150            WRITE_PARA_DBG(MODEL.RADIO.DEBUG_TX.ccasampled, send_res);
    151            if (!send_res)
    152              MODEL.RADIO.CCAReject++;
    153            return send_res;
    154          }
    155          
    156          
    157          static void UnLoadRXData(char *src, size_t len){
    158            for (size_t i = 0 ; i < len; i++)
    159              src[i] = RFD;
    160          };
    161          
    162          
    163          static bool RecvData(ustime_t timeout, nwtime_t *sfd_stamp){   
    164            bool recv_result = true;
    165            
    166            ISFLUSHRX();
    167            RFIRQF0 &= ~RFIRQF0_RXPKTDONE;  
    168            RFIRQF0 &= ~RFIRQF0_SFD; 
    169            ISRXON();
    170            WRITE_TIME_DBG(MODEL.RADIO.DEBUG_RX.isrxon);
    171            stamp_t start = UST_now();
    172            TRY{
    173              while(true){
    174                if (UST_time_over(start, timeout))
    175                  THROW(1);
    176                
    177                if ((RFIRQF0 & RFIRQF0_SFD)){ // Принят сигнал SFD
    178                  *sfd_stamp = AT_time(); 
    179                  WRITE_TIME_DBG(MODEL.RADIO.DEBUG_RX.sfd);
    180                  break;
    181                }
    182              }
    183              // Ждем окончания приема пакета
    184              while (!(RFIRQF0 & RFIRQF0_RXPKTDONE));
    185              WRITE_TIME_DBG(MODEL.RADIO.DEBUG_RX.rxdone);
    186            }
    187            CATCH(1){ // Вышло время ожидания
    188              recv_result = false;
    189            }
    190            FINALLY{
    191              ISRFOFF();
    192            }
    193            ETRY;
    194            return recv_result;
    195          }
    196          
    197          /*!
    198          \brief Принимает данные из эфира
    199          \details Функция принимает данные из эфира. Проводит проверку CRC, увеличивает
    200          RI_CRC_ERROR. Отмечает время прихода SFD в тактах сетевого времени .
    201          \param[in] timeout Время ожидания данных в микросекундах
    202          \return Возвращает NULL если данных нет
    203          */
    204          struct frame* RI_Receive(ustime_t timeout){
    205            // Устанавливаем частоту передачи пакета
    206            pre_config();
    207            nwtime_t sfd_stamp;
    208               
    209            // Принимаем пакет 
    210            stamp_t start = UST_now();
    211            bool recv_res = RecvData(timeout, &sfd_stamp);
    212            stamp_t stop = UST_now();
    213            ustime_t rx_time = UST_interval(start, stop); 
    214            WRITE_PARA_DBG(MODEL.RADIO.DEBUG_RX.fulltime, rx_time);
    215            MODEL.RADIO.UptimeRX += rx_time;
    216            WRITE_PARA_DBG(MODEL.RADIO.DEBUG_RX.received, recv_res);
    217            if (!recv_res) // Нет пакета, возвращаем NULL
    218              return NULL;
    219            
    220            uint8_t frame_size = RXFIFOCNT; // Количество принятых данных
    221            
    222            // Минимальный размер FCS1,FCS2 - 2 байта. LEN не включен в подсчет 
    223            if (frame_size <= 2)
    224              return NULL;
    225            
    226            UnLoadRXData(RXBUFF, frame_size);
    227            
    228            int8_t  FCS1 = RXBUFF[frame_size - 2]; // RSSI
    229            uint8_t FCS2 = RXBUFF[frame_size - 1]; // bit7 = CRCOK, bit[6..0] Corr_val
    230            uint8_t LEN_F = RXBUFF[0]; // Поле LEN
    231            
    232            // Проверим поле LEN. Размер данных в заголовке должен совпадать
    233            // с фактической длинной принятых данных
    234            if (LEN_F != frame_size - 1){
    235              MODEL.RADIO.CRCError++;
    236              return NULL;
    237            }
    238            
    239            // Проверим поле CRCOK
    240            if (!(FCS2 && 1<<7)){
    241              MODEL.RADIO.CRCError++;
    242              return NULL;
    243            }
    244            
    245            // Создаем буфер, последнии два байта FCS1,2 и поле LEN не копируем
    246            struct frame *frame = FR_create();
    247            ASSERT(frame);
    248            bool add_h = FR_add_header(frame, &RXBUFF[1], frame_size - 3);
    249            ASSERT(add_h);
    250            
    251            frame->meta.TIMESTAMP = sfd_stamp;
    252            frame->meta.RSSI_SIG =  FCS1 + RSSI_OFFSET;
    253            uint8_t corr = FCS2 & 0x7F;
    254            frame->meta.LIQ = LIQ_CALC(corr);
    255            frame->meta.CH = MODEL.RADIO.channel;
    256            return frame;
    257          }
    258          
    259          
    260          /**
    261          @breif Подссчет количества бит в байте
    262          @return Возвращает количество бит
    263          */
    264          static uint8_t bits_count(uint8_t value) {
    265            int ret = 0;
    266            for ( ; value; value = value >> 1 )
    267              ret += value & 1;
    268            return ret;
    269          }
    270          
    271          /**
    272          @brief Возращает 1 байт случайного числа
    273          @details Радио выдает всего лишь дви бита, нам нужно 8 
    274          */
    275          static inline uint8_t getRNDByte(void)
    276          {
    277            uint8_t val = 0;
    278            val |= RFRND << 0;
    279            val |= RFRND << 2;
    280            val |= RFRND << 4;
    281            val |= RFRND << 6;
    282            return val;
    283          }
    284          
    285          /**
    286          @brief Возвращает случайное число с числом включеных бит от 2 до 6 включительно
    287          @details Случайные числа появляются в регистре с частотой 170нс. Функция 
    288          возвращает гарантированно новое значение. 
    289          @return возвращает случайное число.
    290          */
    291          static inline uint8_t readRandom(void)
    292          {
    293            uint8_t rnd_val = 0;
    294            uint8_t bit_cnt = 0;
    295            while ( bit_cnt <= 2 || bit_cnt >= 6 )
    296            {
    297              rnd_val = getRNDByte();
    298              while (rnd_val == getRNDByte());
    299              rnd_val = getRNDByte();
    300              bit_cnt = bits_count(rnd_val);
    301            }
    302            return rnd_val;
    303          }
    304          
    305          /*!
    306          \brief Иницилизирует ядро генератора случайных чисел данными из эфира
    307          */
    308          static void random_core_init(void)  
    309          {
    310            unsigned int rnd_core = 0;;
    311               
    312            pre_config();
    313            FREQCTRL = 0x00; // Выбираем не используемую частоту
    314          
    315            // TODO По какой то причине OP_EXE не выполняет команду.
    316            // регистра RFST читается как 0xD0. это его состояние при reset
    317            // Включаем демодулятор
    318            ISRXON();
    319            
    320            // Ждем пока статус RSSI_VALID станет true
    321            while(!RSSISTAT);
    322            
    323            // Ждем случайных чисел
    324            while (RFRND == 0);
    325            
    326            // Настраиваем ядро случайного генератора
    327            rnd_core = readRandom();
    328            rnd_core |= (unsigned int)readRandom()<<8;
    329            srand(rnd_core);
    330            
    331            // Выключаем демодулятор
    332            ISRFOFF();
    333            // Первая генерация случайного числа занимает много времени.
    334            // Влияло на работу радио, так как использовались случайные посылки
    335            rand(); 
    336          }
    337          
    338          /**
    339          @brief Измерение мощности сигнала
    340          @details Частота = 2394+fch. fch = [0..113]. 2394MHz to 2507MHz.
    341           Устройство поддерживает частоты до 2507 МГц
    342          @param[in] fch номер ЧАСТОТНОГО канала
    343          @param[in] timeout_ms время сканирования в мс
    344          @param[out] Максимальная мощность сигнала за время сканирования
    345          @return true если успешно
    346          */
    347          bool RI_Measure_POW(char fch, ustime_t timeout, 
    348                              int8_t *RSSI_SIG){
    349            if (fch > 113)
    350              return false;
    351            //(2394+FREQCTRL.FREQ[6:0])
    352            FREQCTRL = fch; // Выбираем не используемую частоту
    353            ISRXON();
    354            while(!RSSISTAT);
    355            FRMCTRL0 |= 1<<4; // включаем ENERGY_SCAN, детектор пикового сигнала
    356            UST_delay(timeout);
    357            int8_t rssi = RSSI + RSSI_OFFSET;
    358            *RSSI_SIG = rssi;
    359            ISRFOFF();
    360            return true;
    361          }
    362          
E:\WMNU\IAR_new_arch\Stack_core_src\rtc.c
      1          #include "action_manager.h"
      2          #include "model.h"
      3           
      4          static void SW_Init(void); 
      5          static void Cold_Start(void);
      6          static void Hot_Start(void);
      7          
      8          module_s RTC_MODULE = {ALIAS(SW_Init), ALIAS(Cold_Start), 
      9            ALIAS(Hot_Start)};
     10           
     11          static void SW_Init(void){}; 
     12          static void Cold_Start(void){};
     13          
     14          
     15          static void Hot_Start(void){
     16            if (MODEL.TM.timeslot != 0)
     17              return;    
     18            MODEL.RTC.uptime++;
     19            MODEL.RTC.rtc++;
     20          };
E:\WMNU\IAR_NEW_ARCH\STACK_CORE_SRC\sync.c
      1          #include "sync.h"
      2          #include "action_manager.h"
      3          #include "radio.h"
      4          #include "model.h"
      5          #include "alarm_timer.h"
      6          #include "debug.h"
      7          #include "frame.h"
      8          #include "coder.h"
      9          #include "stdlib.h"
     10          #include "macros.h"
     11          #include "global.h"
     12          
     13          #define MODE_0 0 // Отклчена модуль синхронизации 
     14          #define MODE_1 1 // Прием, ретрансляция, синхронизация
     15          #define MODE_2 2 // Периодическое вещание
     16          #define SYNC_TS 0 // Слот для синхронизации
     17          #define MAGIC 0x19833891 // Проверка что пакет действительно sync
     18          #define SYNC_TIME 163 // Точное время отправки пакета.nwtime
     19          #define NEG_RECV_OFFSET 33 // nwtime
     20          #define POS_RECV_OFFSET 33 // nwtime
     21          #define SEND_PERIOD 10 // Периодичность отправки пакетов
     22          #define RETRANSMITE_TRY 3 // Кол-во попыток отправки sync
     23          #define PROBABILIT 40 // % вероятность одной попытки отправки 
     24          #define UNSYNC_TIME 60 // Время в секундах рассинхронизации сети
     25          
     26          static void SW_Init(void);
     27          static void Cold_Start(void);
     28          static void Hot_Start(void);
     29          static bool send_sync(void);
     30          static struct frame* recv_sync(void);
     31          static char retransmite;
     32          
     33          module_s SYNC_MODULE = {ALIAS(SW_Init), ALIAS(Cold_Start), 
     34            ALIAS(Hot_Start)};
     35          
     36          struct sync{
     37            char sys_ch;
     38            char tx_power;
     39            char panid;
     40            unsigned long rtc;
     41            unsigned long magic;
     42          } __attribute__((packed));
     43          
     44          static void SW_Init(void){ 
     45            MODEL.SYNC.next_sync_send = 0;
     46            MODEL.SYNC.next_time_recv = 0;
     47            MODEL.SYNC.last_time_recv = 0;
     48            MODEL.SYNC.sys_channel = DEFAULT_SYS_CH;
     49            MODEL.SYNC.sync_channel = DEFAULT_SYNC_CH;
     50            retransmite = 0;
     51          };
     52          
     53          static void Cold_Start(void){
     54          };
     55          
     56          static inline bool validate_sync(struct sync *sync){
     57            bool valid = 
     58              (sync->magic == MAGIC) &&
     59              (sync->panid == MODEL.SYNC.panid);
     60            return valid;
     61          }
     62          
     63          static inline void accept_sync_data(struct sync *sync){
     64            MODEL.RTC.rtc = sync->rtc;
     65          };
     66          
     67          static inline void syncronize_timer(struct frame *frame){
     68            nwtime_t now = AT_time();
     69            // Время прошедшее с момента получения пакета
     70            // RI_Send корректриует время, чтобы SFD был передан в SEND_TIME
     71            // Поэтому нам корректировать ненужно
     72            nwtime_t passed = AT_interval(now, frame->meta.TIMESTAMP);  
     73            AT_set_time(SYNC_TIME + passed);
     74            MODEL.SYNC.sync_err = SYNC_TIME - frame->meta.TIMESTAMP;
     75            LOG_ON("Sync err %d", MODEL.SYNC.sync_err);
     76          };
     77          
     78          static inline void mode_1_receive_process(void){
     79            LOW(PIN1);
     80            struct frame *fr = recv_sync();
     81            if (!fr)
     82              return;
     83            
     84            struct sync *sync = (struct sync*)(fr->payload);
     85            if (!validate_sync(sync)){
     86              FR_delete(fr);
     87              return;
     88            }
     89            syncronize_timer(fr);
     90            accept_sync_data(sync);
     91            FR_delete(fr);
     92            LOG_ON("Sichronize sync RSSI = %d", fr->meta.RSSI_SIG);
     93            retransmite = RETRANSMITE_TRY;
     94            MODEL.SYNC.next_time_recv = MODEL.RTC.uptime + SEND_PERIOD;
     95            MODEL.SYNC.last_time_recv = MODEL.RTC.uptime;   
     96            HIGH(PIN1);
     97          }
     98          
     99          static inline bool _throw_dice(void){
    100            return  ((rand() % 100) <= PROBABILIT) ? true : false;
    101          };
    102          
    103          static inline void mode_1_retransmition_process(void){
    104            retransmite--;
    105            if (!_throw_dice())
    106              return;
    107            send_sync();
    108            retransmite = 0;
    109          }
    110          
    111          static void mode_1_process(){
    112           // Прием, ретрансляция, синхронизация   
    113            if ( MODEL.RTC.uptime >= MODEL.SYNC.next_time_recv)
    114              mode_1_receive_process();
    115            else if(retransmite)
    116              mode_1_retransmition_process();
    117            
    118            if (MODEL.RTC.uptime - MODEL.SYNC.last_time_recv > UNSYNC_TIME){
    119              MODEL.SYNC.synced = false;
    120              MODEL.SYNC.mode = 0;
    121              MODEL.TM.MODE = 0;
    122              LOG_ON("unsynced");
    123            }
    124          }
    125          
    126          static void mode_2_process(){
    127            // Периодическое вещание
    128            if ( MODEL.RTC.uptime < MODEL.SYNC.next_sync_send)
    129              return;
    130            MODEL.SYNC.next_sync_send = MODEL.RTC.uptime + SEND_PERIOD;
    131            LOW(PIN1);
    132            send_sync();
    133            HIGH(PIN1);
    134          }
    135          
    136          static void Hot_Start(void){
    137            if (MODEL.TM.timeslot != SYNC_TS)
    138              return;
    139            switch(MODEL.SYNC.mode){
    140              case MODE_0: break;
    141              case MODE_1: mode_1_process(); break;
    142              case MODE_2: mode_2_process(); break;
    143              default:
    144              HALT("Wrong mode");
    145            }
    146          };
    147          
    148          static struct frame* recv_sync(void){
    149            if(!RI_SetChannel(MODEL.SYNC.sync_channel))
    150              HALT("Wrong channel");
    151            struct frame *frame;
    152            
    153            AT_wait(SYNC_TIME - NEG_RECV_OFFSET);
    154            ustime_t recv_time = NWTIME_TO_US(NEG_RECV_OFFSET + POS_RECV_OFFSET);
    155            TRY{
    156              frame = RI_Receive(recv_time);
    157              if (!frame)
    158                THROW(1);
    159              if (frame->len != sizeof(struct sync))
    160                THROW(2);
    161              AES_StreamCoder(false, frame->payload, frame->payload, frame->len);
    162              return frame;
    163            }
    164            CATCH(1){
                   ^
Warning[Pe111]: statement is unreachable
          detected during compilation of secondary translation unit
                    "E:\WMNU\IAR_NEW_ARCH\STACK_CORE_SRC\sync.c"
    165              return NULL;
    166            }
    167            CATCH(2){
                   ^
Warning[Pe111]: statement is unreachable
          detected during compilation of secondary translation unit
                    "E:\WMNU\IAR_NEW_ARCH\STACK_CORE_SRC\sync.c"
    168              FR_delete(frame);
    169              return NULL;
    170            }
    171            ETRY;
                   ^
Warning[Pe111]: statement is unreachable
          detected during compilation of secondary translation unit
                    "E:\WMNU\IAR_NEW_ARCH\STACK_CORE_SRC\sync.c"
    172            return frame;
    173          }
    174          
    175          static bool send_sync(void){
    176            struct sync sync;
    177            sync.sys_ch = MODEL.SYNC.sys_channel;
    178            sync.tx_power = MODEL.RADIO.power_tx;
    179            sync.panid = MODEL.SYNC.panid;
    180            sync.rtc = MODEL.RTC.rtc;
    181            sync.magic = MAGIC;
    182            
    183            struct frame *fr = FR_create();
    184            ASSERT(fr);
    185            FR_add_header(fr, &sync, sizeof(struct sync));
    186            
    187            fr->meta.SEND_TIME = (nwtime_t)SYNC_TIME;
    188            AES_StreamCoder(true, fr->payload, fr->payload, fr->len);
    189            
    190            bool set_ch_res = RI_SetChannel(MODEL.SYNC.sync_channel);
    191            ASSERT(set_ch_res);
    192            bool res = RI_Send(fr);
    193            FR_delete(fr);
    194            LOG_ON("SYNC sended, res = %d", res);
    195            return res;
    196          }
    197          
    198          static struct frame* network_recv_sync(ustime_t timeout){
    199            if(!RI_SetChannel(MODEL.SYNC.sync_channel))
    200              HALT("Wrong channel");
    201            
    202            struct frame *frame = NULL;
    203            TRY{
    204              frame = RI_Receive(timeout);
    205              if (!frame)
    206                THROW(1);
    207              if (frame->len != sizeof(struct sync))
    208                THROW(2);
    209              AES_StreamCoder(false, frame->payload, frame->payload, frame->len);
    210              return frame;
    211            }
    212            CATCH(1){
                   ^
Warning[Pe111]: statement is unreachable
          detected during compilation of secondary translation unit
                    "E:\WMNU\IAR_NEW_ARCH\STACK_CORE_SRC\sync.c"
    213              return NULL;
    214            }
    215            CATCH(2){
                   ^
Warning[Pe111]: statement is unreachable
          detected during compilation of secondary translation unit
                    "E:\WMNU\IAR_NEW_ARCH\STACK_CORE_SRC\sync.c"
    216              FR_delete(frame);
    217              return NULL;
    218            }
    219            ETRY;
                   ^
Warning[Pe111]: statement is unreachable
          detected during compilation of secondary translation unit
                    "E:\WMNU\IAR_NEW_ARCH\STACK_CORE_SRC\sync.c"
    220            return frame;
    221          }
    222          
    223          bool network_sync(ustime_t timeout){  
    224            stamp_t now = UST_now();
    225            struct frame *frame;
    226            struct sync *sync;
    227            
    228            TRY{
    229              while(true){
    230                if(UST_time_over(now, timeout))
    231                   THROW(1);
    232                
    233                frame = network_recv_sync(timeout);
    234                if (!frame)
    235                   continue;
    236                
    237                sync = (struct sync*)frame->payload;
    238                if (sync->magic != MAGIC){
    239                  FR_delete(frame);
    240                  continue;
    241                }
    242               
    243                syncronize_timer(frame);
    244                
    245                MODEL.SYNC.synced = true;
    246                MODEL.SYNC.sys_channel = sync->sys_ch;
    247                MODEL.SYNC.panid = sync->panid;
    248                MODEL.RADIO.power_tx = sync->tx_power;
    249                MODEL.RTC.rtc = sync->rtc;
    250                
    251                retransmite = RETRANSMITE_TRY;
    252                MODEL.SYNC.next_time_recv = MODEL.RTC.uptime +  SEND_PERIOD ;
    253                MODEL.SYNC.last_time_recv = MODEL.RTC.uptime;     
    254                break;
    255              }
    256            }
    257            CATCH(1){
    258              FR_delete(frame);
    259              return false; // timeout
    260            }
    261            FINALLY{
                   ^
Warning[Pe111]: statement is unreachable
          detected during compilation of secondary translation unit
                    "E:\WMNU\IAR_NEW_ARCH\STACK_CORE_SRC\sync.c"

  static void SW_Init(void){
              ^
"E:\WMNU\IAR_NEW_ARCH\STACK_CORE_SRC\alarm_timer.c",34  Warning[Pe177]: 
          function "SW_Init" was declared but never referenced
          detected during compilation of secondary translation unit
                    "E:\WMNU\IAR_NEW_ARCH\STACK_CORE_SRC\alarm_timer.c"

  static char xor_calc(struct frame *fr){
              ^
"E:\WMNU\IAR_new_arch\Stack_core_src\mac.c",22  Warning[Pe177]: function
          "xor_calc" was declared but never referenced
          detected during compilation of secondary translation unit
                    "E:\WMNU\IAR_new_arch\Stack_core_src\mac.c"
    262              FR_delete(frame);
    263            }
    264            ETRY;
    265            return true;  
    266          }
E:\WMNU\IAR_NEW_ARCH\STACK_CORE_SRC\time_manager.c
      1          #include "time_manager.h"
      2          #include "model.h"
      3          #include "action_manager.h"
      4          #include "debug.h"
      5          #include "cpu.h"
      6          #include "macros.h"
      7          
      8          /**
      9          @file
     10          */
     11          
     12          #define MAX_TIME_SLOTS 50
     13          
     14          #define ACTIVE_INTERVAL (nwtime_t)327 // 9.979 мс
     15          #define SLEEP_INTERVAL (nwtime_t)327  // 9.979 мс
     16          #define UNACCOUNTED 68 // Остаток времени после 50ого интервала.
     17          #define FULL_INTERVAL (ACTIVE_INTERVAL + SLEEP_INTERVAL)
     18          #define SLOT_TO_NWTIME(slot) ((nwtime_t)((slot) * FULL_INTERVAL)) 
     19          #define NWTIME_TO_SLOT(nwtime) ((timeslot_t)((time)/FULL_INTERVAL))
     20           
     21          //!< Список задач менеджера. Индекс - номер слота, значение-действие
     22          static alarm_t ALARMS[MAX_TIME_SLOTS];
     23          
     24          
     25          void TM_SetAlarm(timeslot_t slot, alarm_t alarm){
     26            ASSERT(slot < MAX_TIME_SLOTS);
     27            ALARMS[slot] |= alarm;
     28          }
     29          
     30          void TM_ClrAlarm(timeslot_t slot, alarm_t alarm){
     31            ASSERT(slot < MAX_TIME_SLOTS);
     32            ALARMS[slot] &= (~alarm);
     33          }
     34          
     35          static inline timeslot_t _inc_timeslot(timeslot_t slot){
     36            slot++;
     37            return (slot >= MAX_TIME_SLOTS) ? 0 : slot;
     38          }
     39          
     40          static inline timeslot_t _find_next_active(timeslot_t slot){
     41            slot = _inc_timeslot(slot);
     42            while (slot && !ALARMS[slot])
     43              slot = _inc_timeslot(slot);
     44            return slot;
     45          }
     46          
     47          static void scheulder_next_alarm(nwtime_t time){
     48            timeslot_t slot = NWTIME_TO_SLOT(time);
     49            slot = _find_next_active(slot);
     50            AT_set_alarm(SLOT_TO_NWTIME(slot));
     51          }
     52          
     53          void TM_IRQ(nwtime_t time){
     54            if (MODEL.TM.MODE == 0){
     55              AT_enable(false);
     56              return;
     57            }
     58            
     59            ATOMIC_BLOCK_RESTORE{     
     60              MODEL.TM.timeslot = NWTIME_TO_SLOT(time);
     61              MODEL.TM.time = time;
     62              scheulder_next_alarm(time);
     63              AM_Hot_start();
     64              AM_Cold_start();
     65            };
     66          }
     67          
     68          static inline void mcu_sleep(void){
     69            SLEEPCMD = 2; // Режим PM2
     70            PCON = 1;
     71          }
     72          
     73          static inline void _clr_all(void){
     74            for_each_type(alarm_t, ALARMS, i)
     75              *i = 0;
     76          }
     77          
     78          static void init(void){
     79            _clr_all();
     80            scheulder_next_alarm(0);
     81            AT_enable(true);
     82          }
     83          
     84          static void start_mode_1(void){
     85            AM_IRQ_Init();
     86            init();
     87            LOG_ON("mcu sleep");
     88          //  EA = 1;
     89            while (true){
     90              mcu_sleep();
     91              if (MODEL.TM.MODE == 0){
     92                AT_enable(false);
     93                break;
     94              }
     95              
     96              AM_Callback();    
     97            }  
     98          }
     99          
    100          static void start_mode_2(void){
    101            AM_IRQ_Init();
    102            init();
    103          }
    104          
    105          void Neocore_start(void){
    106            switch (MODEL.TM.MODE){
    107            case 0:
    108              return;
    109            case 1:
    110              start_mode_1();
    111              break;
    112            case 2:
    113              start_mode_2();
    114              break;
    115            default: 
    116              HALT("Incorrect MODEL.TM.MODE");
    117            }
    118          }
E:\WMNU\IAR_NEW_ARCH\STACK_CORE_SRC\ustimer.c
      1          #include "ioCC2530.h"
      2          #include "ustimer.h"
      3          #include "stdint.h"
      4          #include "action_manager.h"
      5          #include "stdbool.h"
      6          
      7          
      8          #define ACCURATE_VAL_US 500 
      9          
     10          // Максимальное кол-во тактов таймера. Константа 40 бит, 5 байт
     11          static const uint32_t MAC_TIMER_MAX = 0xFFFFFFFFUL; 
     12          static uint32_t DELAY_CALIBRATE_TICS; // Калибровка функции задержки
     13          
     14          static void DelayCalibrate(void);
     15          static void HW_Init(void);  
     16          module_s UST_MODULE = {ALIAS(HW_Init)};
     17          
     18          
     19          void HW_Init(void){
     20            // Запускаем таймер, LATCH MODE = 1
     21            // Latch mode фиксирует значение таймера переполнения при чтении T2M0
     22            // ЗАпускаем MAC таймер без синхронизации с кварцем 32.768к
     23            T2CTRL = (1<<0) | (1<<3); 
     24            // Калибровка функции задержки
     25            DelayCalibrate();
     26          }
     27          
     28          ustime_t UST_now(void){
     29            ustime_t now;
     30            ((char*)&now)[0] = T2M0;
     31            ((char*)&now)[1] = T2M1;
     32            ((char*)&now)[2] = T2MOVF0;
     33            ((char*)&now)[3] = T2MOVF1;
     34            return now;
     35          }
     36          
     37          bool UST_time_over(stamp_t beg, ustime_t wait){
     38            stamp_t now = UST_now(); 
     39            ustime_t delta = UST_interval(beg, now);
     40            return (delta > wait) ?  true:false;
     41          }
     42          
     43          ustime_t UST_interval(stamp_t beg, stamp_t end){
     44            return (end >= beg) ? 
     45              TICKS_TO_US(end - beg) :
     46              TICKS_TO_US(MAC_TIMER_MAX - beg + end);
     47          };
     48          
     49          void UST_delay(ustime_t time){
     50            stamp_t now = UST_now();
     51            stamp_t len = US_TO_TICKS(time);
     52            stamp_t offset = (time > DELAY_CALIBRATE_TICS) ?
     53                              DELAY_CALIBRATE_TICS : 0;
     54            while (UST_now() < (now + len - offset));
     55          }
     56          
     57          
     58          stamp_t _interval(stamp_t beg, stamp_t end){
     59            return (end >= beg) ? 
     60              (end - beg) :
     61              (MAC_TIMER_MAX - beg + end);
     62          };
     63          
     64          /**
     65          @brief Калибровка функции задержки TIM_delay
     66          */
     67          static void DelayCalibrate(void){
     68            DELAY_CALIBRATE_TICS = 0;  
     69            stamp_t start = UST_now();
     70            UST_delay(ACCURATE_VAL_US);
     71            stamp_t end = UST_now();
     72            DELAY_CALIBRATE_TICS = _interval(start, end) -
     73                                    US_TO_TICKS(ACCURATE_VAL_US);
     74          };

   Maximum stack usage in bytes:

   ISTACK XSTACK Function
   ------ ------ --------
      1     74   AES_CCMDecrypt
        0     68   -> CBCMAC_buf_encrypt
        0     72   -> CTR_enc_decrypt
        0     70   -> generateAuthData
        0     70   -> memcpy
        0     70   -> memset
      1     58   AES_CCMEncrypt
        0     52   -> CBCMAC_buf_encrypt
        0     56   -> CTR_enc_decrypt
        0     54   -> generateAuthData
        0     54   -> memcpy
        0     54   -> memset
      0    106   AES_StreamCoder
        0     43   -> memcpy
        0     43   -> memset
      0     26   AM_Callback
        0     10   -> DBG_CORE_HALT
        0     10   -> printf
        0     16   -> printf
      0     25   AM_Cold_start
        0     10   -> DBG_CORE_HALT
        0     10   -> printf
        0     16   -> printf
      0     26   AM_HW_Init
        0     10   -> DBG_CORE_HALT
        0     10   -> printf
        0     16   -> printf
      0     25   AM_Hot_start
        0     10   -> DBG_CORE_HALT
        0     10   -> printf
        0     16   -> printf
      0     26   AM_IRQ_Init
        0     10   -> DBG_CORE_HALT
        0     10   -> printf
        0     16   -> printf
      0     26   AM_SW_Init
        0     10   -> DBG_CORE_HALT
        0     10   -> printf
        0     16   -> printf
      0     26   AM_set_callback
        0     10   -> DBG_CORE_HALT
        0     10   -> printf
        0     16   -> printf
      0     19   AT_enable
        0      9   -> IRQEnable
        0      9   -> __cli
      0     14   AT_interval
      0     32   AT_set_alarm
        0     12   -> DBG_CORE_HALT
        0     12   -> IRQEnable
        0     12   -> calcCompareTime
        0     12   -> loadTimerCompare
        0     12   -> printf
        0     18   -> printf
      0     34   AT_set_time
        0     14   -> AT_set_alarm
        0     14   -> DBG_CORE_HALT
        0     14   -> ReadTimer
        0     14   -> isIRQEnable
        0     14   -> printf
        0     20   -> printf
      0     83   AT_time
        0     16   -> ReadTimer
      0     81   AT_wait
        0     12   -> DBG_CORE_HALT
        0     12   -> printf
        0     18   -> printf
      0     16   BF_available
        0     10   -> DBG_CORE_HALT
        0     10   -> printf
        0     16   -> printf
      2     14   BF_content
      0     25   BF_cursor_next
        0     11   -> __cli
      0     10   BF_cursor_rx
        0     10   -> __cli
        0     10   -> list_empty
      0     24   BF_cursor_tx
        0     10   -> __cli
        0     10   -> list_empty
      0     19   BF_push_rx
        0      9   -> __cli
        0      9   -> _push
      0      9   BF_push_tx
        0      9   -> __cli
        0      9   -> _push
      0     11   BF_remove
        0     11   -> __cli
        0     11   -> list_del
      2      0   BF_rx_busy
      2      0   BF_tx_busy
      0    118   CBCMAC_buf_encrypt
        0     50   -> memcpy
        0     50   -> memset
      0    111   CTR_enc_decrypt
        0     39   -> memcpy
        0     39   -> memset
      0      0   Cold_Start
      2      0   Cold_Start
        2      0   -> scheduler_rx
        2      0   -> scheduler_tx
      0      0   Cold_Start
      0      0   Cold_Start
      0      0   DBG_CORE_FAULT
      0     63   DBG_CORE_HALT
      0     24   DelayCalibrate
        0     20   -> UST_delay
        0     20   -> UST_now
        0     24   -> _interval
      1     59   FR_add_header
        0     23   -> MEM_memcpy
      2      0   FR_available
        2      0   -> SL_available
      2      0   FR_busy
        2      0   -> SL_busy
      2     36   FR_create
        2      0   -> SL_alloc
      1     18   FR_del_header
        0     18   -> MEM_memcpy
        0     18   -> MEM_memset
      0     82   FR_delete
        0      9   -> SL_free
      2      0   HW_Init
        2      0   -> IRQEnable
      0      0   HW_Init
      2      0   HW_Init
        2      0   -> uart_init
      0      0   HW_Init
      0      0   HW_Init
      3      1   HW_Init
      2      0   HW_Init
        2      0   -> DelayCalibrate
      2     84   HW_Init
        2     84   -> MEM_memcpy
      0     16   Hot_Start
        0     10   -> DBG_CORE_HALT
        0     10   -> mode_1_process
        0     10   -> mode_2_process
        0     10   -> printf
        0     16   -> printf
      0     12   Hot_Start
      0      9   Hot_Start
        0      9   -> receive
        0      9   -> transmite
      0      0   Hot_Start
      2      9   INIT_LIST_HEAD
      0     15   IRQEnable
      0      0   IRQ_Init
      0     16   LLC_close_slot
        0     10   -> DBG_CORE_HALT
        0     10   -> printf
        0     16   -> printf
      1     16   LLC_open_slot
        0     10   -> DBG_CORE_HALT
        0     10   -> printf
        0     16   -> printf
      2     59   LoadTXData
      0      0   MAC_Receive
      0      0   MAC_Send
      3     84   MEM_memcpy
      3     18   MEM_memset
      0     16   MyLowLevelPutchar
      0     16   Neocore_start
        0     10   -> DBG_CORE_HALT
        0     10   -> printf
        0     16   -> printf
        0     10   -> start_mode_1
        0     10   -> start_mode_2
      1     16   RI_Measure_POW
        0     14   -> UST_delay
      1    105   RI_Receive
        0     36   -> DBG_CORE_HALT
        0     36   -> FR_add_header
        0     36   -> FR_create
        0     38   -> RecvData
        0     40   -> UST_interval
        0     36   -> UST_now
        0     36   -> UnLoadRXData
        0     36   -> pre_config
        0     36   -> printf
        0     42   -> printf
      0     57   RI_Send
        0     30   -> DBG_CORE_HALT
        0     30   -> SendData
        0     34   -> UST_interval
        0     30   -> UST_now
        0     30   -> pre_config
        0     30   -> printf
        0     36   -> printf
      2     63   RI_SetChannel
      2     22   ReadTimer
      0    109   RecvData
        0     67   -> AT_time
        0     67   -> UST_now
        0     71   -> UST_time_over
      0     15   SL_alloc
        0     15   -> MEM_memset
        0     15   -> __cli
      0     16   SL_available
        0     10   -> DBG_CORE_HALT
        0     10   -> printf
        0     16   -> printf
      0     16   SL_busy
        0     10   -> DBG_CORE_HALT
        0     10   -> printf
        0     16   -> printf
      0     18   SL_free
        0      9   -> __cli
        0      9   -> _free
      2      0   SL_zone_check
      0      9   SW_Init
        0      9   -> INIT_LIST_HEAD
      0      0   SW_Init
      0      0   SW_Init
      2      0   SW_Init
      0      0   SW_Init
      0     13   SW_Init
        0     13   -> MEM_memset
      0      0   SW_Init
      2      0   SW_Init
        2      0   -> random_core_init
      0      0   SW_Init
      2      0   SW_Init
      0     89   SendData
        0     59   -> AT_time
        0     59   -> AT_wait
        0     59   -> LoadTXData
      0     26   TM_ClrAlarm
        0     10   -> DBG_CORE_HALT
        0     10   -> printf
        0     16   -> printf
      0     24   TM_IRQ
        0      9   -> AM_Cold_start
        0      9   -> AM_Hot_start
        0      9   -> AT_enable
        0      9   -> __cli
        0      9   -> scheulder_next_alarm
      0     28   TM_SetAlarm
        0     10   -> DBG_CORE_HALT
        0     10   -> printf
        0     16   -> printf
      0     15   TimerCompareInterrupt
        0     15   -> AT_time
        0     15   -> IRQEnable
        0     15   -> TM_IRQ
      0     52   UST_delay
        0     32   -> UST_now
      0     64   UST_interval
      3     77   UST_now
      0    105   UST_time_over
        0     28   -> UST_interval
        0     24   -> UST_now
      3     36   UnLoadRXData
      0      9   __cli
      0     15   __cli
      0      9   __cli
      0     11   __cli
      0     26   __list_add
        0     14   -> __list_add_valid
      0     14   __list_add_valid
      2      9   __list_del
      0     18   __list_del_entry
        0      9   -> __list_del
        0      9   -> __list_del_entry_valid
      0      9   __list_del_entry_valid
      0     18   __write
        0     16   -> MyLowLevelPutchar
      2      0   _clr_all
      0     18   _find_next_active
        0      9   -> _inc_timeslot
      0     23   _free
        0     14   -> array_index
        0     14   -> is_array_ptr
      0      9   _inc_timeslot
      0     48   _interval
      0     29   _push
        0     14   -> DBG_CORE_HALT
        0     14   -> find_free_node
        0     14   -> list_add
        0     14   -> printf
        0     20   -> printf
      0     10   _throw_dice
        0     10   -> rand
      0     23   accept_sync_data
      0     26   array_index
      0      9   bits_count
      2     34   calcCompareTime
        0     22   -> ReadTimer
      0      0   callback
      0     23   find_free_node
        0      9   -> INIT_LIST_HEAD
      0     88   generateAuthData
        0     18   -> memcpy
      2      9   getRNDByte
      2     10   init
        2      0   -> AT_enable
        2      0   -> _clr_all
        2      0   -> scheulder_next_alarm
      0     14   isIRQEnable
      0     26   is_array_ptr
      0     26   list_add
        0     12   -> __list_add
      0     20   list_del
        0      9   -> __list_del_entry
      2     10   list_empty
      0     28   loadTimerCompare
      0      6   main
        0      0   -> AM_SW_Init
        0      0   -> Neocore_start
        0      0   -> network_sync
        0      0   -> pre_init
        0      0   -> printf
        0      6   -> printf
      0     10   mcu_sleep
      2     28   mode_1_process
        0     12   -> mode_1_receive_process
        0     12   -> mode_1_retransmition_process
        0     12   -> printf
        0     18   -> printf
      0     32   mode_1_receive_process
        0     14   -> FR_delete
        0     14   -> accept_sync_data
        0     14   -> printf
        0     16   -> printf
        0     20   -> printf
        0     14   -> recv_sync
        0     14   -> syncronize_timer
        0     14   -> validate_sync
      2     12   mode_1_retransmition_process
        2      0   -> _throw_dice
        2      0   -> send_sync
      0     22   mode_2_process
        0     12   -> send_sync
      0    142   network_recv_sync
        0     63   -> AES_StreamCoder
        0     63   -> DBG_CORE_HALT
        0     63   -> FR_delete
        0     63   -> RI_Receive
        0     63   -> RI_SetChannel
        0     63   -> printf
        0     69   -> printf
      0     77   network_sync
        0     73   -> FR_delete
        0     73   -> UST_now
        0     77   -> UST_time_over
        0     73   -> network_recv_sync
        0     73   -> syncronize_timer
      2     36   pre_config
        2      0   -> setFreq
      0     16   pre_init
        0     10   -> AM_HW_Init
        0     10   -> AM_SW_Init
        0     10   -> AM_set_callback
        0     10   -> printf
        0     16   -> printf
      0      9   random_core_init
        0      9   -> pre_config
        0      9   -> rand
        0      9   -> readRandom
        0      9   -> srand
      0     18   readRandom
        0      9   -> bits_count
        0      9   -> getRNDByte
      0     25   receive
        0     10   -> BF_push_rx
        0     10   -> DBG_CORE_HALT
        0     10   -> printf
        0     16   -> printf
      0     83   recv_sync
        0     63   -> AES_StreamCoder
        0     63   -> AT_wait
        0     63   -> DBG_CORE_HALT
        0     63   -> FR_delete
        0     63   -> RI_Receive
        0     63   -> RI_SetChannel
        0     63   -> printf
        0     69   -> printf
      0     29   scan_tx_buffer_by_ts
        0     14   -> BF_content
        0     14   -> BF_cursor_next
        0     14   -> BF_cursor_tx
        0     14   -> DBG_CORE_HALT
        0     14   -> printf
        0     20   -> printf
      0     16   scheduler_rx
        0     10   -> DBG_CORE_HALT
        0     10   -> TM_ClrAlarm
        0     10   -> TM_SetAlarm
        0     10   -> printf
        0     16   -> printf
      0     18   scheduler_tx
        0     12   -> BF_content
        0     12   -> BF_cursor_next
        0     12   -> BF_cursor_tx
        0     12   -> DBG_CORE_HALT
        0     12   -> TM_SetAlarm
        0     12   -> printf
        0     18   -> printf
      0     18   scheulder_next_alarm
        0      9   -> AT_set_alarm
        0      9   -> _find_next_active
      1     39   send_sync
        0     21   -> AES_StreamCoder
        0     21   -> DBG_CORE_HALT
        0     21   -> FR_add_header
        0     21   -> FR_create
        0     21   -> FR_delete
        0     21   -> RI_Send
        0     21   -> RI_SetChannel
        0     21   -> printf
        0     23   -> printf
        0     27   -> printf
      1     17   setFreq
        0     11   -> DBG_CORE_HALT
        0     11   -> printf
        0     17   -> printf
      0     26   start_mode_1
        0     10   -> AM_Callback
        0     10   -> AM_IRQ_Init
        0     10   -> AT_enable
        0     10   -> init
        0     10   -> mcu_sleep
        0     10   -> printf
        0     16   -> printf
      2     10   start_mode_2
        2      0   -> AM_IRQ_Init
        2      0   -> init
      0     93   syncronize_timer
        0     14   -> AT_interval
        0     14   -> AT_set_time
        0     14   -> AT_time
        0     14   -> printf
        0     16   -> printf
        0     20   -> printf
      0     18   transmite
        0      9   -> scan_tx_buffer_by_ts
      0      0   uart_init
      0     26   validate_sync


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
      13  ?<Constant "%s:%d:%s -> ">
      13  ?<Constant "%s:%d:%s -> ">_1
      13  ?<Constant "%s:%d:%s -> ">_2
      13  ?<Constant "%s:%d:%s -> ">_3
      13  ?<Constant "%s:%d:%s -> ">_4
      13  ?<Constant "%s:%d:%s -> ">_5
      13  ?<Constant "%s:%d:%s -> ">_6
      13  ?<Constant "%s:%d:%s -> ">_7
      13  ?<Constant "%s:%d:%s -> ">_8
      11  ?<Constant "BF_push_rx">
      18  ?<Constant "Depricated slot 0">
      16  ?<Constant "Hardware inited">
      24  ?<Constant "Incorrect MODEL.TM.MODE">
      13  ?<Constant "Node started">
      13  ?<Constant "START RESYNC">
      22  ?<Constant "SYNC sended, res = %d">
      26  ?<Constant "Sichronize sync RSSI ...">
      12  ?<Constant "Sync err %d">
       7  ?<Constant "Synced">
      14  ?<Constant "Wrong channel">
      11  ?<Constant "Wrong mode">
      45  ?<Constant "\"(ch >= MIN_CH) && (c...">
      21  ?<Constant "\"CALLBACK\" Faild! \r\n">
      44  ?<Constant "\"COLD_MOD[i]->Cold_St...">
      42  ?<Constant "\"HOT_MOD[i]->Hot_Star...">
      39  ?<Constant "\"HW_MOD[i]->HW_Init !...">
      41  ?<Constant "\"IRQ_MOD[i]->IRQ_Init...">
      30  ?<Constant "\"OPENSLOTS[0] == 0\" F...">
      39  ?<Constant "\"SW_MOD[i]->SW_Init !...">
      18  ?<Constant "\"add_h\" Faild! \r\n">
      32  ?<Constant "\"alarm <= MAX_NWTIME\"...">
      41  ?<Constant "\"ch >= MIN_CH && ch <...">
      15  ?<Constant "\"fn\" Faild! \r\n">
      23  ?<Constant "\"fr != NULL\" Faild! \r\n">
      15  ?<Constant "\"fr\" Faild! \r\n">
      26  ?<Constant "\"frame != NULL\" Faild...">
      32  ?<Constant "\"frame->meta.TS != 0\"...">
      18  ?<Constant "\"frame\" Faild! \r\n">
      23  ?<Constant "\"set_ch_res\" Faild! \r\n">
      34  ?<Constant "\"slot < MAX_TIME_SLOT...">
      41  ?<Constant "\"slot_busy <= SLOT_PO...">
      39  ?<Constant "\"summ <= MAX_TXRX_BUF...">
      31  ?<Constant "\"time <= MAX_NWTIME\" ...">
      37  ?<Constant "\"ts > 1 && ts < MAX_S...">
       3  ?<Constant "\r\n">
       3  ?<Constant "\r\n">_1
       3  ?<Constant "\r\n">_2
      17  ?<Constant "action_manager.c">
      14  ?<Constant "alarm_timer.c">
       9  ?<Constant "buffer.c">
       6  ?<Constant "llc.c">
       7  ?<Constant "main.c">
      10  ?<Constant "mcu sleep">
      12  ?<Constant "mem_slots.c">
       8  ?<Constant "radio.c">
       7  ?<Constant "sync.c">
      15  ?<Constant "time_manager.c">
       9  ?<Constant "unsynced">
       4  ?<Constant {(char *)0, 0, 0}>
       4  ?<Constant {(char *)0, 150, 0}>
       4  ?<Constant {(char *)0, 150, 0}>_1
       5  ?<Constant {(char *)MODEL.AES.CCM_IV, (char *)
       5  ?<Constant {(char *)MODEL.AES.CCM_KEY, (char *
       5  ?<Constant {(char *)MODEL.AES.STREAM_IV, (char
       5  ?<Constant {(char *)MODEL.AES.STREAM_KEY, (cha
      16  ?<Constant {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11,
      16  ?<Constant {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11,_1
      16  ?<Constant {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11,_2
      16  ?<Constant {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11,_3
      13  ?<Initializer for <Constant "%s:%d:%s -> ">>
      13  ?<Initializer for <Constant "%s:%d:%s -> ">>_1
      13  ?<Initializer for <Constant "%s:%d:%s -> ">>_2
      13  ?<Initializer for <Constant "%s:%d:%s -> ">>_3
      13  ?<Initializer for <Constant "%s:%d:%s -> ">>_4
      13  ?<Initializer for <Constant "%s:%d:%s -> ">>_5
      13  ?<Initializer for <Constant "%s:%d:%s -> ">>_6
      13  ?<Initializer for <Constant "%s:%d:%s -> ">>_7
      13  ?<Initializer for <Constant "%s:%d:%s -> ">>_8
      11  ?<Initializer for <Constant "BF_push_rx">>
      18  ?<Initializer for <Constant "Depricated slot 0
      16  ?<Initializer for <Constant "Hardware inited">
      24  ?<Initializer for <Constant "Incorrect MODEL.T
      13  ?<Initializer for <Constant "Node started">>
      13  ?<Initializer for <Constant "START RESYNC">>
      22  ?<Initializer for <Constant "SYNC sended, res
      26  ?<Initializer for <Constant "Sichronize sync R
      12  ?<Initializer for <Constant "Sync err %d">>
       7  ?<Initializer for <Constant "Synced">>
      14  ?<Initializer for <Constant "Wrong channel">>
      11  ?<Initializer for <Constant "Wrong mode">>
      45  ?<Initializer for <Constant "\"(ch >= MIN_CH)
      21  ?<Initializer for <Constant "\"CALLBACK\" Fail
      44  ?<Initializer for <Constant "\"COLD_MOD[i]->Co
      42  ?<Initializer for <Constant "\"HOT_MOD[i]->Hot
      39  ?<Initializer for <Constant "\"HW_MOD[i]->HW_I
      41  ?<Initializer for <Constant "\"IRQ_MOD[i]->IRQ
      30  ?<Initializer for <Constant "\"OPENSLOTS[0] ==
      39  ?<Initializer for <Constant "\"SW_MOD[i]->SW_I
      18  ?<Initializer for <Constant "\"add_h\" Faild!
      32  ?<Initializer for <Constant "\"alarm <= MAX_NW
      41  ?<Initializer for <Constant "\"ch >= MIN_CH &&
      15  ?<Initializer for <Constant "\"fn\" Faild! \r\
      23  ?<Initializer for <Constant "\"fr != NULL\" Fa
      15  ?<Initializer for <Constant "\"fr\" Faild! \r\
      26  ?<Initializer for <Constant "\"frame != NULL\"
      32  ?<Initializer for <Constant "\"frame->meta.TS
      18  ?<Initializer for <Constant "\"frame\" Faild!
      23  ?<Initializer for <Constant "\"set_ch_res\" Fa
      34  ?<Initializer for <Constant "\"slot < MAX_TIME
      41  ?<Initializer for <Constant "\"slot_busy <= SL
      39  ?<Initializer for <Constant "\"summ <= MAX_TXR
      31  ?<Initializer for <Constant "\"time <= MAX_NWT
      37  ?<Initializer for <Constant "\"ts > 1 && ts <
       3  ?<Initializer for <Constant "\r\n">>
       3  ?<Initializer for <Constant "\r\n">>_1
       3  ?<Initializer for <Constant "\r\n">>_2
      17  ?<Initializer for <Constant "action_manager.c"
      14  ?<Initializer for <Constant "alarm_timer.c">>
       9  ?<Initializer for <Constant "buffer.c">>
       6  ?<Initializer for <Constant "llc.c">>
       7  ?<Initializer for <Constant "main.c">>
      10  ?<Initializer for <Constant "mcu sleep">>
      12  ?<Initializer for <Constant "mem_slots.c">>
       8  ?<Initializer for <Constant "radio.c">>
       7  ?<Initializer for <Constant "sync.c">>
      15  ?<Initializer for <Constant "time_manager.c">>
       9  ?<Initializer for <Constant "unsynced">>
       4  ?<Initializer for <Constant {(char *)0, 0, 0}>
       4  ?<Initializer for <Constant {(char *)0, 150, 0
       4  ?<Initializer for <Constant {(char *)0, 150, 0_1
       5  ?<Initializer for <Constant {(char *)MODEL.AES
       5  ?<Initializer for <Constant {(char *)MODEL.AES_1
       5  ?<Initializer for <Constant {(char *)MODEL.AES_2
       5  ?<Initializer for <Constant {(char *)MODEL.AES_3
      16  ?<Initializer for <Constant {1, 2, 3, 4, 5, 6,
      16  ?<Initializer for <Constant {1, 2, 3, 4, 5, 6,_1
      16  ?<Initializer for <Constant {1, 2, 3, 4, 5, 6,_2
      16  ?<Initializer for <Constant {1, 2, 3, 4, 5, 6,_3
      10  ?<Initializer for AT_MODULE>
      10  ?<Initializer for BF_MODULE>
      10  ?<Initializer for CODER_MODULE>
       6  ?<Initializer for COLD_MOD>
      10  ?<Initializer for CPU_MODULE>
      10  ?<Initializer for DBG_MODULE>
      10  ?<Initializer for DMA_MODULE>
      10  ?<Initializer for FR_MODULE>
       8  ?<Initializer for HOT_MOD>
      16  ?<Initializer for HW_MOD>
       2  ?<Initializer for IRQ_MOD>
      10  ?<Initializer for LED_MODULE>
      10  ?<Initializer for LLC_MODULE>
      10  ?<Initializer for MAC_MODULE>
       4  ?<Initializer for MAC_TIMER_MAX>
      10  ?<Initializer for MD_MODULE>
      10  ?<Initializer for MS_MODULE>
      10  ?<Initializer for RADIO_MODULE>
      10  ?<Initializer for RTC_MODULE>
       4  ?<Initializer for RX_LIST_HEAD>
      16  ?<Initializer for SW_MOD>
      10  ?<Initializer for SYNC_MODULE>
       4  ?<Initializer for TX_LIST_HEAD>
      10  ?<Initializer for UST_MODULE>
       4  ?<Initializer for __Constant_19833891>
       4  ?<Initializer for __Constant_1>
       4  ?<Initializer for __Constant_1f4>
       4  ?<Initializer for __Constant_20>
       4  ?<Initializer for __Constant_3d>
       4  ?<Initializer for __Constant_7fff>
       4  ?<Initializer for __Constant_8000>
       4  ?<Initializer for __Constant_a>
       4  ?<Initializer for __Constant_f4240>
       4  ?<Initializer for __Constant_ffff8000>
       4  ?<Initializer for __Constant_ffffc180>
       4  ?<Initializer for __Constant_ffffff>
      16  ?<Initializer for __FUNCTION__>
      12  ?<Initializer for __FUNCTION__>_1
      13  ?<Initializer for __FUNCTION__>_10
       6  ?<Initializer for __FUNCTION__>_11
      14  ?<Initializer for __FUNCTION__>_12
      15  ?<Initializer for __FUNCTION__>_13
      13  ?<Initializer for __FUNCTION__>_14
      13  ?<Initializer for __FUNCTION__>_15
      21  ?<Initializer for __FUNCTION__>_16
       8  ?<Initializer for __FUNCTION__>_17
       9  ?<Initializer for __FUNCTION__>_18
       5  ?<Initializer for __FUNCTION__>_19
      14  ?<Initializer for __FUNCTION__>_2
       8  ?<Initializer for __FUNCTION__>_20
      13  ?<Initializer for __FUNCTION__>_21
       8  ?<Initializer for __FUNCTION__>_22
       8  ?<Initializer for __FUNCTION__>_23
      11  ?<Initializer for __FUNCTION__>_24
      17  ?<Initializer for __FUNCTION__>_25
      23  ?<Initializer for __FUNCTION__>_26
      15  ?<Initializer for __FUNCTION__>_27
      10  ?<Initializer for __FUNCTION__>_28
      10  ?<Initializer for __FUNCTION__>_29
      13  ?<Initializer for __FUNCTION__>_3
      10  ?<Initializer for __FUNCTION__>_30
      18  ?<Initializer for __FUNCTION__>_31
      12  ?<Initializer for __FUNCTION__>_32
      12  ?<Initializer for __FUNCTION__>_33
      13  ?<Initializer for __FUNCTION__>_34
      14  ?<Initializer for __FUNCTION__>_35
      11  ?<Initializer for __FUNCTION__>_4
      11  ?<Initializer for __FUNCTION__>_5
      12  ?<Initializer for __FUNCTION__>_6
      12  ?<Initializer for __FUNCTION__>_7
       8  ?<Initializer for __FUNCTION__>_8
      13  ?<Initializer for __FUNCTION__>_9
     482  AES_CCMDecrypt
       6  AES_CCMDecrypt::?relay
     452  AES_CCMEncrypt
       6  AES_CCMEncrypt::?relay
     632  AES_StreamCoder
       6  AES_StreamCoder::?relay
      50  ALARMS
      91  AM_Callback
       6  AM_Callback::?relay
     198  AM_Cold_start
       6  AM_Cold_start::?relay
     186  AM_HW_Init
       6  AM_HW_Init::?relay
     198  AM_Hot_start
       6  AM_Hot_start::?relay
     191  AM_IRQ_Init
       6  AM_IRQ_Init::?relay
     190  AM_SW_Init
       6  AM_SW_Init::?relay
      81  AM_set_callback
       6  AM_set_callback::?relay
      10  AT_MODULE
      43  AT_enable
       6  AT_enable::?relay
      34  AT_interval
       6  AT_interval::?relay
     130  AT_set_alarm
       6  AT_set_alarm::?relay
     144  AT_set_time
       6  AT_set_time::?relay
      55  AT_time
       6  AT_time::?relay
     178  AT_wait
       6  AT_wait::?relay
      10  BF_MODULE
     106  BF_available
       6  BF_available::?relay
      34  BF_content
       6  BF_content::?relay
      91  BF_cursor_next
       6  BF_cursor_next::?relay
      77  BF_cursor_rx
       6  BF_cursor_rx::?relay
      77  BF_cursor_tx
       6  BF_cursor_tx::?relay
      69  BF_push_rx
       6  BF_push_rx::?relay
      69  BF_push_tx
       6  BF_push_tx::?relay
      85  BF_remove
       6  BF_remove::?relay
      19  BF_rx_busy
       6  BF_rx_busy::?relay
      19  BF_tx_busy
       6  BF_tx_busy::?relay
       2  CALLBACK
     469  CBCMAC_buf_encrypt
       6  CBCMAC_buf_encrypt::?relay
       1  CLKCONCMD
       1  CLKCONSTA
      10  CODER_MODULE
       6  COLD_MOD
       4  COMPARE_TIME
      10  CPU_MODULE
     608  CTR_enc_decrypt
       6  CTR_enc_decrypt::?relay
       3  Cold_Start
       3  Cold_Start
       3  Cold_Start
      23  Cold_Start
       6  Cold_Start::?relay
       6  Cold_Start::?relay
       6  Cold_Start::?relay
       6  Cold_Start::?relay
       2  DBG_CORE_FAULT
       6  DBG_CORE_FAULT::?relay
       2  DBG_CORE_HALT
       6  DBG_CORE_HALT::?relay
      10  DBG_MODULE
       4  DELAY_CALIBRATE_TICS
       1  DMA0CFGH
       1  DMA0CFGL
       1  DMA1CFGH
       1  DMA1CFGL
       1  DMAARM
       1  DMAREQ
      40  DMA_CH
      10  DMA_MODULE
     115  DelayCalibrate
       6  DelayCalibrate::?relay
       1  ENCCS
      10  FR_MODULE
     214  FR_add_header
       6  FR_add_header::?relay
      14  FR_available
       6  FR_available::?relay
      14  FR_busy
       6  FR_busy::?relay
      14  FR_create
       6  FR_create::?relay
     181  FR_del_header
       6  FR_del_header::?relay
      21  FR_delete
       6  FR_delete::?relay
       8  HOT_MOD
       3  HW_Init
      17  HW_Init
      19  HW_Init
      23  HW_Init
      37  HW_Init
      44  HW_Init
      63  HW_Init
     409  HW_Init
       6  HW_Init::?relay
       6  HW_Init::?relay
       6  HW_Init::?relay
       6  HW_Init::?relay
       6  HW_Init::?relay
       6  HW_Init::?relay
       6  HW_Init::?relay
       6  HW_Init::?relay
      16  HW_MOD
       3  Hot_Start
      43  Hot_Start
      48  Hot_Start
      95  Hot_Start
       6  Hot_Start::?relay
       6  Hot_Start::?relay
       6  Hot_Start::?relay
       6  Hot_Start::?relay
      31  INIT_LIST_HEAD
       6  INIT_LIST_HEAD::?relay
      17  IRQEnable
       6  IRQEnable::?relay
       3  IRQ_Init
       6  IRQ_Init::?relay
       2  IRQ_MOD
      10  LED_MODULE
      10  LLC_MODULE
      96  LLC_close_slot
       6  LLC_close_slot::?relay
     168  LLC_open_slot
       6  LLC_open_slot::?relay
      54  LoadTXData
       6  LoadTXData::?relay
      10  MAC_MODULE
       3  MAC_Receive
       6  MAC_Receive::?relay
       3  MAC_Send
       6  MAC_Send::?relay
       4  MAC_TIMER_MAX
      10  MD_MODULE
     116  MEM_memcpy
       6  MEM_memcpy::?relay
      79  MEM_memset
       6  MEM_memset::?relay
     149  MODEL
      10  MS_MODULE
      12  MyLowLevelPutchar
       6  MyLowLevelPutchar::?relay
     120  NODE_LIST
      89  Neocore_start
       6  Neocore_start::?relay
      50  OPENSLOTS
       1  P0SEL
       1  P1DIR
       1  PCON
       1  PERCFG
      10  RADIO_MODULE
       1  RFD
       1  RFIRQF0
       1  RFIRQF1
       1  RFST
      96  RI_Measure_POW
       6  RI_Measure_POW::?relay
     601  RI_Receive
       6  RI_Receive::?relay
     256  RI_Send
       6  RI_Send::?relay
      32  RI_SetChannel
       6  RI_SetChannel::?relay
      10  RTC_MODULE
     128  RXBUFF
       2  RX_BUFF_FRAME_COUNT
       4  RX_LIST_HEAD
      59  ReadTimer
       6  ReadTimer::?relay
     203  RecvData
       6  RecvData::?relay
       1  SLEEPCMD
       1  SLEEPSTA
    3060  SLOT_POOL
     155  SL_alloc
       6  SL_alloc::?relay
     100  SL_available
       6  SL_available::?relay
      91  SL_busy
       6  SL_busy::?relay
      49  SL_free
       6  SL_free::?relay
      76  SL_zone_check
       6  SL_zone_check::?relay
       1  ST0
       1  ST1
       1  ST2
       1  STLOAD
       3  SW_Init
       3  SW_Init
       3  SW_Init
       3  SW_Init
       3  SW_Init
      34  SW_Init
      62  SW_Init
      83  SW_Init
      87  SW_Init
     117  SW_Init
       6  SW_Init::?relay
       6  SW_Init::?relay
       6  SW_Init::?relay
       6  SW_Init::?relay
       6  SW_Init::?relay
       6  SW_Init::?relay
       6  SW_Init::?relay
       6  SW_Init::?relay
       6  SW_Init::?relay
       6  SW_Init::?relay
      16  SW_MOD
      10  SYNC_MODULE
     283  SendData
       6  SendData::?relay
       1  T2CTRL
       1  T2M0
       1  T2M1
       1  T2MOVF0
       1  T2MOVF1
      95  TM_ClrAlarm
       6  TM_ClrAlarm::?relay
      88  TM_IRQ
       6  TM_IRQ::?relay
      92  TM_SetAlarm
       6  TM_SetAlarm::?relay
       2  TOFFSET
       2  TX_BUFF_FRAME_COUNT
       4  TX_LIST_HEAD
      37  TimerCompareInterrupt
       3  TimerCompareInterrupt::??INTVEC 43
       1  U0BAUD
       1  U0CSR
       1  U0DBUF
       1  U0GCR
      10  UST_MODULE
     191  UST_delay
       6  UST_delay::?relay
     141  UST_interval
       6  UST_interval::?relay
      79  UST_now
       6  UST_now::?relay
     108  UST_time_over
       6  UST_time_over::?relay
      44  UnLoadRXData
       6  UnLoadRXData::?relay
       1  _A_IEN0
       1  _A_IRCON
       1  _A_P1
       4  __Constant_1
       4  __Constant_19833891
       4  __Constant_1f4
       4  __Constant_20
       4  __Constant_3d
       4  __Constant_7fff
       4  __Constant_8000
       4  __Constant_a
       4  __Constant_f4240
       4  __Constant_ffff8000
       4  __Constant_ffffc180
       4  __Constant_ffffff
       7  __cli
       7  __cli
       7  __cli
       7  __cli
       6  __cli::?relay
       6  __cli::?relay
       6  __cli::?relay
       6  __cli::?relay
     101  __list_add
       6  __list_add::?relay
       4  __list_add_valid
       6  __list_add_valid::?relay
      31  __list_del
       6  __list_del::?relay
      46  __list_del_entry
       6  __list_del_entry::?relay
       4  __list_del_entry_valid
       6  __list_del_entry_valid::?relay
     156  __write
       6  __write::?relay
      34  _clr_all
       6  _clr_all::?relay
      50  _find_next_active
       6  _find_next_active::?relay
     136  _free
       6  _free::?relay
      18  _inc_timeslot
       6  _inc_timeslot::?relay
     127  _interval
       6  _interval::?relay
     123  _push
       6  _push::?relay
      52  _throw_dice
       6  _throw_dice::?relay
      26  accept_sync_data
       6  accept_sync_data::?relay
      48  array_index
       6  array_index::?relay
      34  bits_count
       6  bits_count::?relay
     162  buf
     189  calcCompareTime
       6  calcCompareTime::?relay
       3  callback
       6  callback::?relay
      65  find_free_node
       6  find_free_node::?relay
     241  generateAuthData
       6  generateAuthData::?relay
      53  getRNDByte
       6  getRNDByte::?relay
      26  init
       6  init::?relay
       5  isIRQEnable
       6  isIRQEnable::?relay
      60  is_array_ptr
       6  is_array_ptr::?relay
      41  list_add
       6  list_add::?relay
      45  list_del
       6  list_del::?relay
      41  list_empty
       6  list_empty::?relay
      70  loadTimerCompare
       6  loadTimerCompare::?relay
     212  main
       6  main::?relay
       9  mcu_sleep
       6  mcu_sleep::?relay
     153  mode_1_process
       6  mode_1_process::?relay
     222  mode_1_receive_process
       6  mode_1_receive_process::?relay
      32  mode_1_retransmition_process
       6  mode_1_retransmition_process::?relay
      59  mode_2_process
       6  mode_2_process::?relay
     246  network_recv_sync
       6  network_recv_sync::?relay
     406  network_sync
       6  network_sync::?relay
      27  pre_config
       6  pre_config::?relay
      94  pre_init
       6  pre_init::?relay
      78  random_core_init
       6  random_core_init::?relay
      54  readRandom
       6  readRandom::?relay
      78  receive
       6  receive::?relay
     253  recv_sync
       6  recv_sync::?relay
       4  ret_val
       1  retransmite
     167  scan_tx_buffer_by_ts
       6  scan_tx_buffer_by_ts::?relay
     115  scheduler_rx
       6  scheduler_rx::?relay
     161  scheduler_tx
       6  scheduler_tx::?relay
      65  scheulder_next_alarm
       6  scheulder_next_alarm::?relay
     387  send_sync
       6  send_sync::?relay
     121  setFreq
       6  setFreq::?relay
       2  slot_busy
      96  start_mode_1
       6  start_mode_1::?relay
      17  start_mode_2
       6  start_mode_2::?relay
     165  syncronize_timer
       6  syncronize_timer::?relay
      29  transmite
       6  transmite::?relay
      23  uart_init
       6  uart_init::?relay
       4  val
      59  validate_sync
       6  validate_sync::?relay
     441  -- Other

 
 15 514 bytes in segment BANKED_CODE
    918 bytes in segment BANK_RELAYS
      3 bytes in segment INTVEC
     37 bytes in segment NEAR_CODE
     35 bytes in segment SFR_AN
  1 958 bytes in segment XDATA_I
  1 958 bytes in segment XDATA_ID
  3 786 bytes in segment XDATA_Z
 
  2 865 bytes of CODE     memory (+ 51 bytes shared)
      0 bytes of DATA     memory (+ 35 bytes shared)
 15 514 bytes of HUGECODE memory
  5 696 bytes of XDATA    memory (+ 48 bytes shared)

Errors: none
Warnings: 9
