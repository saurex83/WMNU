###############################################################################
#
# IAR C/C++ Compiler V10.10.1.4655 for 8051               17/Jan/2020  12:49:08
# Copyright 2004-2017 IAR Systems AB.
# PC-locked license - IAR Embedded Workbench for 8051
#
#    Core               =  plain
#    Code model         =  banked
#    Data model         =  large
#    Calling convention =  xdata reentrant
#    Constant location  =  data
#    Dptr setup         =  1,16
#                          
#    Source file        =  
#        \\vmware-host\Shared
#        Folders\Projects\WMNU\IAR\SHARE_PRJ_SRC\nwdebuger.c
#    Command line       =  
#        -f C:\Users\08A4~1\AppData\Local\Temp\EW2854.tmp
#        ("\\vmware-host\Shared
#        Folders\Projects\WMNU\IAR\SHARE_PRJ_SRC\nwdebuger.c" -lcN
#        "\\vmware-host\Shared
#        Folders\Projects\WMNU\IAR\NeocoreGateway\Debug\List" -o
#        "\\vmware-host\Shared
#        Folders\Projects\WMNU\IAR\NeocoreGateway\Debug\Obj" -e --debug
#        --core=plain --dptr=16,1 --data_model=large --code_model=banked
#        --calling_convention=xdata_reentrant --place_constants=data
#        --nr_virtual_regs 8 --dlib_config "C:\Program Files (x86)\IAR
#        Systems\Embedded Workbench 8.0\8051\LIB\DLIB\dl8051Normal.h" -I
#        "\\vmware-host\Shared Folders\Projects\WMNU\IAR\SHARE_PRJ_SRC\" -On
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_cross_call)
#    Locale             =  Russian_Russia.1251
#    List file          =  
#        \\vmware-host\Shared
#        Folders\Projects\WMNU\IAR\NeocoreGateway\Debug\List\nwdebuger.lst
#    Object file        =  
#        \\vmware-host\Shared
#        Folders\Projects\WMNU\IAR\NeocoreGateway\Debug\Obj\nwdebuger.r51
#
###############################################################################

\\vmware-host\Shared Folders\Projects\WMNU\IAR\SHARE_PRJ_SRC\nwdebuger.c
      1          #include "nwdebuger.h"
      2          #include "ioCC2530.h"
      3          #include "stdint.h"
      4          #include "stdio.h"
      5          
      6          // Настройка порта uart для отладки
      7          static void uart_init(void)
      8          {
      9            // Выбор расположения UART на выводах
     10            uint8_t U0CFG = 0; // 0={TX=P0_3, RX=P0_2
     11            PERCFG |= (U0CFG<<0); 
     12            
     13            // U0UCR регистр настройки режима uart. меня устраивает по умолчанию
     14            U0CSR = (1<<7); // Выбираем режим uart  
     15            
     16            // Настройка скорости передачи данных на 2М  
     17            U0BAUD = 0;  // табличные значения из pdf
     18            U0GCR =  16;
     19            
     20            // Включаем альтернативные функции выводов
     21            P0SEL = (1<<2)|(1<<3);
     22            U0CSR |= (1<<6);
     23          }
     24          
     25          static void SetCPU32M(void)
     26          {
     27            CLKCONCMD = 0x88;
     28            while (CLKCONSTA&(1<<6));
     29          }
     30          
     31          void nwDebugerInit(void)
     32          {
     33           // SetCPU32M();
     34          #ifdef UART_DEBUG
     35            uart_init();
     36          #endif
     37          }
     38          
     39          __attribute__((weak)) void STACK_FAILURE(char* msg)
     40          {
     41            LOG_ON("STACK FAILURE. HALT");
     42            while(1);
     43          }
     44          
     45          // Переопределяем функцию записи в порт
     46          #ifdef UART_DEBUG
     47          #include <yfuns.h>
     48          
     49          _STD_BEGIN
     50          
     51          #pragma module_name = "?__write"
     52          
     53          int MyLowLevelPutchar(int x);
     54          
     55          int MyLowLevelPutchar(int x){
     56            while( U0CSR&(1<<0));
     57            U0DBUF = x;
     58            return x;
     59          }
     60          /*
     61           * If the __write implementation uses internal buffering, uncomment
     62           * the following line to ensure that we are called with "buffer" as 0
     63           * (i.e. flush) when the application terminates.
     64           */
     65          
     66          size_t __write(int handle, const unsigned char * buffer, size_t size)
     67          {
     68            /* Remove the #if #endif pair to enable the implementation */
     69             
     70          
     71            size_t nChars = 0;
     72          
     73            if (buffer == 0)
     74            {
     75              /*
     76               * This means that we should flush internal buffers.  Since we
     77               * don't we just return.  (Remember, "handle" == -1 means that all
     78               * handles should be flushed.)
     79               */
     80              return 0;
     81            }
     82          
     83            /* This template only writes to "standard out" and "standard err",
     84             * for all other file handles it returns failure. */
     85            if (handle != _LLIO_STDOUT && handle != _LLIO_STDERR)
     86            {
     87              return _LLIO_ERROR;
     88            }
     89          
     90            for (/* Empty */; size != 0; --size)
     91            {
     92              if (MyLowLevelPutchar(*buffer++) < 0)
     93              {
     94                return _LLIO_ERROR;
     95              }
     96          
     97              ++nChars;
     98            }
     99          
    100            return nChars;
    101          
    102          }
    103          
    104          _STD_END
    105          #endif

   Maximum stack usage in bytes:

   ISTACK XSTACK Function
   ------ ------ --------
      0     16   MyLowLevelPutchar
      0      0   STACK_FAILURE
      0     18   __write
        0     16   -> MyLowLevelPutchar
      2      0   nwDebugerInit
        2      0   -> uart_init
      0      0   uart_init


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
      12  MyLowLevelPutchar
       6  MyLowLevelPutchar::?relay
       1  P0SEL
       1  PERCFG
       2  STACK_FAILURE
       6  STACK_FAILURE::?relay
       1  U0BAUD
       1  U0CSR
       1  U0DBUF
       1  U0GCR
     156  __write
       6  __write::?relay
      14  nwDebugerInit
       6  nwDebugerInit::?relay
      23  uart_init
       6  uart_init::?relay

 
 207 bytes in segment BANKED_CODE
  30 bytes in segment BANK_RELAYS
   6 bytes in segment SFR_AN
 
  24 bytes of CODE     memory (+ 6 bytes shared)
   0 bytes of DATA     memory (+ 6 bytes shared)
 205 bytes of HUGECODE memory (+ 2 bytes shared)

Errors: none
Warnings: 1
