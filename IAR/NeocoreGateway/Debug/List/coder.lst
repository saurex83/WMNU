###############################################################################
#
# IAR C/C++ Compiler V10.10.1.4655 for 8051               17/Jan/2020  17:37:48
# Copyright 2004-2017 IAR Systems AB.
# PC-locked license - IAR Embedded Workbench for 8051
#
#    Core               =  plain
#    Code model         =  banked
#    Data model         =  large
#    Calling convention =  xdata reentrant
#    Constant location  =  data
#    Dptr setup         =  1,16
#                          
#    Source file        =  
#        \\vmware-host\Shared Folders\Projects\WMNU\IAR\SHARE_PRJ_SRC\coder.c
#    Command line       =  
#        -f C:\Users\08A4~1\AppData\Local\Temp\EW71B1.tmp
#        ("\\vmware-host\Shared
#        Folders\Projects\WMNU\IAR\SHARE_PRJ_SRC\coder.c" -lcN
#        "\\vmware-host\Shared
#        Folders\Projects\WMNU\IAR\NeocoreGateway\Debug\List" -o
#        "\\vmware-host\Shared
#        Folders\Projects\WMNU\IAR\NeocoreGateway\Debug\Obj" -e --debug
#        --core=plain --dptr=16,1 --data_model=large --code_model=banked
#        --calling_convention=xdata_reentrant --place_constants=data
#        --nr_virtual_regs 8 --dlib_config "C:\Program Files (x86)\IAR
#        Systems\Embedded Workbench 8.0\8051\LIB\DLIB\dl8051Normal.h" -I
#        "\\vmware-host\Shared Folders\Projects\WMNU\IAR\SHARE_PRJ_SRC\" -On
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_cross_call)
#    Locale             =  Russian_Russia.1251
#    List file          =  
#        \\vmware-host\Shared
#        Folders\Projects\WMNU\IAR\NeocoreGateway\Debug\List\coder.lst
#    Object file        =  
#        \\vmware-host\Shared
#        Folders\Projects\WMNU\IAR\NeocoreGateway\Debug\Obj\coder.r51
#
###############################################################################

\\vmware-host\Shared Folders\Projects\WMNU\IAR\SHARE_PRJ_SRC\coder.c
      1          /*!
      2          \file Модуль шифрования данных
      3          \brief Функции кодирования данных
      4          */
      5          
      6          #include "coder.h"
      7          #include "ioCC2530.h"
      8          #include "string.h"
      9          #include "delays.h" // Для профилирования, Отладка
     10          #include "dma.h"
     11          
     12          #define AES_START()  {ENCCS |= 0x01;} //!< Запуск выполнения команды  
     13          #define AES_SET_MODE(mode) {ENCCS &= ~0x70; ENCCS |= mode;} //!< Установка режима
     14          #define AES_SET_OPERATION(op) {ENCCS = (ENCCS & ~0x07) | op;} 
     15          #define AES_RDY() (ENCCS & 8) //!< Состояние модуля
     16          
     17          
     18          #define BV(n)                   (1 << (n))
     19          #define MIC_2_MICLEN(m)         (BV((m&3)+1) & ~3)
     20          
     21          // Режимы шифрования
     22          #define AES_MODE_CBC            0x00
     23          #define AES_MODE_CFB            0x10
     24          #define AES_MODE_OFB            0x20
     25          #define AES_MODE_CTR            0x30
     26          #define AES_MODE_ECB            0x40
     27          #define AES_MODE_CBCMAC         0x50
     28          
     29          // Операции 
     30          #define AES_ENCRYPT             0x00
     31          #define AES_DECRYPT             0x02
     32          #define AES_LOAD_KEY            0x04
     33          #define AES_LOAD_IV             0x06
     34          
     35          #define ENC_DW 29 // DMA AES тригер запрос загрузки
     36          #define ENC_UP 30 // DMA AES тригер запрос выгрузки
     37          
     38          #define STREAM_ENC_MODE     AES_MODE_OFB //!< Метод шифрования потока данных
     39          
     40          // Доступные методы
     41          void AES_StreamCoder(bool enc_mode, uint8_t *src, uint8_t *dst, 
     42                               uint8_t *key, uint8_t *nonce, uint8_t len);
     43          
     44          // Приватные функции
     45          static inline uint8_t generateAuthData(uint8_t *src, uint8_t *nonce, uint8_t c,
     46                                                 uint8_t f, uint8_t lm);
     47          static void CBCMAC_buf_encrypt(uint8_t len, uint8_t *key, uint8_t *mac);
     48          
     49          /**
     50          @brief Локальный буфер для работы режима CCM
     51          @detail 128 длина сообщения. 18 длинна блока B0 и строки состояния.
     52           16 длина дополнения нулями
     53          */
     54          static uint8_t buf[128+18+16]; 
     55          
     56          
     57          typedef struct //!< Структура блока B0 для режима CCM
     58          {
     59            struct 
     60            {
     61              uint8_t L:3;
     62              uint8_t M:3;
     63              uint8_t A_Data:1;
     64            } flag;
     65            uint16_t nonce[9];
     66            uint8_t L_M[6];
     67          } __attribute__((packed)) B0_s;
     68          
     69          typedef struct //!< Структура блока A0 для режима CCM
     70          {
     71            struct 
     72            {
     73              uint8_t L:3;
     74            } flag;
     75            uint8_t nonce[11];
     76            uint8_t ctr;
     77          } __attribute__((packed)) A0_s;
     78          
     79          
     80          
     81          /**
     82          @brief Иницилизация модуля
     83          @detail Модуль использует DMA каналы 0 и 1
     84          */
     85          void AES_init(void)
     86          {
     87            //DMA_AES_s DMA_CH[0]; //!< DMA на запись будет DMA[0]
     88            //DMA_AES_s DMA_CH[1]; //!< DMA на чтение DMA_CH[1]
     89            
     90            ST_DEF(DMA_CH[0], DSTADDRH, 0x70); // Пишем данные XENCDI = 0xB1 
     91            ST_DEF(DMA_CH[0], DSTADDRL, 0xB1); //  
     92            ST_DEF(DMA_CH[0], PRIORITY, 0x00); // Низкий приоритет
     93            ST_DEF(DMA_CH[0], M8, 0x00); // Используем 8 бит для счетика длинны
     94            ST_DEF(DMA_CH[0], IRQMASK, 0x00); // Запрещаем генерировать перывания
     95            ST_DEF(DMA_CH[0], DESTINC, 0x00); // Не увеличиваем адресс назначения
     96            ST_DEF(DMA_CH[0], SRCINC, 0x01); // Увеличиваем адресс источника
     97            ST_DEF(DMA_CH[0], TRIG, ENC_DW); // Тригер по загрузке
     98            ST_DEF(DMA_CH[0], WORDSIZE, 0x00); // Копируем по 1 байту
     99            ST_DEF(DMA_CH[0], TMODE, 0x01); //  Блочное копирование по тригеру
    100            ST_DEF(DMA_CH[0], VLEN, 0x00); //  Количество байт определяет поле LEN  
    101            ST_DEF(DMA_CH[0], LENH, 0x00); 
    102            
    103            ST_DEF(DMA_CH[1], SRCADDRH, 0x70); // Читаем данные из X_ENCDO  
    104            ST_DEF(DMA_CH[1], SRCADDRL, 0xB2);  
    105            ST_DEF(DMA_CH[1], PRIORITY, 0x00); // Низкий приоритет
    106            ST_DEF(DMA_CH[1], M8, 0x00); // Используем 8 бит для счетика длинны
    107            ST_DEF(DMA_CH[1], IRQMASK, 0x00); // Запрещаем генерировать перывания
    108            ST_DEF(DMA_CH[1], DESTINC, 0x01); // Увеличиваем адресс назначения
    109            ST_DEF(DMA_CH[1], SRCINC, 0x00); // Не увеличиваем адресс источника
    110            ST_DEF(DMA_CH[1], TRIG, ENC_UP); // Тригер по выгрузке
    111            ST_DEF(DMA_CH[1], WORDSIZE, 0x00); // Копируем по 1 байту
    112            ST_DEF(DMA_CH[1], TMODE, 0x01); //  Блочное копирование по тригеру
    113            ST_DEF(DMA_CH[1], VLEN, 0x00); //  Количество байт определяет поле LEN  
    114            ST_DEF(DMA_CH[1], LENH, 0x00); 
    115          }
    116          
    117          /**
    118          @brief Шифрует/дешифрует поток данных во время радиопередачи. Без проверки MIC
    119          @param[in] enc_mode Режим работы процедуры. true - шифрование.
    120          @param[in] src Указатель на данные подлежащии шифрованию
    121          @param[in] dst Указтель куда будут помещены зашифрованные данные
    122          @param[in] key Указатье на ключ. 16 байт
    123          @param[in] iv  Указатель на вектор иницилизации. 16 байт 
    124          @param[in] len Длинна данных
    125          */
    126          void AES_StreamCoder(bool enc_mode, uint8_t *src, uint8_t *dst, uint8_t *key,
    127                                   uint8_t *iv, uint8_t len)
    128          {
    129            // Установим метод кодироваения
    130            AES_SET_MODE(STREAM_ENC_MODE);
    131              
    132            // Загружаем ключ
    133            AES_SET_OPERATION(AES_LOAD_KEY);
    134            ST_DEF(DMA_CH[0], SRCADDRL, LADDR(key));
    135            ST_DEF(DMA_CH[0], SRCADDRH, HADDR(key));
    136            ST_DEF(DMA_CH[0], LENL, 16);
    137            DMAARM |= 0x01;
    138            while(!AES_RDY());
    139            AES_START();
    140            while (DMAARM&0x01);
    141          
    142            // Загружаем IV
    143            AES_SET_OPERATION(AES_LOAD_IV);
    144            ST_DEF(DMA_CH[0], SRCADDRL, LADDR(iv));
    145            ST_DEF(DMA_CH[0], SRCADDRH, HADDR(iv));
    146            ST_DEF(DMA_CH[0], LENL, 16);
    147            DMAARM |= 0x01;
    148            while(!AES_RDY());
    149            AES_START();
    150            while (DMAARM&0x01);
    151          
    152            // Установим необходимую операцию AES
    153            if (enc_mode) 
    154              AES_SET_OPERATION(AES_ENCRYPT)
    155            else 
    156              AES_SET_OPERATION(AES_DECRYPT)
    157            
    158            switch(STREAM_ENC_MODE) 
    159            {
    160            case AES_MODE_ECB: // ECB, CBC не реализованы
    161            case AES_MODE_CBC:
    162              break;
    163            case AES_MODE_CFB:
    164            case AES_MODE_OFB:
    165            case AES_MODE_CTR:
    166              {
    167                // Загрузка блоками по 128 бит с разделением на под-блоки по 32 бита
    168                uint8_t nbrBlocks = len / 16; // Количество целых блоков по 128 бит
    169                uint8_t ptr, sub_ptr; // Смещение
    170                uint8_t *download, *upload;
    171                
    172                // Для этих типов шифрования длина блоков по 4 байта
    173                ST_DEF(DMA_CH[0], LENL, 4);
    174                ST_DEF(DMA_CH[1], LENL, 4);
    175                
    176                // Шифруем все целые блоки
    177                for (uint8_t block = 0; block < nbrBlocks; block ++)
    178                {
    179                  ptr = 16 * block;
    180                  while(!AES_RDY());
    181                  AES_START();
    182                  for (uint8_t j = 0; j < 4; j++)
    183                  {
    184                    sub_ptr = ptr + 4*j;
    185                    download = &src[sub_ptr];
    186                    upload = &dst[sub_ptr];
    187                    // Указываем адресс DMA откуда читать данные
    188                    ST_DEF(DMA_CH[0], SRCADDRL, LADDR(download));
    189                    ST_DEF(DMA_CH[0], SRCADDRH, HADDR(download));
    190                    // Указываем адрес DMA куда записывать данные          
    191                    ST_DEF(DMA_CH[1], DSTADDRL, LADDR(upload));
    192                    ST_DEF(DMA_CH[1], DSTADDRH, HADDR(upload));
    193                    // Активируем DMA
    194                    DMAARM |= 0x03;  
    195                    DMAREQ |= 0x01;
    196                    while (DMAARM&0x03);          
    197                  }
    198                }     
    199                // Шифруем последний блок
    200                uint8_t block_len = len % 16; // Размер последнего блока
    201                
    202                // Завершаем работу если блок пустой
    203                if (!block_len)
    204                  return;
    205                
    206                uint8_t padding_block[16]; // Блок заполненый нулями
    207                ptr = 16*nbrBlocks; // Смещение на первый байт последнего блока в src
    208                memset(padding_block, 0x00, sizeof(padding_block)); // Заполняем нулями
    209                memcpy(padding_block, &src[ptr], block_len); // Копируем данные
    210                
    211                while(!AES_RDY());
    212                AES_START();
    213                for (uint8_t j = 0; j < 4; j++)
    214                  {
    215                    sub_ptr = 4*j;
    216                    download = &padding_block[sub_ptr];
    217                    // Указываем адресс DMA откуда читать данные
    218                    ST_DEF(DMA_CH[0], SRCADDRL, LADDR(download));
    219                    ST_DEF(DMA_CH[0], SRCADDRH, HADDR(download));
    220                    // Указываем аддрес DMA куда записывать данные          
    221                    ST_DEF(DMA_CH[1], DSTADDRL, LADDR(download));
    222                    ST_DEF(DMA_CH[1], DSTADDRH, HADDR(download));
    223                    // Активируем DMA
    224                    DMAARM |= 0x03;  
    225                    DMAREQ |= 0x01;
    226                    while (DMAARM&0x03);
    227                  }
    228                memcpy(&dst[ptr], padding_block, block_len); // Копируем в src
    229                
    230              } //CASE
    231              
    232              break;
    233            } 
    234          }
    235          
    236          /**
    237          @brief Шифрует/дешифрует поток данных во время радиопередачи. Без проверки MIC
    238          @param[in] enc_mode Режим работы процедуры. true - шифрование.
    239          @param[in] src Указатель на данные подлежащии шифрованию
    240          @param[in] dst Указтель куда будут помещены зашифрованные данные
    241          @param[in] key Указатье на ключ. 16 байт
    242          @param[in] iv  Указатель на вектор иницилизации. 16 байт 
    243          @param[in] len Длинна данных
    244          */
    245          static void CTR_enc_decrypt(bool enc_mode, uint8_t *src, uint8_t *dst, uint8_t *key,
    246                                   uint8_t *iv, uint8_t len)
    247          {
    248            // Установим метод кодироваения
    249            AES_SET_MODE(AES_MODE_CTR);
    250            
    251            // Загружаем ключ
    252            AES_SET_OPERATION(AES_LOAD_KEY);
    253            ST_DEF(DMA_CH[0], SRCADDRL, LADDR(key));
    254            ST_DEF(DMA_CH[0], SRCADDRH, HADDR(key));
    255            ST_DEF(DMA_CH[0], LENL, 16);
    256            DMAARM |= 0x01;
    257            while(!AES_RDY());
    258            AES_START();
    259            while (DMAARM&0x01);
    260          
    261            // Загружаем IV
    262            AES_SET_OPERATION(AES_LOAD_IV);
    263            ST_DEF(DMA_CH[0], SRCADDRL, LADDR(iv));
    264            ST_DEF(DMA_CH[0], SRCADDRH, HADDR(iv));
    265            ST_DEF(DMA_CH[0], LENL, 16);
    266            DMAARM |= 0x01;
    267            while(!AES_RDY());
    268            AES_START();
    269            while (DMAARM&0x01);
    270          
    271            // Установим необходимую операцию AES
    272            if (enc_mode) 
    273              AES_SET_OPERATION(AES_ENCRYPT)
    274            else 
    275              AES_SET_OPERATION(AES_DECRYPT)
    276            
    277            // Загрузка блоками по 128 бит с разделением на под-блоки по 32 бита
    278            uint8_t nbrBlocks = len / 16; // Количество целых блоков по 128 бит
    279            uint8_t ptr, sub_ptr; // Смещение
    280            uint8_t *download, *upload;
    281                
    282            // Для этих типов шифрования длина блоков по 4 байта
    283            ST_DEF(DMA_CH[0], LENL, 4);
    284            ST_DEF(DMA_CH[1], LENL, 4);
    285                
    286            // Шифруем все целые блоки
    287            for (uint8_t block = 0; block < nbrBlocks; block ++)
    288              {
    289                ptr = 16 * block;
    290                while(!AES_RDY());
    291                AES_START();
    292                for (uint8_t j = 0; j < 4; j++)
    293                  {
    294                    sub_ptr = ptr + 4*j;
    295                    download = &src[sub_ptr];
    296                    upload = &dst[sub_ptr];
    297                    // Указываем адресс DMA откуда читать данные
    298                    ST_DEF(DMA_CH[0], SRCADDRL, LADDR(download));
    299                    ST_DEF(DMA_CH[0], SRCADDRH, HADDR(download));
    300                    // Указываем адрес DMA куда записывать данные          
    301                    ST_DEF(DMA_CH[1], DSTADDRL, LADDR(upload));
    302                    ST_DEF(DMA_CH[1], DSTADDRH, HADDR(upload));
    303                    // Активируем DMA
    304                    DMAARM |= 0x03;  
    305                    DMAREQ |= 0x01;
    306                    while (DMAARM&0x03);          
    307                  }
    308              }     
    309              // Шифруем последний блок
    310              uint8_t block_len = len % 16; // Размер последнего блока
    311                
    312              // Завершаем работу если блок пустой
    313              if (!block_len)
    314                return;
    315                
    316              uint8_t padding_block[16]; // Блок заполненый нулями
    317              ptr = 16*nbrBlocks; // Смещение на первый байт последнего блока в src
    318              memset(padding_block, 0x00, sizeof(padding_block)); // Заполняем нулями
    319              memcpy(padding_block, &src[ptr], block_len); // Копируем данные
    320              
    321              while(!AES_RDY());
    322              AES_START();
    323              for (uint8_t j = 0; j < 4; j++)
    324                {
    325                  sub_ptr = 4*j;
    326                  download = &padding_block[sub_ptr];
    327                  // Указываем адресс DMA откуда читать данные
    328                  ST_DEF(DMA_CH[0], SRCADDRL, LADDR(download));
    329                  ST_DEF(DMA_CH[0], SRCADDRH, HADDR(download));
    330                  // Указываем аддрес DMA куда записывать данные          
    331                  ST_DEF(DMA_CH[1], DSTADDRL, LADDR(download));
    332                  ST_DEF(DMA_CH[1], DSTADDRH, HADDR(download));
    333                  // Активируем DMA
    334                  DMAARM |= 0x03;  
    335                  DMAREQ |= 0x01;
    336                  while (DMAARM&0x03);
    337                }
    338              memcpy(&dst[ptr], padding_block, block_len); // Копируем в src
    339          }
    340          
    341          /**
    342          @brief Зашифровывает buf в режиме CBC-MAC с IV = 0
    343          @param[in] len улинна последовательности для вычисления MAC
    344          @param[out] mac указатель на память куда будет записан mac (до 16 байт)
    345          */
    346          static void CBCMAC_buf_encrypt(uint8_t len, uint8_t *key, uint8_t *mac)
    347          {
    348            uint8_t IV[16];
    349            
    350            // Заполняем вектор нулями
    351            memset(IV, 0x00, sizeof(IV));
    352            
    353            // Установим метод кодироваения
    354            AES_SET_MODE(AES_MODE_CBCMAC);  
    355            
    356            { // Сворачиваем код для улучшения чтения
    357            // Загружаем ключ
    358            AES_SET_OPERATION(AES_LOAD_KEY);
    359            ST_DEF(DMA_CH[0], SRCADDRL, LADDR(key));
    360            ST_DEF(DMA_CH[0], SRCADDRH, HADDR(key));
    361            ST_DEF(DMA_CH[0], LENL, 16);
    362            DMAARM |= 0x01;
    363            while(!AES_RDY());
    364            AES_START();
    365            while (DMAARM&0x01);
    366          
    367            // Загружаем IV
    368            AES_SET_OPERATION(AES_LOAD_IV);
    369            ST_DEF(DMA_CH[0], SRCADDRL, LADDR(IV));
    370            ST_DEF(DMA_CH[0], SRCADDRH, HADDR(IV));
    371            ST_DEF(DMA_CH[0], LENL, 16);
    372            DMAARM |= 0x01;
    373            while(!AES_RDY());
    374            AES_START();
    375            while (DMAARM&0x01);
    376            };
    377            
    378            // Устанавливаем операцию шифрования
    379            AES_SET_OPERATION(AES_ENCRYPT);
    380            
    381            // Загрузка блоками по 128 бит
    382            uint8_t nbrBlocks = len / 16; // Количество целых блоков по 128 бит
    383            uint8_t block_len = len % 16; // Размер последнего блока
    384            uint8_t ptr; // Смещение
    385                
    386            // Для этого типа шифрования длина блоков по 16 байт
    387            ST_DEF(DMA_CH[0], LENL, 16);
    388            // Устанавливаем куда будем выгружать вычисленный MAC
    389            ST_DEF(DMA_CH[1], DSTADDRL, LADDR(mac));
    390            ST_DEF(DMA_CH[1], DSTADDRH, HADDR(mac));
    391            ST_DEF(DMA_CH[1], LENL, 16);
    392            
    393            // Шифруем все целые блоки
    394            for (uint8_t block = 0; block < nbrBlocks; block ++)
    395              {
    396                // Последний блок шифруем в режиме CBC при условии что нет блок не 
    397                // кратного 16 байтам.
    398                if (!block_len && (block == nbrBlocks - 1))
    399                  AES_SET_MODE(AES_MODE_CBC);
    400                    
    401                ptr = 16 * block;
    402                while(!AES_RDY());
    403                AES_START();
    404                // Указываем адресс DMA откуда читать данные
    405                ST_DEF(DMA_CH[0], SRCADDRL, LADDR(buf[ptr]));
    406                ST_DEF(DMA_CH[0], SRCADDRH, HADDR(buf[ptr]));
    407                // Активируем DMA
    408                DMAARM |= 0x01;  
    409                // Активируем выгрузку только последнего блока
    410                if (!block_len && (block == nbrBlocks - 1))
    411                  DMAARM = 0x03;
    412                
    413                DMAREQ |= 0x01;
    414                while (DMAARM&0x03);          
    415               }
    416                 
    417            // Шифруем последний блок в режиме CBC
    418            AES_SET_MODE(AES_MODE_CBC);
    419                    
    420            // Завершаем работу если блок пустой
    421            if (!block_len)
    422              return;
    423                
    424            uint8_t padding_block[16]; // Блок заполненый нулями
    425            ptr = 16*nbrBlocks; // Смещение на первый байт последнего блока в src
    426            memset(padding_block, 0x00, sizeof(padding_block)); // Заполняем нулями
    427            memcpy(padding_block, &buf[ptr], block_len); // Копируем данные
    428                
    429            while(!AES_RDY());
    430            AES_START();
    431            // Указываем адресс DMA откуда читать данные
    432            ST_DEF(DMA_CH[0], SRCADDRL, LADDR(padding_block));
    433            ST_DEF(DMA_CH[0], SRCADDRH, HADDR(padding_block));
    434            // Активируем DMA и выгрузку MAC
    435            DMAARM |= 0x03;  
    436            DMAREQ |= 0x01;
    437            while (DMAARM&0x03);
    438          }
    439          
    440          static inline uint8_t generateAuthData(uint8_t *src, uint8_t *nonce, uint8_t c,
    441                                                 uint8_t f, uint8_t lm)
    442          {
    443            memcpy(buf, nonce,16);
    444            
    445            // Буфер от 0 до 15 байта специальный блок B0
    446            // Настраиваем флаг. У нас длинна 2 байта. nonce 13 байт => L_M = L-1=0x01
    447            buf[0]=  0x01;  
    448            // Если есть данные для авторизации установим A_Data 
    449            if (f > 0)
    450              buf[0] |= 0x40;
    451            
    452            buf[0] |= ((lm - 2) / 2 ) << 3;   // см. документацию M'= (lm-2) / 2;
    453            
    454            // Устанавливаем длинну сообщения
    455            buf[14] = 0x00;
    456            buf[15] = c;
    457            
    458            // Добавляем строку авторизации L(a). если данных нет, то она пустая. f=0
    459            buf[16]= 0;
    460            buf[17]= f;
    461            
    462            // Копируем данные авторизации в буфер
    463            memcpy(&buf[18], src, f);
    464            
    465            // Смещение на следующий байт после данных авторизации.
    466            // Данные авторизации занимают положение в буфере [18, 18+f]
    467            uint8_t ptr_end= 18 + f;
    468            // Заполняем нулями до границы 16 байт  
    469            while (ptr_end & 0x0f)
    470              buf[ptr_end++] = 0x00;
    471            
    472            // Копируем данные для шифрования в буфер после нулей
    473            memcpy(&buf[ptr_end], &src[f], c);
    474            
    475            // Возвращаем размер данных в буфере
    476            return ptr_end+c;
    477          };
    478          
    479          /**
    480          @brief Шифрует/дешифрует данные с проверкой MIC
    481          @param[in] src Указатель на данные подлежащии шифрованию
    482          @param[in] len Размер данных
    483          @param[in] с Количество байт для шифрования
    484          @param[in] f Количество байт для авторизации
    485          @param[in] m Размер MIC (m=1,2,3 l(m) = 4,8,16 байт)
    486          @param[in] iv  Указатель на вектор иницилизации. 16 байт 
    487          @param[in] len Длинна данных
    488          @param[in,out] MIC Указатель на массив соответсвующий длинне (4,8,16 байт)
    489          */
    490          void AES_CCMEncrypt( uint8_t *src, uint8_t c, uint8_t f, uint8_t m,
    491                              uint8_t *key, uint8_t *nonce, uint8_t *MIC)
    492          {
    493            uint8_t lm = MIC_2_MICLEN(m);
    494            
    495            // Генерируем данные для авторизации
    496            uint8_t dlen = generateAuthData(src, nonce, c, f, lm);
    497            
    498            uint8_t mac[16]; // Сюда пишем мак
    499            CBCMAC_buf_encrypt(dlen, key, mac);
    500            
    501            // Шифруем MAC
    502            uint8_t CTR_IV[16];
    503            memcpy(CTR_IV, nonce, 16);
    504            CTR_IV[0] = 0x01; // Флаг режима CTR
    505            CTR_IV[15] = 0;   // Значение счетчика
    506            CTR_enc_decrypt(true, mac, mac, key, CTR_IV, 16);
    507            
    508            // Шифруем текст. он имеет размер 'c' и находится в буфере начиная с
    509            // dlen-c, dlen
    510            uint8_t ds = dlen - c; // Начало данных для шифрования
    511            
    512            // 0x0F & (16 - (dlen & 0x0f)) оставляет числа от 0 до 15  
    513            memset(buf+dlen, 0x00, 0x0F & (16 - (dlen & 0x0f)) ); // Дополняем нулями
    514            CTR_IV[15] = 1; // Счетчик CTR
    515            CTR_enc_decrypt(true, &buf[ds], &buf[ds], key, CTR_IV, c); // Шифруем
    516            
    517            // Заполняем буфер буфер src. src[0,f] это данные авторизации. 
    518            // src[f, f+c] это шифрованные данные.
    519            memcpy(&src[f], &buf[ds], c); 
    520            memcpy(MIC, mac, lm);
    521            
    522            //https://github.com/zhaohengyi/CC2530Example/blob/
    523            //master/source/components/radios/cc2530/hal_rf_security.c
    524          }
    525          
    526          /**
    527          @brief Дешифрует данные с проверкой MIC
    528          @param[in] src Указатель на данные подлежащии шифрованию
    529          @param[in] len Размер данных
    530          @param[in] с Количество байт для шифрования
    531          @param[in] f Количество байт для авторизации
    532          @param[in] m Размер MIC (m=1,2,3 l(m) = 4,8,16 байт)
    533          @param[in] iv  Указатель на вектор иницилизации. 16 байт 
    534          @param[in] len Длинна данных
    535          @param[in,out] MIC Указатель на массив соответсвующий длинне (4,8,16 байт)
    536          */
    537          bool AES_CCMDecrypt( uint8_t *src, uint8_t c, uint8_t f, uint8_t m,
    538                              uint8_t *key, uint8_t *nonce, uint8_t *MIC)
    539          {
    540            uint8_t lm = MIC_2_MICLEN(m);
    541            
    542            // Расшифровываем MAC
    543            uint8_t mac[16]; // Расшифрованый мак
    544            uint8_t CTR_IV[16];
    545            memcpy(CTR_IV, nonce, 16);
    546            CTR_IV[0] = 0x01; // Флаг режима CTR
    547            CTR_IV[15] = 0;   // Значение счетчика
    548            CTR_enc_decrypt(false, MIC, mac, key, CTR_IV, lm);  
    549            
    550            // Генерируем данные для авторизации
    551            uint8_t dlen = generateAuthData(src, nonce, c, f, lm);
    552            
    553            // Дешифруем текст. он имеет размер 'c' и находится в буфере начиная с
    554            // dlen-c, dlen
    555            uint8_t ds = dlen - c; // Начало данных для дешифрования
    556            
    557            // 0x0F & (16 - (dlen & 0x0f)) оставляет числа от 0 до 15  
    558            memset(buf+dlen, 0x00, 0x0F & (16 - (dlen & 0x0f)) ); // Дополняем нулями
    559            CTR_IV[15] = 1; // Счетчик CTR
    560            CTR_enc_decrypt(false, &buf[ds], &buf[ds], key, CTR_IV, c); // Дешифруем
    561            
    562            uint8_t new_mac[16]; // мак полученный в ходе рашифровки сообщения
    563            CBCMAC_buf_encrypt(dlen, key, new_mac);
    564            
    565            // Проверяем что маки совпадают, значит дешифровано верно
    566            bool mac_equal = true;
    567            for (uint8_t i = 0 ; i < lm ; i++)
    568            {
    569              if (mac[i] != new_mac[i])
    570              mac_equal = false;
    571              break;
    572            }
    573            
    574            // Выходим если MACи не совпали  
    575            if (!mac_equal)
    576              return false;
    577            
    578            // Копируем  расшифрованные данные
    579            memcpy(&src[f], &buf[ds], c); 
    580            return true;
    581          }

   Maximum stack usage in bytes:

   ISTACK XSTACK Function
   ------ ------ --------
      1     76   AES_CCMDecrypt
        0     66   -> CBCMAC_buf_encrypt
        0     70   -> CTR_enc_decrypt
        0     68   -> generateAuthData
        0     68   -> memcpy
        0     68   -> memset
      1     60   AES_CCMEncrypt
        0     50   -> CBCMAC_buf_encrypt
        0     54   -> CTR_enc_decrypt
        0     52   -> generateAuthData
        0     52   -> memcpy
        0     52   -> memset
      0     43   AES_StreamCoder
        0     39   -> memcpy
        0     39   -> memset
      2      0   AES_init
      0    116   CBCMAC_buf_encrypt
        0     50   -> memcpy
        0     50   -> memset
      0    109   CTR_enc_decrypt
        0     39   -> memcpy
        0     39   -> memset
      0     86   generateAuthData
        0     18   -> memcpy


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
     476  AES_CCMDecrypt
       6  AES_CCMDecrypt::?relay
     446  AES_CCMEncrypt
       6  AES_CCMEncrypt::?relay
     608  AES_StreamCoder
       6  AES_StreamCoder::?relay
     205  AES_init
       6  AES_init::?relay
     469  CBCMAC_buf_encrypt
       6  CBCMAC_buf_encrypt::?relay
     608  CTR_enc_decrypt
       6  CTR_enc_decrypt::?relay
       1  DMAARM
       1  DMAREQ
       1  ENCCS
     162  buf
     241  generateAuthData
       6  generateAuthData::?relay

 
 3 053 bytes in segment BANKED_CODE
    42 bytes in segment BANK_RELAYS
     3 bytes in segment SFR_AN
   162 bytes in segment XDATA_Z
 
    42 bytes of CODE     memory
     0 bytes of DATA     memory (+ 3 bytes shared)
 3 053 bytes of HUGECODE memory
   162 bytes of XDATA    memory

Errors: none
Warnings: none
