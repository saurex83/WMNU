###############################################################################
#
# IAR C/C++ Compiler V10.10.1.4655 for 8051               17/Jan/2020  17:06:57
# Copyright 2004-2017 IAR Systems AB.
# PC-locked license - IAR Embedded Workbench for 8051
#
#    Core               =  plain
#    Code model         =  banked
#    Data model         =  large
#    Calling convention =  xdata reentrant
#    Constant location  =  data
#    Dptr setup         =  1,16
#                          
#    Source file        =  
#        \\vmware-host\Shared Folders\Projects\WMNU\IAR\SHARE_PRJ_SRC\manager.c
#    Command line       =  
#        -f C:\Users\08A4~1\AppData\Local\Temp\EW3150.tmp
#        ("\\vmware-host\Shared
#        Folders\Projects\WMNU\IAR\SHARE_PRJ_SRC\manager.c" -lcN
#        "\\vmware-host\Shared
#        Folders\Projects\WMNU\IAR\NeocoreGateway\Debug\List" -o
#        "\\vmware-host\Shared
#        Folders\Projects\WMNU\IAR\NeocoreGateway\Debug\Obj" -e --debug
#        --core=plain --dptr=16,1 --data_model=large --code_model=banked
#        --calling_convention=xdata_reentrant --place_constants=data
#        --nr_virtual_regs 8 --dlib_config "C:\Program Files (x86)\IAR
#        Systems\Embedded Workbench 8.0\8051\LIB\DLIB\dl8051Normal.h" -I
#        "\\vmware-host\Shared Folders\Projects\WMNU\IAR\SHARE_PRJ_SRC\" -On
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_cross_call)
#    Locale             =  Russian_Russia.1251
#    List file          =  
#        \\vmware-host\Shared
#        Folders\Projects\WMNU\IAR\NeocoreGateway\Debug\List\manager.lst
#    Object file        =  
#        \\vmware-host\Shared
#        Folders\Projects\WMNU\IAR\NeocoreGateway\Debug\Obj\manager.r51
#
###############################################################################

\\vmware-host\Shared Folders\Projects\WMNU\IAR\SHARE_PRJ_SRC\manager.c
      1          #include "manager.h"
      2          #include "coder.h"
      3          #include "delays.h"
      4          #include "ethernet.h"
      5          #include "frame.h"
      6          #include "LLC.h"
      7          #include "MAC.h"
      8          #include "NTMR.h"
      9          #include "RADIO.h"
     10          #include "TIC.h"
     11          #include "sync.h"
     12          #include "config.h"
     13          #include "frame.h"
     14          #include "nwdebuger.h"
     15          #include "basic.h"
     16          #include "config.h"
     17          #include "ioCC2530.h"
     18          #include "dma.h"
     19          
     20          static void MG_Init();
     21          static void MG_Reset();
     22          static void re_start();
     23          static bool network_discovery();
     24          
     25          static bool MG_MODULES_INITED = false; //!< Были ли запущенны аппаратные модули
     26          
     27          // Публичные методы
     28          bool MG_Connect();
     29          
     30          // Переменные модуля
     31          
     32          
     33          static void MG_Init()
     34          {
     35            DMA_init();
     36            CF_init();
     37            NT_Init();
     38            TIM_init();
     39            TIC_Init();
     40            RI_init();
     41            AES_init();
     42            MAC_Init();
     43            SY_Init();
     44            LLC_Init();
     45            // TODO Необходимо очищать все ранее выделеную память malloc
     46          }
     47          
     48          static void MG_Reset()
     49          {   
     50            TIC_Reset();
     51            MAC_Reset();
     52            SY_Reset();
     53            LLC_Reset();
     54          }
     55          
     56          static void re_start()
     57          {
     58              if (!MG_MODULES_INITED)
     59            {
     60              MG_Init();
     61              MG_MODULES_INITED = true;
     62            }
     63            else
     64              MG_Reset(); 
     65              
     66            CF_init();
     67            MAC_setIV(CONFIG.stream_iv);
     68            MAC_setKEY(CONFIG.stream_key);
     69            SY_setIV(CONFIG.stream_iv);
     70            SY_setKEY(CONFIG.stream_key);
     71          }
     72          
     73          /**
     74          @brief Алгоритм подключения к сети
     75          */
     76          static bool network_discovery()
     77          {
     78            uint16_t panid;
     79            bool con = false;
     80            
     81            // Тупой алгоритм поиска сети.
     82            while (!con)
     83            {
     84              con = SY_SYNC_NETWORK(&panid, 5000);
     85            }
     86            return con;
     87          }
     88          
     89          /**
     90          @brief Создание сети в режиме шлюза
     91          */
     92          static bool master_mode()
     93          {
     94            // Включает обработку начала слота TS1 для программы собранной с ключом 
     95            // GATEWAY. MAC_TS1_HNDL_MASTER будет создавать пакеты синхронизации.
     96            MAC_Enable(true);
     97            SY_Enable(true);
     98            return true;
     99          }
    100          
    101          /**
    102          @brief Создание сети в режиме узла
    103          */
    104          static bool slave_mode()
    105          {
    106            // В режиме slave сначало нужно подключисться к сети
    107            network_discovery();
    108            
    109            // После синхронизации с сетью разрешаем обработку временных слотов
    110            // Программа собрана без ключа GATEWAY и активной функцией обработки TS1
    111            // будет MAC_TS1_HNDL_SLAVE. Она отвечает за поддержание синхронизации
    112            // и периодиескую ректрансляцию пакетов.
    113            
    114            MAC_Enable(true);
    115            SY_Enable(true);
    116            return true;
    117          }
    118          
    119          bool MG_Connect()
    120          {
    121            EA = 0;
    122            re_start();
    123            EA = 1;
    124            if (frame_getCount())
    125            {
    126              LOG_ON("Frame_s count: %d \r\n",frame_getCount());
    127              return false;
    128            }
    129            
    130          #ifdef GATEWAY
    131              bool con = master_mode();
    132          #else
    133              bool con = slave_mode();  
    134          #endif
    135              
    136              return con;
    137          }
    138           
    139            

   Maximum stack usage in bytes:

   ISTACK Function
   ------ --------
      2   MG_Connect
        2   -> frame_getCount
        2   -> master_mode
        2   -> re_start
      2   MG_Init
        2   -> AES_init
        2   -> CF_init
        2   -> DMA_init
        2   -> LLC_Init
        2   -> MAC_Init
        2   -> NT_Init
        2   -> RI_init
        2   -> SY_Init
        2   -> TIC_Init
        2   -> TIM_init
      2   MG_Reset
        2   -> LLC_Reset
        2   -> MAC_Reset
        2   -> SY_Reset
        2   -> TIC_Reset
      2   master_mode
        2   -> MAC_Enable
        2   -> SY_Enable
      2   re_start
        2   -> CF_init
        2   -> MAC_setIV
        2   -> MAC_setKEY
        2   -> MG_Init
        2   -> MG_Reset
        2   -> SY_setIV
        2   -> SY_setKEY


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
      34  MG_Connect
       6  MG_Connect::?relay
      41  MG_Init
       6  MG_Init::?relay
       1  MG_MODULES_INITED
      23  MG_Reset
       6  MG_Reset::?relay
       1  _A_IEN0
      22  master_mode
       6  master_mode::?relay
      62  re_start
       6  re_start::?relay

 
 182 bytes in segment BANKED_CODE
  30 bytes in segment BANK_RELAYS
   1 byte  in segment SFR_AN
   1 byte  in segment XDATA_Z
 
  30 bytes of CODE     memory
   0 bytes of DATA     memory (+ 1 byte shared)
 182 bytes of HUGECODE memory
   1 byte  of XDATA    memory

Errors: none
Warnings: 1
