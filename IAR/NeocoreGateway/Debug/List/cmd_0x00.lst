###############################################################################
#
# IAR C/C++ Compiler V10.10.1.4655 for 8051               28/Jan/2020  15:31:22
# Copyright 2004-2017 IAR Systems AB.
# PC-locked license - IAR Embedded Workbench for 8051
#
#    Core               =  plain
#    Code model         =  banked
#    Data model         =  large
#    Calling convention =  xdata reentrant
#    Constant location  =  data
#    Dptr setup         =  1,16
#                          
#    Source file        =  E:\WMNU\IAR\NEOCOREGATEWAY\src\cmd_0x00.c
#    Command line       =  
#        -f C:\Users\08A4~1\AppData\Local\Temp\EW4648.tmp
#        (E:\WMNU\IAR\NEOCOREGATEWAY\src\cmd_0x00.c -lcN
#        E:\WMNU\IAR\NeocoreGateway\Debug\List -o
#        E:\WMNU\IAR\NeocoreGateway\Debug\Obj -e --debug --core=plain
#        --dptr=16,1 --data_model=large --code_model=banked
#        --calling_convention=xdata_reentrant --place_constants=data
#        --nr_virtual_regs 8 --dlib_config "C:\Program Files (x86)\IAR
#        Systems\Embedded Workbench 8.0\8051\LIB\DLIB\dl8051Normal.h" -I
#        E:\WMNU\IAR\SHARE_PRJ_SRC\ -On --no_cse --no_unroll --no_inline
#        --no_code_motion --no_tbaa --no_cross_call --mfc
#        E:\WMNU\IAR\NEOCOREGATEWAY\src\cmd_0x01.c
#        E:\WMNU\IAR\NEOCOREGATEWAY\src\cmd_0x02.c
#        E:\WMNU\IAR\NEOCOREGATEWAY\src\cmd_0x03.c
#        E:\WMNU\IAR\NEOCOREGATEWAY\src\cmd_0x04.c
#        E:\WMNU\IAR\NEOCOREGATEWAY\src\cmd_0x05.c
#        E:\WMNU\IAR\NEOCOREGATEWAY\src\cmd_0x06.c
#        E:\WMNU\IAR\NEOCOREGATEWAY\src\cmd_0x07.c
#        E:\WMNU\IAR\NEOCOREGATEWAY\src\cmd_0x08.c
#        E:\WMNU\IAR\NEOCOREGATEWAY\src\cmd_0x09.c
#        E:\WMNU\IAR\NEOCOREGATEWAY\src\cmd_0x0A.c
#        E:\WMNU\IAR\NEOCOREGATEWAY\src\cmd_0x0B.c
#        E:\WMNU\IAR\NEOCOREGATEWAY\src\cmd_0x0C.c
#        E:\WMNU\IAR\NEOCOREGATEWAY\src\cmd_0x0D.c
#        E:\WMNU\IAR\NEOCOREGATEWAY\src\cmd_0x0E.c
#        E:\WMNU\IAR\NEOCOREGATEWAY\src\cmd_parser.c
#        E:\WMNU\IAR\SHARE_PRJ_SRC\coder.c E:\WMNU\IAR\SHARE_PRJ_SRC\config.c
#        E:\WMNU\IAR\SHARE_PRJ_SRC\delays.c E:\WMNU\IAR\SHARE_PRJ_SRC\dma.c
#        E:\WMNU\IAR\SHARE_PRJ_SRC\ethernet.c E:\WMNU\IAR\SHARE_PRJ_SRC\frame.c
#        E:\WMNU\IAR\SHARE_PRJ_SRC\LLC.c E:\WMNU\IAR\SHARE_PRJ_SRC\MAC.c
#        E:\WMNU\IAR\NEOCOREGATEWAY\src\main.c
#        E:\WMNU\IAR\SHARE_PRJ_SRC\manager.c E:\WMNU\IAR\SHARE_PRJ_SRC\mem.c
#        E:\WMNU\IAR\SHARE_PRJ_SRC\NTMR.c E:\WMNU\IAR\SHARE_PRJ_SRC\nwdebuger.c
#        E:\WMNU\IAR\SHARE_PRJ_SRC\RADIO.c E:\WMNU\IAR\SHARE_PRJ_SRC\rx_buff.c
#        E:\WMNU\IAR\SHARE_PRJ_SRC\sync.c E:\WMNU\IAR\SHARE_PRJ_SRC\TIC.c
#        E:\WMNU\IAR\NEOCOREGATEWAY\src\uart_comm.c)
#    Locale             =  Russian_Russia.1251
#    List file          =  E:\WMNU\IAR\NeocoreGateway\Debug\List\cmd_0x00.lst
#    Object file        =  E:\WMNU\IAR\NeocoreGateway\Debug\Obj\cmd_0x00.r51
#
###############################################################################

E:\WMNU\IAR\NEOCOREGATEWAY\src\cmd_0x00.c
      1          #include "stdint.h"
      2          #include "cmd_parser.h"
      3          #include "manager.h"
      4          #include "nwdebuger.h"
      5          
      6          enum {NET_NOSEEDING = 0, NET_SEEDING = 1};
      7          
      8          
      9          /**
     10          @brief Статус приемника
     11          @detail Возвращает true, если идет раздача сети
     12          */
     13          bool cmd_0x00(uint8_t *cmd, uint8_t size)
     14          {
     15            uint8_t answer;
     16            
     17            if (get_network_seed_status()){
     18              answer = NET_SEEDING;
     19              LOG_ON("CMD 0x00. Seeding");
     20            }
     21            else{
     22              answer = NET_NOSEEDING;
     23              LOG_ON("CMD 0x00. No seeding");
     24            }
     25              
     26            cmd_answer(ATYPE_CMD_OK, &answer, sizeof(answer));
     27            return true;
     28          }
E:\WMNU\IAR\NEOCOREGATEWAY\src\cmd_0x01.c
      1          #include "stdint.h"
      2          #include "cmd_parser.h"
      3          #include "manager.h"
      4          #include "config.h"
      5          #include "nwdebuger.h"
      6          
      7          #define ARGS_SIZE sizeof(cmd_args_s)
      8          typedef struct //!< Аргументы команды
      9          {
     10            uint16_t panid;
     11            uint16_t crc16;
     12          } cmd_args_s;
     13          
     14          /**
     15          @brief Установить panid
     16          */
     17          bool cmd_0x01(uint8_t *cmd, uint8_t size)
     18          {
     19            if (size != ARGS_SIZE){ // Размер аргументов не верен
     20              cmd_answer_err(ATYPE_CMD_ERR, CMD_LEN);
     21              return false;
     22            }
     23              
     24            if (get_network_seed_status()){ // Сеть активна и менять ничего нельзя
     25              cmd_answer_err(ATYPE_CMD_ERR, CMD_SEEDING);
     26              return false;
     27            }
     28            
     29            cmd_args_s *args = (cmd_args_s*)cmd; // Извлекаем аргументы
     30            
     31            CONFIG.panid =args->panid;
     32            LOG_ON("CMD 0x01. Set panid");
     33            
     34            cmd_answer(ATYPE_CMD_OK, NULL, 0);
     35            return true;
     36          }
E:\WMNU\IAR\NEOCOREGATEWAY\src\cmd_0x02.c
      1          #include "stdint.h"
      2          #include "cmd_parser.h"
      3          #include "manager.h"
      4          #include "config.h"
      5          #include "TIC.h"
      6          #include "nwdebuger.h"
      7          
      8          #define ARGS_SIZE sizeof(cmd_args_s)
      9          typedef struct //!< Аргументы команды
     10          {
     11            uint32_t RTC;
     12            uint16_t crc16;
     13          } cmd_args_s;
     14          
     15          
     16          /**
     17          @brief Установить RTC
     18          */
     19          bool cmd_0x02(uint8_t *cmd, uint8_t size)
     20          {
     21            
     22            if (size != ARGS_SIZE){ // Размер аргументов не верен
     23              cmd_answer_err(ATYPE_CMD_ERR, CMD_LEN);
     24              return false;
     25            }
     26            
     27            if (get_network_seed_status()){ // Сеть активна и менять ничего нельзя
     28              cmd_answer_err(ATYPE_CMD_ERR, CMD_SEEDING);
     29              return false;
     30            }
     31            
     32            cmd_args_s *args = (cmd_args_s*)cmd; // Извлекаем аргументы
     33            
     34            TIC_SetRTC(args->RTC);
     35            
     36            cmd_answer(ATYPE_CMD_OK, NULL, 0);
     37            return true;
     38          }
E:\WMNU\IAR\NEOCOREGATEWAY\src\cmd_0x03.c
      1          #include "stdint.h"
      2          #include "cmd_parser.h"
      3          #include "manager.h"
      4          #include "config.h"
      5          #include "nwdebuger.h"
      6          
      7          #define ARGS_SIZE sizeof(cmd_args_s)
      8          typedef struct //!< Аргументы команды
      9          {
     10            bool on_off;
     11            uint16_t crc16;
     12          } cmd_args_s;
     13          
     14          /**
     15          @brief Включить или выключить сеть. true - вкл
     16          */
     17          bool cmd_0x03(uint8_t *cmd, uint8_t size)
     18          {
     19            
     20            if (size != ARGS_SIZE){ // Размер аргументов не верен
     21              cmd_answer_err(ATYPE_CMD_ERR, CMD_LEN);
     22              return false;
     23            }
     24            
     25            cmd_args_s *args = (cmd_args_s*)cmd; // Извлекаем аргументы
     26            
     27            bool res;
     28            if (args->on_off){ // Просят включить сеть
     29              res = neocore_stack_reset();
     30              ASSERT(res == true);
     31              network_seed_enable(true);
     32              LOG_ON("CMD 0x03. Start network");
     33            }
     34            else
     35            {
     36              res = neocore_stack_reset();
     37              ASSERT(res == true);
     38              LOG_ON("CMD 0x03. Stop network");
     39            }
     40            
     41            cmd_answer(ATYPE_CMD_OK, NULL, 0);
     42            return true;
     43          }
E:\WMNU\IAR\NEOCOREGATEWAY\src\cmd_0x04.c
      1          #include "stdint.h"
      2          #include "cmd_parser.h"
      3          #include "manager.h"
      4          #include "config.h"
      5          #include "string.h"
      6          #include "nwdebuger.h"
      7          
      8          #define ARGS_SIZE sizeof(cmd_args_s)
      9          typedef struct //!< Аргументы команды
     10          {
     11            uint8_t IV[16];
     12            uint16_t crc16;
     13          } cmd_args_s;
     14          
     15          /**
     16          @brief Загрузка IV
     17          */
     18          bool cmd_0x04(uint8_t *cmd, uint8_t size)
     19          {
     20            if (size != ARGS_SIZE){ // Размер аргументов не верен
     21              cmd_answer_err(ATYPE_CMD_ERR, CMD_LEN);
     22              return false;
     23            }
     24          
     25            if (get_network_seed_status()){ // Сеть активна и менять ничего нельзя
     26              cmd_answer_err(ATYPE_CMD_ERR, CMD_SEEDING);
     27              return false;
     28            }
     29             
     30            cmd_args_s *args = (cmd_args_s*)cmd; // Извлекаем аргументы
     31            memcpy(CONFIG.stream_iv,  args->IV, 16);   
     32           
     33            LOG_ON("CMD 0x04. IV loaded");
     34            
     35            cmd_answer(ATYPE_CMD_OK, NULL, 0);
     36            return true;
     37          }
E:\WMNU\IAR\NEOCOREGATEWAY\src\cmd_0x05.c
      1          #include "stdint.h"
      2          #include "cmd_parser.h"
      3          #include "manager.h"
      4          #include "config.h"
      5          #include "string.h"
      6          #include "nwdebuger.h"
      7          
      8          #define ARGS_SIZE sizeof(cmd_args_s)
      9          typedef struct //!< Аргументы команды
     10          {
     11            uint8_t KEY[16];
     12            uint16_t crc16;
     13          } cmd_args_s;
     14          
     15          /**
     16          @brief Загрузка KEY
     17          */
     18          bool cmd_0x05(uint8_t *cmd, uint8_t size)
     19          {
     20            
     21            if (size != ARGS_SIZE){ // Размер аргументов не верен
     22              cmd_answer_err(ATYPE_CMD_ERR, CMD_LEN);
     23              return false;
     24            }
     25          
     26            if (get_network_seed_status()){ // Сеть активна и менять ничего нельзя
     27              cmd_answer_err(ATYPE_CMD_ERR, CMD_SEEDING);
     28              return false;
     29            }
     30             
     31            cmd_args_s *args = (cmd_args_s*)cmd; // Извлекаем аргументы
     32            memcpy(CONFIG.stream_key,  args->KEY, 16);   
     33           
     34            LOG_ON("CMD 0x05. KEY loaded");
     35            cmd_answer(ATYPE_CMD_OK, NULL, 0);
     36            return true;
     37          }
E:\WMNU\IAR\NEOCOREGATEWAY\src\cmd_0x06.c
      1          #include "stdint.h"
      2          #include "cmd_parser.h"
      3          #include "manager.h"
      4          #include "config.h"
      5          #include "TIC.h"
      6          #include "nwdebuger.h"
      7          
      8          #define ARGS_SIZE sizeof(cmd_args_s)
      9          typedef struct //!< Аргументы команды
     10          {
     11            uint8_t dont_use;
     12            uint16_t crc16;
     13          } cmd_args_s;
     14          
     15          /**
     16          @brief перезарузка
     17          */
     18          bool cmd_0x06(uint8_t *cmd, uint8_t size)
     19          {
     20            
     21            if (size != ARGS_SIZE){ // Размер аргументов не верен
     22              cmd_answer_err(ATYPE_CMD_ERR, CMD_LEN);
     23              return false;
     24            }
     25             
     26            cmd_answer(ATYPE_CMD_OK, NULL, 0);
     27            LOG_ON("CMD 0x06. HW reload");
     28            //TODO АППАПРАТНАЯ перезагрузка.
     29            
     30            return true;
     31          }
E:\WMNU\IAR\NEOCOREGATEWAY\src\cmd_0x07.c
      1          #include "stdint.h"
      2          #include "cmd_parser.h"
      3          #include "manager.h"
      4          #include "config.h"
      5          #include "MAC.h"
      6          #include "nwdebuger.h"
      7          
      8          #define ARGS_SIZE sizeof(cmd_args_s)
      9          typedef struct //!< Аргументы команды
     10          {
     11            uint8_t TS;
     12            uint8_t CH;
     13            uint16_t crc16;
     14          } cmd_args_s;
     15          
     16          /**
     17          @brief Открыть для приема слот TS на канале CH
     18          */
     19          bool cmd_0x07(uint8_t *cmd, uint8_t size)
     20          {
     21            
     22            if (size != ARGS_SIZE){ // Размер аргументов не верен
     23              cmd_answer_err(ATYPE_CMD_ERR, CMD_LEN);
     24              return false;
     25            }
     26            
     27            if (!get_network_seed_status()){ // Сеть отключена
     28              cmd_answer_err(ATYPE_CMD_ERR, CMD_NOSEEDING);
     29              return false;
     30            }
     31            
     32            cmd_args_s *args = (cmd_args_s*)cmd; // Извлекаем аргументы
     33            
     34            MAC_OpenRXSlot(args->TS, args->CH);
     35            LOG_ON("CMD 0x07. Open slot");
     36            cmd_answer(ATYPE_CMD_OK, NULL, 0);
     37            return true;
     38          }
E:\WMNU\IAR\NEOCOREGATEWAY\src\cmd_0x08.c
      1          #include "stdint.h"
      2          #include "cmd_parser.h"
      3          #include "manager.h"
      4          #include "config.h"
      5          #include "MAC.h"
      6          #include "nwdebuger.h"
      7          
      8          #define ARGS_SIZE sizeof(cmd_args_s)
      9          typedef struct //!< Аргументы команды
     10          {
     11            uint8_t TS;
     12            uint16_t crc16;
     13          } cmd_args_s;
     14          
     15          /**
     16          @brief Закрыть для приема слот TS
     17          */
     18          bool cmd_0x08(uint8_t *cmd, uint8_t size)
     19          {
     20            if (size != ARGS_SIZE){ // Размер аргументов не верен
     21              cmd_answer_err(ATYPE_CMD_ERR, CMD_LEN);
     22              return false;
     23            }
     24            
     25            if (!get_network_seed_status()){ // Сеть отключена
     26              cmd_answer_err(ATYPE_CMD_ERR, CMD_NOSEEDING);
     27              return true;
     28            }
     29            
     30            cmd_args_s *args = (cmd_args_s*)cmd; // Извлекаем аргументы
     31            
     32            MAC_CloseRXSlot(args->TS);
     33            
     34            LOG_ON("CMD 0x08. Close TS slot");
     35            cmd_answer(ATYPE_CMD_OK, NULL, 0);
     36            return true;
     37          }
E:\WMNU\IAR\NEOCOREGATEWAY\src\cmd_0x09.c
      1          #include "stdint.h"
      2          #include "cmd_parser.h"
      3          #include "manager.h"
      4          #include "config.h"
      5          #include "MAC.h"
      6          #include "nwdebuger.h"
      7          #include "rx_buff.h"
      8          
      9          #define ARGS_SIZE sizeof(cmd_args_s)
     10          typedef struct //!< Аргументы команды
     11          {
     12            uint16_t crc16;
     13          } cmd_args_s;
     14          
     15          /**
     16          @brief Количество принятых пакетов в буфере RX. Сеть вкл.
     17          */
     18          bool cmd_0x09(uint8_t *cmd, uint8_t size)
     19          {
     20            if (size != ARGS_SIZE){ // Размер аргументов не верен
     21              cmd_answer_err(ATYPE_CMD_ERR, CMD_LEN);
     22              return false;
     23            }
     24            
     25            uint8_t nbItems = RXB_frame_count();
     26            cmd_answer(ATYPE_CMD_OK, &nbItems, sizeof(nbItems));
     27            
     28            LOG_ON("CMD 0x09. RX frame count");
     29            return true;
     30          }
E:\WMNU\IAR\NEOCOREGATEWAY\src\cmd_0x0A.c
      1          #include "stdint.h"
      2          #include "cmd_parser.h"
      3          #include "manager.h"
      4          #include "config.h"
      5          #include "MAC.h"
      6          #include "nwdebuger.h"
      7          #include "LLC.h"
      8          
      9          #define ARGS_SIZE sizeof(cmd_args_s)
     10          typedef struct //!< Аргументы команды
     11          {
     12            uint16_t crc16;
     13          } cmd_args_s;
     14          
     15          /**
     16          @brief Количество пакетов в буфере TX. Сеть вкл.
     17          */
     18          bool cmd_0x0A(uint8_t *cmd, uint8_t size)
     19          {
     20            if (size != ARGS_SIZE){ // Размер аргументов не верен
     21              cmd_answer_err(ATYPE_CMD_ERR, CMD_LEN);
     22              return false;
     23            }
     24          
     25            uint8_t nbItems = LLC_GetTaskLen();
     26            cmd_answer(ATYPE_CMD_OK, &nbItems, sizeof(nbItems));
     27            
     28            LOG_ON("CMD 0x09. TX frame count");
     29            return true;
     30          }
E:\WMNU\IAR\NEOCOREGATEWAY\src\cmd_0x0B.c
      1          #include "stdint.h"
      2          #include "cmd_parser.h"
      3          #include "manager.h"
      4          #include "config.h"
      5          #include "MAC.h"
      6          #include "nwdebuger.h"
      7          #include "frame.h"
      8          #include "mem.h"
      9          #include "LLC.h"
     10          
     11          #define ARGS_SIZE sizeof(cmd_args_s)
     12          typedef struct //!< Аргументы команды
     13          {
     14            meta_s meta;
     15            uint8_t len;
     16            uint8_t offset_payload; //!< это указатель на первый байт payload
     17          } cmd_args_s;
     18          
     19          /**
     20          @brief Поставить пакет в очередь на отправку TX LLC. Сеть вкл.
     21          */
     22          bool cmd_0x0B(uint8_t *cmd, uint8_t size)
     23          {
     24            // Длинна sz{meta} + sz{len} + len(payload) + 2(CRC16)
     25            if (size - 2 < ARGS_SIZE ){ // Прежде чем извлеч проверим мин. размер
     26              cmd_answer_err(ATYPE_CMD_ERR, CMD_LEN);
     27              return false;
     28            }
     29            
     30            cmd_args_s *args = (cmd_args_s*)cmd; // Извлекаем аргументы
     31            uint8_t xx= ARGS_SIZE;
     32            if (size - 2 != ARGS_SIZE + args->len - 1){ // Проверим точный размер
     33              cmd_answer_err(ATYPE_CMD_ERR, CMD_LEN);
     34              return false;
     35            }
     36              
     37            if (!get_network_seed_status()){ // Если отключена. Ошибка
     38              cmd_answer_err(ATYPE_CMD_ERR, CMD_NOSEEDING);
     39              return true;
     40            }
     41            
     42            // TODO проверить значения аргументов
     43            //cmd_answer_err(ATYPE_CMD_ERR, CMD_ARG_VAL); 
     44            
     45            frame_s* tx_frame = frame_create(); // Создаем фрейм
     46            re_memcpy(&tx_frame->meta, &args->meta, sizeof(meta_s)); //Копируем метаданные
     47            
     48            uint8_t *ptr = &args->offset_payload; // Начало содержимого
     49            frame_addHeader(tx_frame, ptr, args->len);
     50            
     51            // Ставим в очередь на отправку
     52            bool res = LLC_AddTask(tx_frame);
     53            
     54            if (!res){ // Буфер полон 
     55              cmd_answer_err(ATYPE_CMD_ERR, CMD_TX_FULL);
     56              LOG_ON("CMD 0x0B. TX buff full");
     57              return false;
     58            }
     59            
     60            LOG_ON("CMD 0x0B. Frame add to LLC");
     61            cmd_answer(ATYPE_CMD_OK, NULL, 0);
     62            return true;
     63          }
E:\WMNU\IAR\NEOCOREGATEWAY\src\cmd_0x0C.c
      1          #include "stdint.h"
      2          #include "cmd_parser.h"
      3          #include "manager.h"
      4          #include "config.h"
      5          #include "MAC.h"
      6          #include "nwdebuger.h"
      7          #include "rx_buff.h"
      8          #include "mem.h"
      9          
     10          static void upload_frame(frame_s *fr);
     11          
     12          #define ARGS_SIZE sizeof(cmd_args_s)
     13          typedef struct //!< Аргументы команды
     14          {
     15            uint16_t crc16;
     16          } cmd_args_s;
     17          
     18          /**
     19          @brief Отправить на PC принятый пакет из буфера RX. Сеть вкл.
     20          */
     21          bool cmd_0x0C(uint8_t *cmd, uint8_t size)
     22          {
     23            if (size != ARGS_SIZE){ // Размер аргументов не верен
     24              cmd_answer_err(ATYPE_CMD_ERR, CMD_LEN);
     25              return false;
     26            }
     27            
     28            if (!get_network_seed_status()){ // Сеть должна работать
     29              cmd_answer_err(ATYPE_CMD_ERR, CMD_NOSEEDING);
     30              return false;
     31            }
     32            
     33            frame_s *rx_frame = RXB_get_frame();
     34            
     35            if (rx_frame == NULL){ // В буфере ничего нет
     36              cmd_answer_err(ATYPE_CMD_ERR, CMD_RX_EMPTY);
     37              return false;
     38            }
     39            
     40            upload_frame(rx_frame);
     41            
     42            LOG_ON("CMD 0x0C. Upload RX frame");
     43            return true;
     44          }
     45          
     46          /**
     47          @brief Выгрузить фрейм в uart
     48          @detail Порядок выгрузки meta, byte len, payload[len]
     49          */
     50          static void upload_frame(frame_s *fr){
     51          /*  Заполнение массива upload
     52                    -----------------------
     53                    |META|LEN|   PAYLOAD  |
     54                    -----------------------
     55                         ^   ^<- fr.len ->^
     56          sizeof(meta_s)-|   |
     57          sizeof(meta_s)+1  -| 
     58          */
     59            // Пакет буду собирать в массиве upload иначе crc считать неудобно
     60            uint8_t upload[sizeof(meta_s) + 1 + 127]; // Размер мета+1 байт длинны+пакет
     61            uint8_t answ_len = sizeof(meta_s) + 1 + fr->len; // Суммарный размер пакета
     62            
     63            re_memcpy(upload, &fr->meta, sizeof(meta_s));
     64            upload[sizeof(meta_s)] = fr->len; // byte len
     65            re_memcpy(&upload[sizeof(meta_s) + 1], fr->payload, fr->len);
     66            
     67            cmd_answer(ATYPE_CMD_OK, upload, answ_len);
     68          }
E:\WMNU\IAR\NEOCOREGATEWAY\src\cmd_0x0D.c
      1          #include "stdint.h"
      2          #include "cmd_parser.h"
      3          #include "manager.h"
      4          #include "config.h"
      5          #include "RADIO.h"
      6          #include "nwdebuger.h"
      7          
      8          #define ARGS_SIZE sizeof(cmd_args_s)
      9          typedef struct //!< Аргументы команды
     10          {
     11            uint8_t FCH;
     12            uint16_t MS;
     13            uint16_t crc16;
     14          } cmd_args_s;
     15          
     16          /**
     17          @brief Скан канала CH в течении time_ms. Сеть выкл.
     18          @detail Ответ после завершения сканирования
     19          */
     20          bool cmd_0x0D(uint8_t *cmd, uint8_t size)
     21          {
     22            if (size != ARGS_SIZE){ // Размер аргументов не верен
     23              cmd_answer_err(ATYPE_CMD_ERR, CMD_LEN);
     24              return false;
     25            }
     26            
     27            if (get_network_seed_status()){ // Сеть активна сканировать нельзя
     28              cmd_answer_err(ATYPE_CMD_ERR, CMD_SEEDING);
     29              return false;
     30            }
     31            
     32            cmd_args_s *args = (cmd_args_s*)cmd; // Извлекаем аргументы
     33            
     34            int8_t rssi;
     35            bool res = RI_Measure_POW(args->FCH, args->MS, &rssi);
     36            
     37            LOG_ON("CMD 0x0D. RSSI scan");
     38            
     39            cmd_answer(ATYPE_CMD_OK, (uint8_t*)&rssi, sizeof(rssi));
     40            return true;
     41          }
E:\WMNU\IAR\NEOCOREGATEWAY\src\cmd_0x0E.c
      1          #include "stdint.h"
      2          #include "cmd_parser.h"
      3          #include "manager.h"
      4          #include "config.h"
      5          #include "MAC.h"
      6          #include "nwdebuger.h"
      7          
      8          #define ARGS_SIZE sizeof(cmd_args_s)
      9          typedef struct //!< Аргументы команды
     10          {
     11            uint8_t CH;
     12            uint16_t crc16;
     13          } cmd_args_s;
     14          
     15          /**
     16          @brief Установить канал для синхросигнала. Сеть выкл.
     17          */
     18          bool cmd_0x0E(uint8_t *cmd, uint8_t size)
     19          {
     20            if (size != ARGS_SIZE){ // Размер аргументов не верен
     21              cmd_answer_err(ATYPE_CMD_ERR, CMD_LEN);
     22              return false;
     23            }
     24            
     25            if (get_network_seed_status()){ // Сеть должна быть отключенна
     26              cmd_answer_err(ATYPE_CMD_ERR, CMD_SEEDING);
     27              return true;
     28            }
     29            
     30            cmd_args_s *args = (cmd_args_s*)cmd; // Извлекаем аргументы
     31            CONFIG.sync_channel = args->CH;
     32            
     33            LOG_ON("CMD 0x0E. Set SYNC CH");
     34            cmd_answer(ATYPE_CMD_OK, NULL, 0);
     35            return true;
     36          }
E:\WMNU\IAR\NEOCOREGATEWAY\src\cmd_parser.c
      1          #include "uart_comm.h"
      2          #include "stdbool.h"
      3          #include "cmd_index_list.h"
      4          #include "nwdebuger.h"
      5          #include "cmd_parser.h"
      6          
      7          /**
      8          @file Прием и парсинг команд по uart
      9          @detail Команда от PC имеет формат:
     10           --------------------------
     11           | 0 | 1 |  n |LEN-1| LEN | 
     12           --------------------------
     13           |LEN|CMD|ARGS|CRC16|CRC16|
     14           --------------------------
     15          Ответ от МК имеет формат:
     16           --------------------------
     17           | 0 | 1 |  n |LEN-1| LEN | 
     18           --------------------------
     19           |LEN|TYP|DATA|CRC16|CRC16|
     20           --------------------------
     21          Где TYP - тип ответа.
     22          TYP = 0x00 ответ от парсера в случаии ошибки.
     23           DATA = 1 ошибка CRC16
     24           DATA = 2 команда отсутсвует
     25          TYP = 0x01 ответ от обработчика команды с ошибкой
     26           DATA = 0x01 Ошибка размера аргументов
     27           DATA = 0x02 Аргумент неверен.
     28          TYP = 0x02 Команда выполнена, следуют данные команды
     29          */
     30          
     31          enum {answ_crc_err = 1, answ_args_err = 2, answ_no_cmd = 3}; //!< Коды ошибок
     32          
     33          //#define USE_CRC16_CHECK //!< Использовать проверку CRC
     34          #define MAX_CMD_INDEX sizeof(CMD_LIST) //!< Все номера команд меньше этого числа
     35          
     36          static unsigned short crc16(unsigned char *pcBlock, unsigned short len);
     37          static bool check_cmd_frame(uint8_t *cmd, uint8_t size);
     38          void cmd_answer(uint8_t ATYPE, uint8_t *data, uint8_t len);
     39          void cmd_answer_err(uint8_t a_type, uint8_t err_code);
     40          
     41          typedef bool(*cmd_handler)(uint8_t *cmd, uint8_t size);
     42          
     43          // Список обработчиков. Номер команды = индекс в массиве
     44          static cmd_handler CMD_LIST[] = { 
     45            cmd_0x00, cmd_0x01, cmd_0x02, cmd_0x03, cmd_0x04, cmd_0x05, cmd_0x06,
     46            cmd_0x07, cmd_0x08, cmd_0x09, cmd_0x0A, cmd_0x0B, cmd_0x0C, cmd_0x0D,
     47            cmd_0x0E
     48          };    
     49           
     50          
     51          
     52          /**
     53          @brief Разбор входящих команд от PC
     54          @detail После приема следует ответ если есть ошибки CRC, args, len.
     55           Если ошибок нет, то ответ формирует команда.
     56          */
     57          void parse_uart_stream(void)
     58          {
     59            uint8_t* cmd;
     60            uint8_t size;
     61            uint8_t iCmd;
     62            
     63            while (true){
     64              cmd = uart_recv_cmd(&size);
     65              if (!check_cmd_frame(cmd,size)){ // Кадр плохой
     66                cmd_answer_err(ATYPE_PAR_ERR, PAR_CRC16);
     67                continue; 
     68              }
     69                
     70              iCmd = cmd[0];
     71              if (!(iCmd < MAX_CMD_INDEX)){ // Нет такой команды
     72                cmd_answer_err(ATYPE_PAR_ERR, PAR_NOCMD);
     73                continue; 
     74              }
     75              
     76              if (!CMD_LIST[iCmd](&cmd[1], size - 1)) 
     77                continue; // если были ошибки в выполнении команды.
     78              
     79              // Впринципе проверять не нужно как завершилась команда, но на будующее 
     80              // оставлю этот функционал. 
     81              // Сюда приходим если нет проблем с командой
     82            }
     83          }
     84          
     85          /**
     86          @brief Ответ на команду с ошибкой
     87          @param[in] ATYPE тип ответа
     88          @param[in] data указатель на данные
     89          @param[in] len размер данных
     90          */
     91          void cmd_answer(uint8_t ATYPE, uint8_t *data, uint8_t len){
     92            // Отдаем заголовок
     93            uint8_t full_len = len+3; // Байт TYPE + 2б CRC16
     94            uint8_t an[2] = {full_len, ATYPE};
     95            uart_write((char*)an, sizeof(an));
     96            
     97            // Отдаем данные
     98            uart_write((char*)data, len);
     99            
    100            unsigned short an_crc16 = crc16(data,len);
    101            uart_write((char*)an_crc16, sizeof(an_crc16));  
    102          }
    103          
    104          void cmd_answer_err(uint8_t a_type, uint8_t err_code){
    105            // Отдаем заголовок
    106            uint8_t answ_err[] = {a_type, err_code};
    107            stream_write(answ_err, sizeof(answ_err));
    108          }
    109          
    110          /**
    111          @brief Отправляем данные в PC. 
    112          @brief Формирует байт размера и добавляет CRC16
    113          */
    114          void stream_write(uint8_t *data, uint8_t size)
    115          {
    116            ASSERT(size > 0 && size < 253) // +2 CRC +1 LEN +252 DATA = 255 максимум
    117            uint8_t nsize = size + 2; // Два байта CRC
    118            unsigned short data_crc16 = crc16(data, size);
    119            uart_write((char*)&nsize, 1);
    120            uart_write((char*)data, size);
    121            uart_write((char*)&data_crc16 , 2);
    122          }
    123          
    124          /**
    125          @brief Проверка коректности принятого пакета
    126          */
    127          static bool check_cmd_frame(uint8_t *cmd, uint8_t size)
    128          {  
    129            if (size < 3) // Размер данных не может быть меньше 3 байт
    130                return false;
    131              
    132          #ifdef USE_CRC16_CHECK    
    133            unsigned short* cmd_crc16;
    134            unsigned short data_crc16;  
    135            // Извлекаем CRC16 из пакета (последнии 2 байта) 
    136            cmd_crc16 = (unsigned short*)&cmd[size - 2];
    137            // Расчитываем CRC16 данных
    138            data_crc16 = crc16(cmd, size - 2);
    139            // Если данные битые то продолжаем прием
    140            if (data_crc16 != *cmd_crc16)
    141              return false;
    142          #endif
    143          
    144            return true;
    145          }
    146          
    147          /**
    148          @brief Расчет CRC16
    149          @param[in] pcBlock указатель на начало масива
    150          @param[in] len размер данных для подсчета
    151          @return код crc16
    152          */
    153          static unsigned short crc16(unsigned char *pcBlock, unsigned short len){
    154              unsigned short crc = 0xFFFF;
    155              unsigned char i;
    156           
    157              while (len--)
    158              {
    159                  crc ^= *pcBlock++ << 8;
    160           
    161                  for (i = 0; i < 8; i++)
    162                      crc = crc & 0x8000 ? (crc << 1) ^ 0x1021 : crc << 1;
    163              }
    164           
    165              return crc;
    166          }
E:\WMNU\IAR\SHARE_PRJ_SRC\coder.c
      1          /*!
      2          \file Модуль шифрования данных
      3          \brief Функции кодирования данных
      4          */
      5          
      6          #include "coder.h"
      7          #include "ioCC2530.h"
      8          #include "string.h"
      9          #include "delays.h" // Для профилирования, Отладка
     10          #include "dma.h"
     11          
     12          #define AES_START()  {ENCCS |= 0x01;} //!< Запуск выполнения команды  
     13          #define AES_SET_MODE(mode) {ENCCS &= ~0x70; ENCCS |= mode;} //!< Установка режима
     14          #define AES_SET_OPERATION(op) {ENCCS = (ENCCS & ~0x07) | op;} 
     15          #define AES_RDY() (ENCCS & 8) //!< Состояние модуля
     16          
     17          
     18          #define BV(n)                   (1 << (n))
     19          #define MIC_2_MICLEN(m)         (BV((m&3)+1) & ~3)
     20          
     21          // Режимы шифрования
     22          #define AES_MODE_CBC            0x00
     23          #define AES_MODE_CFB            0x10
     24          #define AES_MODE_OFB            0x20
     25          #define AES_MODE_CTR            0x30
     26          #define AES_MODE_ECB            0x40
     27          #define AES_MODE_CBCMAC         0x50
     28          
     29          // Операции 
     30          #define AES_ENCRYPT             0x00
     31          #define AES_DECRYPT             0x02
     32          #define AES_LOAD_KEY            0x04
     33          #define AES_LOAD_IV             0x06
     34          
     35          #define ENC_DW 29 // DMA AES тригер запрос загрузки
     36          #define ENC_UP 30 // DMA AES тригер запрос выгрузки
     37          
     38          #define STREAM_ENC_MODE     AES_MODE_OFB //!< Метод шифрования потока данных
     39          
     40          // Доступные методы
     41          void AES_StreamCoder(bool enc_mode, uint8_t *src, uint8_t *dst, 
     42                               uint8_t *key, uint8_t *nonce, uint8_t len);
     43          
     44          // Приватные функции
     45          static inline uint8_t generateAuthData(uint8_t *src, uint8_t *nonce, uint8_t c,
     46                                                 uint8_t f, uint8_t lm);
     47          static void CBCMAC_buf_encrypt(uint8_t len, uint8_t *key, uint8_t *mac);
     48          
     49          /**
     50          @brief Локальный буфер для работы режима CCM
     51          @detail 128 длина сообщения. 18 длинна блока B0 и строки состояния.
     52           16 длина дополнения нулями
     53          */
     54          static uint8_t buf[128+18+16]; 
     55          
     56          
     57          typedef struct //!< Структура блока B0 для режима CCM
     58          {
     59            struct 
     60            {
     61              uint8_t L:3;
     62              uint8_t M:3;
     63              uint8_t A_Data:1;
     64            } flag;
     65            uint16_t nonce[9];
     66            uint8_t L_M[6];
     67          } __attribute__((packed)) B0_s;
     68          
     69          typedef struct //!< Структура блока A0 для режима CCM
     70          {
     71            struct 
     72            {
     73              uint8_t L:3;
     74            } flag;
     75            uint8_t nonce[11];
     76            uint8_t ctr;
     77          } __attribute__((packed)) A0_s;
     78          
     79          
     80          
     81          /**
     82          @brief Иницилизация модуля
     83          @detail Модуль использует DMA каналы 0 и 1
     84          */
     85          void AES_init(void)
     86          {
     87            //DMA_AES_s DMA_CH[0]; //!< DMA на запись будет DMA[0]
     88            //DMA_AES_s DMA_CH[1]; //!< DMA на чтение DMA_CH[1]
     89            
     90            ST_DEF(DMA_CH[0], DSTADDRH, 0x70); // Пишем данные XENCDI = 0xB1 
     91            ST_DEF(DMA_CH[0], DSTADDRL, 0xB1); //  
     92            ST_DEF(DMA_CH[0], PRIORITY, 0x00); // Низкий приоритет
     93            ST_DEF(DMA_CH[0], M8, 0x00); // Используем 8 бит для счетика длинны
     94            ST_DEF(DMA_CH[0], IRQMASK, 0x00); // Запрещаем генерировать перывания
     95            ST_DEF(DMA_CH[0], DESTINC, 0x00); // Не увеличиваем адресс назначения
     96            ST_DEF(DMA_CH[0], SRCINC, 0x01); // Увеличиваем адресс источника
     97            ST_DEF(DMA_CH[0], TRIG, ENC_DW); // Тригер по загрузке
     98            ST_DEF(DMA_CH[0], WORDSIZE, 0x00); // Копируем по 1 байту
     99            ST_DEF(DMA_CH[0], TMODE, 0x01); //  Блочное копирование по тригеру
    100            ST_DEF(DMA_CH[0], VLEN, 0x00); //  Количество байт определяет поле LEN  
    101            ST_DEF(DMA_CH[0], LENH, 0x00); 
    102            
    103            ST_DEF(DMA_CH[1], SRCADDRH, 0x70); // Читаем данные из X_ENCDO  
    104            ST_DEF(DMA_CH[1], SRCADDRL, 0xB2);  
    105            ST_DEF(DMA_CH[1], PRIORITY, 0x00); // Низкий приоритет
    106            ST_DEF(DMA_CH[1], M8, 0x00); // Используем 8 бит для счетика длинны
    107            ST_DEF(DMA_CH[1], IRQMASK, 0x00); // Запрещаем генерировать перывания
    108            ST_DEF(DMA_CH[1], DESTINC, 0x01); // Увеличиваем адресс назначения
    109            ST_DEF(DMA_CH[1], SRCINC, 0x00); // Не увеличиваем адресс источника
    110            ST_DEF(DMA_CH[1], TRIG, ENC_UP); // Тригер по выгрузке
    111            ST_DEF(DMA_CH[1], WORDSIZE, 0x00); // Копируем по 1 байту
    112            ST_DEF(DMA_CH[1], TMODE, 0x01); //  Блочное копирование по тригеру
    113            ST_DEF(DMA_CH[1], VLEN, 0x00); //  Количество байт определяет поле LEN  
    114            ST_DEF(DMA_CH[1], LENH, 0x00); 
    115          }
    116          
    117          /**
    118          @brief Шифрует/дешифрует поток данных во время радиопередачи. Без проверки MIC
    119          @param[in] enc_mode Режим работы процедуры. true - шифрование.
    120          @param[in] src Указатель на данные подлежащии шифрованию
    121          @param[in] dst Указтель куда будут помещены зашифрованные данные
    122          @param[in] key Указатье на ключ. 16 байт
    123          @param[in] iv  Указатель на вектор иницилизации. 16 байт 
    124          @param[in] len Длинна данных
    125          */
    126          void AES_StreamCoder(bool enc_mode, uint8_t *src, uint8_t *dst, uint8_t *key,
    127                                   uint8_t *iv, uint8_t len)
    128          {
    129            // Установим метод кодироваения
    130            AES_SET_MODE(STREAM_ENC_MODE);
    131              
    132            // Загружаем ключ
    133            AES_SET_OPERATION(AES_LOAD_KEY);
    134            ST_DEF(DMA_CH[0], SRCADDRL, LADDR(key));
    135            ST_DEF(DMA_CH[0], SRCADDRH, HADDR(key));
    136            ST_DEF(DMA_CH[0], LENL, 16);
    137            DMAARM |= 0x01;
    138            while(!AES_RDY());
    139            AES_START();
    140            while (DMAARM&0x01);
    141          
    142            // Загружаем IV
    143            AES_SET_OPERATION(AES_LOAD_IV);
    144            ST_DEF(DMA_CH[0], SRCADDRL, LADDR(iv));
    145            ST_DEF(DMA_CH[0], SRCADDRH, HADDR(iv));
    146            ST_DEF(DMA_CH[0], LENL, 16);
    147            DMAARM |= 0x01;
    148            while(!AES_RDY());
    149            AES_START();
    150            while (DMAARM&0x01);
    151          
    152            // Установим необходимую операцию AES
    153            if (enc_mode) 
    154              AES_SET_OPERATION(AES_ENCRYPT)
    155            else 
    156              AES_SET_OPERATION(AES_DECRYPT)
    157            
    158            switch(STREAM_ENC_MODE) 
    159            {
    160            case AES_MODE_ECB: // ECB, CBC не реализованы
    161            case AES_MODE_CBC:
    162              break;
    163            case AES_MODE_CFB:
    164            case AES_MODE_OFB:
    165            case AES_MODE_CTR:
    166              {
    167                // Загрузка блоками по 128 бит с разделением на под-блоки по 32 бита
    168                uint8_t nbrBlocks = len / 16; // Количество целых блоков по 128 бит
    169                uint8_t ptr, sub_ptr; // Смещение
    170                uint8_t *download, *upload;
    171                
    172                // Для этих типов шифрования длина блоков по 4 байта
    173                ST_DEF(DMA_CH[0], LENL, 4);
    174                ST_DEF(DMA_CH[1], LENL, 4);
    175                
    176                // Шифруем все целые блоки
    177                for (uint8_t block = 0; block < nbrBlocks; block ++)
    178                {
    179                  ptr = 16 * block;
    180                  while(!AES_RDY());
    181                  AES_START();
    182                  for (uint8_t j = 0; j < 4; j++)
    183                  {
    184                    sub_ptr = ptr + 4*j;
    185                    download = &src[sub_ptr];
    186                    upload = &dst[sub_ptr];
    187                    // Указываем адресс DMA откуда читать данные
    188                    ST_DEF(DMA_CH[0], SRCADDRL, LADDR(download));
    189                    ST_DEF(DMA_CH[0], SRCADDRH, HADDR(download));
    190                    // Указываем адрес DMA куда записывать данные          
    191                    ST_DEF(DMA_CH[1], DSTADDRL, LADDR(upload));
    192                    ST_DEF(DMA_CH[1], DSTADDRH, HADDR(upload));
    193                    // Активируем DMA
    194                    DMAARM |= 0x03;  
    195                    DMAREQ |= 0x01;
    196                    while (DMAARM&0x03);          
    197                  }
    198                }     
    199                // Шифруем последний блок
    200                uint8_t block_len = len % 16; // Размер последнего блока
    201                
    202                // Завершаем работу если блок пустой
    203                if (!block_len)
    204                  return;
    205                
    206                uint8_t padding_block[16]; // Блок заполненый нулями
    207                ptr = 16*nbrBlocks; // Смещение на первый байт последнего блока в src
    208                memset(padding_block, 0x00, sizeof(padding_block)); // Заполняем нулями
    209                memcpy(padding_block, &src[ptr], block_len); // Копируем данные
    210                
    211                while(!AES_RDY());
    212                AES_START();
    213                for (uint8_t j = 0; j < 4; j++)
    214                  {
    215                    sub_ptr = 4*j;
    216                    download = &padding_block[sub_ptr];
    217                    // Указываем адресс DMA откуда читать данные
    218                    ST_DEF(DMA_CH[0], SRCADDRL, LADDR(download));
    219                    ST_DEF(DMA_CH[0], SRCADDRH, HADDR(download));
    220                    // Указываем аддрес DMA куда записывать данные          
    221                    ST_DEF(DMA_CH[1], DSTADDRL, LADDR(download));
    222                    ST_DEF(DMA_CH[1], DSTADDRH, HADDR(download));
    223                    // Активируем DMA
    224                    DMAARM |= 0x03;  
    225                    DMAREQ |= 0x01;
    226                    while (DMAARM&0x03);
    227                  }
    228                memcpy(&dst[ptr], padding_block, block_len); // Копируем в src
    229                
    230              } //CASE
    231              
    232              break;
    233            } 
    234          }
    235          
    236          /**
    237          @brief Шифрует/дешифрует поток данных во время радиопередачи. Без проверки MIC
    238          @param[in] enc_mode Режим работы процедуры. true - шифрование.
    239          @param[in] src Указатель на данные подлежащии шифрованию
    240          @param[in] dst Указтель куда будут помещены зашифрованные данные
    241          @param[in] key Указатье на ключ. 16 байт
    242          @param[in] iv  Указатель на вектор иницилизации. 16 байт 
    243          @param[in] len Длинна данных
    244          */
    245          static void CTR_enc_decrypt(bool enc_mode, uint8_t *src, uint8_t *dst, uint8_t *key,
    246                                   uint8_t *iv, uint8_t len)
    247          {
    248            // Установим метод кодироваения
    249            AES_SET_MODE(AES_MODE_CTR);
    250            
    251            // Загружаем ключ
    252            AES_SET_OPERATION(AES_LOAD_KEY);
    253            ST_DEF(DMA_CH[0], SRCADDRL, LADDR(key));
    254            ST_DEF(DMA_CH[0], SRCADDRH, HADDR(key));
    255            ST_DEF(DMA_CH[0], LENL, 16);
    256            DMAARM |= 0x01;
    257            while(!AES_RDY());
    258            AES_START();
    259            while (DMAARM&0x01);
    260          
    261            // Загружаем IV
    262            AES_SET_OPERATION(AES_LOAD_IV);
    263            ST_DEF(DMA_CH[0], SRCADDRL, LADDR(iv));
    264            ST_DEF(DMA_CH[0], SRCADDRH, HADDR(iv));
    265            ST_DEF(DMA_CH[0], LENL, 16);
    266            DMAARM |= 0x01;
    267            while(!AES_RDY());
    268            AES_START();
    269            while (DMAARM&0x01);
    270          
    271            // Установим необходимую операцию AES
    272            if (enc_mode) 
    273              AES_SET_OPERATION(AES_ENCRYPT)
    274            else 
    275              AES_SET_OPERATION(AES_DECRYPT)
    276            
    277            // Загрузка блоками по 128 бит с разделением на под-блоки по 32 бита
    278            uint8_t nbrBlocks = len / 16; // Количество целых блоков по 128 бит
    279            uint8_t ptr, sub_ptr; // Смещение
    280            uint8_t *download, *upload;
    281                
    282            // Для этих типов шифрования длина блоков по 4 байта
    283            ST_DEF(DMA_CH[0], LENL, 4);
    284            ST_DEF(DMA_CH[1], LENL, 4);
    285                
    286            // Шифруем все целые блоки
    287            for (uint8_t block = 0; block < nbrBlocks; block ++)
    288              {
    289                ptr = 16 * block;
    290                while(!AES_RDY());
    291                AES_START();
    292                for (uint8_t j = 0; j < 4; j++)
    293                  {
    294                    sub_ptr = ptr + 4*j;
    295                    download = &src[sub_ptr];
    296                    upload = &dst[sub_ptr];
    297                    // Указываем адресс DMA откуда читать данные
    298                    ST_DEF(DMA_CH[0], SRCADDRL, LADDR(download));
    299                    ST_DEF(DMA_CH[0], SRCADDRH, HADDR(download));
    300                    // Указываем адрес DMA куда записывать данные          
    301                    ST_DEF(DMA_CH[1], DSTADDRL, LADDR(upload));
    302                    ST_DEF(DMA_CH[1], DSTADDRH, HADDR(upload));
    303                    // Активируем DMA
    304                    DMAARM |= 0x03;  
    305                    DMAREQ |= 0x01;
    306                    while (DMAARM&0x03);          
    307                  }
    308              }     
    309              // Шифруем последний блок
    310              uint8_t block_len = len % 16; // Размер последнего блока
    311                
    312              // Завершаем работу если блок пустой
    313              if (!block_len)
    314                return;
    315                
    316              uint8_t padding_block[16]; // Блок заполненый нулями
    317              ptr = 16*nbrBlocks; // Смещение на первый байт последнего блока в src
    318              memset(padding_block, 0x00, sizeof(padding_block)); // Заполняем нулями
    319              memcpy(padding_block, &src[ptr], block_len); // Копируем данные
    320              
    321              while(!AES_RDY());
    322              AES_START();
    323              for (uint8_t j = 0; j < 4; j++)
    324                {
    325                  sub_ptr = 4*j;
    326                  download = &padding_block[sub_ptr];
    327                  // Указываем адресс DMA откуда читать данные
    328                  ST_DEF(DMA_CH[0], SRCADDRL, LADDR(download));
    329                  ST_DEF(DMA_CH[0], SRCADDRH, HADDR(download));
    330                  // Указываем аддрес DMA куда записывать данные          
    331                  ST_DEF(DMA_CH[1], DSTADDRL, LADDR(download));
    332                  ST_DEF(DMA_CH[1], DSTADDRH, HADDR(download));
    333                  // Активируем DMA
    334                  DMAARM |= 0x03;  
    335                  DMAREQ |= 0x01;
    336                  while (DMAARM&0x03);
    337                }
    338              memcpy(&dst[ptr], padding_block, block_len); // Копируем в src
    339          }
    340          
    341          /**
    342          @brief Зашифровывает buf в режиме CBC-MAC с IV = 0
    343          @param[in] len улинна последовательности для вычисления MAC
    344          @param[out] mac указатель на память куда будет записан mac (до 16 байт)
    345          */
    346          static void CBCMAC_buf_encrypt(uint8_t len, uint8_t *key, uint8_t *mac)
    347          {
    348            uint8_t IV[16];
    349            
    350            // Заполняем вектор нулями
    351            memset(IV, 0x00, sizeof(IV));
    352            
    353            // Установим метод кодироваения
    354            AES_SET_MODE(AES_MODE_CBCMAC);  
    355            
    356            { // Сворачиваем код для улучшения чтения
    357            // Загружаем ключ
    358            AES_SET_OPERATION(AES_LOAD_KEY);
    359            ST_DEF(DMA_CH[0], SRCADDRL, LADDR(key));
    360            ST_DEF(DMA_CH[0], SRCADDRH, HADDR(key));
    361            ST_DEF(DMA_CH[0], LENL, 16);
    362            DMAARM |= 0x01;
    363            while(!AES_RDY());
    364            AES_START();
    365            while (DMAARM&0x01);
    366          
    367            // Загружаем IV
    368            AES_SET_OPERATION(AES_LOAD_IV);
    369            ST_DEF(DMA_CH[0], SRCADDRL, LADDR(IV));
    370            ST_DEF(DMA_CH[0], SRCADDRH, HADDR(IV));
    371            ST_DEF(DMA_CH[0], LENL, 16);
    372            DMAARM |= 0x01;
    373            while(!AES_RDY());
    374            AES_START();
    375            while (DMAARM&0x01);
    376            };
    377            
    378            // Устанавливаем операцию шифрования
    379            AES_SET_OPERATION(AES_ENCRYPT);
    380            
    381            // Загрузка блоками по 128 бит
    382            uint8_t nbrBlocks = len / 16; // Количество целых блоков по 128 бит
    383            uint8_t block_len = len % 16; // Размер последнего блока
    384            uint8_t ptr; // Смещение
    385                
    386            // Для этого типа шифрования длина блоков по 16 байт
    387            ST_DEF(DMA_CH[0], LENL, 16);
    388            // Устанавливаем куда будем выгружать вычисленный MAC
    389            ST_DEF(DMA_CH[1], DSTADDRL, LADDR(mac));
    390            ST_DEF(DMA_CH[1], DSTADDRH, HADDR(mac));
    391            ST_DEF(DMA_CH[1], LENL, 16);
    392            
    393            // Шифруем все целые блоки
    394            for (uint8_t block = 0; block < nbrBlocks; block ++)
    395              {
    396                // Последний блок шифруем в режиме CBC при условии что нет блок не 
    397                // кратного 16 байтам.
    398                if (!block_len && (block == nbrBlocks - 1))
    399                  AES_SET_MODE(AES_MODE_CBC);
    400                    
    401                ptr = 16 * block;
    402                while(!AES_RDY());
    403                AES_START();
    404                // Указываем адресс DMA откуда читать данные
    405                ST_DEF(DMA_CH[0], SRCADDRL, LADDR(buf[ptr]));
    406                ST_DEF(DMA_CH[0], SRCADDRH, HADDR(buf[ptr]));
    407                // Активируем DMA
    408                DMAARM |= 0x01;  
    409                // Активируем выгрузку только последнего блока
    410                if (!block_len && (block == nbrBlocks - 1))
    411                  DMAARM |= 0x03;
    412                
    413                DMAREQ |= 0x01;
    414                while (DMAARM&0x03);          
    415               }
    416                 
    417            // Шифруем последний блок в режиме CBC
    418            AES_SET_MODE(AES_MODE_CBC);
    419                    
    420            // Завершаем работу если блок пустой
    421            if (!block_len)
    422              return;
    423                
    424            uint8_t padding_block[16]; // Блок заполненый нулями
    425            ptr = 16*nbrBlocks; // Смещение на первый байт последнего блока в src
    426            memset(padding_block, 0x00, sizeof(padding_block)); // Заполняем нулями
    427            memcpy(padding_block, &buf[ptr], block_len); // Копируем данные
    428                
    429            while(!AES_RDY());
    430            AES_START();
    431            // Указываем адресс DMA откуда читать данные
    432            ST_DEF(DMA_CH[0], SRCADDRL, LADDR(padding_block));
    433            ST_DEF(DMA_CH[0], SRCADDRH, HADDR(padding_block));
    434            // Активируем DMA и выгрузку MAC
    435            DMAARM |= 0x03;  
    436            DMAREQ |= 0x01;
    437            while (DMAARM&0x03);
    438          }
    439          
    440          static inline uint8_t generateAuthData(uint8_t *src, uint8_t *nonce, uint8_t c,
    441                                                 uint8_t f, uint8_t lm)
    442          {
    443            memcpy(buf, nonce,16);
    444            
    445            // Буфер от 0 до 15 байта специальный блок B0
    446            // Настраиваем флаг. У нас длинна 2 байта. nonce 13 байт => L_M = L-1=0x01
    447            buf[0]=  0x01;  
    448            // Если есть данные для авторизации установим A_Data 
    449            if (f > 0)
    450              buf[0] |= 0x40;
    451            
    452            buf[0] |= ((lm - 2) / 2 ) << 3;   // см. документацию M'= (lm-2) / 2;
    453            
    454            // Устанавливаем длинну сообщения
    455            buf[14] = 0x00;
    456            buf[15] = c;
    457            
    458            // Добавляем строку авторизации L(a). если данных нет, то она пустая. f=0
    459            buf[16]= 0;
    460            buf[17]= f;
    461            
    462            // Копируем данные авторизации в буфер
    463            memcpy(&buf[18], src, f);
    464            
    465            // Смещение на следующий байт после данных авторизации.
    466            // Данные авторизации занимают положение в буфере [18, 18+f]
    467            uint8_t ptr_end= 18 + f;
    468            // Заполняем нулями до границы 16 байт  
    469            while (ptr_end & 0x0f)
    470              buf[ptr_end++] = 0x00;
    471            
    472            // Копируем данные для шифрования в буфер после нулей
    473            memcpy(&buf[ptr_end], &src[f], c);
    474            
    475            // Возвращаем размер данных в буфере
    476            return ptr_end+c;
    477          };
    478          
    479          /**
    480          @brief Шифрует/дешифрует данные с проверкой MIC
    481          @param[in] src Указатель на данные подлежащии шифрованию
    482          @param[in] len Размер данных
    483          @param[in] с Количество байт для шифрования
    484          @param[in] f Количество байт для авторизации
    485          @param[in] m Размер MIC (m=1,2,3 l(m) = 4,8,16 байт)
    486          @param[in] iv  Указатель на вектор иницилизации. 16 байт 
    487          @param[in] len Длинна данных
    488          @param[in,out] MIC Указатель на массив соответсвующий длинне (4,8,16 байт)
    489          */
    490          void AES_CCMEncrypt( uint8_t *src, uint8_t c, uint8_t f, uint8_t m,
    491                              uint8_t *key, uint8_t *nonce, uint8_t *MIC)
    492          {
    493            uint8_t lm = MIC_2_MICLEN(m);
    494            
    495            // Генерируем данные для авторизации
    496            uint8_t dlen = generateAuthData(src, nonce, c, f, lm);
    497            
    498            uint8_t mac[16]; // Сюда пишем мак
    499            CBCMAC_buf_encrypt(dlen, key, mac);
    500            
    501            // Шифруем MAC
    502            uint8_t CTR_IV[16];
    503            memcpy(CTR_IV, nonce, 16);
    504            CTR_IV[0] = 0x01; // Флаг режима CTR
    505            CTR_IV[15] = 0;   // Значение счетчика
    506            CTR_enc_decrypt(true, mac, mac, key, CTR_IV, 16);
    507            
    508            // Шифруем текст. он имеет размер 'c' и находится в буфере начиная с
    509            // dlen-c, dlen
    510            uint8_t ds = dlen - c; // Начало данных для шифрования
    511            
    512            // 0x0F & (16 - (dlen & 0x0f)) оставляет числа от 0 до 15  
    513            memset(buf+dlen, 0x00, 0x0F & (16 - (dlen & 0x0f)) ); // Дополняем нулями
    514            CTR_IV[15] = 1; // Счетчик CTR
    515            CTR_enc_decrypt(true, &buf[ds], &buf[ds], key, CTR_IV, c); // Шифруем
    516            
    517            // Заполняем буфер буфер src. src[0,f] это данные авторизации. 
    518            // src[f, f+c] это шифрованные данные.
    519            memcpy(&src[f], &buf[ds], c); 
    520            memcpy(MIC, mac, lm);
    521            
    522            //https://github.com/zhaohengyi/CC2530Example/blob/
    523            //master/source/components/radios/cc2530/hal_rf_security.c
    524          }
    525          
    526          /**
    527          @brief Дешифрует данные с проверкой MIC
    528          @param[in] src Указатель на данные подлежащии шифрованию
    529          @param[in] len Размер данных
    530          @param[in] с Количество байт для шифрования
    531          @param[in] f Количество байт для авторизации
    532          @param[in] m Размер MIC (m=1,2,3 l(m) = 4,8,16 байт)
    533          @param[in] iv  Указатель на вектор иницилизации. 16 байт 
    534          @param[in] len Длинна данных
    535          @param[in,out] MIC Указатель на массив соответсвующий длинне (4,8,16 байт)
    536          */
    537          bool AES_CCMDecrypt( uint8_t *src, uint8_t c, uint8_t f, uint8_t m,
    538                              uint8_t *key, uint8_t *nonce, uint8_t *MIC)
    539          {
    540            uint8_t lm = MIC_2_MICLEN(m);
    541            
    542            // Расшифровываем MAC
    543            uint8_t mac[16]; // Расшифрованый мак
    544            uint8_t CTR_IV[16];
    545            memcpy(CTR_IV, nonce, 16);
    546            CTR_IV[0] = 0x01; // Флаг режима CTR
    547            CTR_IV[15] = 0;   // Значение счетчика
    548            CTR_enc_decrypt(false, MIC, mac, key, CTR_IV, lm);  
    549            
    550            // Генерируем данные для авторизации
    551            uint8_t dlen = generateAuthData(src, nonce, c, f, lm);
    552            
    553            // Дешифруем текст. он имеет размер 'c' и находится в буфере начиная с
    554            // dlen-c, dlen
    555            uint8_t ds = dlen - c; // Начало данных для дешифрования
    556            
    557            // 0x0F & (16 - (dlen & 0x0f)) оставляет числа от 0 до 15  
    558            memset(buf+dlen, 0x00, 0x0F & (16 - (dlen & 0x0f)) ); // Дополняем нулями
    559            CTR_IV[15] = 1; // Счетчик CTR
    560            CTR_enc_decrypt(false, &buf[ds], &buf[ds], key, CTR_IV, c); // Дешифруем
    561            
    562            uint8_t new_mac[16]; // мак полученный в ходе рашифровки сообщения
    563            CBCMAC_buf_encrypt(dlen, key, new_mac);
    564            
    565            // Проверяем что маки совпадают, значит дешифровано верно
    566            bool mac_equal = true;
    567            for (uint8_t i = 0 ; i < lm ; i++)
    568            {
    569              if (mac[i] != new_mac[i])
    570              mac_equal = false;
    571              break;
    572            }
    573            
    574            // Выходим если MACи не совпали  
    575            if (!mac_equal)
    576              return false;
    577            
    578            // Копируем  расшифрованные данные
    579            memcpy(&src[f], &buf[ds], c); 
    580            return true;
    581          }
E:\WMNU\IAR\SHARE_PRJ_SRC\config.c
      1          #include "stdint.h"
      2          #include "string.h"
      3          #include "stdbool.h"
      4          #include "string.h"
      5          #include "basic.h"
      6          #include "config.h"
      7          
      8          static uint8_t default_key[16] = DEFAULT_KEY;
      9          static uint8_t default_iv[16] = DEFAULT_IV;
     10          database_s CONFIG;
     11          
     12          
     13          void CF_init()
     14          {
     15            // Загрузка данных из различных источников
     16            memcpy(CONFIG.stream_key, default_key, 16); 
     17            memcpy(CONFIG.stream_iv,  default_iv, 16);
     18            CONFIG.node_ver = NODE_VER;
     19            CONFIG.node_type = NODE_TYPE;
     20            CONFIG.sync_channel = DEFAULT_SYNC_CHANNEL;
     21            CONFIG.panid = DEFAULT_PANID;
     22          }
E:\WMNU\IAR\SHARE_PRJ_SRC\delays.c
      1          /*!
      2          \file  Модуль измерения интервалов времени и функция задержки времени
      3          \brief Функции измерения времени и задержки
      4          */
      5          
      6          #include "ioCC2530.h"
      7          #include "delays.h"
      8          #include "string.h"
      9          
     10          #define TICK_NS  31.25 // Количество нс в одном такте TIM2
     11          #define TICK_US  0.03125 // Количество мкс в одном такте TIM2
     12          #define TICK_PER_US 32 // Количество тактов в одной микросекунде
     13          
     14          // Максимальное кол-во тактов таймера. Константа 40 бит, 5 байт
     15          static const uint32_t MAC_TIMER_MAX = 0xFFFFFFFFUL; 
     16          static uint32_t DELAY_CALIBRATE_TICS; // Колибровка функции задержки
     17          
     18          // Публичные методы
     19          void TIM_init(void);
     20          void TIM_TimeStamp(TimeStamp_s* timestamp);
     21          void TIM_delay(uint32_t delay);
     22          uint32_t TIM_passedTime(TimeStamp_s* start, TimeStamp_s* stop);
     23          void TIM_copy(TimeStamp_s *src, TimeStamp_s *dst);
     24          
     25          // Приватные
     26          static inline uint32_t Interval(TimeStamp_s* start, TimeStamp_s* stop);
     27          static void DelayCalibrate(void);
     28          
     29          /**
     30          @brief Иницилизация таймера
     31          @brief Используется таймер 2. MAC таймер
     32          */
     33          void TIM_init(void)
     34          {
     35            // Запускаем таймер, LATCH MODE = 1
     36            // Latch mode фиксирует значение таймера переполнения при чтении T2M0
     37            // ЗАпускаем MAC таймер без синхронизации с кварцем 32.768к
     38            T2CTRL = (1<<0) | (1<<3); 
     39            // Калибровка функции задержки
     40            DelayCalibrate();
     41          }
     42          
     43          /**
     44          @brief Возвращает временую метку.
     45          @params[out] timestamp указатель на временную метку 
     46          */
     47          void TIM_TimeStamp(TimeStamp_s* timestamp)
     48          {
     49            timestamp->byte[0] = T2M0;
     50            timestamp->byte[1] = T2M1;
     51            timestamp->byte[2] = T2MOVF0;
     52            timestamp->byte[3] = T2MOVF1;
     53          }
     54          
     55          /**
     56          @brief Калибровка функции задержки TIM_delay
     57          */
     58          static void DelayCalibrate(void)
     59          {
     60            #define ACCURATE_VAL_US 500 
     61            DELAY_CALIBRATE_TICS = 0;
     62            TimeStamp_s start, stop;
     63            uint32_t passed, cal;
     64            
     65            TIM_TimeStamp(&start);
     66            TIM_delay(ACCURATE_VAL_US);
     67            TIM_TimeStamp(&stop);
     68            passed = TIM_passedTime(&start, &stop);
     69            
     70            cal = passed - ACCURATE_VAL_US;
     71            DELAY_CALIBRATE_TICS = cal * TICK_PER_US; 
     72          };
     73          
     74          /**
     75          @brief Вычисляет количество тактов между двумя времеными метками
     76          @return Количество тактов
     77          */
     78          static inline uint32_t Interval(TimeStamp_s* start, TimeStamp_s* stop)
     79          {
     80            uint32_t ret;
     81          
     82            if (stop->timer >= start->timer)
     83              ret = stop->timer - start->timer;
     84            else
     85            { 
     86              ret = (MAC_TIMER_MAX - start->timer) + stop->timer;
     87            }
     88            return ret;
     89          }
     90          
     91          /**
     92          @brief Вычисляет прошедшее время между двумя времеными метками
     93          @return Время в мкс.
     94          */
     95          uint32_t TIM_passedTime(TimeStamp_s* start, TimeStamp_s* stop)
     96          {
     97            uint32_t ret = Interval(start, stop);
     98            
     99            ret = (uint32_t)((float)ret * TICK_US);
    100            return ret;
    101          }
    102          
    103          /**
    104          @brief Задержка на заданное количество мкс. 
    105          @details Погрешность около 20 мкс при значениях выше 150 мкс.
    106           Рекомендуется использовать для организации задержек не менее 200 мкс.
    107          @params[in] delay количество микросекунд. Не более 134217727 мкс (134.2 сек)
    108          */
    109          void TIM_delay(uint32_t delay)
    110          {
    111            uint32_t passed = 0;
    112            TimeStamp_s start, now;
    113            TIM_TimeStamp(&start);
    114            
    115            // Конвертируем мкс в такты и вносим поправку
    116            delay = delay * TICK_PER_US; 
    117            if (delay > DELAY_CALIBRATE_TICS)
    118              delay -= DELAY_CALIBRATE_TICS;
    119            
    120            do
    121            {
    122              TIM_TimeStamp(&now);
    123              passed = Interval(&start, &now);
    124            } while (passed < delay);
    125          }
    126          
    127          /**
    128          @brief Копирование временной метки
    129          @param[in] src указатель на исходную метку для копирование
    130          @param[out] dst указатель на метку назначения
    131          */
    132          void TIM_copy(TimeStamp_s *src, TimeStamp_s *dst)
    133          {
    134            memcpy(src, dst, sizeof(TimeStamp_s));
    135          }
E:\WMNU\IAR\SHARE_PRJ_SRC\dma.c
      1          #include "dma.h"
      2          #include "ioCC2530.h"
      3          
      4          DMA_s DMA_CH[5];
      5          
      6          /**
      7          @brief Настройка DMA каналов.
      8          @detail Согласно документации каналы 1-4 идут последовательно
      9          */
     10          void DMA_init()
     11          {
     12              // Настроим канал 0 DMA для загрузки данных в AES
     13            uint16_t CONF_ADDR = (uint16_t)&DMA_CH[0];
     14            DMA0CFGH = CONF_ADDR >> 8;
     15            DMA0CFGL = CONF_ADDR & 0xFF;
     16            
     17            // Настроим канал 1 DMA для выгрузки данных из AES
     18            CONF_ADDR = (uint16_t)&DMA_CH[1];
     19            DMA1CFGH = CONF_ADDR >> 8;
     20            DMA1CFGL = CONF_ADDR & 0xFF;
     21          }
E:\WMNU\IAR\SHARE_PRJ_SRC\ethernet.c
      1          #include "frame.h"
      2          #include "Net_frames.h"
      3          #include "stdint.h"
      4          #include "nwdebuger.h"
      5          #include "LLC.h"
      6          #include "mem.h"
      7          
      8          void ETH_Send(frame_s *fr);
      9          
     10          static void ETH_RX_HNDL(frame_s *fr);
     11          static void (*RXCallback)(frame_s *fr); //frame_s RAW_LAY, wthout ETH_LAY
     12          static bool validate(ETH_LAY *eth);
     13          static ETH_LAY* extract_header(frame_s *fr);
     14          static void send_ack(ETH_LAY *eth);
     15          static frame_s* strip_header(frame_s *fr);
     16          
     17          /**
     18          @brief Иницилизация модуля
     19          */
     20          void ETH_Init(void)
     21          {
     22            RXCallback = NULL; 
     23            LLC_SetRXCallback(ETH_RX_HNDL);
     24          }
     25          
     26          /**
     27          @brief Установка обработчика приема пакета ETH
     28          */
     29          void ETH_Set_RXCallback(void (*fn)(frame_s *fr))
     30          {
     31            ASSERT(fn != NULL);
     32            RXCallback = fn;
     33          }
     34          
     35          /**
     36          @brief Обработка принятого пакет сети.
     37          @detail После валидации пакета, уничтожается заголовок ETH и пакет передается
     38           на дальнейшую обработку вверх по стеку с помощью обратного вызова RXCallback
     39          */
     40          static void ETH_RX_HNDL(frame_s *fr)
     41          {
     42            ASSERT(fr != NULL);
     43            
     44            bool valid;
     45            frame_s *striped_frame;
     46            
     47            ETH_LAY* eth_h = extract_header(fr);
     48            
     49            // Извлечь заголовок не удалось
     50            if (eth_h == NULL)
     51              goto ERR_FRAME;
     52            
     53            valid = validate(eth_h);
     54           
     55            // Заголовок не верный
     56            if (!valid)
     57              goto ERR_FRAME;
     58           
     59            // Требуется отправить подтверждение приема пакета
     60            if (eth_h->ETH_T.bits.ACK)
     61              send_ack(eth_h);
     62            
     63            // Создаем новый пакет без заголовка и удаляем исходный
     64            striped_frame = strip_header(fr);
     65            frame_delete(fr);
     66            ASSERT(striped_frame != NULL);
     67            
     68            // Передаем обработчику выше по стеку
     69            ASSERT(RXCallback != NULL);
     70            RXCallback(striped_frame);
     71            
     72            re_free(eth_h);
     73            return;
     74            
     75          ERR_FRAME:
     76            frame_delete(fr);
     77            re_free(eth_h);
     78            return;
     79          }
     80          
     81          /**
     82          @brief Создает новый пакет без заголовка ETH_H
     83          @return указатель на новый frame_s*. NULL - не удалось создать пакет
     84          */
     85          static frame_s* strip_header(frame_s *fr)
     86          {
     87          }
     88          
     89          /**
     90          @brief Подготавливает и отпправляет подтверждение приема пакета
     91          */
     92          static void send_ack(ETH_LAY *eth)
     93          {
     94           
     95          }
     96          
     97          static bool validate(ETH_LAY *eth)
     98          {
     99            return true;
    100          }
    101          
    102          static ETH_LAY* extract_header(frame_s *fr)
    103          {
    104            ETH_LAY* eth_h = (ETH_LAY*)re_malloc(ETH_LAY_SIZE);
    105            ASSERT(eth_h != NULL);
    106            
    107            uint8_t len = frame_len(fr);
    108            ASSERT(len >= ETH_LAY_SIZE);
    109            
    110            //fbuf_s *fb = frame_get_fbuf_head(fr);
    111            //re_memcpy(eth_h, fb->payload, ETH_LAY_SIZE);
    112            return eth_h;
    113          }
E:\WMNU\IAR\SHARE_PRJ_SRC\frame.c
      1          /**
      2          @file Модуль описывает сетевой кадр и связанные с ним буферы данных
      3          @brief Типы frame
      4          */
      5          
      6          #include "frame.h"
      7          #include "string.h"
      8          #include "mem.h"
      9          #include "nwdebuger.h"
     10          #include "ioCC2530.h"
     11          
     12          frame_s* frame_create(void);
     13          void frame_delete(frame_s *fr);
     14          uint8_t frame_len(frame_s *fr);
     15          uint8_t frame_getCount(void);
     16          
     17          static uint8_t NBR_FRAME = 0; //!< Количество фреймов в памяти
     18          
     19          /**
     20          @brief Получить количество фреймов в памяти
     21          @return Возвращает количество фреймов
     22          */
     23          uint8_t frame_getCount(void)
     24          {
     25            return NBR_FRAME;
     26          }
     27          
     28          /**
     29          @brief Добавить заголовок
     30          @param[in] fr указатель на фрейм
     31          @param[in] src данные для добавления
     32          @param[in] len размер данных
     33          */
     34          void frame_addHeader(frame_s *fr, void *src, uint8_t len)
     35          {
     36            unsigned short EA_save = EA;
     37            EA = 0; 
     38            // Ранее небыло создано данных 
     39            if (fr->payload == NULL)
     40              {
     41                fr->payload = re_malloc(len);
     42                fr->len = len;
     43                re_memcpy(fr->payload, src, len);
     44                EA = EA_save;
     45                return;
     46              }
     47            
     48            uint8_t new_len = fr->len + len; // Новый размер
     49            void *new_payload = re_malloc(new_len);
     50            ASSERT(new_payload != NULL);
     51            
     52            // Копируем данные в конец области
     53            re_memcpy((char*)new_payload + len, fr->payload, fr->len);
     54            // Копируем данные спереди в свободную область
     55            re_memcpy(new_payload, src, len);
     56            // Уничтожаем старые данные
     57            re_free(fr->payload);
     58            fr->payload = new_payload;
     59            fr->len = new_len;
     60            EA = EA_save;
     61          }
     62          
     63          /**
     64          @brief Удалить заголовок
     65          @param[in] fr указатель на фрейм
     66          @param[in] len размер  удаляемых данных
     67          */
     68          void frame_delHeader(frame_s *fr, uint8_t len)
     69          {
     70            if (fr->payload == NULL)
     71              return;
     72          
     73            if (fr->len <= len)
     74              return;  
     75            
     76            uint8_t new_len = fr->len - len; // Новый размер
     77            void *new_payload = re_malloc(new_len);
     78            ASSERT(new_payload != NULL);
     79            
     80            // Копируем данные с пропуском первых len байт
     81            re_memcpy((char*)new_payload, (char*)fr->payload + len, new_len);
     82            
     83            // Уничтожаем старые данные
     84            re_free(fr->payload);
     85            fr->payload = new_payload;
     86            fr->len = new_len;
     87          }
     88          
     89          /**
     90          @brief Создание структуры frame
     91          @return Указатель на структуру frame
     92          */
     93          frame_s* frame_create(void)
     94          {
     95              unsigned short EA_save = EA;
     96              EA = 0; 
     97              
     98              frame_s* fr= (frame_s*)re_malloc(FRAME_S_SIZE);
     99              ASSERT(fr != NULL);
    100              
    101              fr->payload = NULL;
    102              fr->len = 0;
    103              memset(&fr->meta, 0x00, META_S_SIZE);
    104              NBR_FRAME++;
    105              
    106              EA = EA_save;
    107              return fr;
    108          };
    109          
    110          /**
    111          @brief Удаление frame
    112          @detail Проуедура так же удаляет все связанные с ней буфера fbuf
    113          @param[in] fr указатель на структуру frame
    114          */
    115          void frame_delete(frame_s *fr)
    116          {
    117            unsigned short EA_save = EA;
    118            EA = 0;  
    119            
    120            if (fr->payload != NULL)
    121              re_free(fr->payload);
    122           
    123            NBR_FRAME--;
    124            re_free(fr);
    125            EA = EA_save;
    126          }
    127          
    128          
    129          /**
    130          @brief Вычисляет размер цепочки fbuf
    131          @param[in] fr указатель на frame_s
    132          @return Количество байт в цепочке буферов
    133          */
    134          uint8_t frame_len(frame_s *fr)
    135          {
    136            return fr->len;
    137          }
E:\WMNU\IAR\SHARE_PRJ_SRC\LLC.c
      1          /**
      2          @file 
      3          @brief Модуль содержит реализацию интерфейса радио для приема/передачи данных.
      4          */
      5          
      6          #include "LLC.h"
      7          #include "MAC.h"
      8          #include "TIC.h"
      9          #include "mem.h"
     10          #include "nwdebuger.h"
     11          #include "ioCC2530.h"
     12          
     13          // Публичные методы
     14          void LLC_Init(void);
     15          
     16          // Методы модуля
     17          void LLC_SetRXCallback(void (*fn)(frame_s *fr));
     18          void LLC_TimeAlloc(void (*fn)(void)); 
     19          bool LLC_AddTask(frame_s* fr);
     20          uint8_t LLC_GetTaskLen(void);
     21          void LLC_Reset(void);
     22          
     23          // Закрытые методы
     24          static void LLC_SE_HNDL(uint8_t TS); //!< Обработчик завешения слота TIC
     25          static void LLC_Shelduler(uint8_t TS);
     26          static void LLC_RX_HNDL(frame_s *fr); //!< Обработчик примема пакета
     27          static void LLC_RunTimeAlloc(void);
     28          
     29          // Переменные модуля
     30          #define UNICAST_SEND_ATEMPTS 5 //!< Количество попыток передачи пакета 
     31          #define BROADCAST_SEND_ATEMPTS 3 //!< Количество попыток передачи пакета 
     32          #define MAX_nbrTASKS 20 //!< Максимальное количество задач в очередях
     33          
     34          typedef struct LLCTask LLCTask;
     35          typedef struct TimeAllocFunc TimeAllocFunc;
     36          static bool tasksBLOCK; //!< блокировка доступа к LLCTask
     37          
     38          /**
     39          @brief Описание задачи модуля LLC
     40          */
     41          struct LLCTask
     42          {
     43            LLCTask *next; //!< Указатель на следующую задачу. NULL - конец очереди
     44            uint8_t TS; //!< Номер временого канала для передачи сообщения
     45            uint8_t CH; //!< Номера радиоканала для передачи сообщения
     46            frame_s *fr; //!< Указатель на данные для передачи
     47          };
     48          
     49          /**
     50          @brief Список функций вызываемых по завешению временного слота
     51          */
     52          struct TimeAllocFunc
     53          {
     54            TimeAllocFunc *next; //!< Указатель на следующую функцию. NULL - конец списка
     55            void (*fn)(void); //!< Указатель на функцию. NULL - нет обработчика
     56          };
     57          
     58          static LLCTask *FirstTask; //!< Указатель на первый элемент очереди задач
     59          static uint8_t nbrTasks; // Количество задач в очереди
     60          
     61          /**
     62          @brief Обратный вызов при приеме пакета данных
     63          */
     64          static void (*RXCallback)(frame_s *fr);
     65          
     66          /**
     67          @brief Первый элемент обработчика конца временного слота
     68          @details Элемент создается статически, все остальные задачи создаются re_malloc
     69          и добавляются к HeadAllocFunc.
     70          */
     71          static TimeAllocFunc HeadAllocFunc;
     72          
     73          /**
     74          @brief Инициализация модуля
     75          @detail Иницилизирует MAC
     76          */
     77          void LLC_Init(void)
     78          {  
     79            nbrTasks = 0; 
     80            tasksBLOCK = false;
     81            FirstTask = NULL;
     82            // TODO Очистить очередь HeadTask
     83            // Регистрируем обработчики
     84            TIC_SetSECallback(LLC_SE_HNDL); // Завершение временного слота
     85            MAC_SetRXCallback(LLC_RX_HNDL); // Принято сообщение
     86          }
     87          
     88          /**
     89          @brief Сброс модуля
     90          @detail Удаяляем все пакеты в очереди. Аллокатор времени не трогаем
     91          */
     92          void LLC_Reset(void)
     93          {
     94            LLCTask *task = FirstTask;
     95            LLCTask *next;
     96            
     97            while (task != NULL)
     98            {
     99              next = task;
    100              re_free(task);
    101              task = next;
    102            }
    103          }
    104          
    105          /**
    106          @brief Количество задач в очереди
    107          @return количество задач в очереди
    108          */
    109          uint8_t LLC_GetTaskLen(void)
    110          {
    111            return nbrTasks;
    112          }
    113          
    114          void LLC_SetRXCallback(void (*fn)(frame_s *fr))
    115          {
    116            ASSERT(fn != NULL);
    117            RXCallback = fn;
    118          }
    119          
    120          /**
    121          @brief Добавляет обработчик заверешения временого слота в список
    122          */
    123          void LLC_TimeAlloc(void (*fn)(void))
    124          {
    125            TimeAllocFunc *ta = re_malloc(sizeof(TimeAllocFunc));
    126            ASSERT(ta != NULL);
    127            ta->next = NULL;
    128            ta->fn = fn;
    129          
    130            // Перебираемся в конец списка
    131            TimeAllocFunc *next = &HeadAllocFunc;
    132            while (next->next != NULL)
    133              next = next->next;
    134            
    135            // Добавляем новый элемент
    136            next->next = ta;
    137          };
    138          
    139          /**
    140          @brief Добавляем задачу в очередь
    141          @brief Взовращает true если задача добавлена в очередь. false, если размер 
    142           очереди достиг максимального размера.
    143          */
    144          bool LLC_AddTask(frame_s* fr)
    145          {
    146             ASSERT(fr != NULL);
    147           
    148              if (nbrTasks == MAX_nbrTASKS)
    149                return false;
    150              
    151             // Ждем пока разблокируется доступ.
    152             while (tasksBLOCK);
    153             tasksBLOCK = true;
    154          
    155             // Создаем новую задачу
    156             LLCTask *new_task = (LLCTask*)re_malloc(sizeof(LLCTask));
    157             ASSERT(new_task !=NULL); 
    158                
    159             new_task->TS = fr->meta.TS;
    160             new_task->CH = fr->meta.CH;
    161             new_task->fr = fr;
    162             
    163            LOG_ON("Add task = %u, CH = %d, TS = %d, OTS = %d. fr = %d",
    164                (uint16_t)new_task,new_task->CH, new_task->TS, fr->meta.TS, (uint16_t)fr);
    165            
    166             // Если в очереди нет задач, добавим первую
    167             if (FirstTask == NULL) 
    168             {
    169               new_task->next = NULL;
    170               FirstTask = new_task;
    171             }
    172             // Если в очереди были задачи то вставим новую в голову списка
    173             else 
    174             {
    175               new_task->next = FirstTask;
    176               FirstTask = new_task;  
    177             }
    178             
    179             nbrTasks ++;
    180             tasksBLOCK = false;
    181          
    182             return true;
    183          }
    184          
    185          
    186          
    187          
    188          /**
    189          @brief Планировщик задач
    190          @details Соотносит задачи в очереди и свободные временные слоты MAC уровня.
    191          При освобождении временных слотов, планировщик устанавливает данные для 
    192          передачи в MAC.
    193          @param[in] TS номер текущего временого слота
    194          */
    195          static void LLC_Shelduler(uint8_t TS)
    196          {
    197            // Если работает функция добавления задачи, то обслуживание очереди не
    198            // производится. Это может привести к необычным последствиям
    199            if (tasksBLOCK)
    200              return;
    201            tasksBLOCK = true;
    202            
    203            // Перебираем попорядку весь список на отправку
    204            // HeadTask только указатель на первый элемент, сам он не подлежит отправке
    205            LLCTask *task = FirstTask;
    206            LLCTask *last = FirstTask;
    207            LLCTask *next = FirstTask;
    208            
    209            while (task != NULL)
    210            {    
    211              if (MAC_GetTXState(task->TS)) // Занят ли временой слот
    212              {
    213                // Если слот занят переходим к следующей задаче
    214                last = task;
    215                task = task->next;
    216                continue; 
    217              }
    218              
    219              //Выбераем количество попыток передачи в зависимости от типа пакета
    220              uint8_t attempts;
    221              if (task->fr->meta.TX_METHOD == UNICAST)
    222                attempts = UNICAST_SEND_ATEMPTS;
    223              else if (task->fr->meta.TX_METHOD == BROADCAST)
    224                attempts = BROADCAST_SEND_ATEMPTS;
    225              else
    226                ASSERT(false);
    227              
    228              MAC_Send(task->fr, attempts);
    229              
    230              next = task->next; // Запомним следующую задачу
    231              
    232              // Удаляем текущую задачу из списка
    233              if (task == FirstTask)
    234              {
    235              // Удаляемым элементом является указателем на голову
    236                 FirstTask = next;
    237                 last = FirstTask;
    238              }
    239              else
    240              {
    241                // Удаляемым элементом является промежуточный элемент
    242                last->next = next;
    243              }
    244              
    245              nbrTasks--;
    246              LOG_OFF("Free task = %u, nbrTasks = %d\r\n",
    247                  (uint16_t)task, nbrTasks); 
    248              re_free(task);
    249              task = next;
    250            }
    251            
    252            tasksBLOCK = false;
    253          }
    254          
    255          /**
    256          @brief Обработчик заверешния временого слота
    257          @details Обратный вызов из TIC. Обработчик вызывает планировщик задач очереди
    258          и передает управление зарегистрированым функциям с помощью LLC_TimeAlloc.
    259          @param[in] TS номер завершенного временого слота
    260          */
    261          static void LLC_SE_HNDL(uint8_t TS)
    262          {
    263            LLC_Shelduler(TS);
    264            LLC_RunTimeAlloc();
    265          }
    266          
    267          static void LLC_RX_HNDL(frame_s *fr)
    268          {
    269            ASSERT(RXCallback !=NULL);
    270            RXCallback(fr);
    271          }
    272          
    273          /**
    274          @brief Передаем управление зарегистрированным функциям
    275          */
    276          static void LLC_RunTimeAlloc(void)
    277          {
    278              TimeAllocFunc *next = &HeadAllocFunc;
    279            // HeadAllocFunc служит только для указания на первый элемент в очереди
    280            // так что его нужно пропустить и переходить сразу к next
    281            while (next->next != NULL)
    282            {
    283              next->next->fn();
    284              next = next->next;
    285            }
    286          }
E:\WMNU\IAR\SHARE_PRJ_SRC\MAC.c
      1          #include "MAC.h"
      2          #include "frame.h"
      3          #include "string.h"
      4          #include "nwdebuger.h"
      5          #include "coder.h"
      6          #include "TIC.h"
      7          #include "stdlib.h"
      8          #include "basic.h"
      9          
     10          // Обработчики прерываний
     11          static void MAC_RX_HNDL(uint8_t TS);
     12          static void MAC_TX_HNDL(uint8_t TS);
     13          static void (*RXCallback)(frame_s *fr);
     14          static void BitRawDecrypt(uint8_t *src, uint8_t size);
     15          static void BitRawCrypt(uint8_t *src, uint8_t size);
     16          static uint8_t xor_calc(frame_s *fr);
     17          
     18          // Публичные методы
     19          void MAC_Init(void);
     20          void MAC_Reset(void);
     21          void MAC_Enable(bool en);
     22          void MAC_OpenRXSlot(uint8_t TS, uint8_t CH);
     23          void MAC_CloseRXSlot(uint8_t TS);
     24          void MAC_Send(frame_s *fr, uint8_t attempts);
     25          bool MAC_ACK_Send(frame_s *fr);
     26          void MAC_SetRXCallback(void (*fn)(frame_s *fr));
     27          bool MAC_GetTXState(uint8_t TS);
     28          bool MAC_GetRXState(uint8_t TS);
     29          
     30          // Ключ потокового шифрования и вектор иницилизации
     31          static uint8_t KEY[16] = DEFAULT_KEY;
     32          static uint8_t IV[16] = DEFAULT_IV;
     33            
     34          #define RECV_TIMEOUT 2 // Время ожидания приема пакета в мс с начала слота
     35          #define ACK_RECV_TIMEOUT 1 // Время ожидания приема подтверждения в мс
     36          #define TX_DELAY 1*Tmsec // Смещение при передаче пакета. Защита от девиации времени
     37          
     38          typedef struct // Формат структуры пакета ACK
     39          {
     40            uint16_t CRC8;
     41          } __attribute__((packed)) ACK_s;
     42          
     43          typedef struct
     44          {
     45           struct 
     46           {
     47             bool enable;
     48             uint8_t attempts;
     49             uint8_t CH;
     50             frame_s *fr;
     51           } __attribute__((packed)) TX;
     52           
     53           struct
     54           {
     55            bool enable; 
     56            uint8_t CH;
     57           } __attribute__((packed)) RX;
     58          } __attribute__((packed)) MACSState_s; 
     59          
     60          static bool MAC_ENABLE_MODULE = false; //!< Модуль активен
     61          
     62          
     63          // Таблица состояний слотов приема/передачи
     64          MACSState_s MACSlotTable[50];
     65          
     66          /**
     67          @brief Установить вектор иницилизации для шифрования
     68          @param[in] ptr_IV указатель на 16 байтный вектор иницилизации
     69          */
     70          void MAC_setIV(void* ptr_IV)
     71          {
     72            memcpy(IV, ptr_IV, 16);
     73          }
     74          
     75          /**
     76          @brief Установить ключ шифрования
     77          @param[in] ptr_KEY указатель на 16 байтный ключ
     78          */
     79          void MAC_setKEY(void* ptr_KEY)
     80          {
     81            memcpy(KEY, ptr_KEY, 16);
     82          }
     83          
     84          /**
     85          @brief Иницилизация MAC
     86          @detail Инизилизирует TIM, TIC, RI, AES
     87          */
     88          void MAC_Init(void)
     89          {
     90            MAC_ENABLE_MODULE = false;
     91            TIC_SetRXCallback(MAC_RX_HNDL);
     92            TIC_SetTXCallback(MAC_TX_HNDL);  
     93            memset(MACSlotTable, 0x00, 50*sizeof(MACSState_s));
     94          }
     95          
     96          /**
     97          @brief Сброс настроек модуля.
     98          @detail Удаяляет все пакеты для передачи. Активным остается TS1 обработчик sync
     99          */
    100          void MAC_Reset(void)
    101          {
    102            MAC_ENABLE_MODULE = false;
    103            // Удаляем все пакеты на передачу
    104            for (uint8_t i = 0; i < 50; i++)
    105              if (MACSlotTable[i].TX.enable)
    106                frame_delete(MACSlotTable[i].TX.fr);
    107            
    108            memset(MACSlotTable, 0x00, 50*sizeof(MACSState_s));
    109          }
    110          
    111          /**
    112          @brief Открыть временой слот приема данных
    113          @param[in] TS номер слота от 0 до 49
    114          @param[in] CH номер радиоканала
    115          */
    116          void MAC_OpenRXSlot(uint8_t TS, uint8_t CH)
    117          {
    118              ASSERT(TS < 50 || TS !=0 );
    119              MACSlotTable[TS].RX.enable = true;
    120              MACSlotTable[TS].RX.CH = CH;
    121              TIC_SetRXState(TS, true);
    122          }
    123          
    124          /**
    125          @brief Закрыть временой слот приема данных
    126          @param[in] TS номер слота от 0 до 49
    127          */
    128          void MAC_CloseRXSlot(uint8_t TS)
    129          {
    130            ASSERT(TS < 50 || TS !=0);
    131            MACSlotTable[TS].RX.enable = false;
    132            TIC_SetRXState(TS, false);
    133          }
    134          
    135          /**
    136          @brief Поставить пакет в таблицу отправки сообщений
    137          @param[in] fr указатель на пакет
    138          @param[in] attempts количество попыток
    139          */
    140          void MAC_Send(frame_s *fr, uint8_t attempts)
    141          {
    142              ASSERT(fr != NULL);
    143              ASSERT(attempts != 0);
    144              ASSERT(fr->meta.TS != 0);
    145              
    146              uint8_t TS = fr->meta.TS; 
    147              MACSlotTable[TS].TX.attempts = attempts;
    148              MACSlotTable[TS].TX.CH = fr->meta.CH;
    149              MACSlotTable[TS].TX.enable = true;
    150              MACSlotTable[TS].TX.fr = fr;
    151              
    152              #ifdef RARIO_STREAM_ENCRYPT
    153              BitRawCrypt(fr->payload, fr->len);
    154              #endif
    155              
    156              TIC_SetTXState(TS, true);
    157          }
    158          
    159          void MAC_Enable(bool en)
    160          {
    161            MAC_ENABLE_MODULE = en;
    162          }
    163          
    164          /**
    165          @brief Расчитывает CRC8 код
    166          @param[in] fr указатель на кадр
    167          @return CRC8
    168          */
    169          static uint8_t xor_calc(frame_s *fr)
    170          {
    171            uint8_t crc = 0x34; // Начальное значение
    172            uint8_t *val = fr->payload;
    173            
    174            for (uint8_t i = 0; i < fr->len; i++)
    175              crc ^= val[i];
    176            return crc;
    177          }
    178          
    179          /**
    180          @brief Посылает подтверждение приема пакета
    181          @param[in] fr указатель на кадр который нужно подтвердить
    182          @return true если передача подтверждения успешна (канал свободен)
    183          */
    184          static bool MAC_ACK_Send(frame_s *fr)
    185          {
    186            static ACK_s pACK;
    187            frame_s *fr_ACK;
    188            
    189            // Создаем подтверждение кадра
    190            pACK.CRC8 = xor_calc(fr);
    191            
    192            // Создаем кадр для отправки
    193            fr_ACK = frame_create();
    194            frame_addHeader(fr_ACK, &pACK, sizeof(ACK_s));
    195            fr_ACK->meta.SEND_TIME = 0;
    196            
    197           
    198            bool res = RI_Send(fr_ACK);
    199            frame_delete(fr_ACK);
    200            return res;
    201          }
    202          
    203          /**
    204          @brief Ожидает прием пакета подтверждения
    205          @param[in] fr указатель на пакет подтверждение которого ожидаем 
    206          @return true если приняли подтверждение
    207          */
    208          static bool MAC_ACK_Recv(frame_s *fr)
    209          {
    210            frame_s *fr_ACK = RI_Receive(ACK_RECV_TIMEOUT);
    211            
    212            // Если пакета нет, выходим из обработчика
    213            if (fr_ACK == NULL)
    214              return false;
    215            
    216            // Проверим размер пакета
    217            if (fr_ACK->len != sizeof(ACK_s))
    218            {
    219              frame_delete(fr_ACK);
    220              return false;
    221            }
    222              
    223            ACK_s *ptrACK;
    224            ptrACK = (ACK_s*)fr_ACK->payload;
    225            
    226            uint8_t crc8 = xor_calc(fr);
    227            uint8_t ack_crc8 = ptrACK->CRC8;
    228            frame_delete(fr_ACK);
    229            
    230            if (crc8 == ack_crc8)
    231              return true;
    232            return false;
    233          }
    234          
    235          /**
    236          @brief Устанавливает функцию обратного вызова при приеме пакета
    237          @param[in] fn указатель на функцию обработчик
    238          */
    239          void MAC_SetRXCallback(void (*fn)(frame_s *fr))
    240          {
    241            RXCallback = fn;
    242          }
    243          
    244          /**
    245          @brief Состояние слота TS передача
    246          @return возвращает true, если слот содержит пакет для передачи
    247          */
    248          bool MAC_GetTXState(uint8_t TS)
    249          {
    250            ASSERT(TS < 50  || TS !=0 );
    251            return MACSlotTable[TS].TX.enable;
    252          }
    253          
    254          /**
    255          @brief Состояние слота TS приема
    256          @return возвращает true, если слот принимает пакет
    257          */
    258          bool MAC_GetRXState(uint8_t TS)
    259          {
    260            ASSERT(TS < 50  || TS !=0);
    261            return MACSlotTable[TS].RX.enable;
    262          }
    263          
    264          /**
    265          @brief Обработчик слота приема пакета
    266          @detail При необходимости подтвеждает пакет
    267          @param[in] TS номер временного слота
    268          */
    269          static void MAC_RX_HNDL(uint8_t TS)
    270          {
    271            ASSERT(TS < 50  || TS !=0);
    272          
    273            if (!MAC_ENABLE_MODULE) // Модуль откючен
    274              return;
    275            
    276            RI_SetChannel(MACSlotTable[TS].RX.CH);
    277            frame_s *fr = RI_Receive(RECV_TIMEOUT);
    278            
    279            // Если пакета нет, выходим из обработчика
    280            if (fr == NULL)
    281              return;
    282            
    283            // Пакеты во временные слоты 1..49 требуют подтверждения
    284            // Слоты 0 и 1 для швс и синхронизации соответсвенно
    285            if (TS > 1)
    286              MAC_ACK_Send(fr);
    287           
    288            #ifdef RARIO_STREAM_ENCRYPT
    289            BitRawDecrypt(fr->payload, fr->len);
    290            #endif
    291            
    292            RXCallback(fr);   // Передаем пакет на дальнейшую обработку
    293            // Удаление пакета не наша забота
    294          }
    295          
    296          /**
    297          @brief Обработчик слота пердачи пакета
    298          @detail После отправки пакета требуется подтверждение приема если meta.ACK = 1.
    299           После отправки ждем приема ACK. Проверка подлинности ACK происходит с помощью
    300           обратного вызова isACK_OK(*fr, *fr_ACK). Результат true или false.
    301          @param[in] TS номер временного слота
    302          */
    303          static void MAC_TX_HNDL(uint8_t TS)
    304          {
    305            ASSERT(TS < 50  || TS !=0);
    306            
    307            if (!MAC_ENABLE_MODULE) // Модуль отключен
    308              return;
    309            
    310            // По ошибки вызвали. Такого быть не должно, но подстрахуемся.
    311            if ((!MACSlotTable[TS].TX.enable) || (MACSlotTable[TS].TX.attempts == 0)) 
    312            {
    313              TIC_SetTXState(TS, false);
    314              return;
    315            }
    316            
    317            RI_SetChannel(MACSlotTable[TS].TX.CH); // Устанавливаем канал передачи
    318          
    319            // Задержка перед передачей данных необходима для учета отклонения
    320            // времени между узлами из-за рассинхронизации узлов
    321            TIM_delay(TX_DELAY);
    322            // Пробуем передать данные
    323            bool tx_success = RI_Send(MACSlotTable[TS].TX.fr); 
    324            bool send_success = false;  
    325            
    326            LOG_OFF("RI_Send = %d, CH = %d, TS = %d\r\n",
    327                tx_success, MACSlotTable[TS].TX.CH, TS);
    328              
    329            if (tx_success)
    330            {
    331              if (TS > 1) // требуется подтверждение ACK
    332              {
    333                if (MAC_ACK_Recv(MACSlotTable[TS].TX.fr))
    334                    send_success = true;
    335              }
    336              else // не требуеться подтверждение
    337                send_success = true;
    338            }
    339            
    340          
    341            if (send_success) // В случаи успеха удаляем данные и закрываем слоты 
    342            { 
    343              frame_delete(MACSlotTable[TS].TX.fr);
    344              MACSlotTable[TS].TX.enable = false;
    345              TIC_SetTXState(TS, false);      
    346            }
    347            else // Уменьшаем счетчик попыток передачи и удаляем пакет при достижении 0.
    348            {
    349              MACSlotTable[TS].TX.attempts --;
    350              if (MACSlotTable[TS].TX.attempts == 0)
    351                {
    352                  frame_delete(MACSlotTable[TS].TX.fr);
    353                  MACSlotTable[TS].TX.enable = false;
    354                  TIC_SetTXState(TS, false);  
    355                }
    356            }
    357          }
    358          
    359          /*!
    360          \brief Расшифровка область памяти
    361          \param[in,out] *src Указатель на начало области дешифрования
    362          \param[in] size Размер расшифруемых данных
    363          */
    364          static void BitRawDecrypt(uint8_t *src, uint8_t size)
    365          {
    366            AES_StreamCoder(false, src, src, KEY, IV, size);
    367          }
    368          
    369          /*!
    370          \brief Шифрует область памяти
    371          \param[in,out] *src Указатель на начало области шифрования
    372          \param[in] size Размер шифруемых данных
    373          */
    374          static void BitRawCrypt(uint8_t *src, uint8_t size)
    375          {
    376            AES_StreamCoder(true, src, src, KEY, IV, size);
    377          }
    378          
E:\WMNU\IAR\NEOCOREGATEWAY\src\main.c
      1          #include "manager.h"
      2          #include "nwdebuger.h"
      3          #include "ioCC2530.h"
      4          #include "stdint.h"
      5          #include "uart_comm.h"
      6          #include "cmd_parser.h"
      7          extern  char uart_getchar(void);
      8          // Собирать проект с ключем GATEWAY в файле basic.h
      9          void main(void)
     10          {
     11            neocore_hw_init();
     12            network_seed_enable(true);
     13            com_uart_init();
     14            parse_uart_stream();
     15          }
E:\WMNU\IAR\SHARE_PRJ_SRC\manager.c
      1          #include "manager.h"
      2          #include "coder.h"
      3          #include "delays.h"
      4          #include "ethernet.h"
      5          #include "frame.h"
      6          #include "LLC.h"
      7          #include "MAC.h"
      8          #include "NTMR.h"
      9          #include "RADIO.h"
     10          #include "TIC.h"
     11          #include "sync.h"
     12          #include "config.h"
     13          #include "frame.h"
     14          #include "nwdebuger.h"
     15          #include "basic.h"
     16          #include "config.h"
     17          #include "ioCC2530.h"
     18          #include "dma.h"
     19          #include "rx_buff.h"
     20          
     21          static void MG_Init();
     22          
     23          static bool MG_MODULES_INITED = false; //!< Были ли запущенны аппаратные модули
     24          static bool NETWORK_SEED = false; //!< Раздача сети шлюзом
     25          
     26          // Публичные методы
     27          void neocore_hw_init();
     28          bool neocore_stack_reset();
     29          void network_seed_enable(bool en);
     30          bool network_discovery(uint8_t timeout_ms);
     31          bool MG_Connect();
     32          
     33          // Переменные модуля
     34          
     35          /**
     36          @brief Начальная иницилизация стека
     37          */
     38          static void MG_Init()
     39          {
     40            NETWORK_SEED = false;
     41            DMA_init();
     42            CF_init();
     43            NT_Init();
     44            TIM_init();
     45            TIC_Init();
     46            RI_init();
     47            AES_init();
     48            MAC_Init();
     49            SY_Init();
     50            LLC_Init();
     51            
     52          #ifdef GATEWAY
     53            RXB_Init();
     54          #endif
     55            
     56            // Загрузка дефолтных параметров
     57            MAC_setIV(CONFIG.stream_iv);
     58            MAC_setKEY(CONFIG.stream_key);
     59            SY_setIV(CONFIG.stream_iv);
     60            SY_setKEY(CONFIG.stream_key);  
     61            // TODO Необходимо очищать все ранее выделеную память malloc
     62          }
     63          
     64          /**
     65          @brief Иницилизация аппаратуры стека
     66          */
     67          void neocore_hw_init()
     68          {
     69            if (!MG_MODULES_INITED){
     70              MG_Init();
     71              MG_MODULES_INITED = true;
     72            }  
     73          }
     74          
     75          /**
     76          @brief Сброс всех настроек стека и удаление пакетов
     77          */
     78          bool neocore_stack_reset(){
     79            TIC_Reset();
     80            MAC_Reset();
     81            SY_Reset();
     82            LLC_Reset();
     83          
     84          #ifdef GATEWAY
     85            RXB_Reset();
     86          #endif
     87          
     88            network_seed_enable(false);
     89            
     90            // Проверим все ли пакеты уничтожены
     91            uint8_t nbrF = frame_getCount(); 
     92            ASSERT(nbrF == 0);
     93            if (!nbrF)
     94              return true;
     95            return false;
     96          }
     97          
     98          /**
     99          @brief Алгоритм подключения к сети
    100          @param[in] timeout_ms время поиска сети
    101          */
    102          bool network_discovery(uint8_t timeout_ms)
    103          {
    104            uint16_t panid;
    105            bool con = false;
    106            
    107            // Тупой алгоритм поиска сети.
    108            while (!con)
    109            {
    110              con = SY_SYNC_NETWORK(&panid, timeout_ms);
    111            }
    112            
    113            if (con){ // После синх. разрешаем обработку слотов
    114              NETWORK_SEED = true;
    115              MAC_Enable(true);
    116              SY_Enable(true);
    117            }
    118            return con;
    119          }
    120          
    121          /**
    122          @brief Начинаем раздачу сети
    123          @param[in] en true начать раздачу сети
    124          */
    125          void network_seed_enable(bool en)
    126          {
    127            if (en){
    128              NETWORK_SEED = true;
    129              MAC_Enable(true);
    130              SY_Enable(true);
    131            }
    132            else{ 
    133              NETWORK_SEED = false;
    134              MAC_Enable(false);
    135              SY_Enable(false);
    136            }
    137          }
    138          
    139          /**
    140          @brief Возвращает состояние сети
    141          @return true если сеть раздается
    142          */
    143          bool get_network_seed_status(void){
    144            return NETWORK_SEED;
    145          }
    146          
    147           
    148            
E:\WMNU\IAR\SHARE_PRJ_SRC\mem.c
      1          #include "ioCC2530.h"
      2          #include "stdlib.h"
      3          #include "stdint.h"
      4          #include "string.h"
      5          #include "nwdebuger.h"
      6          
      7          void re_free(void* ptr);
      8          void* re_malloc(size_t size);
      9          uint16_t heap_ptr(size_t size);
     10          void re_memcpy(void *dst, const void *src, size_t n);
     11          
     12          /**
     13          @brief Возвращает адрес следующего свободного участка памяти
     14          @detail Функция нужна для оценки использования стека
     15          @param[in] size размер запрашиваемой области
     16          @return если памяти нету возвращает 0, иначе адрес свободного участка.
     17          */
     18          uint16_t heap_ptr(size_t size)
     19          {
     20            unsigned short EA_save = EA;
     21            EA = 0; 
     22            uint16_t *heap_ptr;
     23            heap_ptr = (uint16_t*)re_malloc(size);
     24            re_free(heap_ptr);
     25            EA = EA_save;
     26            return (uint16_t)heap_ptr;
     27          }
     28          
     29          /**
     30          @brief Реентерабельное копирование памяти
     31          */
     32          void re_memcpy(void *dst, const void *src, size_t n)
     33          {
     34            unsigned short EA_save = EA;
     35            EA = 0;
     36            memcpy(dst, src, n);
     37            EA = EA_save;  
     38          }
     39          
     40          /**
     41          @brief Реентерабельное выделение памяти
     42          */
     43          void* re_malloc(size_t size)
     44          {
     45            unsigned short EA_save = EA;
     46            void* ptr; 
     47            EA = 0;
     48            ptr = malloc(size);
     49            EA = EA_save;
     50            //LOG(MSG_OFF | MSG_INFO | MSG_TRACE, "malloc = %d, L= %d \r\n", (uint16_t)ptr, size);
     51            return ptr;
     52          }
     53          
     54          /**
     55          @brief Реентерабельное освобождение памяти
     56          */
     57          void re_free(void* ptr)
     58          {
     59            unsigned short EA_save = EA;
     60            EA = 0;
     61            free(ptr);
     62            EA = EA_save;
     63            //LOG(MSG_OFF | MSG_INFO | MSG_TRACE, "free = %d\r\n", (uint16_t)ptr);  
     64          }
E:\WMNU\IAR\SHARE_PRJ_SRC\NTMR.c
      1          #include "NTMR.h"
      2          #include "stdlib.h"
      3          #include "ioCC2530.h"
      4          #include "nwdebuger.h"
      5          
      6          /**
      7          @file 
      8          @brief Модуль управления таймером сна
      9          @details При создании обьекта с помощью NT_Create, производится иницилизация
     10           аппаратного таймера сна и он переходит в активное состояние. Если установлено 
     11           определение #define USE_OSC32K будет использван внешний кварц.
     12           За установку глобального прерывания IE отвечает пользователь.
     13           Для использования модуля необходимо установить обработчик прерывания
     14           NT_SetEventCallback(..). Далее с помощью NT_SetCompare(..) установить
     15           время срабатывания прерывания, она же включит прерывание таймера. 
     16           Перед вызовом пользовательского обработчика, запрещается прерывание таймера,
     17           пользователь должен установить его повторно на необходимое время.
     18           Модуль сна пробуждает МК из режимов PM1,PM2, но не переводит их обратно.
     19           После завершения обработки прерывание, продолжится выполнение основного 
     20           потока программы. Пользователь самостоятельно должен перевести МК в режим сна.
     21           Функция NT_SetTime(..) производит подстройку времени сети и корректирует время
     22           срабатывания прерывания. Что бы было понятнее приведу пример: 
     23           Время сети 400 и установленно прерывание на 700.
     24           Пользователь корректирует время на 300, но из-за разной разрядности счетчиков
     25           прерывание произойдет по "старым часам", так как NT_SetTime только изменит
     26           переменную относительного смещения, а не непосредственно значение счетчика.
     27           Поэтому необходимо пересчитать время прерывания 700 к новому смещению.
     28           Из найденных особенностей: когда вызывается обработчик прерывания, значение
     29           времени всегда больше на 2 тика. Предполагаю из за ожидания синхронизации при
     30           чтении значения таймера. 
     31          */
     32          
     33          
     34          // После вызова EventCallback аппаратное прерывание завершается
     35          // и управление передается в главный цикл main.
     36          // Пользователь сам должен положить систему в сон
     37          // Для работы используется sleep timer.
     38          // Значение таймера изменить нельзя, он автоматически стартует после
     39          // Включения микроконтроллера. Нам нужно выбрать XOSC вместо RCOSC,
     40          // Но на отладочной плате нет резонатора
     41          // Чтение значения ST2:ST1:ST0 первым из ST0
     42          // Таймер работает во всех режимах кроме PM3
     43          // После пробуждения нужно убеиться что SLEEPSTA.CLK32K бит установлен прежде 
     44          // чем считывать ST0-3
     45          
     46          
     47          #define USE_OSC32K // Использовать внешний квац 32.768 кГц
     48          
     49          // Методы модуля
     50          bool NT_SetTime(uint16_t ticks);
     51          void NT_SetCompare(uint16_t ticks);
     52          void NT_SetEventCallback(void (*fn)(uint16_t ticks));
     53          uint16_t NT_GetTime(void);
     54          uint16_t NT_WaitTime(uint16_t ticks);
     55          
     56          // Приватные методы
     57          static uint32_t ReadTimer(void);
     58          static void loadTimerCompare(uint32_t ticks);
     59          static inline bool isIRQEnable(void);
     60          static inline void NT_IRQEnable(bool state);
     61          
     62          // Переменные модуля
     63          static void (*EventCallback)(uint16_t ticks);
     64          static uint32_t COMPARE_TIME; //!< Значение загруженное в регистр compare
     65          
     66          /**
     67          @details Смещение времени сети относительно времени таймера.
     68           NETWORK TIME = TIMER + TOFFSET
     69          */
     70          uint16_t TOFFSET; 
     71          
     72          /**
     73          @brief Инизиализация таймера
     74          */
     75          void NT_Init(void)
     76          {
     77            TOFFSET = 0;
     78            COMPARE_TIME = 0;
     79            EventCallback = NULL;
     80          
     81            // Сначало нужно настроить кварц 32кГц только потом поднимать
     82            // основной квар до 32 Мгц
     83            #ifdef USE_OSC32K
     84            CLKCONCMD &= ~(1<<7); // Сбрасываем бит OSC32K, будет выбран 32.768 кварц
     85            while (CLKCONSTA & (1<<7)); // Ждем пока бит не станет 0
     86            #endif
     87          
     88            // Переходим на 32 Мгц
     89            CLKCONCMD = 0;// (1<<3);
     90            while (CLKCONSTA&(1<<6));
     91            
     92            NT_IRQEnable(false);
     93            EA = 1;
     94          }
     95          
     96          /**
     97          @brief Устанавливаем текущее время сети и переустанавливает capture time
     98          @param[in] ticks время от 0-32767. Один tick 1/32768
     99          @return true если аргумент в диапазоне
    100          */
    101          bool NT_SetTime(uint16_t ticks)
    102          {
    103            ASSERT(ticks < 32768);
    104            if (ticks > 32767)
    105              return false;
    106           
    107            uint16_t timer = ReadTimer();
    108            TOFFSET = ticks - timer;
    109            TOFFSET &= 0x7FFF;
    110          
    111            // После установки времени нужно изменить compare time в таймере
    112            // Но только в случаи если прерывание активно
    113            if (isIRQEnable())
    114            {
    115              NT_SetCompare(COMPARE_TIME);
    116            }
    117          
    118            return true;
    119          }
    120          
    121          /**
    122          @brief Вычисляет значение, которое нужно установить в регистр compare таймера.
    123          @params[in] ticks время сети в тикак
    124          */
    125          static inline uint32_t calcCompareTime(uint16_t ticks)
    126          {   
    127              uint32_t timer = ReadTimer(); // Текущее значение счетчика
    128              
    129              //NETWORK TIME = TIMER + TOFFSET  
    130              // Приводим такты к тактам таймера
    131              uint16_t ticks_offset = (ticks - TOFFSET) & 0x7FFF;
    132              
    133              uint32_t cmp_time = timer & ~0x7FFF; // Убираем младшие 15 бит
    134              cmp_time |= ticks_offset; // Вычисляем новое время
    135              
    136              if (cmp_time <= timer)
    137              {
    138                cmp_time += 0x8000;
    139                cmp_time &=0xFFFFFF;
    140              }
    141                
    142               LOG_OFF("Timer = %lu, Ticks = %d,CMP = %lu \r\n",
    143                    timer, ticks, cmp_time );
    144              return cmp_time;
    145          }
    146          
    147          /**
    148          @brief Устанавливает время прерывания
    149          @details Время прерывания устанавливается относительно времени сети
    150          ,к примеру, что бы проснуться в таймслот номер 0, нужно установить ticks = 0.
    151          Процедура учитывает текущее значение таймера и перерасчитывает значение ticks. 
    152          @params[in] ticks время сети в тиках когда нужно проснуться
    153          */
    154          void NT_SetCompare(uint16_t ticks)
    155          {
    156            ASSERT(ticks < 32768);
    157            
    158            COMPARE_TIME = ticks; // Сохраняем установленное значение
    159           
    160            uint32_t compare_time = calcCompareTime(ticks);
    161           
    162            loadTimerCompare(compare_time);
    163            NT_IRQEnable(true);
    164          }
    165          
    166          /**
    167          @brief Разрешение прерываний таймера сна
    168          @params[in] state = true - разрешить обработку прерываний
    169          */
    170          static inline void NT_IRQEnable(bool state)
    171          {
    172            STIF = 0;
    173            if (state)
    174            {
    175              STIE = 1;
    176            }
    177            else
    178            {
    179              STIE = 0;
    180            }
    181          }
    182          
    183          /**
    184          @brief Проверка активности прерывания таймера
    185          @return true если прерывание установленно
    186          */
    187          static inline bool isIRQEnable(void)
    188          {
    189            if (STIE)
    190              return true;
    191            else 
    192              return false;
    193          }
    194          
    195          /**
    196          @brief Устанавливает обработчик прерывания таймера
    197          @param[in] fn(uint16_t ticks) указатель на функцию-обработчик
    198          */
    199          void NT_SetEventCallback(void (*fn)(uint16_t ticks))
    200          {
    201            EventCallback = fn;
    202          }
    203          
    204          /**
    205          @brief Возвращает время сети 
    206          @return Время сети в тиках
    207          */
    208          uint16_t NT_GetTime(void)
    209          {
    210            uint32_t val = ReadTimer();
    211            // TOFFSET = NETWORK TIME - TIMER
    212            // NETWORK TIME = TIMER + TOFFSET
    213            val +=TOFFSET;
    214            val &= 0x7FFF; // Приводим значения таймера к 0-32767
    215            return val;
    216          }
    217          
    218          /**
    219          @brief Обработчик прерывания таймера сна
    220          */
    221          #pragma vector=ST_VECTOR
    222          __interrupt void TimerCompareInterrupt(void)
    223          {  
    224            uint16_t ticks = NT_GetTime();
    225            if (EventCallback == NULL)
    226              return;
    227            // Отключаем прерывание таймера. Забота пользователя его включить
    228            NT_IRQEnable(false); 
    229            EventCallback(ticks); // Вызываем пользовательский обработчик
    230            STIF = 0; // Очищаем флаг прерывания
    231          }
    232          
    233          /**
    234          @breif Ожидание наступления времени сети
    235          @param[in] ticks время в тактах
    236          @return фактическое время сети
    237          */
    238          uint16_t NT_WaitTime(uint16_t ticks)
    239          {
    240            static union 
    241            {
    242              uint32_t val;
    243              uint8_t fild[4];
    244            } val;
    245            
    246            val.val = 0;
    247            // TOFFSET = NETWORK TIME - TIMER
    248            // NETWORK TIME = TIMER + TOFFSET
    249            
    250            // Ждем синхронизацию таймера после пробуждения
    251            while (!(SLEEPSTA & 0x01));
    252            
    253            do
    254            {
    255              // Соблюдаем порядок чтения регисторов ST  
    256              val.fild[0] = ST0;
    257              val.fild[1] = ST1;
    258              val.fild[2] = ST2;
    259              val.val +=TOFFSET;
    260              val.val &= 0x7FFF; // Приводим значения таймера к 0-32767    
    261            } while (val.val < ticks);
    262            return val.val;
    263          }
    264          
    265          /**
    266          @brief Возвращает текущее значение таймера
    267          @return Текущие ticks
    268          */
    269          static uint32_t ReadTimer(void)
    270          {
    271            static union 
    272            {
    273              uint32_t val;
    274              uint8_t fild[4];
    275            } ret_val;
    276            
    277            ret_val.val = 0;
    278            
    279            // Ждем синхронизацию таймера после пробуждения
    280            while (!(SLEEPSTA & 0x01));
    281            
    282            // Соблюдаем порядок чтения регисторов ST  
    283            ret_val.fild[0] = ST0;
    284            ret_val.fild[1] = ST1;
    285            ret_val.fild[2] = ST2;
    286            return ret_val.val;
    287          }
    288          
    289          /**
    290          @brief Устанавливает время пробуждения микроконтролера
    291          @params[in] ticks 24 битное значение времени пробуждения в ticks
    292          */
    293          static void loadTimerCompare(uint32_t ticks)
    294          {
    295            union 
    296            {
    297              uint32_t val;
    298              uint8_t fild[4];
    299            } value;
    300            
    301            value.val = ticks;
    302            
    303            // Ждем разрешения на запись нового значения
    304            while (!(STLOAD & 0x01));
    305            
    306            // Регистр ST0 должен быть записан в последнию очередь
    307            ST2 = value.fild[2];
    308            ST1 = value.fild[1];
    309            ST0 = value.fild[0];
    310          }
E:\WMNU\IAR\SHARE_PRJ_SRC\nwdebuger.c
      1          #include "nwdebuger.h"
      2          #include "ioCC2530.h"
      3          #include "stdint.h"
      4          #include "stdio.h"
      5          
      6          // Настройка порта uart для отладки
      7          static void uart_init(void)
      8          {
      9            // Выбор расположения UART на выводах
     10            uint8_t U0CFG = 0; // 0={TX=P0_3, RX=P0_2
     11            PERCFG |= (U0CFG<<0); 
     12            
     13            // U0UCR регистр настройки режима uart. меня устраивает по умолчанию
     14            U0CSR = (1<<7); // Выбираем режим uart  
     15            
     16            // Настройка скорости передачи данных на 2М  
     17            U0BAUD = 0;  // табличные значения из pdf
     18            U0GCR =  16;
     19            
     20            // Включаем альтернативные функции выводов
     21            P0SEL = (1<<2)|(1<<3);
     22            U0CSR |= (1<<6);
     23          }
     24          
     25          static void SetCPU32M(void)
     26          {
     27            CLKCONCMD = 0x88;
     28            while (CLKCONSTA&(1<<6));
     29          }
     30          
     31          void nwDebugerInit(void)
     32          {
     33           // SetCPU32M();
     34          #ifdef UART_DEBUG
     35            uart_init();
     36          #endif
     37          }
     38          
     39          __attribute__((weak)) void STACK_FAILURE(char* msg)
     40          {
     41            LOG_ON("STACK FAILURE. HALT");
     42            while(1);
     43          }
     44          
     45          // Переопределяем функцию записи в порт
     46          #ifdef UART_DEBUG
     47          #include <yfuns.h>
     48          
     49          _STD_BEGIN
     50          
     51          #pragma module_name = "?__write"
     52          
     53          int MyLowLevelPutchar(int x);
     54          
     55          int MyLowLevelPutchar(int x){
     56            while( U0CSR&(1<<0));
     57            U0DBUF = x;
     58            return x;
     59          }
     60          /*
     61           * If the __write implementation uses internal buffering, uncomment
     62           * the following line to ensure that we are called with "buffer" as 0
     63           * (i.e. flush) when the application terminates.
     64           */
     65          
     66          size_t __write(int handle, const unsigned char * buffer, size_t size)
     67          {
     68            /* Remove the #if #endif pair to enable the implementation */
     69             
     70          
     71            size_t nChars = 0;
     72          
     73            if (buffer == 0)
     74            {
     75              /*
     76               * This means that we should flush internal buffers.  Since we
     77               * don't we just return.  (Remember, "handle" == -1 means that all
     78               * handles should be flushed.)
     79               */
     80              return 0;
     81            }
     82          
     83            /* This template only writes to "standard out" and "standard err",
     84             * for all other file handles it returns failure. */
     85            if (handle != _LLIO_STDOUT && handle != _LLIO_STDERR)
     86            {
     87              return _LLIO_ERROR;
     88            }
     89          
     90            for (/* Empty */; size != 0; --size)
     91            {
     92              if (MyLowLevelPutchar(*buffer++) < 0)
     93              {
     94                return _LLIO_ERROR;
     95              }
     96          
     97              ++nChars;
     98            }
     99          
    100            return nChars;
    101          
    102          }
    103          
    104          _STD_END
    105          #endif
E:\WMNU\IAR\SHARE_PRJ_SRC\RADIO.c
      1          /*!
      2          \file 
      3          \brief Модуль содержит реализацию интерфейса радио для приема/передачи данных.
      4          */
      5          
      6          #include "RADIO.h"
      7          #include "mem.h"
      8          #include "nwdebuger.h"
      9          #include "Radio_defs.h"
     10          #include "TIC.h"
     11          #include "delays.h"
     12          #include "frame.h"
     13          #include "string.h"
     14          #include "NTMR.h"
     15          
     16          // Открытые методы модуля
     17          void RI_init(void);
     18          bool RI_SetChannel(uint8_t CH);
     19          bool RI_Send(frame_s *fr);
     20          frame_s* RI_Receive(uint16_t timeout);
     21          uint32_t RI_GetCRCError(void);
     22          uint32_t RI_GetCCAReject(void);
     23          float RI_GetUptime(void);
     24          
     25          // Приватные методы
     26          static void random_core_init(void);
     27          static void RI_cfg(void);
     28          
     29          static inline void setFreq(uint8_t CH); // Установка частоты передатчика
     30          static void LoadTXData(uint8_t *src, uint8_t len); // Загрузка данных в tx buf
     31          static void UnLoadRXData(uint8_t *src, uint8_t len);
     32          static bool SendData(frame_s *fc);
     33          static bool RecvData(uint32_t timeout_us, uint16_t *SFD_TimeStamp);
     34          
     35          // Переменные модуля
     36          static float RI_UPTIME = 0; // Время работы радио в мс. 49 дней максимум
     37          static uint32_t RI_CRC_ERROR = 0; // Количество ошибок CRC
     38          static uint32_t RI_CCA_REJECT = 0; // Количество отказов передач из-за CCA
     39          
     40          /*!
     41          \brief Константы для установки выходной мощности радиопередатчика.
     42          Пример: p4x5 = +4,5 дБ. m0x5 = -0.5 дБ
     43          */
     44          enum TX_POWER_e 
     45          {
     46            // +4.5дБ = p4x5, -1.5дБ = m1x5.
     47            // +4.5 = 34мА, +1 = 29мА, -4 = 26мА, -10 = 25 мА, -22 = 23 мА
     48            p4x5 = 0xF5, p2x5 = 0xE5, p1x0 = 0xD5, m0x5 = 0xC5, m1x5 = 0xB5, m3x0 = 0xA5,
     49            m4x0 = 0x95, m6x0 = 0x85, m8x0 = 0x75, m10x0 = 0x65, m12x0 = 0x55, 
     50            m14x0 = 0x45, m16x0 = 0x35, m20x0 = 0x15, m22x0 = 0x05
     51          };
     52          
     53          
     54          #define IEEE_MODE 0     //!< Режимы фазы сигнала
     55          #define NOT_IEEE_MODE 1 //!< Режимы фазы сигнала
     56          #define RSSI_OFFSET -76 //!< Константа для вычисления реальной мощности
     57          
     58          /*!
     59          \details 
     60           Расчет качества связи. Коэффициенты получаются эксперементально.
     61           Есть предположение, что количество ошибок будет пропорционально квадрату
     62           коеффициента корреляции сигнала.
     63           LIQ = 255 передача 1000 пакетов без ошибок CRC
     64           LIQ = 127 передача 1000 пакетов с 50% ошибок CRC
     65           LIQ = 0   передача 1000 пакетов с 100% ошибок CRC
     66          */ 
     67          #define CONST_A (int8_t)0 //!< Коэффициент A
     68          #define CONST_B (int8_t)1 //!< Коэффициент B
     69          #define LIQ_CALC(corr) ((corr-CONST_A)*CONST_B) //!< Формула вычисление LIQ 
     70          #define FRQ_CALC(x) (11+5*(x-11)) //!< Формул вычисления частоты сигнала
     71          
     72          /// Глобальные параметры модуля
     73          struct
     74          {
     75            uint8_t CH;       //!< Номер канала с 11 до 28 включительно
     76            uint8_t TX_POWER; //!< Мощность радиопередатчика по умолчанию. 7 бит
     77            bool MODULATION_MODE; //!< false - совместимость с IEEE 802.15.4
     78          } RADIO_CFG;
     79          
     80          /*!
     81          \brief Иницилизация радио интерфейса
     82          */
     83          void RI_init(void)
     84          {
     85            // Настройки поумолчанию
     86            RADIO_CFG.CH = CH11;
     87            RADIO_CFG.TX_POWER = m0x5;
     88            RADIO_CFG.MODULATION_MODE = IEEE_MODE;
     89            // Пост действия с радио
     90            random_core_init();
     91          }
     92          
     93          /*!
     94          \brief Переводит радио в активный режим и устанавливает параметры.
     95          */
     96          static void RI_cfg(void)
     97          {
     98          /*
     99          APPEND_DATA_MODE = 0. FCS1 = signed rssi, FCS2.7 CRC OK, FCS2.6-0 Correlation
    100          A correlation value of ~110 indicates a maximum quality frame while a value 
    101          of ~50 is typically the lowest quality frames detectable by CC2520. 
    102          */
    103          /* После включения радио находится в активном режиме но приемник выключен */
    104            
    105            // Устанавливаем частоту радиопередатчика
    106            setFreq(RADIO_CFG.CH);
    107            
    108            // Устанавливаем мощность выходного сигнала
    109            TXPOWER = RADIO_CFG.TX_POWER;
    110           
    111            FRMFILT0 = 0x00; // Отключаем фильтрацию пакетов
    112            
    113            // Устанавливаем режим модуляции
    114            MDMTEST1_u MDM1;
    115            MDM1.value = MDMTEST1;
    116            MDM1.bits.MODULATION_MODE = RADIO_CFG.MODULATION_MODE;
    117            MDMTEST1 = MDM1.value; 
    118          }
    119          
    120          /*!
    121          \brief Устанавливает канал радиопередатчика.
    122          \param[in] CH Номера каналов [11..28]
    123          \return Возвращает true если аргументы верны
    124          */
    125          bool RI_SetChannel(uint8_t CH)
    126          {
    127            if ((CH >=11) && (CH<=28))
    128            {
    129              RADIO_CFG.CH = CH;
    130              return true;
    131            }
    132            return false;
    133          }
    134          
    135          /*!
    136          \brief Передает данные в эфир
    137          \details Увеличивает  RI_CCA_REJECT при невозможности отправки сообщения, расчитывает время работы 
    138           радио передатчика. Отправка сообщения в заданное сетевое время 
    139           fr->meta.SEND_TIME. Если равно 0, то отправка через случайноу время в мкс.
    140           Данные автоматически оборачиваются в LEN, CRC1,CRC2
    141          \param[in] *fr Указатель на структуру frame_s RAW_LAY
    142          \return Возвращает true в случаи успешной передачи
    143          */
    144          bool RI_Send(frame_s *fr)
    145          {
    146            ASSERT(fr != NULL);
    147            
    148            // Устанавливаем частоту передачи пакета
    149            RI_cfg();
    150            
    151            bool send_res; // Результат передачи данных
    152            TimeStamp_s start,stop; // Измерение времени
    153            
    154            TIM_TimeStamp(&start); // Начало измерения времени
    155            send_res = SendData(fr);
    156            TIM_TimeStamp(&stop); // Конец измерения времени
    157            
    158            uint32_t passed = TIM_passedTime(&start, &stop);
    159            RI_UPTIME += (float)passed/1000; // Микросекунды в милисекунды
    160            
    161            // В случаи ошибки передачи увеличиваем счетчик RI_CCA_REJECT
    162            if (!send_res)
    163              RI_CCA_REJECT++;
    164            
    165            return send_res;
    166          }
    167          
    168          /**
    169          @brief Отправка сообщения
    170          @detail Время отправки с шифрованием 10 байт в мкс. Merge = 155, Crypt = 239,
    171           Load TX = 30, RSSI_OK = 328, ISTXON = 11, SFD(192us+5*8*4us) = 400, TX = 370, Full = 1535.
    172          Время работы радио RSSI_OK+ISTXON+SFD+TX = 1109 us
    173          @return true в случаи успеха
    174          */
    175          static bool SendData(frame_s *fr)
    176          {
    177          ////TimeStamp_s ts_start, ts_frame_merge, ts_crypt, ts_load_tx, 
    178          ////ts_rssistat, ts_istxon, ts_sfd, ts_stop;
    179            
    180          ////TIM_TimeStamp(&ts_start);  
    181                
    182          ////TIM_TimeStamp(&ts_frame_merge);  
    183            bool result = true;
    184            switch(true)
    185            {
    186              case true:
    187          ////TIM_TimeStamp(&ts_crypt); 
    188                // Копируем данные в буфер. Очистка буфера автоматическая
    189                LoadTXData(fr->payload, fr->len);
    190          ////TIM_TimeStamp(&ts_load_tx); 
    191                // Для начала передачи по команде STXONCCA нужно включить приемник
    192                ISRXON();
    193                // Ждем пока статус RSSI_VALID станет true
    194                while(!RSSISTAT);
    195          ////TIM_TimeStamp(&ts_rssistat); 
    196                // Очищаем флаг завершения передачи сообщения
    197                RFIRQF1 &= ~RFIRQF1_TXDONE;
    198                RFIRQF0 &= ~RFIRQF0_SFD;
    199                
    200                // Время отправки сообщения измеряется в тактах сетевого времени NTMR
    201                // Он работатаеи намного лучше чем MAC таймер(меньше погрешность)
    202                // Отправка в обозначенное время или по факту готовности
    203                //13 - поправка в тактах сети на передачу преамболы
    204                uint16_t timer = 0; // Для отлалки. 
    205                if (fr->meta.SEND_TIME != 0)
    206                  timer = NT_WaitTime(fr->meta.SEND_TIME - 13); 
    207          
    208                // Начинаем передачу данных
    209                // Transmission of preamble begins 192 μs after the STXON or STXONCCA 
    210                // command strobe
    211                // 192+(4(pream)+1(sfd))*8bit*4us = 352 мкс. Измерил 360мкс
    212                // Измерил в тактах NT_GetTimer() получилось 13 тиков. 396 мкс 
    213                ISTXONCCA();
    214          ////TIM_TimeStamp(&ts_istxon); 
    215                // Произошла ошибка передачи если SAMPLED_CCA false
    216                if (!(FSMSTAT1 & 1<<3)) //SAMPLED_CCA == 0
    217                {
    218                  result = false;
    219                  break;
    220                }
    221          
    222                // Ждем завершения отправки SFD
    223                while (!(RFIRQF0 & RFIRQF0_SFD));
    224                fr->meta.TIMESTAMP = NT_GetTime(); 
    225          ////TIM_TimeStamp(&ts_sfd); 
    226                // Проверим переданно ли сообщение TX_FRM_DONE
    227                while (!(RFIRQF1 & RFIRQF1_TXDONE));
    228                break;
    229            }
    230          ////TIM_TimeStamp(&ts_stop);
    231            
    232            ISRFOFF();
    233          ////  LOG(MSG_ON | MSG_INFO | MSG_TRACE, 
    234          ////"Merge = %lu. Crypt = %lu. Load TX = %lu. RSSI_OK = %lu. ISTXON = %lu. SFD = %lu. TX = %lu. FULL = %lu \n", 
    235          ////      TIM_passedTime(&ts_start, &ts_frame_merge),
    236          ////      TIM_passedTime(&ts_frame_merge, &ts_crypt),
    237          ////      TIM_passedTime(&ts_crypt, &ts_load_tx),
    238          ////      TIM_passedTime(&ts_load_tx, &ts_rssistat),
    239          ////      TIM_passedTime(&ts_rssistat, &ts_istxon),
    240          ////      TIM_passedTime(&ts_istxon, &ts_sfd),
    241          ////      TIM_passedTime(&ts_sfd, &ts_stop),
    242          ////      TIM_passedTime(&ts_start, &ts_stop)
    243          ////      );
    244            
    245            if (result)
    246              return true;
    247            return false; 
    248          }
    249          
    250          /**
    251          @brief Загрузка данных для передачи в буфер. 
    252          @detail Поля LEN, FCS1, FCS2 добавляются автоматически
    253          @param[in] src указатель на данные
    254          @param[in] len размер данных
    255          */
    256          static void LoadTXData(uint8_t *src, uint8_t len)
    257          {
    258            // Очищаем буфер передатчика
    259            ISFLUSHTX(); 
    260            // Поле LEN на два байта больше
    261            RFD = len + 2;
    262            
    263            for (uint8_t i = 0 ; i < len; i++)
    264              RFD = src[i];
    265            
    266            // Добавляем CRC1,2
    267            RFD = 0x00;
    268            RFD = 0x00;
    269          };
    270          
    271          /**
    272          @brief Выгружаем принятый пакет из радио
    273          @param[out] src указатель на буфер приемника
    274          @param[in] len размер выгружаемых данных
    275          */
    276          static void UnLoadRXData(uint8_t *src, uint8_t len)
    277          {
    278            for (uint8_t i = 0 ; i < len; i++)
    279              src[i] = RFD;
    280          };
    281          
    282          static inline void setFreq(uint8_t CH)
    283          {
    284            ASSERT( (CH >= 11) && (CH <= 28));
    285            // Устанавливаем частоту радиопередатчика
    286            FREQCTRL_u FRQ;
    287            FRQ.value = FRQ_CALC(RADIO_CFG.CH);
    288            FREQCTRL = FRQ.value;  
    289          }
    290          
    291          /*!
    292          \brief Принимает данные из эфира
    293          \details Функция принимает данные из эфира. Проводит проверку CRC, увеличивает
    294          RI_CRC_ERROR. Отмечает время прихода SFD в тактах сетевого времени .
    295          \param[in] timeout Время ожидания данных в милисекундах
    296          \return Возвращает NULL если данных нет
    297          */
    298          frame_s* RI_Receive(uint16_t timeout)
    299          {
    300            // Устанавливаем частоту передачи пакета
    301            RI_cfg();
    302            uint16_t SFD_TimeStamp;
    303            
    304            // Принимаем пакет 
    305            uint32_t timeout_us = timeout*1000UL; // Переводим мс->мкс
    306            TimeStamp_s start,stop; // Измерение времени
    307            TIM_TimeStamp(&start); // Начало измерения времени работы радио
    308            bool recv_res = RecvData(timeout_us, &SFD_TimeStamp);
    309            TIM_TimeStamp(&stop); // Конец измерения времени радио
    310            uint32_t passed = TIM_passedTime(&start, &stop);
    311            RI_UPTIME += (float)passed/(float)1000; // Микросекунды в милисекунды
    312            
    313            // Если ничего не приняли возвращаем NULL
    314            if (!recv_res)
    315              return NULL;
    316            
    317            uint8_t frame_size = RXFIFOCNT; // Количество принятых данных
    318            
    319            // Минимальный размер FCS1,FCS2 - 2 байта. LEN не включен в подсчет 
    320            if (frame_size <= 2)
    321              return NULL;
    322            
    323            // Выгружаем данные из приемника
    324            uint8_t *frame_raw = re_malloc(frame_size); 
    325            UnLoadRXData(frame_raw, frame_size);
    326            
    327            int8_t  FCS1 = frame_raw[frame_size - 2]; // RSSI
    328            uint8_t FCS2 = frame_raw[frame_size - 1]; // bit7 = CRCOK, bit[6..0] Corr_val
    329            uint8_t LEN_F = frame_raw[0]; // Поле LEN
    330            
    331            // Проверим поле LEN. Размер данных в заголовке должен совпадать
    332            // с фактической длинной принятых данных
    333            if (LEN_F != frame_size - 1)
    334            {
    335              re_free(frame_raw);
    336              RI_CRC_ERROR ++;
    337              return NULL;
    338            }
    339            
    340            // Проверим поле CRCOK
    341            if (!(FCS2 && 1<<7))
    342            {
    343              re_free(frame_raw);
    344              RI_CRC_ERROR ++;
    345              return NULL;
    346            }
    347            
    348            // Создаем буфер, последнии два байта FCS1,2 и поле LEN не копируем
    349            frame_s *raw_frame = frame_create();
    350            frame_addHeader(raw_frame, &frame_raw[1], frame_size - 3);
    351            
    352            // Копируем метку времени SFD
    353            raw_frame->meta.TIMESTAMP = SFD_TimeStamp;
    354            
    355            // Расчитываем мощность принятого сигнала
    356            raw_frame->meta.RSSI_SIG =  FCS1 + RSSI_OFFSET;
    357            // Расчитываем качество сигнала
    358            uint8_t corr = FCS2 & 0x7F;
    359            raw_frame->meta.LIQ = LIQ_CALC(corr); // Значение коэфф. корреляции
    360          
    361            raw_frame->meta.CH = RADIO_CFG.CH;
    362          
    363            re_free(frame_raw);
    364            return raw_frame;
    365          }
    366          
    367          /**
    368          @brief Прием данных из эфира
    369          @param[in] timeout_us время ожидания в микросекундах
    370          @param[out] SFD_TimeStamp отметка времени завершения приема SFD
    371          */
    372          static bool RecvData(uint32_t timeout_us, uint16_t *SFD_TimeStamp)
    373          {
    374            TimeStamp_s start,stop; // Измерение времени  
    375            ISFLUSHRX(); // Очищаем буфер приема
    376            
    377            TIM_TimeStamp(&start);
    378            
    379            // Очищаем флаг завершения передачи сообщения и приема SFD
    380            RFIRQF0 &= ~RFIRQF0_RXPKTDONE;  
    381            RFIRQF0 &= ~RFIRQF0_SFD; 
    382            ISRXON(); // Включаем радиопередатчик
    383          
    384            bool time_out = false; // Истекло время ожидания пакета
    385            bool packet_received = false; // Приняли пакет
    386            bool sfd_received = false; // Приняли sfd
    387            
    388            // Цикл приема пакета
    389            while (true)
    390            {
    391              TIM_TimeStamp(&stop);
    392              if (TIM_passedTime(&start, &stop) >= timeout_us)
    393              {
    394                time_out = true;
    395                break;
    396              }
    397             
    398              // Принят сигнал SFD
    399              if ((RFIRQF0 & RFIRQF0_SFD))
    400              {
    401                *SFD_TimeStamp = NT_GetTime(); 
    402                sfd_received = true;
    403              }
    404              
    405              //  Завершен ли прием сообщения RX_FRM_DONE (RXPKTDONE)
    406              if ((RFIRQF0 & RFIRQF0_RXPKTDONE))
    407              {
    408                packet_received = true;
    409                break;
    410              }
    411            } // while 
    412            
    413            ISRFOFF();
    414            if (packet_received && sfd_received && !time_out)
    415              return true;
    416            else
    417              return false;
    418          }
    419          
    420          /*!
    421          \brief Возвращает количество ошибок возникших с момента иницилизации
    422          \return Количество CRC ошибок
    423          */
    424          uint32_t RI_GetCRCError(void)
    425          {
    426            return RI_CRC_ERROR;
    427          }
    428          
    429          /*!
    430          \brief Возвращает количестов отказов передачи пакета из-за занятости канала.
    431          \return Количество отказов CCA
    432          */
    433          uint32_t RI_GetCCAReject(void)
    434          {
    435            return RI_CCA_REJECT;
    436          }
    437          
    438          /*!
    439          \brief Возвращает суммарное время работы радио в режиме прием/передача
    440          \return Вермя в милисекундах
    441          */
    442          float RI_GetUptime(void)
    443          {
    444            return RI_UPTIME;
    445          }
    446          
    447          /**
    448          @breif Подссчет количества бит в байте
    449          @return Возвращает количество бит
    450          */
    451          static uint8_t bits_count(uint8_t value) {
    452            int ret = 0;
    453            for ( ; value; value = value >> 1 )
    454              ret += value & 1;
    455            return ret;
    456          }
    457          
    458          /**
    459          @brief Возращает 1 байт случайного числа
    460          @details Радио выдает всего лишь дви бита, нам нужно 8 
    461          */
    462          static inline uint8_t getRNDByte(void)
    463          {
    464            uint8_t val = 0;
    465            val |= RFRND << 0;
    466            val |= RFRND << 2;
    467            val |= RFRND << 4;
    468            val |= RFRND << 6;
    469            return val;
    470          }
    471          
    472          /**
    473          @brief Возвращает случайное число с числом включеных бит от 2 до 6 включительно
    474          @details Случайные числа появляются в регистре с частотой 170нс. Функция 
    475          возвращает гарантированно новое значение. 
    476          @return возвращает случайное число.
    477          */
    478          static inline uint8_t readRandom(void)
    479          {
    480            uint8_t rnd_val = 0;
    481            uint8_t bit_cnt = 0;
    482            while ( bit_cnt <= 2 || bit_cnt >= 6 )
    483            {
    484              rnd_val = getRNDByte();
    485              while (rnd_val == getRNDByte());
    486              rnd_val = getRNDByte();
    487              bit_cnt = bits_count(rnd_val);
    488            }
    489            return rnd_val;
    490          }
    491          
    492          /*!
    493          \brief Иницилизирует ядро генератора случайных чисел данными из эфира
    494          */
    495          static void random_core_init(void)  
    496          {
    497            unsigned int rnd_core = 0;;
    498               
    499            RI_cfg();
    500            FREQCTRL = 0x00; // Выбираем не используемую частоту
    501          
    502            // TODO По какой то причине OP_EXE не выполняет команду.
    503            // регистра RFST читается как 0xD0. это его состояние при reset
    504            // Включаем демодулятор
    505            ISRXON();
    506            
    507            // Ждем пока статус RSSI_VALID станет true
    508            while(!RSSISTAT);
    509            
    510            // Ждем случайных чисел
    511            while (RFRND == 0);
    512            
    513            // Настраиваем ядро случайного генератора
    514            rnd_core = readRandom();
    515            rnd_core |= (unsigned int)readRandom()<<8;
    516            srand(rnd_core);
    517            
    518            // Выключаем демодулятор
    519            ISRFOFF();
    520            // Первая генерация случайного числа занимает много времени.
    521            // Влияло на работу радио, так как использовались случайные посылки
    522            rand(); 
    523          }
    524          
    525          /**
    526          @brief Измерение мощности сигнала
    527          @details Частота = 2394+fch. fch = [0..113]. 2394MHz to 2507MHz.
    528           Устройство поддерживает частоты до 2507 МГц
    529          @param[in] fch номер ЧАСТОТНОГО канала
    530          @param[in] timeout_ms время сканирования в мс
    531          @param[out] Максимальная мощность сигнала за время сканирования
    532          @return true если успешно
    533          */
    534          bool RI_Measure_POW(uint8_t fch, uint16_t timeout_ms, int8_t *RSSI_SIG){
    535            
    536            RI_cfg();
    537            
    538            if (fch > 113)
    539              return false;
    540            
    541            //(2394+FREQCTRL.FREQ[6:0])
    542            FREQCTRL = fch; // Выбираем не используемую частоту
    543          
    544            // Включаем демодулятор
    545            ISRXON();
    546            
    547            // Ждем пока статус RSSI_VALID станет true
    548            while(!RSSISTAT);
    549            FRMCTRL0 |= 1<<4; // включаем ENERGY_SCAN, детектор пикового сигнала
    550            
    551            // Ждем пока канал анализируется
    552            TIM_delay(1000*timeout_ms);
    553            
    554            int8_t rssi = RSSI + RSSI_OFFSET;
    555            *RSSI_SIG = rssi;
    556            // Отключаем радио
    557            ISRFOFF();
    558            return true;
    559          }
    560          
E:\WMNU\IAR\SHARE_PRJ_SRC\rx_buff.c
      1          #include "LLC.h"
      2          #include "nwdebuger.h"
      3          
      4          /**
      5          @file Буфер приемника пакетов.
      6          @detail Буфер используется шлюзом для временого хранения принятых пакетов
      7           перед передачей компьютеру по уарт.
      8          */
      9          
     10          // Определения
     11          #define RX_BUFF_SIZE 10 //!< Количество пакетов для хранения 
     12          
     13          // Глобальные функции
     14          void RXB_Init(void);
     15          void RXB_Reset(void);
     16          uint8_t RXB_frame_count(void);
     17          frame_s* RXB_get_frame(void);
     18          void RXB_del_frame(frame_s *fr);
     19          
     20          // Статические функции
     21          static void RXB_Callback(frame_s *fr);
     22          static void Delete_frame(uint8_t index);
     23          
     24          // Локальные переменные
     25          frame_s* FRAME_POOL[RX_BUFF_SIZE]; //!< Хранилище указателей на пакетов. NULL - нет пакета
     26          
     27          /**
     28          @brief Первоначальная настройка
     29          */
     30          void RXB_Init(void){
     31            LLC_SetRXCallback(RXB_Callback);
     32            RXB_Reset();
     33          }
     34          
     35          /**
     36          @brief Сброс всех данных и настройка
     37          */
     38          void RXB_Reset(void){
     39            for (uint8_t i = 0; i < RX_BUFF_SIZE; i++)
     40              Delete_frame(i);
     41          }
     42          
     43          /**
     44          @brief Количество принятых пакетов в буфере
     45          @return Количество пакетов
     46          */
     47          uint8_t RXB_frame_count(void){
     48            uint8_t cnt = 0;
     49            for (uint8_t i = 0; i < RX_BUFF_SIZE; i++)
     50              if (FRAME_POOL[i] != NULL)
     51                cnt ++;
     52            return cnt;
     53          }
     54          
     55          /**
     56          @brief Возращает указатель на принятый пакет
     57          */
     58          frame_s* RXB_get_frame(void){
     59            frame_s *rx_frame = NULL;
     60          
     61            for (uint8_t i = 0; i < RX_BUFF_SIZE; i++)
     62              if (FRAME_POOL[i] != NULL){
     63                rx_frame = FRAME_POOL[i];
     64                break;
     65              }
     66            return rx_frame;
     67          }
     68          
     69          /**
     70          @brief Удаляет пакет по указателю
     71          */
     72          void RXB_del_frame(frame_s *fr){
     73            int index = -1;
     74            
     75            for (uint8_t i = 0; i < RX_BUFF_SIZE; i++)
     76              if (FRAME_POOL[i] == fr){
     77                index = i;
     78                break;
     79              }    
     80            
     81            ASSERT(index > 0);
     82            Delete_frame(index);
     83          }
     84          
     85          /**
     86          @brief Удаляет пакет из RX_BUFF_SIZE по индексу
     87          @param[in] индекс пакета в массиве RX_BUFF_SIZE
     88          */
     89          static void Delete_frame(uint8_t index){
     90            ASSERT(index < RX_BUFF_SIZE);
     91            if (FRAME_POOL[index] != NULL){
     92                frame_delete(FRAME_POOL[index]);
     93                FRAME_POOL[index] = NULL;
     94            }
     95          }
     96          
     97          /**
     98          @brief Обработчик принятого пакета
     99          @detail Вставляет принятые пакеты в буфере, если места нет то размещает
    100           по индексу 0.
    101          */
    102          static void RXB_Callback(frame_s *fr){
    103            
    104            for (uint8_t i = 0; i < RX_BUFF_SIZE; i++)
    105              if (FRAME_POOL[i] == NULL){
    106                FRAME_POOL[i] = fr;
    107                return;
    108              }
    109            
    110            FRAME_POOL[0] = fr;
    111          }
E:\WMNU\IAR\SHARE_PRJ_SRC\sync.c
      1          #include "stdlib.h"
      2          #include "basic.h"
      3          #include "frame.h"
      4          #include "string.h"
      5          #include "nwdebuger.h"
      6          #include "coder.h"
      7          #include "TIC.h"
      8          #include "RADIO.h"
      9          #include "NTMR.h"
     10          #include "config.h"
     11          #include "ioCC2530.h" // ОТЛАДДКА
     12          
     13          void SY_Init(void);
     14          void SY_Reset(void);
     15          void SY_setIV(void* ptr_IV);
     16          void SY_setKEY(void* ptr_KEY);
     17          bool SY_SYNC_NETWORK(uint16_t *panid,uint16_t timeout);
     18          void SY_Enable(bool en);
     19          uint32_t SY_sync_sended(void);
     20          
     21          static void SY_TS1_HNDL_MASTER(void);
     22          static void SY_TS1_HNDL_SLAVE(void);
     23          static void SY_TIME_ALLOC_SLAVE(void);
     24          static void SY_TIME_ALLOC_MASTER(void);
     25          static void BitRawDecrypt(uint8_t *src, uint8_t size);
     26          static void BitRawCrypt(uint8_t *src, uint8_t size);
     27          static frame_s* get_sync(uint16_t timeout);
     28          static bool send_sync(void);
     29          
     30          static uint32_t LAST_SYNC_TIME = 0; //!< Время последней синхр.
     31          static uint32_t NEXT_SYNC_TIME = 0; //!< Время следующей синхр.
     32          static uint32_t SYNC_SENDED = 0; //!< Количество успешно ретранслированых пакетов
     33          static bool NEED_SEND_SYNC = false; //!< Нужно отослать синхропакет
     34          static bool SY_ENABLE_MODULE = false;
     35          
     36          // Ключ потокового шифрования и вектор иницилизации
     37          static uint8_t KEY[16] = DEFAULT_KEY;
     38          static uint8_t IV[16] = DEFAULT_IV;
     39          //@brief Точное время приема/передачи пакета синхронизации времени
     40          // Расчитывается при иницилизации
     41          static uint16_t SYNC_ACCURATE_NETWORK_TIME; 
     42          
     43          #define SYNC_TS 1 //!< Номер временного слота синхросигнала
     44          #define SYNC_RECV_TIMEOUT 2 // Время ожидания приема пакета в мс
     45          #define SYNC_TIMEOUT 110//!< Время в сек после которого сеть не синхронна
     46          
     47          
     48          typedef struct // Формат структуры пакета синхронизации
     49          {
     50              uint16_t panid;
     51              uint32_t rtc;
     52              uint32_t magic;
     53          } __attribute__((packed)) SYNC_s;
     54          
     55          #define MAGIC 0x19833891 // Проверка что пакет действительно sync
     56          #define RAND_SYNC_RX_DELAY  9 // Фиксированое время приема rand()%10 + 5
     57          #define RAND_SYNC_TX_DELAY  10 // Фиксированное время передачи сигнала
     58          // Максимальное отклонение при приеме sync в тактах сети
     59          #define SYNC_TIME_DRIFT 35  
     60          
     61          #ifdef GATEWAY
     62            #define SYNC_MASTER     // Если определено, то узел является шлюзом
     63          #endif
     64          
     65          void SY_Init(void)
     66          {
     67            SYNC_SENDED = 0;
     68            LAST_SYNC_TIME = 0;
     69            NEXT_SYNC_TIME = 0;
     70            SY_ENABLE_MODULE = false;
     71            SYNC_ACCURATE_NETWORK_TIME = TIC_SlotTime(SYNC_TS) + TIC_SlotActivityTime()/2;
     72          #ifdef SYNC_MASTER
     73            TIC_SetTS1Callback(SY_TS1_HNDL_MASTER);
     74            TIC_SetSyncTimeAllocCallback(SY_TIME_ALLOC_MASTER);
     75          #else
     76            TIC_SetTS1Callback(SY_TS1_HNDL_SLAVE);
     77            TIC_SetSyncTimeAllocCallback(SY_TIME_ALLOC_SLAVE);
     78          #endif
     79          }
     80          
     81          void SY_Reset(void)
     82          {
     83            SYNC_SENDED = 0;
     84            LAST_SYNC_TIME = 0;
     85            NEXT_SYNC_TIME = 0;
     86            SY_ENABLE_MODULE = false;
     87          }
     88          
     89          void SY_Enable(bool en)
     90          {
     91            SY_ENABLE_MODULE = en;
     92          }
     93          
     94          /**
     95          @brief Количество успешно переданных пакетов синхронизации
     96          @return Количечтво пакетов
     97          */
     98          uint32_t SY_sync_sended(void)
     99          {
    100            return SYNC_SENDED;
    101          }
    102          
    103          /**
    104          @brief Установить вектор иницилизации для шифрования
    105          @param[in] ptr_IV указатель на 16 байтный вектор иницилизации
    106          */
    107          void SY_setIV(void* ptr_IV)
    108          {
    109            memcpy(IV, ptr_IV, 16);
    110          }
    111          
    112          /**
    113          @brief Установить ключ шифрования
    114          @param[in] ptr_KEY указатель на 16 байтный ключ
    115          */
    116          void SY_setKEY(void* ptr_KEY)
    117          {
    118            memcpy(KEY, ptr_KEY, 16);
    119          }
    120          
    121          /**
    122          @brief Функция вызывается после каждого завершенного слота времени
    123          @detail Детектирует потерю синхронизации, активирует процесс синхронизации
    124           активирует слот для ретрансляцию сигнала
    125          */
    126          static void SY_TIME_ALLOC_SLAVE(void)
    127          { 
    128            if (!SY_ENABLE_MODULE) // Модуль отключен
    129              return;  
    130            
    131            // Потеря синхронизации
    132            if ( (TIC_GetUptime() - LAST_SYNC_TIME) > SYNC_TIMEOUT)
    133            {
    134                LOG_ON("Network out of sync.");
    135                return;
    136            }
    137            
    138            if (TIC_GetRXState(SYNC_TS)) // Если прием уже активен
    139              return;
    140            
    141            // Ретрансляция синхропакета
    142            if (NEED_SEND_SYNC)
    143            {
    144              LOG_OFF("Need to send resync");
    145              TIC_SetRXState(SYNC_TS, true);
    146              return;
    147            }
    148            
    149            // Необходимо начать процесс синхронизации
    150            if (TIC_GetUptime() > NEXT_SYNC_TIME)
    151            {
    152              LOG_ON("Begin resync");
    153              P1_0 = !true; 
    154              TIC_SetRXState(SYNC_TS, true);
    155            }
    156          }
    157          
    158          /**
    159          @brief Функция вызывается после каждого завершенного слота времени
    160          @detail Запускает процесс передачи синхросигнала в равные промежутки времени
    161          */
    162          static void SY_TIME_ALLOC_MASTER(void)
    163          { 
    164            static uint32_t sync_send_time = 0;
    165           
    166            if (!SY_ENABLE_MODULE) // Модуль отключен
    167            {
    168              sync_send_time = 0;
    169              return;  
    170            }
    171            
    172            if (TIC_GetTXState(SYNC_TS)) // Если передача уже активна.
    173              return;
    174            
    175            uint32_t now = TIC_GetUptime();
    176            if ( now < sync_send_time) // Если время новой передачи не наступило
    177              return;
    178            
    179            TIC_SetTXState(SYNC_TS,true); // Разрешаем передачу
    180             
    181             // Определяем следующее время передачи
    182             sync_send_time = now + RAND_SYNC_TX_DELAY;
    183          }
    184          
    185          /**
    186          @brief Вызывает при активности TS1 RX или TX
    187          @detail Выполняет две функции: синхронизацию с сетью или передачу синхр.
    188          */
    189          static void SY_TS1_HNDL_SLAVE(void)
    190          {
    191            if (!SY_ENABLE_MODULE) // Модуль отключен
    192              return;
    193              
    194            // Нужно отослать синхропакет
    195            if (NEED_SEND_SYNC)
    196            {
    197              if (send_sync())
    198                SYNC_SENDED++;
    199              LOG_ON("Resync TX. CNT=%d",(uint16_t)SYNC_SENDED);
    200              NEED_SEND_SYNC = false;
    201              TIC_SetRXState(SYNC_TS, false);
    202            }
    203            
    204            // Ждем начала точного времени начала передачи сигнала заранее
    205            // Время в тактах сети
    206            NT_WaitTime(SYNC_ACCURATE_NETWORK_TIME - SYNC_TIME_DRIFT);
    207           
    208            // Время в мс
    209            frame_s *fr_SYNC = get_sync(SYNC_RECV_TIMEOUT); 
    210            
    211            if (!fr_SYNC)
    212              return;
    213            
    214            SYNC_s *sync;
    215            sync = (SYNC_s*)fr_SYNC->payload;
    216            
    217            // Проверяем принадлежность пакета
    218            if (( sync->panid != CONFIG.panid) && (sync->magic != MAGIC))
    219            {
    220              frame_delete(fr_SYNC);
    221              return;
    222            }
    223            
    224            // Синхронизируемся
    225            // Время прошедшее с момента приема пакета в тактах сети
    226            uint16_t delta = TIC_GetTimer() - fr_SYNC->meta.TIMESTAMP;
    227            TIC_SetTimer(SYNC_ACCURATE_NETWORK_TIME + delta);
    228            TIC_SetRTC(sync->rtc);
    229            
    230            LAST_SYNC_TIME = TIC_GetUptime();
    231            NEXT_SYNC_TIME = LAST_SYNC_TIME + RAND_SYNC_RX_DELAY; 
    232            TIC_SetRXState(SYNC_TS, false);
    233            LOG_ON("Node Synced. TS=%d, AT=%d, DEL=%d, AD=%d, RTC=%d, NRTC=%d, SRTC=%d",
    234                   fr_SYNC->meta.TIMESTAMP,SYNC_ACCURATE_NETWORK_TIME, delta,
    235                   SYNC_ACCURATE_NETWORK_TIME - fr_SYNC->meta.TIMESTAMP, 
    236                   (uint16_t)LAST_SYNC_TIME,
    237                   (uint16_t)NEXT_SYNC_TIME,
    238                   (uint16_t)TIC_GetRTC());
    239            frame_delete(fr_SYNC);
    240            // После приема нужно ретранслировать синхропакет
    241            NEED_SEND_SYNC = true; 
    242          P1_0 = !false; // ОТЛАДКА
    243          }
    244          
    245          /**
    246          @brief Вызывает при активносм TS1 RX или TX
    247          @detail Формирует кадр синхронизации и передает его в строго определенное время
    248          */
    249          static void SY_TS1_HNDL_MASTER(void)
    250          {
    251            if (!SY_ENABLE_MODULE) // Модуль отключен
    252              return;  
    253             
    254          P1_0 = !true; //ОТЛАДКА  
    255            if (send_sync())
    256              SYNC_SENDED++;
    257            
    258            LOG_ON("Sync send."); 
    259          P1_0 = !false; //ОТЛАДКА
    260            
    261            TIC_SetTXState(SYNC_TS, false);
    262          }
    263          
    264          /**
    265          @brief Создать и отправить синхропакет
    266          */
    267          static bool send_sync(void)
    268          {
    269            SYNC_s sync;
    270            sync.panid = CONFIG.panid;
    271            sync.rtc = TIC_GetRTC();
    272            sync.magic = MAGIC;
    273            
    274            frame_s *fr_SYNC = frame_create();
    275            frame_addHeader(fr_SYNC, &sync, sizeof(SYNC_s));
    276            fr_SYNC->meta.SEND_TIME = SYNC_ACCURATE_NETWORK_TIME; // время в тактах сети. ((1/32768)*164)*1000
    277              
    278          #ifdef RARIO_STREAM_ENCRYPT
    279            BitRawCrypt(fr_SYNC->payload, fr_SYNC->len);
    280          #endif
    281            
    282            RI_SetChannel(CONFIG.sync_channel);
    283            bool res = RI_Send(fr_SYNC);
    284            
    285            frame_delete(fr_SYNC);
    286            return res;
    287          }
    288          
    289          /**
    290          @brief Прием пакет синхронизации
    291          @param[in] Время ожидания в мс
    292          @return Указатель на пакет или NULL
    293          */
    294          static frame_s* get_sync(uint16_t timeout)
    295          {
    296            RI_SetChannel(CONFIG.sync_channel);
    297            frame_s *fr_SYNC = RI_Receive(timeout);
    298            
    299            // Если пакета нет, выходим из обработчика
    300            if (fr_SYNC == NULL)
    301              return NULL;
    302            
    303            // Проверим размер пакета
    304            if (fr_SYNC->len != sizeof(SYNC_s))
    305            {
    306              frame_delete(fr_SYNC);
    307              return NULL;
    308            }
    309            
    310            #ifdef RARIO_STREAM_ENCRYPT
    311            BitRawDecrypt(fr_SYNC->payload, fr_SYNC->len);
    312            #endif
    313            return fr_SYNC;
    314          }
    315          
    316          /**
    317          @brief Процедура синхронизации с сетью
    318          @detail Процедура изет сеть в течении времени timeout и синхронизируется с ней
    319          @param[in] timeout время в милисекундах
    320          @param[out] panid указатель на идентификатор найденой сети
    321          @return true если сеть найдета
    322          */
    323          bool SY_SYNC_NETWORK(uint16_t *panid,uint16_t timeout)
    324          {
    325            // TODO Нужно обнулить настройки всех модулей
    326            // Или об этом будет заботиться верхний уровень?
    327            TIC_CloseAllState();
    328            
    329            RI_SetChannel(CONFIG.sync_channel);
    330            
    331            TimeStamp_s begin, end;
    332            TIM_TimeStamp(&begin);
    333            TIM_TimeStamp(&end);
    334            
    335            bool net_found = false;
    336            uint32_t passed = 0;
    337            frame_s *fr_SYNC;
    338            SYNC_s *sync;
    339            uint32_t timeout_us = timeout * 1000;
    340            
    341            while (passed < timeout_us)
    342            {
    343              fr_SYNC = get_sync(timeout);
    344              if (fr_SYNC == NULL)
    345              {
    346                passed = TIM_passedTime(&begin, &end);
    347                continue;
    348              }
    349              
    350              // Приняли какойто пакет, декодируем.
    351              sync = (SYNC_s*)fr_SYNC->payload;
    352              
    353              if (sync->magic != MAGIC)
    354              { // Проверим что пакет именно тот а не эфирный мусор
    355                frame_delete(fr_SYNC);
    356                passed = TIM_passedTime(&begin, &end);
    357                continue;
    358              }   
    359              
    360              // Возвращаем результат
    361              *panid = sync->panid;
    362              CONFIG.panid = sync->panid;
    363              net_found = true;
    364              
    365              // Синхронизируемся с сетью
    366              // Время прошедшее с момента приема пакета в тактах сети
    367              uint16_t delta = TIC_GetTimer() - fr_SYNC->meta.TIMESTAMP;
    368              TIC_SetTimer(SYNC_ACCURATE_NETWORK_TIME + delta);
    369              TIC_SetRTC(sync->rtc);
    370              LAST_SYNC_TIME = TIC_GetUptime();
    371              NEXT_SYNC_TIME = LAST_SYNC_TIME + RAND_SYNC_RX_DELAY; 
    372              frame_delete(fr_SYNC);
    373              break;
    374            } 
    375            
    376            return net_found;
    377          }
    378          
    379          /*!
    380          \brief Расшифровка область памяти
    381          \param[in,out] *src Указатель на начало области дешифрования
    382          \param[in] size Размер расшифруемых данных
    383          */
    384          static void BitRawDecrypt(uint8_t *src, uint8_t size)
    385          {
    386            AES_StreamCoder(false, src, src, KEY, IV, size);
    387          }
    388          
    389          /*!
    390          \brief Шифрует область памяти
    391          \param[in,out] *src Указатель на начало области шифрования
    392          \param[in] size Размер шифруемых данных
    393          */
    394          static void BitRawCrypt(uint8_t *src, uint8_t size)
    395          {
    396            AES_StreamCoder(true, src, src, KEY, IV, size);
    397          }
    398          
E:\WMNU\IAR\SHARE_PRJ_SRC\TIC.c
      1          #include "TIC.h"
      2          #include "NTMR.h"
      3          #include "stdlib.h"
      4          #include "nwdebuger.h"
      5          #include "delays.h"
      6          #include "basic.h"
      7          #include "ioCC2530.h" // ОТЛАДДКА
      8          
      9          /**
     10          @file 
     11          @brief 
     12          @details
     13          */
     14          
     15          // Публичные методы
     16          void TIC_Init(void);
     17          void TIC_Reset(void);
     18          
     19          // Методы класса
     20          void TIC_SetTimer(uint16_t ticks);
     21          uint16_t TIC_GetTimer(void);
     22          bool TIC_SetTXState(uint8_t TS, bool state);
     23          bool TIC_SetRXState(uint8_t TS, bool state);
     24          bool TIC_GetTXState(uint8_t TS);
     25          bool TIC_GetRXState(uint8_t TS);
     26          void TIC_CloseAllState();
     27          void TIC_SetRXCallback(void (*fn)(uint8_t TS));
     28          void TIC_SetTXCallback(void (*fn)(uint8_t TS));
     29          void TIC_SetSECallback(void (*fn)(uint8_t TS));
     30          void TIC_SetTS1Callback(void (*fn)(void));
     31          void TIC_SetSyncTimeAllocCallback(void (*fn)(void));
     32          uint32_t TIC_GetUptime(void);
     33          uint32_t TIC_GetRTC(void);
     34          bool TIC_SetRTC(uint32_t RTC);
     35          void TIC_SetNonce(uint32_t nonce);
     36          uint32_t TIC_GetNonce(void);
     37          uint32_t TIC_TimeUsFromTS0();
     38          TimeStamp_s* TIC_GetTimeStampTS0(void);
     39          uint16_t TIC_SleepTime(void);
     40          uint16_t TIC_SlotActivityTime(void);
     41          uint16_t TIC_SlotTime(uint8_t TS);
     42          
     43          // Приватные методы
     44          static uint8_t TIC_getCurrentTS(uint16_t ticks);
     45          static void TIC_TDMAShelduler(uint8_t TS);
     46          static void TIC_HW_Timer_IRQ(uint16_t ticks);
     47          static inline void set_capture_time(uint8_t TS);
     48          static inline void Callback_execution(void (*fn)(uint8_t TS), uint8_t TS);
     49          static inline void incrementTS(uint8_t *TS);
     50          static void clocks_update(void);
     51          
     52          // Переменные модуля
     53          
     54          // Всего 50 слотов. (50 активных и 50 слотов сна)
     55          // Кварц имеет 32768 тактов в секунду. После 100 слотов
     56          // Остается 68 неучтеных тактов. Их нужно учитывать.
     57          #define MAX_TS (uint8_t)50
     58          #define TS_ACTIVE (uint16_t)327 // 9.979 мс
     59          #define TS_SLEEP (uint16_t)327  // 2.075 мс
     60          #define TS_UNACCOUNTED 68
     61          // Целый цикл-это сумма времени активного периода и сна
     62          #define FULL_SLOT  (TS_ACTIVE+TS_SLEEP)
     63          #define NO_TIME_SLOT 0xFF
     64          
     65          #define TS_RX (uint8_t)(1<<0)
     66          #define TS_TX (uint8_t)(1<<1)
     67          #define DAILY_SEC (uint32_t)86400
     68          #define MAX_TICKS (uint16_t)32768
     69          
     70          static uint32_t NODE_UPTIME = 0;
     71          static uint32_t NODE_RTC = 0;
     72          static uint32_t NODE_NONCE = 0;
     73          static void (*RXCallback)(uint8_t TS);
     74          static void (*TXCallback)(uint8_t TS);
     75          static void (*SECallback)(uint8_t TS);
     76          static void (*SyncTimeAllocCallback)(void);
     77          static void (*TS1Callback)(void);
     78          static uint8_t TSStateTable[MAX_TS];
     79          static TimeStamp_s TimeStampTS0;
     80          
     81          
     82          TimeStamp_s* TIC_GetTimeStampTS0(void)
     83          {
     84            return &TimeStampTS0;
     85          }
     86          
     87          void TIC_Init(void)
     88          {    
     89            TIC_CloseAllState();
     90            // Устанавливаем обработчик прерываний таймера
     91            NT_SetEventCallback(TIC_HW_Timer_IRQ);
     92            // Запускаем процесс планировщика
     93            NT_SetCompare(0); 
     94            TIC_SetTimer(0);
     95            TIM_TimeStamp(&TimeStampTS0);
     96          }
     97          
     98          /**
     99          @brief Сброс настроек. 
    100          @detail Модуль генерирует только SECallback и считает время RTC, UPTIME, NONCE.
    101          Так как была переустановка времени, значение RTC не верное на 1с (плюс, минус)
    102          */
    103          void TIC_Reset(void)
    104          {
    105          #ifdef GATEWAY
    106            NODE_RTC = 0;
    107            NODE_NONCE = 0;
    108            NODE_UPTIME = 0;
    109          #endif
    110            TIC_CloseAllState();  
    111            NT_SetCompare(0); 
    112            TIC_SetTimer(0);
    113            TIM_TimeStamp(&TimeStampTS0);
    114          }
    115          
    116          void TIC_CloseAllState()
    117          {
    118            for (uint8_t i = 0 ; i < 50; i++)
    119            {
    120              TIC_SetTXState(i, false);
    121              TIC_SetRXState(i, false);
    122            }
    123          }
    124          uint32_t TIC_TimeUsFromTS0()
    125          {
    126            uint32_t passed;
    127            TimeStamp_s now;
    128            TIM_TimeStamp(&now);
    129            passed = TIM_passedTime(&TimeStampTS0, &now);
    130            return passed;
    131          }
    132          
    133          void TIC_SetTimer(uint16_t ticks)
    134          {
    135            ASSERT(ticks < MAX_TICKS);
    136            if (ticks >= MAX_TICKS)
    137              return ;
    138            
    139            NT_SetTime(ticks);
    140          }
    141          
    142          uint16_t TIC_GetTimer(void)
    143          {
    144            return NT_GetTime();
    145          }
    146          
    147          bool TIC_SetTXState(uint8_t TS, bool state)
    148          {
    149            if (TS>=MAX_TS)
    150            {
    151              return false;
    152            }
    153            ASSERT(TS<MAX_TS);
    154            
    155            if (state)
    156              TSStateTable[TS] |= TS_TX;
    157            else
    158              TSStateTable[TS] &= ~TS_TX;
    159            
    160            return true;
    161          }
    162          
    163          bool TIC_SetRXState(uint8_t TS, bool state)
    164          {
    165            if (TS>=MAX_TS)
    166            {
    167              return false;
    168            }
    169            ASSERT(TS<MAX_TS);
    170            
    171            if (state)
    172              TSStateTable[TS] |= TS_RX;
    173            else
    174              TSStateTable[TS] &= ~TS_RX;
    175            
    176            return true;
    177          }
    178          
    179          bool TIC_GetTXState(uint8_t TS)
    180          {
    181              if (TS>=MAX_TS)
    182            {
    183              return false;
    184            }
    185            ASSERT(TS<MAX_TS);
    186            
    187            return (TSStateTable[TS] & TS_TX) ;
    188          }
    189          
    190          bool TIC_GetRXState(uint8_t TS)
    191          {
    192              if (TS>=MAX_TS)
    193            {
    194              return false;
    195            }
    196            ASSERT(TS<MAX_TS);
    197            
    198            return (TSStateTable[TS] & TS_RX) ;
    199          }
    200          
    201          void TIC_SetTS1Callback(void (*fn)(void))
    202          {
    203            ASSERT (fn != NULL);
    204            TS1Callback = fn;
    205          }
    206          
    207          void TIC_SetRXCallback(void (*fn)(uint8_t TS))
    208          {
    209            ASSERT(fn != NULL);
    210            RXCallback = fn;
    211          }
    212          
    213          void TIC_SetSyncTimeAllocCallback(void (*fn)(void))
    214          {
    215            ASSERT(fn != NULL);
    216            SyncTimeAllocCallback = fn;
    217          }
    218          
    219          void TIC_SetTXCallback(void (*fn)(uint8_t TS))
    220          {
    221            ASSERT(fn != NULL);
    222            TXCallback = fn;
    223          }
    224          
    225          void TIC_SetSECallback(void (*fn)(uint8_t TS))
    226          {
    227            ASSERT(fn != NULL);
    228            SECallback = fn;
    229          }
    230          
    231          uint32_t TIC_GetUptime(void)
    232          {
    233            return NODE_UPTIME;
    234          }
    235          
    236          uint32_t TIC_GetRTC(void)
    237          {
    238            return NODE_RTC;
    239          }
    240          
    241          bool TIC_SetRTC(uint32_t RTC)
    242          {
    243            if (RTC >= DAILY_SEC)
    244              return false;
    245            
    246            NODE_RTC = RTC;
    247            return true;
    248          }
    249          
    250          static uint8_t TIC_getCurrentTS(uint16_t ticks)
    251          {
    252            //uint16_t ticks = nt->NT_GetTime();
    253            // Вычисляем количество целых циклов
    254            uint8_t full_slot_num = ticks/FULL_SLOT;
    255            
    256            // Вычисляем остаток от деления. Остаток - смещение внутри
    257            // временного слота.
    258            uint16_t time_remainder = ticks % FULL_SLOT; 
    259            // Если значение внутри интервала 0..TS_ACTIVE. 
    260            if (time_remainder < TS_ACTIVE)
    261              return full_slot_num;
    262            
    263            return NO_TIME_SLOT;
    264          }
    265          
    266          static inline void incrementTS(uint8_t *TS)
    267          {
    268            // Выбираем следующий тайм слот
    269            (*TS)++;
    270            if (*TS >= MAX_TS)
    271              *TS = 0;
    272          }
    273          
    274          /**
    275          @brief Время активного слота в тактах сети
    276          @return время в тактах сети
    277          */
    278          uint16_t TIC_SlotActivityTime(void)
    279          {
    280            return TS_ACTIVE;
    281          }
    282          
    283          /**
    284          @brief Время неактивного слота в тактах сети
    285          @return время в тактах сети
    286          */
    287          uint16_t TIC_SleepTime(void)
    288          {
    289            return TS_SLEEP;
    290          }
    291          
    292          /**
    293          @brief Время начала временного слота в тактах сети
    294          @param[in] TS номер слота
    295          @return время в тактах сети
    296          */
    297          uint16_t TIC_SlotTime(uint8_t TS)
    298          {
    299            return FULL_SLOT*(uint16_t)TS;
    300          }
    301          
    302          static inline void set_capture_time(uint8_t TS)
    303          {
    304            //uint16_t ct = FULL_SLOT*(uint16_t)TS;
    305            
    306            LOG_OFF("Set compare = %d, TS = %d \r\n", ct, TS);
    307            // Установка прерывания на нужный слот
    308            NT_SetCompare(FULL_SLOT*(uint16_t)TS);
    309          }
    310          
    311          static void TIC_TDMAShelduler(uint8_t TS)
    312          {
    313            // Устанавливает прерывание на ближайший активный слот
    314            // Если слот 0 ближе, то на него. 
    315            // Cлот - обработка секундных таймеров 
    316            
    317            // Ищем следующий активный слот или слот 0
    318            incrementTS(&TS);
    319            while ((TS != 0) && !TSStateTable[TS])  
    320              incrementTS(&TS); 
    321            
    322            set_capture_time(TS);
    323          }
    324          
    325          static inline void Callback_execution(void (*fn)(uint8_t TS), uint8_t TS)
    326          {
    327            // Помошник вызова функций. Упрощает проверки
    328            ASSERT(fn != NULL);
    329            if (fn == NULL)
    330              return;
    331            fn(TS);
    332          }
    333          
    334          static void TIC_HW_Timer_IRQ(uint16_t ticks)
    335          {
    336            // TODO Обработка TS=0xFF
    337            // Номер текущего слота 
    338            uint8_t c_TS = TIC_getCurrentTS(ticks);
    339            
    340            // Обновляем часы NODE_RTC и NODE_UPTIME
    341            if (c_TS == 0)
    342            {
    343              TIM_TimeStamp(&TimeStampTS0); // Первым делом обновим отметку точного времени
    344              clocks_update();
    345           //   P1_0 = !true;
    346              LOG_OFF("TS0");
    347           //   P1_0 = !false;;
    348            }
    349            // Если что то пошло не так и мы промахнулись мимо слота
    350            // запускаем планировщик заново
    351            if (c_TS == NO_TIME_SLOT)
    352            {
    353              TIC_TDMAShelduler(c_TS);
    354              LOG_ON("TS = 255 \r\n");
    355              return;
    356            }
    357              
    358            // Вызываем один из указанных обработчиков.
    359            // Передача имеет приоритет над приемом.
    360            if (c_TS != 1)
    361            {
    362              if (TSStateTable[c_TS] & TS_TX) 
    363                Callback_execution(TXCallback, c_TS);
    364              else if (TSStateTable[c_TS] & TS_RX)
    365                Callback_execution(RXCallback, c_TS);
    366            }  
    367            else // Для TS1 свой обработчик слота
    368            {
    369              if (TS1Callback != NULL)
    370                TS1Callback();
    371            }
    372            
    373            // Выделяем время протоколу синхронизации
    374            if (SyncTimeAllocCallback)
    375              SyncTimeAllocCallback();
    376            
    377            Callback_execution(SECallback, c_TS); // Вызываем обработчик завершения слота
    378            
    379            // Запускаем планировщик таймера
    380            TIC_TDMAShelduler(c_TS);
    381          }
    382          
    383          static void clocks_update(void)
    384          {
    385            NODE_UPTIME++;
    386            NODE_RTC++;
    387            NODE_NONCE++;
    388            if (NODE_RTC >= DAILY_SEC)
    389              NODE_RTC = 0;
    390          }
    391          
    392          void TIC_SetNonce(uint32_t nonce)
    393          {
    394            NODE_NONCE = nonce;
    395          }
    396          
    397          uint32_t TIC_GetNonce(void)
    398          {
    399            return NODE_NONCE;
    400          }
E:\WMNU\IAR\NEOCOREGATEWAY\src\uart_comm.c
      1          #include "nwdebuger.h"
      2          #include "ioCC2530.h"
      3          #include "stdint.h"
      4          #include "stdbool.h"
      5          #include "DMA.h"
      6          
      7          /**
      8          @file Настройка UART для приема команд от PC
      9          */
     10          
     11          #define UART_RX_BUF_LEN 0xff //!< Размер приемного буфера
     12          #define TRIG_URX1 16
     13          
     14          static void uart_dma_init(void);
     15          
     16          void uart_write(const char *data, uint8_t size);
     17          uint8_t* uart_recv_cmd(uint8_t *size);
     18          
     19          static uint8_t uart_rx_buff[UART_RX_BUF_LEN]; //1 для поля длинны
     20          static void uart_putchar(char x);
     21          
     22          static void uart_dma_init(void)
     23          {
     24            // Настроим канал 2 DMA для загрузки данных из uart
     25            // DMA0 и 1 заняты кодером AES
     26            
     27            ST_DEF(DMA_CH[2], SRCADDRL, 0xF9); //U1DBUF
     28            ST_DEF(DMA_CH[2], SRCADDRH, 0x70);
     29            ST_DEF(DMA_CH[2], LENL, UART_RX_BUF_LEN); // Максимальный размер данных
     30            ST_DEF(DMA_CH[2], DSTADDRH, HADDR(uart_rx_buff)); // Пишем данные XENCDI = 0xB1 
     31            ST_DEF(DMA_CH[2], DSTADDRL, LADDR(uart_rx_buff)); //  
     32            ST_DEF(DMA_CH[2], PRIORITY, 0x00); // Низкий приоритет
     33            ST_DEF(DMA_CH[2], M8, 0x00); // Используем 8 бит для счетика длинны
     34            ST_DEF(DMA_CH[2], IRQMASK, 0x00); // Запрещаем генерировать перывания
     35            ST_DEF(DMA_CH[2], DESTINC, 0x01); // Увеличиваем адресс назначения
     36            ST_DEF(DMA_CH[2], SRCINC, 0x00); // Не увеличиваем адресс источника
     37            ST_DEF(DMA_CH[2], TRIG, TRIG_URX1); // Тригер по приходу байта UART0
     38            ST_DEF(DMA_CH[2], WORDSIZE, 0x00); // Копируем по 1 байту
     39            ST_DEF(DMA_CH[2], TMODE, 0x00); //  Одиночное копирование по тригеру
     40            ST_DEF(DMA_CH[2], VLEN, 0x01); // Длинна данных определяется 1ым байтом  
     41            ST_DEF(DMA_CH[2], LENH, 0x00); 
     42          }
     43          
     44          /**
     45          @brief Прием команды по uart
     46          @param[out] size размер принятых данных
     47          @return указатель на начало данных или null
     48          */
     49          uint8_t* uart_recv_cmd(uint8_t *size)
     50          {  
     51            // Начинаем прием
     52            DMAARM |= 0x04;
     53            
     54            while (DMAARM&0x04);
     55            
     56            *size = uart_rx_buff[0];
     57            return &uart_rx_buff[1];
     58          }
     59          
     60          /**
     61          @brief Иницилизация uart с компьютером
     62          @detail Скорость 115200 бод. Частота микроконтроллера 32Мгц.
     63          */
     64          void com_uart_init(void)
     65          {
     66            // Выбор расположения UART на выводах
     67            uint8_t U1CFG = 1; // 0={TX=P0_4, RX=P0_5 Локация 1. 1={P1_6=TX P1_7=RX}
     68            PERCFG |= (U1CFG<<1); 
     69            
     70            // U1UCR регистр настройки режима uart. меня устраивает по умолчанию
     71            U1CSR = (1<<7); // Выбираем режим uart  
     72            
     73            // Настройка скорости передачи данных на 115200  
     74            U1BAUD = 216;  // табличные значения из pdf
     75            U1GCR =  11; //16
     76            
     77            // Включаем альтернативные функции выводов
     78            P1SEL |= (1<<6)|(1<<7);
     79            U1CSR |= (1<<6);
     80            uart_dma_init();
     81          }
     82          
     83          /**
     84          @brief Запись в uart
     85          @param[in] data указатель на начало массива данных
     86          @param[in] size размер передаваемых данных
     87          */
     88          void uart_write(const char *data, uint8_t size)
     89          {
     90            for (uint8_t i = 0; i < size; i++)
     91              uart_putchar((char)data[i]);
     92          };
     93          
     94          
     95          static void uart_putchar(char x){
     96            while( U1CSR&(1<<0));
     97            U1DBUF = x;
     98          }
     99          
    100           char uart_getchar(void)
    101          {
    102            char x;
    103            while( !(U1CSR&(1<<2)));
    104            x = U1DBUF;
    105            return x;
    106          }

   Maximum stack usage in bytes:

   ISTACK XSTACK Function
   ------ ------ --------
      1     76   AES_CCMDecrypt
        0     66   -> CBCMAC_buf_encrypt
        0     70   -> CTR_enc_decrypt
        0     68   -> generateAuthData
        0     68   -> memcpy
        0     68   -> memset
      1     60   AES_CCMEncrypt
        0     50   -> CBCMAC_buf_encrypt
        0     54   -> CTR_enc_decrypt
        0     52   -> generateAuthData
        0     52   -> memcpy
        0     52   -> memset
      0     55   AES_StreamCoder
        0     39   -> memcpy
        0     39   -> memset
      2      0   AES_init
      0     28   BitRawCrypt
        0     16   -> AES_StreamCoder
      0     36   BitRawCrypt
        0     16   -> AES_StreamCoder
      0     28   BitRawDecrypt
        0     16   -> AES_StreamCoder
      0     28   BitRawDecrypt
        0     16   -> AES_StreamCoder
      0    116   CBCMAC_buf_encrypt
        0     50   -> memcpy
        0     50   -> memset
      0     12   CF_init
        0     12   -> memcpy
      0    109   CTR_enc_decrypt
        0     39   -> memcpy
        0     39   -> memset
      0     27   Callback_execution
        0     12   -> printf
        0     18   -> printf
      0      0   DMA_init
      0     40   DelayCalibrate
        0     40   -> TIM_TimeStamp
        0     40   -> TIM_delay
        0     40   -> TIM_passedTime
      0     28   Delete_frame
        0     10   -> frame_delete
        0     10   -> printf
        0     16   -> printf
      2      0   ETH_Init
        2      0   -> LLC_SetRXCallback
      0     20   ETH_RX_HNDL
        0     14   -> extract_header
        0     14   -> frame_delete
        0     14   -> printf
        0     20   -> printf
        0     14   -> re_free
        0     14   -> send_ack
        0     14   -> strip_header
        0     14   -> validate
      0     16   ETH_Set_RXCallback
        0     10   -> printf
        0     16   -> printf
      0     54   Interval
      1     34   LLC_AddTask
        0     12   -> printf
        0     18   -> printf
        0     12   -> re_malloc
      2     10   LLC_GetTaskLen
      2      0   LLC_Init
        2      0   -> MAC_SetRXCallback
        2      0   -> TIC_SetSECallback
      0     16   LLC_RX_HNDL
        0     10   -> printf
        0     16   -> printf
      0     20   LLC_Reset
        0     10   -> re_free
      0     18   LLC_RunTimeAlloc
      0      9   LLC_SE_HNDL
        0      9   -> LLC_RunTimeAlloc
        0      9   -> LLC_Shelduler
      0     16   LLC_SetRXCallback
        0     10   -> printf
        0     16   -> printf
      0     31   LLC_Shelduler
        0     16   -> MAC_GetTXState
        0     16   -> MAC_Send
        0     16   -> printf
        0     22   -> printf
        0     16   -> re_free
      0     18   LLC_TimeAlloc
        0     12   -> printf
        0     18   -> printf
        0     12   -> re_malloc
      2     12   LoadTXData
      0     24   MAC_ACK_Recv
        0     14   -> RI_Receive
        0     14   -> frame_delete
        0     14   -> xor_calc
      0     24   MAC_ACK_Send
        0     12   -> RI_Send
        0     12   -> frame_addHeader
        0     12   -> frame_create
        0     12   -> frame_delete
        0     12   -> xor_calc
      1     28   MAC_CloseRXSlot
        0     10   -> TIC_SetRXState
        0     10   -> printf
        0     16   -> printf
      2     11   MAC_Enable
      0     16   MAC_GetRXState
        0     10   -> printf
        0     16   -> printf
      0     32   MAC_GetTXState
        0     10   -> printf
        0     16   -> printf
      0     12   MAC_Init
        0     10   -> TIC_SetRXCallback
        0     10   -> TIC_SetTXCallback
        0     12   -> memset
      1     28   MAC_OpenRXSlot
        0     10   -> TIC_SetRXState
        0     10   -> printf
        0     16   -> printf
      0     18   MAC_RX_HNDL
        0     12   -> BitRawDecrypt
        0     12   -> MAC_ACK_Send
        0     12   -> RI_Receive
        0     12   -> RI_SetChannel
        0     12   -> printf
        0     18   -> printf
      0     22   MAC_Reset
        0     10   -> frame_delete
        0     12   -> memset
      1     34   MAC_Send
        0     12   -> BitRawCrypt
        0     12   -> TIC_SetTXState
        0     12   -> printf
        0     18   -> printf
      2      0   MAC_SetRXCallback
      1     16   MAC_TX_HNDL
        0     10   -> MAC_ACK_Recv
        0     10   -> RI_Send
        0     10   -> RI_SetChannel
        0     10   -> TIC_SetTXState
        0     10   -> TIM_delay
        0     10   -> frame_delete
        0     10   -> printf
        0     16   -> printf
      0     12   MAC_setIV
        0     12   -> memcpy
      0     12   MAC_setKEY
        0     12   -> memcpy
      2      0   MG_Init
        2      0   -> AES_init
        2      0   -> CF_init
        2      0   -> DMA_init
        2      0   -> LLC_Init
        2      0   -> MAC_Init
        2      0   -> MAC_setIV
        2      0   -> MAC_setKEY
        2      0   -> NT_Init
        2      0   -> RI_init
        2      0   -> RXB_Init
        2      0   -> SY_Init
        2      0   -> SY_setIV
        2      0   -> SY_setKEY
        2      0   -> TIC_Init
        2      0   -> TIM_init
      0     16   MyLowLevelPutchar
      0     48   NT_GetTime
        0     16   -> ReadTimer
      0     15   NT_IRQEnable
      2      0   NT_Init
        2      0   -> NT_IRQEnable
      0     32   NT_SetCompare
        0     12   -> NT_IRQEnable
        0     12   -> calcCompareTime
        0     12   -> loadTimerCompare
        0     12   -> printf
        0     18   -> printf
      2      0   NT_SetEventCallback
      0     30   NT_SetTime
        0     14   -> NT_SetCompare
        0     14   -> ReadTimer
        0     14   -> isIRQEnable
        0     14   -> printf
        0     20   -> printf
      0     24   NT_WaitTime
      2      0   RI_GetCCAReject
      2      0   RI_GetCRCError
      2      0   RI_GetUptime
      1     27   RI_Measure_POW
        0     14   -> RI_cfg
        0     14   -> TIM_delay
      1     60   RI_Receive
        0     44   -> RI_cfg
        0     46   -> RecvData
        0     44   -> TIM_TimeStamp
        0     44   -> TIM_passedTime
        0     44   -> UnLoadRXData
        0     44   -> frame_addHeader
        0     44   -> frame_create
        0     44   -> re_free
        0     44   -> re_malloc
      0     62   RI_Send
        0     36   -> RI_cfg
        0     36   -> SendData
        0     36   -> TIM_TimeStamp
        0     36   -> TIM_passedTime
        0     36   -> printf
        0     42   -> printf
      2     44   RI_SetChannel
      3     45   RI_cfg
        2      1   -> setFreq
      2      0   RI_init
        2      0   -> random_core_init
      2      0   RXB_Callback
      2      0   RXB_Init
        2      0   -> LLC_SetRXCallback
        2      0   -> RXB_Reset
      0     19   RXB_Reset
        0      9   -> Delete_frame
      0     18   RXB_del_frame
        0     12   -> Delete_frame
        0     12   -> printf
        0     18   -> printf
      2     10   RXB_frame_count
      2     14   RXB_get_frame
      2     22   ReadTimer
      0     78   RecvData
        0     32   -> NT_GetTime
        0     32   -> TIM_TimeStamp
        0     32   -> TIM_passedTime
      0      0   STACK_FAILURE
      2     11   SY_Enable
      0     10   SY_Init
        0     10   -> TIC_SetSyncTimeAllocCallback
        0     10   -> TIC_SetTS1Callback
        0     10   -> TIC_SlotActivityTime
        0     10   -> TIC_SlotTime
      2     10   SY_Reset
      0     55   SY_SYNC_NETWORK
        0     44   -> RI_SetChannel
        0     44   -> TIC_CloseAllState
        0     44   -> TIC_GetTimer
        0     44   -> TIC_GetUptime
        0     44   -> TIC_SetRTC
        0     44   -> TIC_SetTimer
        0     44   -> TIM_TimeStamp
        0     44   -> TIM_passedTime
        0     44   -> frame_delete
        0     44   -> get_sync
      0     16   SY_TIME_ALLOC_MASTER
        0     16   -> TIC_GetTXState
        0     16   -> TIC_GetUptime
        0     16   -> TIC_SetTXState
      0     12   SY_TS1_HNDL_MASTER
        0     12   -> TIC_SetTXState
        0     12   -> send_sync
      0     12   SY_setIV
        0     12   -> memcpy
      0     12   SY_setKEY
        0     12   -> memcpy
      2      0   SY_sync_sended
      0     48   SendData
        0     12   -> LoadTXData
        0     12   -> NT_GetTime
        0     12   -> NT_WaitTime
      0     53   TIC_CloseAllState
        0      9   -> TIC_SetRXState
        0      9   -> TIC_SetTXState
      2      0   TIC_GetNonce
      2     20   TIC_GetRTC
      0     16   TIC_GetRXState
        0     10   -> printf
        0     16   -> printf
      0     32   TIC_GetTXState
        0     10   -> printf
        0     16   -> printf
      0      0   TIC_GetTimeStampTS0
      2     44   TIC_GetTimer
        2      0   -> NT_GetTime
      2     44   TIC_GetUptime
      0      9   TIC_HW_Timer_IRQ
        0      9   -> Callback_execution
        0      9   -> TIC_TDMAShelduler
        0      9   -> TIC_getCurrentTS
        0      9   -> TIM_TimeStamp
        0      9   -> clocks_update
      2      0   TIC_Init
        2      0   -> NT_SetCompare
        2      0   -> NT_SetEventCallback
        2      0   -> TIC_CloseAllState
        2      0   -> TIC_SetTimer
        2      0   -> TIM_TimeStamp
      2     10   TIC_Reset
        2      0   -> NT_SetCompare
        2      0   -> TIC_CloseAllState
        2      0   -> TIC_SetTimer
        2      0   -> TIM_TimeStamp
      0     12   TIC_SetNonce
      0     56   TIC_SetRTC
      0     26   TIC_SetRXCallback
        0     10   -> printf
        0     16   -> printf
      0     26   TIC_SetRXState
        0     10   -> printf
        0     16   -> printf
      0     16   TIC_SetSECallback
        0     10   -> printf
        0     16   -> printf
      0     26   TIC_SetSyncTimeAllocCallback
        0     10   -> printf
        0     16   -> printf
      0     26   TIC_SetTS1Callback
        0     10   -> printf
        0     16   -> printf
      0     26   TIC_SetTXCallback
        0     10   -> printf
        0     16   -> printf
      0     32   TIC_SetTXState
        0     10   -> printf
        0     16   -> printf
      0     60   TIC_SetTimer
        0     10   -> NT_SetTime
        0     10   -> printf
        0     16   -> printf
      0      0   TIC_SleepTime
      0     10   TIC_SlotActivityTime
      0     10   TIC_SlotTime
      3     10   TIC_TDMAShelduler
        2      1   -> incrementTS
        2      1   -> set_capture_time
      0     24   TIC_TimeUsFromTS0
        0     24   -> TIM_TimeStamp
        0     24   -> TIM_passedTime
      0     19   TIC_getCurrentTS
      3     44   TIM_TimeStamp
      0     14   TIM_copy
        0     14   -> memcpy
      0     76   TIM_delay
        0     36   -> Interval
        0     36   -> TIM_TimeStamp
      2      0   TIM_init
        2      0   -> DelayCalibrate
      0     62   TIM_passedTime
        0     18   -> Interval
      0     15   TimerCompareInterrupt
        0     15   -> NT_GetTime
        0     15   -> NT_IRQEnable
      3     44   UnLoadRXData
      0     18   __write
        0     16   -> MyLowLevelPutchar
      0      9   bits_count
      2     34   calcCompareTime
        0     22   -> ReadTimer
      0     13   check_cmd_frame
      0     21   clocks_update
      0     10   cmd_0x00
        0     10   -> cmd_answer
        0     10   -> get_network_seed_status
      0     12   cmd_0x01
        0     12   -> cmd_answer
        0     12   -> cmd_answer_err
        0     12   -> get_network_seed_status
      0     12   cmd_0x02
        0     12   -> TIC_SetRTC
        0     12   -> cmd_answer
        0     12   -> cmd_answer_err
        0     12   -> get_network_seed_status
      0     20   cmd_0x03
        0     14   -> cmd_answer
        0     14   -> cmd_answer_err
        0     14   -> neocore_stack_reset
        0     14   -> network_seed_enable
        0     14   -> printf
        0     20   -> printf
      0     16   cmd_0x04
        0     14   -> cmd_answer
        0     14   -> cmd_answer_err
        0     14   -> get_network_seed_status
        0     16   -> memcpy
      0     16   cmd_0x05
        0     14   -> cmd_answer
        0     14   -> cmd_answer_err
        0     14   -> get_network_seed_status
        0     16   -> memcpy
      0      9   cmd_0x06
        0      9   -> cmd_answer
        0      9   -> cmd_answer_err
      0     12   cmd_0x07
        0     12   -> MAC_OpenRXSlot
        0     12   -> cmd_answer
        0     12   -> cmd_answer_err
        0     12   -> get_network_seed_status
      0     12   cmd_0x08
        0     12   -> MAC_CloseRXSlot
        0     12   -> cmd_answer
        0     12   -> cmd_answer_err
        0     12   -> get_network_seed_status
      1     10   cmd_0x09
        0     10   -> RXB_frame_count
        0     10   -> cmd_answer
        0     10   -> cmd_answer_err
      1     10   cmd_0x0A
        0     10   -> LLC_GetTaskLen
        0     10   -> cmd_answer
        0     10   -> cmd_answer_err
      0     18   cmd_0x0B
        0     16   -> LLC_AddTask
        0     16   -> cmd_answer
        0     16   -> cmd_answer_err
        0     16   -> frame_addHeader
        0     16   -> frame_create
        0     16   -> get_network_seed_status
        0     18   -> re_memcpy
      0     14   cmd_0x0C
        0     14   -> RXB_get_frame
        0     14   -> cmd_answer_err
        0     14   -> get_network_seed_status
        0     14   -> upload_frame
      0     13   cmd_0x0D
        0     13   -> RI_Measure_POW
        0     13   -> cmd_answer
        0     13   -> cmd_answer_err
        0     13   -> get_network_seed_status
      0     12   cmd_0x0E
        0     12   -> cmd_answer
        0     12   -> cmd_answer_err
        0     12   -> get_network_seed_status
      1    179   cmd_answer
        0     18   -> crc16
        0     18   -> uart_write
      1     27   cmd_answer_err
        0     11   -> stream_write
      0      9   com_uart_init
        0      9   -> uart_dma_init
      0     27   crc16
      0     34   extract_header
        0     14   -> frame_len
        0     14   -> printf
        0     20   -> printf
        0     14   -> re_malloc
      1     68   frame_addHeader
        0     18   -> printf
        0     24   -> printf
        0     18   -> re_free
        0     18   -> re_malloc
        0     20   -> re_memcpy
      0     62   frame_create
        0     14   -> memset
        0     12   -> printf
        0     18   -> printf
        0     12   -> re_malloc
      1     20   frame_delHeader
        0     14   -> printf
        0     20   -> printf
        0     14   -> re_free
        0     14   -> re_malloc
        0     16   -> re_memcpy
      0     54   frame_delete
        0     10   -> re_free
      2     10   frame_getCount
      2     14   frame_len
      0     19   free
        0      9   -> __xdata_free
      0     86   generateAuthData
        0     18   -> memcpy
      2      9   getRNDByte
      2     16   get_network_seed_status
      0     56   get_sync
        0     12   -> BitRawDecrypt
        0     12   -> RI_Receive
        0     12   -> RI_SetChannel
        0     12   -> frame_delete
      0     14   heap_ptr
        0     14   -> re_free
        0     14   -> re_malloc
      2      1   incrementTS
      0     14   isIRQEnable
      0     28   loadTimerCompare
      0      0   main
        0      0   -> com_uart_init
        0      0   -> neocore_hw_init
        0      0   -> network_seed_enable
        0      0   -> parse_uart_stream
      0     23   malloc
        0      9   -> __xdata_malloc
      2      0   neocore_hw_init
        2      0   -> MG_Init
      0     30   neocore_stack_reset
        0     10   -> LLC_Reset
        0     10   -> MAC_Reset
        0     10   -> RXB_Reset
        0     10   -> SY_Reset
        0     10   -> TIC_Reset
        0     10   -> frame_getCount
        0     10   -> network_seed_enable
        0     10   -> printf
        0     16   -> printf
      0     11   network_discovery
        0     11   -> MAC_Enable
        0     11   -> SY_Enable
        0     11   -> SY_SYNC_NETWORK
      0     23   network_seed_enable
        0      9   -> MAC_Enable
        0      9   -> SY_Enable
      2      0   nwDebugerInit
        2      0   -> uart_init
      0     13   parse_uart_stream
        0     13   -> check_cmd_frame
        0     13   -> cmd_answer_err
        0     13   -> uart_recv_cmd
      0      9   random_core_init
        0      9   -> RI_cfg
        0      9   -> rand
        0      9   -> readRandom
        0      9   -> srand
      0     54   re_free
        0     10   -> free
      0     58   re_malloc
        0     14   -> malloc
      0    179   re_memcpy
        0     16   -> memcpy
      0     18   readRandom
        0      9   -> bits_count
        0      9   -> getRNDByte
      0     14   send_ack
      0     32   send_sync
        0     20   -> BitRawCrypt
        0     20   -> RI_Send
        0     20   -> RI_SetChannel
        0     20   -> TIC_GetRTC
        0     20   -> frame_addHeader
        0     20   -> frame_create
        0     20   -> frame_delete
      1     18   setFreq
        0     11   -> printf
        0     17   -> printf
      0     10   set_capture_time
        0      9   -> NT_SetCompare
      1     32   stream_write
        0     15   -> crc16
        0     15   -> printf
        0     21   -> printf
        0     15   -> uart_write
      0     14   strip_header
      2      9   uart_dma_init
      0      0   uart_getchar
      0      0   uart_init
      0     10   uart_putchar
      3     13   uart_recv_cmd
      0     28   uart_write
        0     10   -> uart_putchar
      1    177   upload_frame
        0    161   -> cmd_answer
        0    163   -> re_memcpy
      0     14   validate
      0     23   xor_calc


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
      22  ?<Constant "*ASSERT* %s:%d:%s -> ">
      22  ?<Constant "*ASSERT* %s:%d:%s -> ">_1
      22  ?<Constant "*ASSERT* %s:%d:%s -> ">_10
      22  ?<Constant "*ASSERT* %s:%d:%s -> ">_2
      22  ?<Constant "*ASSERT* %s:%d:%s -> ">_3
      22  ?<Constant "*ASSERT* %s:%d:%s -> ">_4
      22  ?<Constant "*ASSERT* %s:%d:%s -> ">_5
      22  ?<Constant "*ASSERT* %s:%d:%s -> ">_6
      22  ?<Constant "*ASSERT* %s:%d:%s -> ">_7
      22  ?<Constant "*ASSERT* %s:%d:%s -> ">_8
      22  ?<Constant "*ASSERT* %s:%d:%s -> ">_9
      42  ?<Constant "E:\\WMNU\\IAR\\NEOCOREGA...">
      44  ?<Constant "E:\\WMNU\\IAR\\NEOCOREGA...">_1
      37  ?<Constant "E:\\WMNU\\IAR\\SHARE_PRJ...">
      34  ?<Constant "E:\\WMNU\\IAR\\SHARE_PRJ...">_1
      32  ?<Constant "E:\\WMNU\\IAR\\SHARE_PRJ...">_2
      32  ?<Constant "E:\\WMNU\\IAR\\SHARE_PRJ...">_3
      36  ?<Constant "E:\\WMNU\\IAR\\SHARE_PRJ...">_4
      33  ?<Constant "E:\\WMNU\\IAR\\SHARE_PRJ...">_5
      34  ?<Constant "E:\\WMNU\\IAR\\SHARE_PRJ...">_6
      36  ?<Constant "E:\\WMNU\\IAR\\SHARE_PRJ...">_7
      32  ?<Constant "E:\\WMNU\\IAR\\SHARE_PRJ...">_8
       3  ?<Constant "\r\n">
       3  ?<Constant "\r\n">_1
       3  ?<Constant "\r\n">_10
       3  ?<Constant "\r\n">_2
       3  ?<Constant "\r\n">_3
       3  ?<Constant "\r\n">_4
       3  ?<Constant "\r\n">_5
       3  ?<Constant "\r\n">_6
       3  ?<Constant "\r\n">_7
       3  ?<Constant "\r\n">_8
       3  ?<Constant "\r\n">_9
      22  ?<Initializer for <Constant "*ASSERT* %s:%d:%s
      22  ?<Initializer for <Constant "*ASSERT* %s:%d:%s_1
      22  ?<Initializer for <Constant "*ASSERT* %s:%d:%s_10
      22  ?<Initializer for <Constant "*ASSERT* %s:%d:%s_2
      22  ?<Initializer for <Constant "*ASSERT* %s:%d:%s_3
      22  ?<Initializer for <Constant "*ASSERT* %s:%d:%s_4
      22  ?<Initializer for <Constant "*ASSERT* %s:%d:%s_5
      22  ?<Initializer for <Constant "*ASSERT* %s:%d:%s_6
      22  ?<Initializer for <Constant "*ASSERT* %s:%d:%s_7
      22  ?<Initializer for <Constant "*ASSERT* %s:%d:%s_8
      22  ?<Initializer for <Constant "*ASSERT* %s:%d:%s_9
      42  ?<Initializer for <Constant "E:\\WMNU\\IAR\\NE
      44  ?<Initializer for <Constant "E:\\WMNU\\IAR\\NE_1
      37  ?<Initializer for <Constant "E:\\WMNU\\IAR\\SH
      34  ?<Initializer for <Constant "E:\\WMNU\\IAR\\SH_1
      32  ?<Initializer for <Constant "E:\\WMNU\\IAR\\SH_2
      32  ?<Initializer for <Constant "E:\\WMNU\\IAR\\SH_3
      36  ?<Initializer for <Constant "E:\\WMNU\\IAR\\SH_4
      33  ?<Initializer for <Constant "E:\\WMNU\\IAR\\SH_5
      34  ?<Initializer for <Constant "E:\\WMNU\\IAR\\SH_6
      36  ?<Initializer for <Constant "E:\\WMNU\\IAR\\SH_7
      32  ?<Initializer for <Constant "E:\\WMNU\\IAR\\SH_8
       3  ?<Initializer for <Constant "\r\n">>
       3  ?<Initializer for <Constant "\r\n">>_1
       3  ?<Initializer for <Constant "\r\n">>_10
       3  ?<Initializer for <Constant "\r\n">>_2
       3  ?<Initializer for <Constant "\r\n">>_3
       3  ?<Initializer for <Constant "\r\n">>_4
       3  ?<Initializer for <Constant "\r\n">>_5
       3  ?<Initializer for <Constant "\r\n">>_6
       3  ?<Initializer for <Constant "\r\n">>_7
       3  ?<Initializer for <Constant "\r\n">>_8
       3  ?<Initializer for <Constant "\r\n">>_9
      30  ?<Initializer for CMD_LIST>
      16  ?<Initializer for IV>
      16  ?<Initializer for IV>_1
      16  ?<Initializer for KEY>
      16  ?<Initializer for KEY>_1
       4  ?<Initializer for MAC_TIMER_MAX>
       4  ?<Initializer for __Constant_15180>
       4  ?<Initializer for __Constant_19833891>
       4  ?<Initializer for __Constant_1>
       4  ?<Initializer for __Constant_1f4>
       4  ?<Initializer for __Constant_20>
       4  ?<Initializer for __Constant_3d000000>
       4  ?<Initializer for __Constant_3e8>
       4  ?<Initializer for __Constant_447a0000>
       4  ?<Initializer for __Constant_7fff>
       4  ?<Initializer for __Constant_8000>
       4  ?<Initializer for __Constant_9>
       4  ?<Initializer for __Constant_a>
       4  ?<Initializer for __Constant_ffff8000>
       4  ?<Initializer for __Constant_fffffe0c>
       4  ?<Initializer for __Constant_ffffff>
       9  ?<Initializer for __FUNCTION__>
      13  ?<Initializer for __FUNCTION__>_1
      12  ?<Initializer for __FUNCTION__>_10
      14  ?<Initializer for __FUNCTION__>_11
      12  ?<Initializer for __FUNCTION__>_12
      15  ?<Initializer for __FUNCTION__>_13
      16  ?<Initializer for __FUNCTION__>_14
       9  ?<Initializer for __FUNCTION__>_15
      15  ?<Initializer for __FUNCTION__>_16
      15  ?<Initializer for __FUNCTION__>_17
      12  ?<Initializer for __FUNCTION__>_18
      12  ?<Initializer for __FUNCTION__>_19
      19  ?<Initializer for __FUNCTION__>_2
      20  ?<Initializer for __FUNCTION__>_20
      11  ?<Initializer for __FUNCTION__>_21
      14  ?<Initializer for __FUNCTION__>_22
       8  ?<Initializer for __FUNCTION__>_23
       8  ?<Initializer for __FUNCTION__>_24
      14  ?<Initializer for __FUNCTION__>_25
      13  ?<Initializer for __FUNCTION__>_26
      13  ?<Initializer for __FUNCTION__>_27
      15  ?<Initializer for __FUNCTION__>_28
      15  ?<Initializer for __FUNCTION__>_29
      12  ?<Initializer for __FUNCTION__>_3
      15  ?<Initializer for __FUNCTION__>_30
      15  ?<Initializer for __FUNCTION__>_31
      19  ?<Initializer for __FUNCTION__>_32
      18  ?<Initializer for __FUNCTION__>_33
      29  ?<Initializer for __FUNCTION__>_34
      18  ?<Initializer for __FUNCTION__>_35
      18  ?<Initializer for __FUNCTION__>_36
      19  ?<Initializer for __FUNCTION__>_37
      15  ?<Initializer for __FUNCTION__>_4
      16  ?<Initializer for __FUNCTION__>_5
      16  ?<Initializer for __FUNCTION__>_6
      13  ?<Initializer for __FUNCTION__>_7
      18  ?<Initializer for __FUNCTION__>_8
      14  ?<Initializer for __FUNCTION__>_9
      16  ?<Initializer for default_iv>
      16  ?<Initializer for default_key>
     476  AES_CCMDecrypt
       6  AES_CCMDecrypt::?relay
     446  AES_CCMEncrypt
       6  AES_CCMEncrypt::?relay
     608  AES_StreamCoder
       6  AES_StreamCoder::?relay
     205  AES_init
       6  AES_init::?relay
      58  BitRawCrypt
      58  BitRawCrypt
       6  BitRawCrypt::?relay
       6  BitRawCrypt::?relay
      58  BitRawDecrypt
      58  BitRawDecrypt
       6  BitRawDecrypt::?relay
       6  BitRawDecrypt::?relay
     469  CBCMAC_buf_encrypt
       6  CBCMAC_buf_encrypt::?relay
      88  CF_init
       6  CF_init::?relay
       1  CLKCONCMD
       1  CLKCONSTA
      30  CMD_LIST
       4  COMPARE_TIME
      36  CONFIG
     608  CTR_enc_decrypt
       6  CTR_enc_decrypt::?relay
      87  Callback_execution
       6  Callback_execution::?relay
       4  DELAY_CALIBRATE_TICS
       1  DMA0CFGH
       1  DMA0CFGL
       1  DMA1CFGH
       1  DMA1CFGL
       1  DMAARM
       1  DMAREQ
      40  DMA_CH
      37  DMA_init
       6  DMA_init::?relay
     147  DelayCalibrate
       6  DelayCalibrate::?relay
     201  Delete_frame
       6  Delete_frame::?relay
       1  ENCCS
      28  ETH_Init
       6  ETH_Init::?relay
     319  ETH_RX_HNDL
       6  ETH_RX_HNDL::?relay
      80  ETH_Set_RXCallback
       6  ETH_Set_RXCallback::?relay
       2  EventCallback
      20  FRAME_POOL
       2  FirstTask
       4  HeadAllocFunc
      16  IV
      16  IV
     163  Interval
       6  Interval::?relay
      16  KEY
      16  KEY
       4  LAST_SYNC_TIME
     310  LLC_AddTask
       6  LLC_AddTask::?relay
      16  LLC_GetTaskLen
       6  LLC_GetTaskLen::?relay
      47  LLC_Init
       6  LLC_Init::?relay
      98  LLC_RX_HNDL
       6  LLC_RX_HNDL::?relay
      43  LLC_Reset
       6  LLC_Reset::?relay
      67  LLC_RunTimeAlloc
       6  LLC_RunTimeAlloc::?relay
      20  LLC_SE_HNDL
       6  LLC_SE_HNDL::?relay
      80  LLC_SetRXCallback
       6  LLC_SetRXCallback::?relay
     317  LLC_Shelduler
       6  LLC_Shelduler::?relay
     148  LLC_TimeAlloc
       6  LLC_TimeAlloc::?relay
      50  LoadTXData
       6  LoadTXData::?relay
     350  MACSlotTable
     111  MAC_ACK_Recv
       6  MAC_ACK_Recv::?relay
      91  MAC_ACK_Send
       6  MAC_ACK_Send::?relay
     124  MAC_CloseRXSlot
       6  MAC_CloseRXSlot::?relay
       1  MAC_ENABLE_MODULE
      23  MAC_Enable
       6  MAC_Enable::?relay
     113  MAC_GetRXState
       6  MAC_GetRXState::?relay
     113  MAC_GetTXState
       6  MAC_GetTXState::?relay
      57  MAC_Init
       6  MAC_Init::?relay
     167  MAC_OpenRXSlot
       6  MAC_OpenRXSlot::?relay
     195  MAC_RX_HNDL
       6  MAC_RX_HNDL::?relay
     135  MAC_Reset
       6  MAC_Reset::?relay
     422  MAC_Send
       6  MAC_Send::?relay
      19  MAC_SetRXCallback
       6  MAC_SetRXCallback::?relay
       4  MAC_TIMER_MAX
     595  MAC_TX_HNDL
       6  MAC_TX_HNDL::?relay
      41  MAC_setIV
       6  MAC_setIV::?relay
      41  MAC_setKEY
       6  MAC_setKEY::?relay
      78  MG_Init
       6  MG_Init::?relay
       1  MG_MODULES_INITED
      12  MyLowLevelPutchar
       6  MyLowLevelPutchar::?relay
       1  NBR_FRAME
       1  NETWORK_SEED
       4  NEXT_SYNC_TIME
       4  NODE_NONCE
       4  NODE_RTC
       4  NODE_UPTIME
      55  NT_GetTime
       6  NT_GetTime::?relay
      19  NT_IRQEnable
       6  NT_IRQEnable::?relay
      74  NT_Init
       6  NT_Init::?relay
     129  NT_SetCompare
       6  NT_SetCompare::?relay
      19  NT_SetEventCallback
       6  NT_SetEventCallback::?relay
     156  NT_SetTime
       6  NT_SetTime::?relay
     126  NT_WaitTime
       6  NT_WaitTime::?relay
       1  P0SEL
       1  P1SEL
       1  PERCFG
       3  RADIO_CFG
       1  RFD
       1  RFIRQF0
       1  RFIRQF1
       1  RFST
       4  RI_CCA_REJECT
       4  RI_CRC_ERROR
      17  RI_GetCCAReject
       6  RI_GetCCAReject::?relay
      17  RI_GetCRCError
       6  RI_GetCRCError::?relay
      17  RI_GetUptime
       6  RI_GetUptime::?relay
     117  RI_Measure_POW
       6  RI_Measure_POW::?relay
     535  RI_Receive
       6  RI_Receive::?relay
     216  RI_Send
       6  RI_Send::?relay
      32  RI_SetChannel
       6  RI_SetChannel::?relay
       4  RI_UPTIME
     109  RI_cfg
       6  RI_cfg::?relay
      32  RI_init
       6  RI_init::?relay
     116  RXB_Callback
       6  RXB_Callback::?relay
      21  RXB_Init
       6  RXB_Init::?relay
      26  RXB_Reset
       6  RXB_Reset::?relay
     162  RXB_del_frame
       6  RXB_del_frame::?relay
      69  RXB_frame_count
       6  RXB_frame_count::?relay
     116  RXB_get_frame
       6  RXB_get_frame::?relay
       2  RXCallback
       2  RXCallback
       2  RXCallback
       2  RXCallback
      59  ReadTimer
       6  ReadTimer::?relay
     152  RecvData
       6  RecvData::?relay
       2  SECallback
       1  SLEEPSTA
       1  ST0
       1  ST1
       1  ST2
       2  STACK_FAILURE
       6  STACK_FAILURE::?relay
       1  STLOAD
       2  SYNC_ACCURATE_NETWORK_TIME
       4  SYNC_SENDED
       1  SY_ENABLE_MODULE
      23  SY_Enable
       6  SY_Enable::?relay
     121  SY_Init
       6  SY_Init::?relay
      71  SY_Reset
       6  SY_Reset::?relay
     501  SY_SYNC_NETWORK
       6  SY_SYNC_NETWORK::?relay
      99  SY_TIME_ALLOC_MASTER
       6  SY_TIME_ALLOC_MASTER::?relay
      48  SY_TS1_HNDL_MASTER
       6  SY_TS1_HNDL_MASTER::?relay
      41  SY_setIV
       6  SY_setIV::?relay
      41  SY_setKEY
       6  SY_setKEY::?relay
      17  SY_sync_sended
       6  SY_sync_sended::?relay
     159  SendData
       6  SendData::?relay
       2  SyncTimeAllocCallback
       1  T2CTRL
       1  T2M0
       1  T2M1
       1  T2MOVF0
       1  T2MOVF1
      35  TIC_CloseAllState
       6  TIC_CloseAllState::?relay
      17  TIC_GetNonce
       6  TIC_GetNonce::?relay
      17  TIC_GetRTC
       6  TIC_GetRTC::?relay
      98  TIC_GetRXState
       6  TIC_GetRXState::?relay
      98  TIC_GetTXState
       6  TIC_GetTXState::?relay
       7  TIC_GetTimeStampTS0
       6  TIC_GetTimeStampTS0::?relay
      14  TIC_GetTimer
       6  TIC_GetTimer::?relay
      17  TIC_GetUptime
       6  TIC_GetUptime::?relay
     198  TIC_HW_Timer_IRQ
       6  TIC_HW_Timer_IRQ::?relay
      42  TIC_Init
       6  TIC_Init::?relay
      89  TIC_Reset
       6  TIC_Reset::?relay
      26  TIC_SetNonce
       6  TIC_SetNonce::?relay
      40  TIC_SetRTC
       6  TIC_SetRTC::?relay
      80  TIC_SetRXCallback
       6  TIC_SetRXCallback::?relay
     128  TIC_SetRXState
       6  TIC_SetRXState::?relay
      80  TIC_SetSECallback
       6  TIC_SetSECallback::?relay
      80  TIC_SetSyncTimeAllocCallback
       6  TIC_SetSyncTimeAllocCallback::?relay
      80  TIC_SetTS1Callback
       6  TIC_SetTS1Callback::?relay
      80  TIC_SetTXCallback
       6  TIC_SetTXCallback::?relay
     128  TIC_SetTXState
       6  TIC_SetTXState::?relay
      93  TIC_SetTimer
       6  TIC_SetTimer::?relay
       7  TIC_SleepTime
       6  TIC_SleepTime::?relay
       7  TIC_SlotActivityTime
       6  TIC_SlotActivityTime::?relay
      28  TIC_SlotTime
       6  TIC_SlotTime::?relay
      92  TIC_TDMAShelduler
       6  TIC_TDMAShelduler::?relay
      66  TIC_TimeUsFromTS0
       6  TIC_TimeUsFromTS0::?relay
      61  TIC_getCurrentTS
       6  TIC_getCurrentTS::?relay
      61  TIM_TimeStamp
       6  TIM_TimeStamp::?relay
      45  TIM_copy
       6  TIM_copy::?relay
     133  TIM_delay
       6  TIM_delay::?relay
      17  TIM_init
       6  TIM_init::?relay
      94  TIM_passedTime
       6  TIM_passedTime::?relay
       2  TOFFSET
       2  TS1Callback
      50  TSStateTable
       2  TXCallback
       8  TimeStampTS0
      60  TimerCompareInterrupt
       3  TimerCompareInterrupt::??INTVEC 43
       1  U0BAUD
       1  U0CSR
       1  U0DBUF
       1  U0GCR
       1  U1BAUD
       1  U1DBUF
       1  U1GCR
      40  UnLoadRXData
       6  UnLoadRXData::?relay
       1  _A_IEN0
       1  _A_IRCON
       1  _A_P1
       1  _A_U1CSR
       4  __Constant_1
       4  __Constant_15180
       4  __Constant_19833891
       4  __Constant_1f4
       4  __Constant_20
       4  __Constant_3d000000
       4  __Constant_3e8
       4  __Constant_447a0000
       4  __Constant_7fff
       4  __Constant_8000
       4  __Constant_9
       4  __Constant_a
       4  __Constant_ffff8000
       4  __Constant_fffffe0c
       4  __Constant_ffffff
     156  __write
       6  __write::?relay
      34  bits_count
       6  bits_count::?relay
     162  buf
     189  calcCompareTime
       6  calcCompareTime::?relay
      13  check_cmd_frame
       6  check_cmd_frame::?relay
      94  clocks_update
       6  clocks_update::?relay
      63  cmd_0x00
       6  cmd_0x00::?relay
      77  cmd_0x01
       6  cmd_0x01::?relay
      76  cmd_0x02
       6  cmd_0x02::?relay
     189  cmd_0x03
       6  cmd_0x03::?relay
      91  cmd_0x04
       6  cmd_0x04::?relay
      91  cmd_0x05
       6  cmd_0x05::?relay
      44  cmd_0x06
       6  cmd_0x06::?relay
      79  cmd_0x07
       6  cmd_0x07::?relay
      72  cmd_0x08
       6  cmd_0x08::?relay
      69  cmd_0x09
       6  cmd_0x09::?relay
      69  cmd_0x0A
       6  cmd_0x0A::?relay
     239  cmd_0x0B
       6  cmd_0x0B::?relay
      84  cmd_0x0C
       6  cmd_0x0C::?relay
     103  cmd_0x0D
       6  cmd_0x0D::?relay
      72  cmd_0x0E
       6  cmd_0x0E::?relay
     104  cmd_answer
       6  cmd_answer::?relay
      56  cmd_answer_err
       6  cmd_answer_err::?relay
      34  com_uart_init
       6  com_uart_init::?relay
      93  crc16
       6  crc16::?relay
      16  default_iv
      16  default_key
     162  extract_header
       6  extract_header::?relay
     367  frame_addHeader
       6  frame_addHeader::?relay
     168  frame_create
       6  frame_create::?relay
     215  frame_delHeader
       6  frame_delHeader::?relay
      71  frame_delete
       6  frame_delete::?relay
      16  frame_getCount
       6  frame_getCount::?relay
      19  frame_len
       6  frame_len::?relay
      21  free
       6  free::?relay
     241  generateAuthData
       6  generateAuthData::?relay
      53  getRNDByte
       6  getRNDByte::?relay
      17  get_network_seed_status
       6  get_network_seed_status::?relay
      95  get_sync
       6  get_sync::?relay
      56  heap_ptr
       6  heap_ptr::?relay
      36  incrementTS
       6  incrementTS::?relay
      11  isIRQEnable
       6  isIRQEnable::?relay
      70  loadTimerCompare
       6  loadTimerCompare::?relay
      17  main
       6  main::?relay
      21  malloc
       6  malloc::?relay
       1  nbrTasks
      26  neocore_hw_init
       6  neocore_hw_init::?relay
      99  neocore_stack_reset
       6  neocore_stack_reset::?relay
      65  network_discovery
       6  network_discovery::?relay
      52  network_seed_enable
       6  network_seed_enable::?relay
      14  nwDebugerInit
       6  nwDebugerInit::?relay
       2  pACK
     148  parse_uart_stream
       6  parse_uart_stream::?relay
      78  random_core_init
       6  random_core_init::?relay
      35  re_free
       6  re_free::?relay
      49  re_malloc
       6  re_malloc::?relay
      65  re_memcpy
       6  re_memcpy::?relay
      54  readRandom
       6  readRandom::?relay
       4  ret_val
       3  send_ack
       6  send_ack::?relay
     161  send_sync
       6  send_sync::?relay
     120  setFreq
       6  setFreq::?relay
      40  set_capture_time
       6  set_capture_time::?relay
     156  stream_write
       6  stream_write::?relay
       3  strip_header
       6  strip_header::?relay
       4  sync_send_time
       1  tasksBLOCK
     132  uart_dma_init
       6  uart_dma_init::?relay
       9  uart_getchar
       6  uart_getchar::?relay
      23  uart_init
       6  uart_init::?relay
       9  uart_putchar
       6  uart_putchar::?relay
      41  uart_recv_cmd
       6  uart_recv_cmd::?relay
     255  uart_rx_buff
      48  uart_write
       6  uart_write::?relay
     137  upload_frame
       6  upload_frame::?relay
       4  val
       4  validate
       6  validate::?relay
      59  xor_calc
       6  xor_calc::?relay
     559  -- Other

 
 18 816 bytes in segment BANKED_CODE
  1 098 bytes in segment BANK_RELAYS
      3 bytes in segment INTVEC
     60 bytes in segment NEAR_CODE
     37 bytes in segment SFR_AN
  1 416 bytes in segment XDATA_I
  1 416 bytes in segment XDATA_ID
  1 017 bytes in segment XDATA_Z
 
  2 496 bytes of CODE     memory (+ 81 bytes shared)
      0 bytes of DATA     memory (+ 37 bytes shared)
 18 772 bytes of HUGECODE memory (+ 44 bytes shared)
  2 373 bytes of XDATA    memory (+ 60 bytes shared)

Errors: none
Warnings: 8
