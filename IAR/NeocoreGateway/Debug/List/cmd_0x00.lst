###############################################################################
#
# IAR C/C++ Compiler V10.10.1.4655 for 8051               01/Feb/2020  17:32:42
# Copyright 2004-2017 IAR Systems AB.
# PC-locked license - IAR Embedded Workbench for 8051
#
#    Core               =  plain
#    Code model         =  banked
#    Data model         =  large
#    Calling convention =  xdata reentrant
#    Constant location  =  data
#    Dptr setup         =  1,16
#                          
#    Source file        =  E:\WMNU\IAR\NeocoreGateway\src\cmd_0x00.c
#    Command line       =  
#        -f C:\Users\08A4~1\AppData\Local\Temp\EW8010.tmp
#        (E:\WMNU\IAR\NeocoreGateway\src\cmd_0x00.c -lcN
#        E:\WMNU\IAR\NeocoreGateway\Debug\List -o
#        E:\WMNU\IAR\NeocoreGateway\Debug\Obj -e --debug --core=plain
#        --dptr=16,1 --data_model=large --code_model=banked
#        --calling_convention=xdata_reentrant --place_constants=data
#        --nr_virtual_regs 8 --dlib_config "C:\Program Files (x86)\IAR
#        Systems\Embedded Workbench 8.0\8051\LIB\DLIB\dl8051Normal.h" -I
#        E:\WMNU\IAR\SHARE_PRJ_SRC\ -On --no_cse --no_unroll --no_inline
#        --no_code_motion --no_tbaa --no_cross_call --mfc
#        E:\WMNU\IAR\NeocoreGateway\src\cmd_0x01.c
#        E:\WMNU\IAR\NeocoreGateway\src\cmd_0x02.c
#        E:\WMNU\IAR\NeocoreGateway\src\cmd_0x03.c
#        E:\WMNU\IAR\NeocoreGateway\src\cmd_0x04.c
#        E:\WMNU\IAR\NeocoreGateway\src\cmd_0x05.c
#        E:\WMNU\IAR\NeocoreGateway\src\cmd_0x06.c
#        E:\WMNU\IAR\NeocoreGateway\src\cmd_0x07.c
#        E:\WMNU\IAR\NeocoreGateway\src\cmd_0x08.c
#        E:\WMNU\IAR\NeocoreGateway\src\cmd_0x09.c
#        E:\WMNU\IAR\NeocoreGateway\src\cmd_0x0A.c
#        E:\WMNU\IAR\NeocoreGateway\src\cmd_0x0B.c
#        E:\WMNU\IAR\NeocoreGateway\src\cmd_0x0C.c
#        E:\WMNU\IAR\NeocoreGateway\src\cmd_0x0D.c
#        E:\WMNU\IAR\NEOCOREGATEWAY\src\cmd_0x0E.c
#        E:\WMNU\IAR\NEOCOREGATEWAY\src\cmd_0x0F.c
#        E:\WMNU\IAR\NEOCOREGATEWAY\src\cmd_0x10.c
#        E:\WMNU\IAR\NEOCOREGATEWAY\src\cmd_parser.c
#        E:\WMNU\IAR\SHARE_PRJ_SRC\coder.c E:\WMNU\IAR\SHARE_PRJ_SRC\config.c
#        E:\WMNU\IAR\SHARE_PRJ_SRC\delays.c E:\WMNU\IAR\SHARE_PRJ_SRC\dma.c
#        E:\WMNU\IAR\SHARE_PRJ_SRC\frame.c E:\WMNU\IAR\SHARE_PRJ_SRC\LLC.c
#        E:\WMNU\IAR\SHARE_PRJ_SRC\MAC.c E:\WMNU\IAR\NeocoreGateway\src\main.c
#        E:\WMNU\IAR\SHARE_PRJ_SRC\manager.c E:\WMNU\IAR\SHARE_PRJ_SRC\mem.c
#        E:\WMNU\IAR\SHARE_PRJ_SRC\NTMR.c E:\WMNU\IAR\SHARE_PRJ_SRC\nwdebuger.c
#        E:\WMNU\IAR\SHARE_PRJ_SRC\RADIO.c E:\WMNU\IAR\SHARE_PRJ_SRC\rx_buff.c
#        E:\WMNU\IAR\SHARE_PRJ_SRC\sync.c E:\WMNU\IAR\SHARE_PRJ_SRC\TIC.c
#        E:\WMNU\IAR\NeocoreGateway\src\uart_comm.c)
#    Locale             =  Russian_Russia.1251
#    List file          =  E:\WMNU\IAR\NeocoreGateway\Debug\List\cmd_0x00.lst
#    Object file        =  E:\WMNU\IAR\NeocoreGateway\Debug\Obj\cmd_0x00.r51
#
###############################################################################

E:\WMNU\IAR\NeocoreGateway\src\cmd_0x00.c
      1          #include "stdint.h"
      2          #include "cmd_parser.h"
      3          #include "manager.h"
      4          #include "nwdebuger.h"
      5          
      6          enum {NET_NOSEEDING = 0, NET_SEEDING = 1};
      7          
      8          
      9          /**
     10          @brief Статус приемника
     11          @detail Возвращает true, если идет раздача сети
     12          */
     13          bool cmd_0x00(uint8_t *cmd, uint8_t size)
     14          {
     15            uint8_t answer;
     16            
     17            if (get_network_seed_status()){
     18              answer = NET_SEEDING;
     19              LOG_ON("CMD 0x00. Seeding");
     20            }
     21            else{
     22              answer = NET_NOSEEDING;
     23              LOG_ON("CMD 0x00. No seeding");
     24            }
     25              
     26            cmd_answer(ATYPE_CMD_OK, &answer, sizeof(answer));
     27            return true;
     28          }
E:\WMNU\IAR\NeocoreGateway\src\cmd_0x01.c
      1          #include "stdint.h"
      2          #include "cmd_parser.h"
      3          #include "manager.h"
      4          #include "config.h"
      5          #include "nwdebuger.h"
      6          
      7          #define ARGS_SIZE sizeof(cmd_args_s)
      8          typedef struct //!< Аргументы команды
      9          {
     10            uint8_t panid;
     11            uint16_t crc16;
     12          } cmd_args_s;
     13          
     14          /**
     15          @brief Установить panid
     16          */
     17          bool cmd_0x01(uint8_t *cmd, uint8_t size)
     18          {
     19            if (size != ARGS_SIZE){ // Размер аргументов не верен
     20              cmd_answer_err(ATYPE_CMD_ERR, CMD_LEN);
     21              return false;
     22            }
     23              
     24            if (get_network_seed_status()){ // Сеть активна и менять ничего нельзя
     25              cmd_answer_err(ATYPE_CMD_ERR, CMD_SEEDING);
     26              return false;
     27            }
     28            
     29            cmd_args_s *args = (cmd_args_s*)cmd; // Извлекаем аргументы
     30            
     31            CONFIG.panid =args->panid;
     32            LOG_ON("CMD 0x01. Set panid");
     33            
     34            cmd_answer(ATYPE_CMD_OK, NULL, 0);
     35            return true;
     36          }
E:\WMNU\IAR\NeocoreGateway\src\cmd_0x02.c
      1          #include "stdint.h"
      2          #include "cmd_parser.h"
      3          #include "manager.h"
      4          #include "config.h"
      5          #include "TIC.h"
      6          #include "nwdebuger.h"
      7          
      8          #define ARGS_SIZE sizeof(cmd_args_s)
      9          typedef struct //!< Аргументы команды
     10          {
     11            uint32_t RTC;
     12            uint16_t crc16;
     13          } cmd_args_s;
     14          
     15          
     16          /**
     17          @brief Установить RTC
     18          */
     19          bool cmd_0x02(uint8_t *cmd, uint8_t size)
     20          {
     21            
     22            if (size != ARGS_SIZE){ // Размер аргументов не верен
     23              cmd_answer_err(ATYPE_CMD_ERR, CMD_LEN);
     24              return false;
     25            }
     26            
     27            if (get_network_seed_status()){ // Сеть активна и менять ничего нельзя
     28              cmd_answer_err(ATYPE_CMD_ERR, CMD_SEEDING);
     29              return false;
     30            }
     31            
     32            cmd_args_s *args = (cmd_args_s*)cmd; // Извлекаем аргументы
     33            
     34            TIC_SetRTC(args->RTC);
     35            
     36            cmd_answer(ATYPE_CMD_OK, NULL, 0);
     37            return true;
     38          }
E:\WMNU\IAR\NeocoreGateway\src\cmd_0x03.c
      1          #include "stdint.h"
      2          #include "cmd_parser.h"
      3          #include "manager.h"
      4          #include "config.h"
      5          #include "nwdebuger.h"
      6          
      7          #define ARGS_SIZE sizeof(cmd_args_s)
      8          typedef struct //!< Аргументы команды
      9          {
     10            bool on_off;
     11            uint16_t crc16;
     12          } cmd_args_s;
     13          
     14          /**
     15          @brief Включить или выключить сеть. true - вкл
     16          */
     17          bool cmd_0x03(uint8_t *cmd, uint8_t size)
     18          {
     19            
     20            if (size != ARGS_SIZE){ // Размер аргументов не верен
     21              cmd_answer_err(ATYPE_CMD_ERR, CMD_LEN);
     22              return false;
     23            }
     24            
     25            cmd_args_s *args = (cmd_args_s*)cmd; // Извлекаем аргументы
     26            
     27            bool res;
     28            if (args->on_off){ // Просят включить сеть
     29              res = neocore_stack_reset();
     30              ASSERT(res == true);
     31              network_seed_enable(true);
     32              LOG_ON("CMD 0x03. Start network");
     33            }
     34            else
     35            {
     36              res = neocore_stack_reset();
     37              ASSERT(res == true);
     38              LOG_ON("CMD 0x03. Stop network");
     39            }
     40            
     41            cmd_answer(ATYPE_CMD_OK, NULL, 0);
     42            return true;
     43          }
E:\WMNU\IAR\NeocoreGateway\src\cmd_0x04.c
      1          #include "stdint.h"
      2          #include "cmd_parser.h"
      3          #include "manager.h"
      4          #include "config.h"
      5          #include "string.h"
      6          #include "nwdebuger.h"
      7          
      8          #define ARGS_SIZE sizeof(cmd_args_s)
      9          typedef struct //!< Аргументы команды
     10          {
     11            uint8_t IV[16];
     12            uint16_t crc16;
     13          } cmd_args_s;
     14          
     15          /**
     16          @brief Загрузка IV
     17          */
     18          bool cmd_0x04(uint8_t *cmd, uint8_t size)
     19          {
     20            if (size != ARGS_SIZE){ // Размер аргументов не верен
     21              cmd_answer_err(ATYPE_CMD_ERR, CMD_LEN);
     22              return false;
     23            }
     24          
     25            if (get_network_seed_status()){ // Сеть активна и менять ничего нельзя
     26              cmd_answer_err(ATYPE_CMD_ERR, CMD_SEEDING);
     27              return false;
     28            }
     29             
     30            cmd_args_s *args = (cmd_args_s*)cmd; // Извлекаем аргументы
     31            memcpy(CONFIG.stream_iv,  args->IV, 16);   
     32           
     33            LOG_ON("CMD 0x04. IV loaded");
     34            
     35            cmd_answer(ATYPE_CMD_OK, NULL, 0);
     36            return true;
     37          }
E:\WMNU\IAR\NeocoreGateway\src\cmd_0x05.c
      1          #include "stdint.h"
      2          #include "cmd_parser.h"
      3          #include "manager.h"
      4          #include "config.h"
      5          #include "string.h"
      6          #include "nwdebuger.h"
      7          
      8          #define ARGS_SIZE sizeof(cmd_args_s)
      9          typedef struct //!< Аргументы команды
     10          {
     11            uint8_t KEY[16];
     12            uint16_t crc16;
     13          } cmd_args_s;
     14          
     15          /**
     16          @brief Загрузка KEY
     17          */
     18          bool cmd_0x05(uint8_t *cmd, uint8_t size)
     19          {
     20            
     21            if (size != ARGS_SIZE){ // Размер аргументов не верен
     22              cmd_answer_err(ATYPE_CMD_ERR, CMD_LEN);
     23              return false;
     24            }
     25          
     26            if (get_network_seed_status()){ // Сеть активна и менять ничего нельзя
     27              cmd_answer_err(ATYPE_CMD_ERR, CMD_SEEDING);
     28              return false;
     29            }
     30             
     31            cmd_args_s *args = (cmd_args_s*)cmd; // Извлекаем аргументы
     32            memcpy(CONFIG.stream_key,  args->KEY, 16);   
     33           
     34            LOG_ON("CMD 0x05. KEY loaded");
     35            cmd_answer(ATYPE_CMD_OK, NULL, 0);
     36            return true;
     37          }
E:\WMNU\IAR\NeocoreGateway\src\cmd_0x06.c
      1          #include "stdint.h"
      2          #include "cmd_parser.h"
      3          #include "manager.h"
      4          #include "config.h"
      5          #include "TIC.h"
      6          #include "nwdebuger.h"
      7          
      8          #define ARGS_SIZE sizeof(cmd_args_s)
      9          typedef struct //!< Аргументы команды
     10          {
     11            uint8_t dont_use;
     12            uint16_t crc16;
     13          } cmd_args_s;
     14          
     15          /**
     16          @brief перезарузка
     17          */
     18          bool cmd_0x06(uint8_t *cmd, uint8_t size)
     19          {
     20            
     21            if (size != ARGS_SIZE){ // Размер аргументов не верен
     22              cmd_answer_err(ATYPE_CMD_ERR, CMD_LEN);
     23              return false;
     24            }
     25             
     26            cmd_answer(ATYPE_CMD_OK, NULL, 0);
     27            LOG_ON("CMD 0x06. HW reload");
     28            //TODO АППАПРАТНАЯ перезагрузка.
     29            
     30            return true;
     31          }
E:\WMNU\IAR\NeocoreGateway\src\cmd_0x07.c
      1          #include "stdint.h"
      2          #include "cmd_parser.h"
      3          #include "manager.h"
      4          #include "config.h"
      5          #include "MAC.h"
      6          #include "nwdebuger.h"
      7          
      8          #define ARGS_SIZE sizeof(cmd_args_s)
      9          typedef struct //!< Аргументы команды
     10          {
     11            uint8_t TS;
     12            uint8_t CH;
     13            uint16_t crc16;
     14          } cmd_args_s;
     15          
     16          /**
     17          @brief Открыть для приема слот TS на канале CH
     18          */
     19          bool cmd_0x07(uint8_t *cmd, uint8_t size)
     20          {
     21            
     22            if (size != ARGS_SIZE){ // Размер аргументов не верен
     23              cmd_answer_err(ATYPE_CMD_ERR, CMD_LEN);
     24              return false;
     25            }
     26            
     27            if (!get_network_seed_status()){ // Сеть отключена
     28              cmd_answer_err(ATYPE_CMD_ERR, CMD_NOSEEDING);
     29              return false;
     30            }
     31            
     32            cmd_args_s *args = (cmd_args_s*)cmd; // Извлекаем аргументы
     33            
     34            MAC_OpenRXSlot(args->TS, args->CH);
     35            LOG_ON("CMD 0x07. Open slot");
     36            cmd_answer(ATYPE_CMD_OK, NULL, 0);
     37            return true;
     38          }
E:\WMNU\IAR\NeocoreGateway\src\cmd_0x08.c
      1          #include "stdint.h"
      2          #include "cmd_parser.h"
      3          #include "manager.h"
      4          #include "config.h"
      5          #include "MAC.h"
      6          #include "nwdebuger.h"
      7          
      8          #define ARGS_SIZE sizeof(cmd_args_s)
      9          typedef struct //!< Аргументы команды
     10          {
     11            uint8_t TS;
     12            uint16_t crc16;
     13          } cmd_args_s;
     14          
     15          /**
     16          @brief Закрыть для приема слот TS
     17          */
     18          bool cmd_0x08(uint8_t *cmd, uint8_t size)
     19          {
     20            if (size != ARGS_SIZE){ // Размер аргументов не верен
     21              cmd_answer_err(ATYPE_CMD_ERR, CMD_LEN);
     22              return false;
     23            }
     24            
     25            if (!get_network_seed_status()){ // Сеть отключена
     26              cmd_answer_err(ATYPE_CMD_ERR, CMD_NOSEEDING);
     27              return true;
     28            }
     29            
     30            cmd_args_s *args = (cmd_args_s*)cmd; // Извлекаем аргументы
     31            
     32            MAC_CloseRXSlot(args->TS);
     33            
     34            LOG_ON("CMD 0x08. Close TS slot");
     35            cmd_answer(ATYPE_CMD_OK, NULL, 0);
     36            return true;
     37          }
E:\WMNU\IAR\NeocoreGateway\src\cmd_0x09.c
      1          #include "stdint.h"
      2          #include "cmd_parser.h"
      3          #include "manager.h"
      4          #include "config.h"
      5          #include "MAC.h"
      6          #include "nwdebuger.h"
      7          #include "rx_buff.h"
      8          
      9          #define ARGS_SIZE sizeof(cmd_args_s)
     10          typedef struct //!< Аргументы команды
     11          {
     12            uint16_t crc16;
     13          } cmd_args_s;
     14          
     15          /**
     16          @brief Количество принятых пакетов в буфере RX. Сеть вкл.
     17          */
     18          bool cmd_0x09(uint8_t *cmd, uint8_t size)
     19          {
     20            if (size != ARGS_SIZE){ // Размер аргументов не верен
     21              cmd_answer_err(ATYPE_CMD_ERR, CMD_LEN);
     22              return false;
     23            }
     24            
     25            uint8_t nbItems = RXB_frame_count();
     26            cmd_answer(ATYPE_CMD_OK, &nbItems, sizeof(nbItems));
     27            
     28            LOG_ON("CMD 0x09. RX frame count");
     29            return true;
     30          }
E:\WMNU\IAR\NeocoreGateway\src\cmd_0x0A.c
      1          #include "stdint.h"
      2          #include "cmd_parser.h"
      3          #include "manager.h"
      4          #include "config.h"
      5          #include "MAC.h"
      6          #include "nwdebuger.h"
      7          #include "LLC.h"
      8          
      9          #define ARGS_SIZE sizeof(cmd_args_s)
     10          typedef struct //!< Аргументы команды
     11          {
     12            uint16_t crc16;
     13          } cmd_args_s;
     14          
     15          /**
     16          @brief Количество пакетов в буфере TX. Сеть вкл.
     17          */
     18          bool cmd_0x0A(uint8_t *cmd, uint8_t size)
     19          {
     20            if (size != ARGS_SIZE){ // Размер аргументов не верен
     21              cmd_answer_err(ATYPE_CMD_ERR, CMD_LEN);
     22              return false;
     23            }
     24          
     25            uint8_t nbItems = LLC_GetTaskLen();
     26            cmd_answer(ATYPE_CMD_OK, &nbItems, sizeof(nbItems));
     27            
     28            LOG_ON("CMD 0x09. TX frame count");
     29            return true;
     30          }
E:\WMNU\IAR\NeocoreGateway\src\cmd_0x0B.c
      1          #include "stdint.h"
      2          #include "cmd_parser.h"
      3          #include "manager.h"
      4          #include "config.h"
      5          #include "MAC.h"
      6          #include "nwdebuger.h"
      7          #include "frame.h"
      8          #include "mem.h"
      9          #include "LLC.h"
     10          
     11          #define ARGS_SIZE sizeof(cmd_args_s)
     12          typedef struct //!< Аргументы команды
     13          {
     14            meta_s meta;
     15            uint8_t len;
     16            uint8_t offset_payload; //!< это указатель на первый байт payload
     17          } cmd_args_s;
     18          
     19          /**
     20          @brief Поставить пакет в очередь на отправку TX LLC. Сеть вкл.
     21          */
     22          bool cmd_0x0B(uint8_t *cmd, uint8_t size)
     23          {
     24            // Длинна sz{meta} + sz{len} + len(payload) + 2(CRC16)
     25            if (size - 2 < ARGS_SIZE ){ // Прежде чем извлеч проверим мин. размер
     26              cmd_answer_err(ATYPE_CMD_ERR, CMD_LEN);
     27              return false;
     28            }
     29            
     30            cmd_args_s *args = (cmd_args_s*)cmd; // Извлекаем аргументы
     31          
     32            if (size - 2 != ARGS_SIZE + args->len - 1){ // Проверим точный размер
     33              cmd_answer_err(ATYPE_CMD_ERR, CMD_LEN);
     34              return false;
     35            }
     36              
     37            if (!get_network_seed_status()){ // Если отключена. Ошибка
     38              cmd_answer_err(ATYPE_CMD_ERR, CMD_NOSEEDING);
     39              return true;
     40            }
     41            
     42            // TODO проверить значения аргументов
     43            //cmd_answer_err(ATYPE_CMD_ERR, CMD_ARG_VAL); 
     44            
     45            frame_s* tx_frame = frame_create(); // Создаем фрейм
     46            re_memcpy(&tx_frame->meta, &args->meta, sizeof(meta_s)); //Копируем метаданные
     47            
     48            uint8_t *ptr = &args->offset_payload; // Начало содержимого
     49            frame_addHeader(tx_frame, ptr, args->len);
     50            
     51            // Ставим в очередь на отправку
     52            bool res = LLC_AddTask(tx_frame);
     53            
     54            if (!res){ // Буфер полон 
     55              frame_delete(tx_frame);
     56              cmd_answer_err(ATYPE_CMD_ERR, CMD_TX_FULL);
     57              LOG_ON("CMD 0x0B. TX buff full");
     58              return false;
     59            }
     60            
     61            LOG_ON("CMD 0x0B. Frame add to LLC");
     62            cmd_answer(ATYPE_CMD_OK, NULL, 0);
     63            return true;
     64          }
E:\WMNU\IAR\NeocoreGateway\src\cmd_0x0C.c
      1          #include "stdint.h"
      2          #include "cmd_parser.h"
      3          #include "manager.h"
      4          #include "config.h"
      5          #include "MAC.h"
      6          #include "nwdebuger.h"
      7          #include "rx_buff.h"
      8          
      9          static void upload_frame(frame_s *fr);
     10          static void mem_move(uint8_t *dst, uint8_t *src, uint8_t len);
     11          
     12          #define ARGS_SIZE sizeof(cmd_args_s)
     13          typedef struct //!< Аргументы команды
     14          {
     15            uint16_t crc16;
     16          } cmd_args_s;
     17          
     18          
     19          static uint8_t upload[sizeof(meta_s) + 1 + 127];
     20          
     21          /**
     22          @brief Отправить на PC принятый пакет из буфера RX. Сеть вкл.
     23          */
     24          bool cmd_0x0C(uint8_t *cmd, uint8_t size)
     25          {
     26            if (size != ARGS_SIZE){ // Размер аргументов не верен
     27              cmd_answer_err(ATYPE_CMD_ERR, CMD_LEN);
     28              return false;
     29            }
     30            
     31            if (!get_network_seed_status()){ // Сеть должна работать
     32              cmd_answer_err(ATYPE_CMD_ERR, CMD_NOSEEDING);
     33              return false;
     34            }
     35            
     36            frame_s *rx_frame = RXB_get_frame();
     37            
     38            if (rx_frame == NULL){ // В буфере ничего нет
     39              cmd_answer_err(ATYPE_CMD_ERR, CMD_RX_EMPTY);
     40              return false;
     41            }
     42            
     43            upload_frame(rx_frame);
     44            RXB_del_frame(rx_frame);
     45            LOG_ON("CMD 0x0C. Upload RX frame");
     46            return true;
     47          }
     48          
     49          /**
     50          @brief Выгрузить фрейм в uart
     51          @detail Порядок выгрузки meta, byte len, payload[len]
     52          */
     53          static void upload_frame(frame_s *fr){
     54          /*  Заполнение массива upload
     55                    -----------------------
     56                    |META|LEN|   PAYLOAD  |
     57                    -----------------------
     58                         ^   ^<- fr.len ->^
     59          sizeof(meta_s)-|   |
     60          sizeof(meta_s)+1  -| 
     61          */
     62            // Пакет буду собирать в массиве upload иначе crc считать неудобно
     63             // Размер мета+1 байт длинны+пакет
     64            uint8_t answ_len = sizeof(meta_s) + 1 + fr->len; // Суммарный размер пакета
     65            mem_move(upload, (uint8_t*)&fr->meta, sizeof(meta_s));
     66            upload[sizeof(meta_s)] = fr->len; // byte len
     67            mem_move(&upload[sizeof(meta_s) + 1], (uint8_t*)fr->payload, fr->len);
     68            
     69            cmd_answer(ATYPE_CMD_OK, upload, answ_len);
     70            //cmd_answer(ATYPE_CMD_OK, upload, 10);
     71          }
     72          
     73          static void mem_move(uint8_t *dst, uint8_t *src, uint8_t len){
     74            for (uint8_t i = 0; i < len; i++)
     75              dst[i] = src[i];
     76          }
E:\WMNU\IAR\NeocoreGateway\src\cmd_0x0D.c
      1          #include "stdint.h"
      2          #include "cmd_parser.h"
      3          #include "manager.h"
      4          #include "config.h"
      5          #include "RADIO.h"
      6          #include "nwdebuger.h"
      7          
      8          #define ARGS_SIZE sizeof(cmd_args_s)
      9          typedef struct //!< Аргументы команды
     10          {
     11            uint8_t FCH;
     12            uint16_t MS;
     13            uint16_t crc16;
     14          } cmd_args_s;
     15          
     16          /**
     17          @brief Скан канала CH в течении time_ms. Сеть выкл.
     18          @detail Ответ после завершения сканирования
     19          */
     20          bool cmd_0x0D(uint8_t *cmd, uint8_t size)
     21          {
     22            if (size != ARGS_SIZE){ // Размер аргументов не верен
     23              cmd_answer_err(ATYPE_CMD_ERR, CMD_LEN);
     24              return false;
     25            }
     26            
     27            if (get_network_seed_status()){ // Сеть активна сканировать нельзя
     28              cmd_answer_err(ATYPE_CMD_ERR, CMD_SEEDING);
     29              return false;
     30            }
     31            
     32            cmd_args_s *args = (cmd_args_s*)cmd; // Извлекаем аргументы
     33            
     34            int8_t rssi;
     35            bool res = RI_Measure_POW(args->FCH, args->MS, &rssi);
     36            
     37            LOG_ON("CMD 0x0D. RSSI scan");
     38            
     39            cmd_answer(ATYPE_CMD_OK, (uint8_t*)&rssi, sizeof(rssi));
     40            return true;
     41          }
E:\WMNU\IAR\NEOCOREGATEWAY\src\cmd_0x0E.c
      1          #include "stdint.h"
      2          #include "cmd_parser.h"
      3          #include "manager.h"
      4          #include "config.h"
      5          #include "MAC.h"
      6          #include "nwdebuger.h"
      7          
      8          #define ARGS_SIZE sizeof(cmd_args_s)
      9          typedef struct //!< Аргументы команды
     10          {
     11            uint8_t CH;
     12            uint16_t crc16;
     13          } cmd_args_s;
     14          
     15          /**
     16          @brief Установить канал для синхросигнала. Сеть выкл.
     17          */
     18          bool cmd_0x0E(uint8_t *cmd, uint8_t size)
     19          {
     20            if (size != ARGS_SIZE){ // Размер аргументов не верен
     21              cmd_answer_err(ATYPE_CMD_ERR, CMD_LEN);
     22              return false;
     23            }
     24            
     25            if (get_network_seed_status()){ // Сеть должна быть отключенна
     26              cmd_answer_err(ATYPE_CMD_ERR, CMD_SEEDING);
     27              return true;
     28            }
     29            
     30            cmd_args_s *args = (cmd_args_s*)cmd; // Извлекаем аргументы
     31            CONFIG.sync_channel = args->CH;
     32            
     33            LOG_ON("CMD 0x0E. Set SYNC CH");
     34            cmd_answer(ATYPE_CMD_OK, NULL, 0);
     35            return true;
     36          }
E:\WMNU\IAR\NEOCOREGATEWAY\src\cmd_0x0F.c
      1          #include "stdint.h"
      2          #include "cmd_parser.h"
      3          #include "manager.h"
      4          #include "config.h"
      5          #include "MAC.h"
      6          #include "nwdebuger.h"
      7          
      8          #define ARGS_SIZE sizeof(cmd_args_s)
      9          typedef struct //!< Аргументы команды
     10          {
     11            uint8_t CH;
     12            uint16_t crc16;
     13          } cmd_args_s;
     14          
     15          /**
     16          @brief Установить системный канал. Сеть выкл.
     17          Информация о системном канала распространяется в пакете синхронизации
     18          */
     19          bool cmd_0x0F(uint8_t *cmd, uint8_t size)
     20          {
     21            if (size != ARGS_SIZE){ // Размер аргументов не верен
     22              cmd_answer_err(ATYPE_CMD_ERR, CMD_LEN);
     23              return false;
     24            }
     25            
     26            if (get_network_seed_status()){ // Сеть должна быть отключенна
     27              cmd_answer_err(ATYPE_CMD_ERR, CMD_SEEDING);
     28              return true;
     29            }
     30            
     31            cmd_args_s *args = (cmd_args_s*)cmd; // Извлекаем аргументы
     32            CONFIG.sys_channel = args->CH;
     33            
     34            LOG_ON("CMD 0x0А. Set SYS CH");
     35            cmd_answer(ATYPE_CMD_OK, NULL, 0);
     36            return true;
     37          }
E:\WMNU\IAR\NEOCOREGATEWAY\src\cmd_0x10.c
      1          #include "stdint.h"
      2          #include "cmd_parser.h"
      3          #include "manager.h"
      4          #include "config.h"
      5          #include "MAC.h"
      6          #include "nwdebuger.h"
      7          
      8          #define ARGS_SIZE sizeof(cmd_args_s)
      9          typedef struct //!< Аргументы команды
     10          {
     11            uint8_t POW;
     12            uint16_t crc16;
     13          } cmd_args_s;
     14          
     15          /**
     16          @brief Установить мощность радиопередатчика
     17          */
     18          bool cmd_0x10(uint8_t *cmd, uint8_t size)
     19          {
     20            if (size != ARGS_SIZE){ // Размер аргументов не верен
     21              cmd_answer_err(ATYPE_CMD_ERR, CMD_LEN);
     22              return false;
     23            }
     24            
     25            if (get_network_seed_status()){ // Сеть должна быть отключенна
     26              cmd_answer_err(ATYPE_CMD_ERR, CMD_SEEDING);
     27              return true;
     28            }
     29            
     30            cmd_args_s *args = (cmd_args_s*)cmd; // Извлекаем аргументы
     31            CONFIG.tx_power = args->POW;
     32            
     33            LOG_ON("CMD 0x10. Set TX POWER");
     34            cmd_answer(ATYPE_CMD_OK, NULL, 0);
     35            return true;
     36          }
E:\WMNU\IAR\NEOCOREGATEWAY\src\cmd_parser.c
      1          #include "uart_comm.h"
      2          #include "stdbool.h"
      3          #include "cmd_index_list.h"
      4          #include "nwdebuger.h"
      5          #include "cmd_parser.h"
      6          
      7          /**
      8          @file Прием и парсинг команд по uart
      9          @detail Команда от PC имеет формат:
     10           --------------------------
     11           | 0 | 1 |  n |LEN-1| LEN | 
     12           --------------------------
     13           |LEN|CMD|ARGS|CRC16|CRC16|
     14           --------------------------
     15          Ответ от МК имеет формат:
     16           --------------------------
     17           | 0 | 1 |  n |LEN-1| LEN | 
     18           --------------------------
     19           |LEN|TYP|DATA|CRC16|CRC16|
     20           --------------------------
     21          Где TYP - тип ответа.
     22          TYP = 0x00 ответ от парсера в случаии ошибки.
     23           DATA = 1 ошибка CRC16
     24           DATA = 2 команда отсутсвует
     25          TYP = 0x01 ответ от обработчика команды с ошибкой
     26           DATA = 0x01 Ошибка размера аргументов
     27           DATA = 0x02 Аргумент неверен.
     28          TYP = 0x02 Команда выполнена, следуют данные команды
     29          */
     30          
     31          enum {answ_crc_err = 1, answ_args_err = 2, answ_no_cmd = 3}; //!< Коды ошибок
     32          
     33          //#define USE_CRC16_CHECK //!< Использовать проверку CRC
     34          #define MAX_CMD_INDEX sizeof(CMD_LIST) //!< Все номера команд меньше этого числа
     35          
     36          static unsigned short crc16(unsigned char *pcBlock, unsigned short len);
     37          static bool check_cmd_frame(uint8_t *cmd, uint8_t size);
     38          void cmd_answer(uint8_t ATYPE, uint8_t *data, uint8_t len);
     39          void cmd_answer_err(uint8_t a_type, uint8_t err_code);
     40          
     41          typedef bool(*cmd_handler)(uint8_t *cmd, uint8_t size);
     42          
     43          // Список обработчиков. Номер команды = индекс в массиве
     44          static cmd_handler CMD_LIST[] = { 
     45            cmd_0x00, cmd_0x01, cmd_0x02, cmd_0x03, cmd_0x04, cmd_0x05, cmd_0x06,
     46            cmd_0x07, cmd_0x08, cmd_0x09,cmd_0x0A, cmd_0x0B, cmd_0x0C, cmd_0x0D,
     47            cmd_0x0E, cmd_0x0F, cmd_0x10
     48          };    
     49           
     50          
     51          
     52          /**
     53          @brief Разбор входящих команд от PC
     54          @detail После приема следует ответ если есть ошибки CRC, args, len.
     55           Если ошибок нет, то ответ формирует команда.
     56          */
     57          void parse_uart_stream(void)
     58          {
     59            uint8_t* cmd;
     60            uint8_t size;
     61            uint8_t iCmd;
     62            
     63            while (true){
     64              cmd = uart_recv_cmd(&size);
     65              if (!check_cmd_frame(cmd,size)){ // Кадр плохой
     66                cmd_answer_err(ATYPE_PAR_ERR, PAR_CRC16);
     67                continue; 
     68              }
     69                
     70              iCmd = cmd[0];
     71              if (!(iCmd < MAX_CMD_INDEX)){ // Нет такой команды
     72                cmd_answer_err(ATYPE_PAR_ERR, PAR_NOCMD);
     73                continue; 
     74              }
     75              
     76              if (!CMD_LIST[iCmd](&cmd[1], size - 1)) 
     77                continue; // если были ошибки в выполнении команды.
     78              
     79              // Впринципе проверять не нужно как завершилась команда, но на будующее 
     80              // оставлю этот функционал. 
     81              // Сюда приходим если нет проблем с командой
     82            }
     83          }
     84          
     85          /**
     86          @brief Ответ на команду с ошибкой
     87          @param[in] ATYPE тип ответа
     88          @param[in] data указатель на данные
     89          @param[in] len размер данных
     90          */
     91          void cmd_answer(uint8_t ATYPE, uint8_t *data, uint8_t len){
     92            // Отдаем заголовок
     93            uint8_t full_len = len+3; // Байт TYPE + 2б CRC16
     94            uint8_t an[2] = {full_len, ATYPE};
     95            uart_write((char*)an, sizeof(an));
     96            
     97            // Отдаем данные
     98            uart_write((char*)data, len);
     99            
    100            unsigned short an_crc16 = crc16(data,len);
    101            uart_write((char*)an_crc16, sizeof(an_crc16));  
    102          }
    103          
    104          void cmd_answer_err(uint8_t a_type, uint8_t err_code){
    105            // Отдаем заголовок
    106            uint8_t answ_err[] = {a_type, err_code};
    107            stream_write(answ_err, sizeof(answ_err));
    108          }
    109          
    110          /**
    111          @brief Отправляем данные в PC. 
    112          @brief Формирует байт размера и добавляет CRC16
    113          */
    114          void stream_write(uint8_t *data, uint8_t size)
    115          {
    116            ASSERT(size > 0 && size < 253) // +2 CRC +1 LEN +252 DATA = 255 максимум
    117            uint8_t nsize = size + 2; // Два байта CRC
    118            unsigned short data_crc16 = crc16(data, size);
    119            uart_write((char*)&nsize, 1);
    120            uart_write((char*)data, size);
    121            uart_write((char*)&data_crc16 , 2);
    122          }
    123          
    124          /**
    125          @brief Проверка коректности принятого пакета
    126          */
    127          static bool check_cmd_frame(uint8_t *cmd, uint8_t size)
    128          {  
    129            if (size < 3) // Размер данных не может быть меньше 3 байт
    130                return false;
    131              
    132          #ifdef USE_CRC16_CHECK    
    133            unsigned short* cmd_crc16;
    134            unsigned short data_crc16;  
    135            // Извлекаем CRC16 из пакета (последнии 2 байта) 
    136            cmd_crc16 = (unsigned short*)&cmd[size - 2];
    137            // Расчитываем CRC16 данных
    138            data_crc16 = crc16(cmd, size - 2);
    139            // Если данные битые то продолжаем прием
    140            if (data_crc16 != *cmd_crc16)
    141              return false;
    142          #endif
    143          
    144            return true;
    145          }
    146          
    147          /**
    148          @brief Расчет CRC16
    149          @param[in] pcBlock указатель на начало масива
    150          @param[in] len размер данных для подсчета
    151          @return код crc16
    152          */
    153          static unsigned short crc16(unsigned char *pcBlock, unsigned short len){
    154              unsigned short crc = 0xFFFF;
    155              unsigned char i;
    156           
    157              while (len--)
    158              {
    159                  crc ^= *pcBlock++ << 8;
    160           
    161                  for (i = 0; i < 8; i++)
    162                      crc = crc & 0x8000 ? (crc << 1) ^ 0x1021 : crc << 1;
    163              }
    164           
    165              return crc;
    166          }
E:\WMNU\IAR\SHARE_PRJ_SRC\coder.c
      1          /*!
      2          \file Модуль шифрования данных
      3          \brief Функции кодирования данных
      4          */
      5          
      6          #include "coder.h"
      7          #include "ioCC2530.h"
      8          #include "string.h"
      9          #include "delays.h" // Для профилирования, Отладка
     10          #include "dma.h"
     11          
     12          #define AES_START()  {ENCCS |= 0x01;} //!< Запуск выполнения команды  
     13          #define AES_SET_MODE(mode) {ENCCS &= ~0x70; ENCCS |= mode;} //!< Установка режима
     14          #define AES_SET_OPERATION(op) {ENCCS = (ENCCS & ~0x07) | op;} 
     15          #define AES_RDY() (ENCCS & 8) //!< Состояние модуля
     16          
     17          
     18          #define BV(n)                   (1 << (n))
     19          #define MIC_2_MICLEN(m)         (BV((m&3)+1) & ~3)
     20          
     21          // Режимы шифрования
     22          #define AES_MODE_CBC            0x00
     23          #define AES_MODE_CFB            0x10
     24          #define AES_MODE_OFB            0x20
     25          #define AES_MODE_CTR            0x30
     26          #define AES_MODE_ECB            0x40
     27          #define AES_MODE_CBCMAC         0x50
     28          
     29          // Операции 
     30          #define AES_ENCRYPT             0x00
     31          #define AES_DECRYPT             0x02
     32          #define AES_LOAD_KEY            0x04
     33          #define AES_LOAD_IV             0x06
     34          
     35          #define ENC_DW 29 // DMA AES тригер запрос загрузки
     36          #define ENC_UP 30 // DMA AES тригер запрос выгрузки
     37          
     38          #define STREAM_ENC_MODE     AES_MODE_OFB //!< Метод шифрования потока данных
     39          
     40          // Доступные методы
     41          void AES_StreamCoder(bool enc_mode, uint8_t *src, uint8_t *dst, 
     42                               uint8_t *key, uint8_t *nonce, uint8_t len);
     43          
     44          // Приватные функции
     45          static inline uint8_t generateAuthData(uint8_t *src, uint8_t *nonce, uint8_t c,
     46                                                 uint8_t f, uint8_t lm);
     47          static void CBCMAC_buf_encrypt(uint8_t len, uint8_t *key, uint8_t *mac);
     48          
     49          /**
     50          @brief Локальный буфер для работы режима CCM
     51          @detail 128 длина сообщения. 18 длинна блока B0 и строки состояния.
     52           16 длина дополнения нулями
     53          */
     54          static uint8_t buf[128+18+16]; 
     55          
     56          
     57          typedef struct //!< Структура блока B0 для режима CCM
     58          {
     59            struct 
     60            {
     61              uint8_t L:3;
     62              uint8_t M:3;
     63              uint8_t A_Data:1;
     64            } flag;
     65            uint16_t nonce[9];
     66            uint8_t L_M[6];
     67          } __attribute__((packed)) B0_s;
     68          
     69          typedef struct //!< Структура блока A0 для режима CCM
     70          {
     71            struct 
     72            {
     73              uint8_t L:3;
     74            } flag;
     75            uint8_t nonce[11];
     76            uint8_t ctr;
     77          } __attribute__((packed)) A0_s;
     78          
     79          
     80          
     81          /**
     82          @brief Иницилизация модуля
     83          @detail Модуль использует DMA каналы 0 и 1
     84          */
     85          void AES_init(void)
     86          {
     87            //DMA_AES_s DMA_CH[0]; //!< DMA на запись будет DMA[0]
     88            //DMA_AES_s DMA_CH[1]; //!< DMA на чтение DMA_CH[1]
     89            
     90            ST_DEF(DMA_CH[0], DSTADDRH, 0x70); // Пишем данные XENCDI = 0xB1 
     91            ST_DEF(DMA_CH[0], DSTADDRL, 0xB1); //  
     92            ST_DEF(DMA_CH[0], PRIORITY, 0x00); // Низкий приоритет
     93            ST_DEF(DMA_CH[0], M8, 0x00); // Используем 8 бит для счетика длинны
     94            ST_DEF(DMA_CH[0], IRQMASK, 0x00); // Запрещаем генерировать перывания
     95            ST_DEF(DMA_CH[0], DESTINC, 0x00); // Не увеличиваем адресс назначения
     96            ST_DEF(DMA_CH[0], SRCINC, 0x01); // Увеличиваем адресс источника
     97            ST_DEF(DMA_CH[0], TRIG, ENC_DW); // Тригер по загрузке
     98            ST_DEF(DMA_CH[0], WORDSIZE, 0x00); // Копируем по 1 байту
     99            ST_DEF(DMA_CH[0], TMODE, 0x01); //  Блочное копирование по тригеру
    100            ST_DEF(DMA_CH[0], VLEN, 0x00); //  Количество байт определяет поле LEN  
    101            ST_DEF(DMA_CH[0], LENH, 0x00); 
    102            
    103            ST_DEF(DMA_CH[1], SRCADDRH, 0x70); // Читаем данные из X_ENCDO  
    104            ST_DEF(DMA_CH[1], SRCADDRL, 0xB2);  
    105            ST_DEF(DMA_CH[1], PRIORITY, 0x00); // Низкий приоритет
    106            ST_DEF(DMA_CH[1], M8, 0x00); // Используем 8 бит для счетика длинны
    107            ST_DEF(DMA_CH[1], IRQMASK, 0x00); // Запрещаем генерировать перывания
    108            ST_DEF(DMA_CH[1], DESTINC, 0x01); // Увеличиваем адресс назначения
    109            ST_DEF(DMA_CH[1], SRCINC, 0x00); // Не увеличиваем адресс источника
    110            ST_DEF(DMA_CH[1], TRIG, ENC_UP); // Тригер по выгрузке
    111            ST_DEF(DMA_CH[1], WORDSIZE, 0x00); // Копируем по 1 байту
    112            ST_DEF(DMA_CH[1], TMODE, 0x01); //  Блочное копирование по тригеру
    113            ST_DEF(DMA_CH[1], VLEN, 0x00); //  Количество байт определяет поле LEN  
    114            ST_DEF(DMA_CH[1], LENH, 0x00); 
    115          }
    116          
    117          /**
    118          @brief Шифрует/дешифрует поток данных во время радиопередачи. Без проверки MIC
    119          @param[in] enc_mode Режим работы процедуры. true - шифрование.
    120          @param[in] src Указатель на данные подлежащии шифрованию
    121          @param[in] dst Указтель куда будут помещены зашифрованные данные
    122          @param[in] key Указатье на ключ. 16 байт
    123          @param[in] iv  Указатель на вектор иницилизации. 16 байт 
    124          @param[in] len Длинна данных
    125          */
    126          void AES_StreamCoder(bool enc_mode, uint8_t *src, uint8_t *dst, uint8_t *key,
    127                                   uint8_t *iv, uint8_t len)
    128          {
    129            // Установим метод кодироваения
    130            AES_SET_MODE(STREAM_ENC_MODE);
    131              
    132            // Загружаем ключ
    133            AES_SET_OPERATION(AES_LOAD_KEY);
    134            ST_DEF(DMA_CH[0], SRCADDRL, LADDR(key));
    135            ST_DEF(DMA_CH[0], SRCADDRH, HADDR(key));
    136            ST_DEF(DMA_CH[0], LENL, 16);
    137            DMAARM |= 0x01;
    138            while(!AES_RDY());
    139            AES_START();
    140            while (DMAARM&0x01);
    141          
    142            // Загружаем IV
    143            AES_SET_OPERATION(AES_LOAD_IV);
    144            ST_DEF(DMA_CH[0], SRCADDRL, LADDR(iv));
    145            ST_DEF(DMA_CH[0], SRCADDRH, HADDR(iv));
    146            ST_DEF(DMA_CH[0], LENL, 16);
    147            DMAARM |= 0x01;
    148            while(!AES_RDY());
    149            AES_START();
    150            while (DMAARM&0x01);
    151          
    152            // Установим необходимую операцию AES
    153            if (enc_mode) 
    154              AES_SET_OPERATION(AES_ENCRYPT)
    155            else 
    156              AES_SET_OPERATION(AES_DECRYPT)
    157            
    158            switch(STREAM_ENC_MODE) 
    159            {
    160            case AES_MODE_ECB: // ECB, CBC не реализованы
    161            case AES_MODE_CBC:
    162              break;
    163            case AES_MODE_CFB:
    164            case AES_MODE_OFB:
    165            case AES_MODE_CTR:
    166              {
    167                // Загрузка блоками по 128 бит с разделением на под-блоки по 32 бита
    168                uint8_t nbrBlocks = len / 16; // Количество целых блоков по 128 бит
    169                uint8_t ptr, sub_ptr; // Смещение
    170                uint8_t *download, *upload;
    171                
    172                // Для этих типов шифрования длина блоков по 4 байта
    173                ST_DEF(DMA_CH[0], LENL, 4);
    174                ST_DEF(DMA_CH[1], LENL, 4);
    175                
    176                // Шифруем все целые блоки
    177                for (uint8_t block = 0; block < nbrBlocks; block ++)
    178                {
    179                  ptr = 16 * block;
    180                  while(!AES_RDY());
    181                  AES_START();
    182                  for (uint8_t j = 0; j < 4; j++)
    183                  {
    184                    sub_ptr = ptr + 4*j;
    185                    download = &src[sub_ptr];
    186                    upload = &dst[sub_ptr];
    187                    // Указываем адресс DMA откуда читать данные
    188                    ST_DEF(DMA_CH[0], SRCADDRL, LADDR(download));
    189                    ST_DEF(DMA_CH[0], SRCADDRH, HADDR(download));
    190                    // Указываем адрес DMA куда записывать данные          
    191                    ST_DEF(DMA_CH[1], DSTADDRL, LADDR(upload));
    192                    ST_DEF(DMA_CH[1], DSTADDRH, HADDR(upload));
    193                    // Активируем DMA
    194                    DMAARM |= 0x03;  
    195                    DMAREQ |= 0x01;
    196                    while (DMAARM&0x03);          
    197                  }
    198                }     
    199                // Шифруем последний блок
    200                uint8_t block_len = len % 16; // Размер последнего блока
    201                
    202                // Завершаем работу если блок пустой
    203                if (!block_len)
    204                  return;
    205                
    206                uint8_t padding_block[16]; // Блок заполненый нулями
    207                ptr = 16*nbrBlocks; // Смещение на первый байт последнего блока в src
    208                memset(padding_block, 0x00, sizeof(padding_block)); // Заполняем нулями
    209                memcpy(padding_block, &src[ptr], block_len); // Копируем данные
    210                
    211                while(!AES_RDY());
    212                AES_START();
    213                for (uint8_t j = 0; j < 4; j++)
    214                  {
    215                    sub_ptr = 4*j;
    216                    download = &padding_block[sub_ptr];
    217                    // Указываем адресс DMA откуда читать данные
    218                    ST_DEF(DMA_CH[0], SRCADDRL, LADDR(download));
    219                    ST_DEF(DMA_CH[0], SRCADDRH, HADDR(download));
    220                    // Указываем аддрес DMA куда записывать данные          
    221                    ST_DEF(DMA_CH[1], DSTADDRL, LADDR(download));
    222                    ST_DEF(DMA_CH[1], DSTADDRH, HADDR(download));
    223                    // Активируем DMA
    224                    DMAARM |= 0x03;  
    225                    DMAREQ |= 0x01;
    226                    while (DMAARM&0x03);
    227                  }
    228                memcpy(&dst[ptr], padding_block, block_len); // Копируем в src
    229                
    230              } //CASE
    231              
    232              break;
    233            } 
    234          }
    235          
    236          /**
    237          @brief Шифрует/дешифрует поток данных во время радиопередачи. Без проверки MIC
    238          @param[in] enc_mode Режим работы процедуры. true - шифрование.
    239          @param[in] src Указатель на данные подлежащии шифрованию
    240          @param[in] dst Указтель куда будут помещены зашифрованные данные
    241          @param[in] key Указатье на ключ. 16 байт
    242          @param[in] iv  Указатель на вектор иницилизации. 16 байт 
    243          @param[in] len Длинна данных
    244          */
    245          static void CTR_enc_decrypt(bool enc_mode, uint8_t *src, uint8_t *dst, uint8_t *key,
    246                                   uint8_t *iv, uint8_t len)
    247          {
    248            // Установим метод кодироваения
    249            AES_SET_MODE(AES_MODE_CTR);
    250            
    251            // Загружаем ключ
    252            AES_SET_OPERATION(AES_LOAD_KEY);
    253            ST_DEF(DMA_CH[0], SRCADDRL, LADDR(key));
    254            ST_DEF(DMA_CH[0], SRCADDRH, HADDR(key));
    255            ST_DEF(DMA_CH[0], LENL, 16);
    256            DMAARM |= 0x01;
    257            while(!AES_RDY());
    258            AES_START();
    259            while (DMAARM&0x01);
    260          
    261            // Загружаем IV
    262            AES_SET_OPERATION(AES_LOAD_IV);
    263            ST_DEF(DMA_CH[0], SRCADDRL, LADDR(iv));
    264            ST_DEF(DMA_CH[0], SRCADDRH, HADDR(iv));
    265            ST_DEF(DMA_CH[0], LENL, 16);
    266            DMAARM |= 0x01;
    267            while(!AES_RDY());
    268            AES_START();
    269            while (DMAARM&0x01);
    270          
    271            // Установим необходимую операцию AES
    272            if (enc_mode) 
    273              AES_SET_OPERATION(AES_ENCRYPT)
    274            else 
    275              AES_SET_OPERATION(AES_DECRYPT)
    276            
    277            // Загрузка блоками по 128 бит с разделением на под-блоки по 32 бита
    278            uint8_t nbrBlocks = len / 16; // Количество целых блоков по 128 бит
    279            uint8_t ptr, sub_ptr; // Смещение
    280            uint8_t *download, *upload;
    281                
    282            // Для этих типов шифрования длина блоков по 4 байта
    283            ST_DEF(DMA_CH[0], LENL, 4);
    284            ST_DEF(DMA_CH[1], LENL, 4);
    285                
    286            // Шифруем все целые блоки
    287            for (uint8_t block = 0; block < nbrBlocks; block ++)
    288              {
    289                ptr = 16 * block;
    290                while(!AES_RDY());
    291                AES_START();
    292                for (uint8_t j = 0; j < 4; j++)
    293                  {
    294                    sub_ptr = ptr + 4*j;
    295                    download = &src[sub_ptr];
    296                    upload = &dst[sub_ptr];
    297                    // Указываем адресс DMA откуда читать данные
    298                    ST_DEF(DMA_CH[0], SRCADDRL, LADDR(download));
    299                    ST_DEF(DMA_CH[0], SRCADDRH, HADDR(download));
    300                    // Указываем адрес DMA куда записывать данные          
    301                    ST_DEF(DMA_CH[1], DSTADDRL, LADDR(upload));
    302                    ST_DEF(DMA_CH[1], DSTADDRH, HADDR(upload));
    303                    // Активируем DMA
    304                    DMAARM |= 0x03;  
    305                    DMAREQ |= 0x01;
    306                    while (DMAARM&0x03);          
    307                  }
    308              }     
    309              // Шифруем последний блок
    310              uint8_t block_len = len % 16; // Размер последнего блока
    311                
    312              // Завершаем работу если блок пустой
    313              if (!block_len)
    314                return;
    315                
    316              uint8_t padding_block[16]; // Блок заполненый нулями
    317              ptr = 16*nbrBlocks; // Смещение на первый байт последнего блока в src
    318              memset(padding_block, 0x00, sizeof(padding_block)); // Заполняем нулями
    319              memcpy(padding_block, &src[ptr], block_len); // Копируем данные
    320              
    321              while(!AES_RDY());
    322              AES_START();
    323              for (uint8_t j = 0; j < 4; j++)
    324                {
    325                  sub_ptr = 4*j;
    326                  download = &padding_block[sub_ptr];
    327                  // Указываем адресс DMA откуда читать данные
    328                  ST_DEF(DMA_CH[0], SRCADDRL, LADDR(download));
    329                  ST_DEF(DMA_CH[0], SRCADDRH, HADDR(download));
    330                  // Указываем аддрес DMA куда записывать данные          
    331                  ST_DEF(DMA_CH[1], DSTADDRL, LADDR(download));
    332                  ST_DEF(DMA_CH[1], DSTADDRH, HADDR(download));
    333                  // Активируем DMA
    334                  DMAARM |= 0x03;  
    335                  DMAREQ |= 0x01;
    336                  while (DMAARM&0x03);
    337                }
    338              memcpy(&dst[ptr], padding_block, block_len); // Копируем в src
    339          }
    340          
    341          /**
    342          @brief Зашифровывает buf в режиме CBC-MAC с IV = 0
    343          @param[in] len улинна последовательности для вычисления MAC
    344          @param[out] mac указатель на память куда будет записан mac (до 16 байт)
    345          */
    346          static void CBCMAC_buf_encrypt(uint8_t len, uint8_t *key, uint8_t *mac)
    347          {
    348            uint8_t IV[16];
    349            
    350            // Заполняем вектор нулями
    351            memset(IV, 0x00, sizeof(IV));
    352            
    353            // Установим метод кодироваения
    354            AES_SET_MODE(AES_MODE_CBCMAC);  
    355            
    356            { // Сворачиваем код для улучшения чтения
    357            // Загружаем ключ
    358            AES_SET_OPERATION(AES_LOAD_KEY);
    359            ST_DEF(DMA_CH[0], SRCADDRL, LADDR(key));
    360            ST_DEF(DMA_CH[0], SRCADDRH, HADDR(key));
    361            ST_DEF(DMA_CH[0], LENL, 16);
    362            DMAARM |= 0x01;
    363            while(!AES_RDY());
    364            AES_START();
    365            while (DMAARM&0x01);
    366          
    367            // Загружаем IV
    368            AES_SET_OPERATION(AES_LOAD_IV);
    369            ST_DEF(DMA_CH[0], SRCADDRL, LADDR(IV));
    370            ST_DEF(DMA_CH[0], SRCADDRH, HADDR(IV));
    371            ST_DEF(DMA_CH[0], LENL, 16);
    372            DMAARM |= 0x01;
    373            while(!AES_RDY());
    374            AES_START();
    375            while (DMAARM&0x01);
    376            };
    377            
    378            // Устанавливаем операцию шифрования
    379            AES_SET_OPERATION(AES_ENCRYPT);
    380            
    381            // Загрузка блоками по 128 бит
    382            uint8_t nbrBlocks = len / 16; // Количество целых блоков по 128 бит
    383            uint8_t block_len = len % 16; // Размер последнего блока
    384            uint8_t ptr; // Смещение
    385                
    386            // Для этого типа шифрования длина блоков по 16 байт
    387            ST_DEF(DMA_CH[0], LENL, 16);
    388            // Устанавливаем куда будем выгружать вычисленный MAC
    389            ST_DEF(DMA_CH[1], DSTADDRL, LADDR(mac));
    390            ST_DEF(DMA_CH[1], DSTADDRH, HADDR(mac));
    391            ST_DEF(DMA_CH[1], LENL, 16);
    392            
    393            // Шифруем все целые блоки
    394            for (uint8_t block = 0; block < nbrBlocks; block ++)
    395              {
    396                // Последний блок шифруем в режиме CBC при условии что нет блок не 
    397                // кратного 16 байтам.
    398                if (!block_len && (block == nbrBlocks - 1))
    399                  AES_SET_MODE(AES_MODE_CBC);
    400                    
    401                ptr = 16 * block;
    402                while(!AES_RDY());
    403                AES_START();
    404                // Указываем адресс DMA откуда читать данные
    405                ST_DEF(DMA_CH[0], SRCADDRL, LADDR(buf[ptr]));
    406                ST_DEF(DMA_CH[0], SRCADDRH, HADDR(buf[ptr]));
    407                // Активируем DMA
    408                DMAARM |= 0x01;  
    409                // Активируем выгрузку только последнего блока
    410                if (!block_len && (block == nbrBlocks - 1))
    411                  DMAARM |= 0x03;
    412                
    413                DMAREQ |= 0x01;
    414                while (DMAARM&0x03);          
    415               }
    416                 
    417            // Шифруем последний блок в режиме CBC
    418            AES_SET_MODE(AES_MODE_CBC);
    419                    
    420            // Завершаем работу если блок пустой
    421            if (!block_len)
    422              return;
    423                
    424            uint8_t padding_block[16]; // Блок заполненый нулями
    425            ptr = 16*nbrBlocks; // Смещение на первый байт последнего блока в src
    426            memset(padding_block, 0x00, sizeof(padding_block)); // Заполняем нулями
    427            memcpy(padding_block, &buf[ptr], block_len); // Копируем данные
    428                
    429            while(!AES_RDY());
    430            AES_START();
    431            // Указываем адресс DMA откуда читать данные
    432            ST_DEF(DMA_CH[0], SRCADDRL, LADDR(padding_block));
    433            ST_DEF(DMA_CH[0], SRCADDRH, HADDR(padding_block));
    434            // Активируем DMA и выгрузку MAC
    435            DMAARM |= 0x03;  
    436            DMAREQ |= 0x01;
    437            while (DMAARM&0x03);
    438          }
    439          
    440          static inline uint8_t generateAuthData(uint8_t *src, uint8_t *nonce, uint8_t c,
    441                                                 uint8_t f, uint8_t lm)
    442          {
    443            memcpy(buf, nonce,16);
    444            
    445            // Буфер от 0 до 15 байта специальный блок B0
    446            // Настраиваем флаг. У нас длинна 2 байта. nonce 13 байт => L_M = L-1=0x01
    447            buf[0]=  0x01;  
    448            // Если есть данные для авторизации установим A_Data 
    449            if (f > 0)
    450              buf[0] |= 0x40;
    451            
    452            buf[0] |= ((lm - 2) / 2 ) << 3;   // см. документацию M'= (lm-2) / 2;
    453            
    454            // Устанавливаем длинну сообщения
    455            buf[14] = 0x00;
    456            buf[15] = c;
    457            
    458            // Добавляем строку авторизации L(a). если данных нет, то она пустая. f=0
    459            buf[16]= 0;
    460            buf[17]= f;
    461            
    462            // Копируем данные авторизации в буфер
    463            memcpy(&buf[18], src, f);
    464            
    465            // Смещение на следующий байт после данных авторизации.
    466            // Данные авторизации занимают положение в буфере [18, 18+f]
    467            uint8_t ptr_end= 18 + f;
    468            // Заполняем нулями до границы 16 байт  
    469            while (ptr_end & 0x0f)
    470              buf[ptr_end++] = 0x00;
    471            
    472            // Копируем данные для шифрования в буфер после нулей
    473            memcpy(&buf[ptr_end], &src[f], c);
    474            
    475            // Возвращаем размер данных в буфере
    476            return ptr_end+c;
    477          };
    478          
    479          /**
    480          @brief Шифрует/дешифрует данные с проверкой MIC
    481          @param[in] src Указатель на данные подлежащии шифрованию
    482          @param[in] len Размер данных
    483          @param[in] с Количество байт для шифрования
    484          @param[in] f Количество байт для авторизации
    485          @param[in] m Размер MIC (m=1,2,3 l(m) = 4,8,16 байт)
    486          @param[in] iv  Указатель на вектор иницилизации. 16 байт 
    487          @param[in] len Длинна данных
    488          @param[in,out] MIC Указатель на массив соответсвующий длинне (4,8,16 байт)
    489          */
    490          void AES_CCMEncrypt( uint8_t *src, uint8_t c, uint8_t f, uint8_t m,
    491                              uint8_t *key, uint8_t *nonce, uint8_t *MIC)
    492          {
    493            uint8_t lm = MIC_2_MICLEN(m);
    494            
    495            // Генерируем данные для авторизации
    496            uint8_t dlen = generateAuthData(src, nonce, c, f, lm);
    497            
    498            uint8_t mac[16]; // Сюда пишем мак
    499            CBCMAC_buf_encrypt(dlen, key, mac);
    500            
    501            // Шифруем MAC
    502            uint8_t CTR_IV[16];
    503            memcpy(CTR_IV, nonce, 16);
    504            CTR_IV[0] = 0x01; // Флаг режима CTR
    505            CTR_IV[15] = 0;   // Значение счетчика
    506            CTR_enc_decrypt(true, mac, mac, key, CTR_IV, 16);
    507            
    508            // Шифруем текст. он имеет размер 'c' и находится в буфере начиная с
    509            // dlen-c, dlen
    510            uint8_t ds = dlen - c; // Начало данных для шифрования
    511            
    512            // 0x0F & (16 - (dlen & 0x0f)) оставляет числа от 0 до 15  
    513            memset(buf+dlen, 0x00, 0x0F & (16 - (dlen & 0x0f)) ); // Дополняем нулями
    514            CTR_IV[15] = 1; // Счетчик CTR
    515            CTR_enc_decrypt(true, &buf[ds], &buf[ds], key, CTR_IV, c); // Шифруем
    516            
    517            // Заполняем буфер буфер src. src[0,f] это данные авторизации. 
    518            // src[f, f+c] это шифрованные данные.
    519            memcpy(&src[f], &buf[ds], c); 
    520            memcpy(MIC, mac, lm);
    521            
    522            //https://github.com/zhaohengyi/CC2530Example/blob/
    523            //master/source/components/radios/cc2530/hal_rf_security.c
    524          }
    525          
    526          /**
    527          @brief Дешифрует данные с проверкой MIC
    528          @param[in] src Указатель на данные подлежащии шифрованию
    529          @param[in] len Размер данных
    530          @param[in] с Количество байт для шифрования
    531          @param[in] f Количество байт для авторизации
    532          @param[in] m Размер MIC (m=1,2,3 l(m) = 4,8,16 байт)
    533          @param[in] iv  Указатель на вектор иницилизации. 16 байт 
    534          @param[in] len Длинна данных
    535          @param[in,out] MIC Указатель на массив соответсвующий длинне (4,8,16 байт)
    536          */
    537          bool AES_CCMDecrypt( uint8_t *src, uint8_t c, uint8_t f, uint8_t m,
    538                              uint8_t *key, uint8_t *nonce, uint8_t *MIC)
    539          {
    540            uint8_t lm = MIC_2_MICLEN(m);
    541            
    542            // Расшифровываем MAC
    543            uint8_t mac[16]; // Расшифрованый мак
    544            uint8_t CTR_IV[16];
    545            memcpy(CTR_IV, nonce, 16);
    546            CTR_IV[0] = 0x01; // Флаг режима CTR
    547            CTR_IV[15] = 0;   // Значение счетчика
    548            CTR_enc_decrypt(false, MIC, mac, key, CTR_IV, lm);  
    549            
    550            // Генерируем данные для авторизации
    551            uint8_t dlen = generateAuthData(src, nonce, c, f, lm);
    552            
    553            // Дешифруем текст. он имеет размер 'c' и находится в буфере начиная с
    554            // dlen-c, dlen
    555            uint8_t ds = dlen - c; // Начало данных для дешифрования
    556            
    557            // 0x0F & (16 - (dlen & 0x0f)) оставляет числа от 0 до 15  
    558            memset(buf+dlen, 0x00, 0x0F & (16 - (dlen & 0x0f)) ); // Дополняем нулями
    559            CTR_IV[15] = 1; // Счетчик CTR
    560            CTR_enc_decrypt(false, &buf[ds], &buf[ds], key, CTR_IV, c); // Дешифруем
    561            
    562            uint8_t new_mac[16]; // мак полученный в ходе рашифровки сообщения
    563            CBCMAC_buf_encrypt(dlen, key, new_mac);
    564            
    565            // Проверяем что маки совпадают, значит дешифровано верно
    566            bool mac_equal = true;
    567            for (uint8_t i = 0 ; i < lm ; i++)
    568            {
    569              if (mac[i] != new_mac[i])
    570              mac_equal = false;
    571              break;
    572            }
    573            
    574            // Выходим если MACи не совпали  
    575            if (!mac_equal)
    576              return false;
    577            
    578            // Копируем  расшифрованные данные
    579            memcpy(&src[f], &buf[ds], c); 
    580            return true;
    581          }
E:\WMNU\IAR\SHARE_PRJ_SRC\config.c
      1          #include "stdint.h"
      2          #include "string.h"
      3          #include "stdbool.h"
      4          #include "string.h"
      5          #include "basic.h"
      6          #include "config.h"
      7          
      8          static uint8_t default_key[16] = DEFAULT_KEY;
      9          static uint8_t default_iv[16] = DEFAULT_IV;
     10          database_s CONFIG;
     11          
     12          
     13          void CF_init()
     14          {
     15            // Загрузка данных из различных источников
     16            memcpy(CONFIG.stream_key, default_key, 16); 
     17            memcpy(CONFIG.stream_iv,  default_iv, 16);
     18            CONFIG.node_ver = NODE_VER;
     19            CONFIG.node_type = NODE_TYPE;
     20            CONFIG.sync_channel = DEFAULT_SYNC_CHANNEL;
     21            CONFIG.sys_channel = DEFAULT_SYS_CHANNEL;
     22            CONFIG.tx_power = DEFAULT_TX_POWER;
     23            CONFIG.panid = DEFAULT_PANID;
     24          }
E:\WMNU\IAR\SHARE_PRJ_SRC\delays.c
      1          /*!
      2          \file  Модуль измерения интервалов времени и функция задержки времени
      3          \brief Функции измерения времени и задержки
      4          */
      5          
      6          #include "ioCC2530.h"
      7          #include "delays.h"
      8          #include "string.h"
      9          
     10          #define TICK_NS  31.25 // Количество нс в одном такте TIM2
     11          #define TICK_US  0.03125 // Количество мкс в одном такте TIM2
     12          #define TICK_PER_US 32 // Количество тактов в одной микросекунде
     13          
     14          // Максимальное кол-во тактов таймера. Константа 40 бит, 5 байт
     15          static const uint32_t MAC_TIMER_MAX = 0xFFFFFFFFUL; 
     16          static uint32_t DELAY_CALIBRATE_TICS; // Колибровка функции задержки
     17          
     18          // Публичные методы
     19          void TIM_init(void);
     20          void TIM_TimeStamp(TimeStamp_s* timestamp);
     21          void TIM_delay(uint32_t delay);
     22          uint32_t TIM_passedTime(TimeStamp_s* start, TimeStamp_s* stop);
     23          void TIM_copy(TimeStamp_s *src, TimeStamp_s *dst);
     24          
     25          // Приватные
     26          static inline uint32_t Interval(TimeStamp_s* start, TimeStamp_s* stop);
     27          static void DelayCalibrate(void);
     28          
     29          /**
     30          @brief Иницилизация таймера
     31          @brief Используется таймер 2. MAC таймер
     32          */
     33          void TIM_init(void)
     34          {
     35            // Запускаем таймер, LATCH MODE = 1
     36            // Latch mode фиксирует значение таймера переполнения при чтении T2M0
     37            // ЗАпускаем MAC таймер без синхронизации с кварцем 32.768к
     38            T2CTRL = (1<<0) | (1<<3); 
     39            // Калибровка функции задержки
     40            DelayCalibrate();
     41          }
     42          
     43          /**
     44          @brief Возвращает временую метку.
     45          @params[out] timestamp указатель на временную метку 
     46          */
     47          void TIM_TimeStamp(TimeStamp_s* timestamp)
     48          {
     49            timestamp->byte[0] = T2M0;
     50            timestamp->byte[1] = T2M1;
     51            timestamp->byte[2] = T2MOVF0;
     52            timestamp->byte[3] = T2MOVF1;
     53          }
     54          
     55          /**
     56          @brief Калибровка функции задержки TIM_delay
     57          */
     58          static void DelayCalibrate(void)
     59          {
     60            #define ACCURATE_VAL_US 500 
     61            DELAY_CALIBRATE_TICS = 0;
     62            TimeStamp_s start, stop;
     63            uint32_t passed, cal;
     64            
     65            TIM_TimeStamp(&start);
     66            TIM_delay(ACCURATE_VAL_US);
     67            TIM_TimeStamp(&stop);
     68            passed = TIM_passedTime(&start, &stop);
     69            
     70            cal = passed - ACCURATE_VAL_US;
     71            DELAY_CALIBRATE_TICS = cal * TICK_PER_US; 
     72          };
     73          
     74          /**
     75          @brief Вычисляет количество тактов между двумя времеными метками
     76          @return Количество тактов
     77          */
     78          static inline uint32_t Interval(TimeStamp_s* start, TimeStamp_s* stop)
     79          {
     80            uint32_t ret;
     81          
     82            if (stop->timer >= start->timer)
     83              ret = stop->timer - start->timer;
     84            else
     85            { 
     86              ret = (MAC_TIMER_MAX - start->timer) + stop->timer;
     87            }
     88            return ret;
     89          }
     90          
     91          /**
     92          @brief Вычисляет прошедшее время между двумя времеными метками
     93          @return Время в мкс.
     94          */
     95          uint32_t TIM_passedTime(TimeStamp_s* start, TimeStamp_s* stop)
     96          {
     97            uint32_t ret = Interval(start, stop);
     98            
     99            ret = (uint32_t)((float)ret * TICK_US);
    100            return ret;
    101          }
    102          
    103          /**
    104          @brief Задержка на заданное количество мкс. 
    105          @details Погрешность около 20 мкс при значениях выше 150 мкс.
    106           Рекомендуется использовать для организации задержек не менее 200 мкс.
    107          @params[in] delay количество микросекунд. Не более 134217727 мкс (134.2 сек)
    108          */
    109          void TIM_delay(uint32_t delay)
    110          {
    111            uint32_t passed = 0;
    112            TimeStamp_s start, now;
    113            TIM_TimeStamp(&start);
    114            
    115            // Конвертируем мкс в такты и вносим поправку
    116            delay = delay * TICK_PER_US; 
    117            if (delay > DELAY_CALIBRATE_TICS)
    118              delay -= DELAY_CALIBRATE_TICS;
    119            
    120            do
    121            {
    122              TIM_TimeStamp(&now);
    123              passed = Interval(&start, &now);
    124            } while (passed < delay);
    125          }
    126          
    127          /**
    128          @brief Копирование временной метки
    129          @param[in] src указатель на исходную метку для копирование
    130          @param[out] dst указатель на метку назначения
    131          */
    132          void TIM_copy(TimeStamp_s *src, TimeStamp_s *dst)
    133          {
    134            memcpy(src, dst, sizeof(TimeStamp_s));
    135          }
E:\WMNU\IAR\SHARE_PRJ_SRC\dma.c
      1          #include "dma.h"
      2          #include "ioCC2530.h"
      3          
      4          DMA_s DMA_CH[5];
      5          
      6          /**
      7          @brief Настройка DMA каналов.
      8          @detail Согласно документации каналы 1-4 идут последовательно
      9          */
     10          void DMA_init()
     11          {
     12              // Настроим канал 0 DMA для загрузки данных в AES
     13            uint16_t CONF_ADDR = (uint16_t)&DMA_CH[0];
     14            DMA0CFGH = CONF_ADDR >> 8;
     15            DMA0CFGL = CONF_ADDR & 0xFF;
     16            
     17            // Настроим канал 1 DMA для выгрузки данных из AES
     18            CONF_ADDR = (uint16_t)&DMA_CH[1];
     19            DMA1CFGH = CONF_ADDR >> 8;
     20            DMA1CFGL = CONF_ADDR & 0xFF;
     21          }
E:\WMNU\IAR\SHARE_PRJ_SRC\frame.c
      1          /**
      2          @file Модуль описывает сетевой кадр и связанные с ним буферы данных
      3          @brief Типы frame
      4          */
      5          
      6          #include "frame.h"
      7          #include "string.h"
      8          #include "mem.h"
      9          #include "nwdebuger.h"
     10          #include "ioCC2530.h"
     11          
     12          frame_s* frame_create(void);
     13          void frame_delete(frame_s *fr);
     14          uint8_t frame_len(frame_s *fr);
     15          uint8_t frame_getCount(void);
     16          
     17          static uint8_t NBR_FRAME = 0; //!< Количество фреймов в памяти
     18          
     19          /**
     20          @brief Получить количество фреймов в памяти
     21          @return Возвращает количество фреймов
     22          */
     23          uint8_t frame_getCount(void)
     24          {
     25            return NBR_FRAME;
     26          }
     27          
     28          /**
     29          @brief Добавить заголовок
     30          @param[in] fr указатель на фрейм
     31          @param[in] src данные для добавления
     32          @param[in] len размер данных
     33          */
     34          void frame_addHeader(frame_s *fr, void *src, uint8_t len)
     35          {
     36            unsigned short EA_save = EA;
     37            EA = 0; 
     38            // Ранее небыло создано данных 
     39            if (fr->payload == NULL)
     40              {
     41                fr->payload = re_malloc(len);
     42                fr->len = len;
     43                re_memcpy(fr->payload, src, len);
     44                EA = EA_save;
     45                return;
     46              }
     47            
     48            uint8_t new_len = fr->len + len; // Новый размер
     49            void *new_payload = re_malloc(new_len);
     50            ASSERT(new_payload != NULL);
     51            
     52            // Копируем данные в конец области
     53            re_memcpy((char*)new_payload + len, fr->payload, fr->len);
     54            // Копируем данные спереди в свободную область
     55            re_memcpy(new_payload, src, len);
     56            // Уничтожаем старые данные
     57            re_free(fr->payload);
     58            fr->payload = new_payload;
     59            fr->len = new_len;
     60            EA = EA_save;
     61          }
     62          
     63          /**
     64          @brief Удалить заголовок
     65          @param[in] fr указатель на фрейм
     66          @param[in] len размер  удаляемых данных
     67          */
     68          void frame_delHeader(frame_s *fr, uint8_t len)
     69          {
     70            if (fr->payload == NULL)
     71              return;
     72          
     73            if (fr->len < len)
     74              return;  
     75            
     76            uint8_t new_len = fr->len - len; // Новый размер
     77            void *new_payload = re_malloc(new_len);
     78            ASSERT(new_payload != NULL);
     79            
     80            // Копируем данные с пропуском первых len байт
     81            re_memcpy((char*)new_payload, (char*)fr->payload + len, new_len);
     82            
     83            // Уничтожаем старые данные
     84            re_free(fr->payload);
     85            fr->payload = new_payload;
     86            fr->len = new_len;
     87          }
     88          
     89          /**
     90          @brief Создание структуры frame
     91          @return Указатель на структуру frame
     92          */
     93          frame_s* frame_create(void)
     94          {
     95              unsigned short EA_save = EA;
     96              EA = 0; 
     97              
     98              frame_s* fr= (frame_s*)re_malloc(FRAME_S_SIZE);
     99              ASSERT(fr != NULL);
    100              
    101              fr->payload = NULL;
    102              fr->len = 0;
    103              memset(&fr->meta, 0x00, META_S_SIZE);
    104              NBR_FRAME++;
    105              
    106              EA = EA_save;
    107              return fr;
    108          };
    109          
    110          /**
    111          @brief Удаление frame
    112          @detail Проуедура так же удаляет все связанные с ней буфера fbuf
    113          @param[in] fr указатель на структуру frame
    114          */
    115          void frame_delete(frame_s *fr)
    116          {
    117            unsigned short EA_save = EA;
    118            EA = 0;  
    119            
    120            if (fr->payload != NULL)
    121              re_free(fr->payload);
    122           
    123            NBR_FRAME--;
    124            re_free(fr);
    125            EA = EA_save;
    126          }
    127          
    128          
    129          /**
    130          @brief Вычисляет размер цепочки fbuf
    131          @param[in] fr указатель на frame_s
    132          @return Количество байт в цепочке буферов
    133          */
    134          uint8_t frame_len(frame_s *fr)
    135          {
    136            return fr->len;
    137          }
E:\WMNU\IAR\SHARE_PRJ_SRC\LLC.c
      1          /**
      2          @file 
      3          @brief Модуль содержит реализацию интерфейса радио для приема/передачи данных.
      4          */
      5          
      6          #include "LLC.h"
      7          #include "MAC.h"
      8          #include "TIC.h"
      9          #include "mem.h"
     10          #include "nwdebuger.h"
     11          #include "ioCC2530.h"
     12          
     13          // Публичные методы
     14          void LLC_Init(void);
     15          
     16          // Методы модуля
     17          void LLC_SetRXCallback(void (*fn)(frame_s *fr));
     18          void LLC_TimeAlloc(void (*fn)(void)); 
     19          bool LLC_AddTask(frame_s* fr);
     20          uint8_t LLC_GetTaskLen(void);
     21          void LLC_Reset(void);
     22          
     23          // Закрытые методы
     24          static void LLC_SE_HNDL(uint8_t TS); //!< Обработчик завешения слота TIC
     25          static void LLC_Shelduler(uint8_t TS);
     26          static void LLC_RX_HNDL(frame_s *fr); //!< Обработчик примема пакета
     27          static void LLC_RunTimeAlloc(void);
     28          
     29          // Переменные модуля
     30          #define UNICAST_SEND_ATEMPTS 5 //!< Количество попыток передачи пакета 
     31          #define BROADCAST_SEND_ATEMPTS 3 //!< Количество попыток передачи пакета 
     32          #define MAX_nbrTASKS 20 //!< Максимальное количество задач в очередях
     33          
     34          typedef struct LLCTask LLCTask;
     35          typedef struct TimeAllocFunc TimeAllocFunc;
     36          static bool tasksBLOCK; //!< блокировка доступа к LLCTask
     37          
     38          /**
     39          @brief Описание задачи модуля LLC
     40          */
     41          struct LLCTask
     42          {
     43            LLCTask *next; //!< Указатель на следующую задачу. NULL - конец очереди
     44            uint8_t TS; //!< Номер временого канала для передачи сообщения
     45            uint8_t CH; //!< Номера радиоканала для передачи сообщения
     46            frame_s *fr; //!< Указатель на данные для передачи
     47          };
     48          
     49          /**
     50          @brief Список функций вызываемых по завешению временного слота
     51          */
     52          struct TimeAllocFunc
     53          {
     54            TimeAllocFunc *next; //!< Указатель на следующую функцию. NULL - конец списка
     55            void (*fn)(void); //!< Указатель на функцию. NULL - нет обработчика
     56          };
     57          
     58          static LLCTask *FirstTask; //!< Указатель на первый элемент очереди задач
     59          static uint8_t nbrTasks; // Количество задач в очереди
     60          
     61          /**
     62          @brief Обратный вызов при приеме пакета данных
     63          */
     64          static void (*RXCallback)(frame_s *fr);
     65          
     66          /**
     67          @brief Первый элемент обработчика конца временного слота
     68          @details Элемент создается статически, все остальные задачи создаются re_malloc
     69          и добавляются к HeadAllocFunc.
     70          */
     71          static TimeAllocFunc HeadAllocFunc;
     72          
     73          /**
     74          @brief Инициализация модуля
     75          @detail Иницилизирует MAC
     76          */
     77          void LLC_Init(void)
     78          {  
     79            nbrTasks = 0; 
     80            tasksBLOCK = false;
     81            FirstTask = NULL;
     82            // TODO Очистить очередь HeadTask
     83            // Регистрируем обработчики
     84            TIC_SetSECallback(LLC_SE_HNDL); // Завершение временного слота
     85            MAC_SetRXCallback(LLC_RX_HNDL); // Принято сообщение
     86          }
     87          
     88          /**
     89          @brief Сброс модуля
     90          @detail Удаяляем все пакеты в очереди. Аллокатор времени не трогаем
     91          */
     92          void LLC_Reset(void)
     93          {
     94            LLCTask *task = FirstTask;
     95            LLCTask *next;
     96            
     97            while (task != NULL)
     98            {
     99              next = task;
    100              re_free(task);
    101              task = next;
    102            }
    103          }
    104          
    105          /**
    106          @brief Количество задач в очереди
    107          @return количество задач в очереди
    108          */
    109          uint8_t LLC_GetTaskLen(void)
    110          {
    111            return nbrTasks;
    112          }
    113          
    114          void LLC_SetRXCallback(void (*fn)(frame_s *fr))
    115          {
    116            ASSERT(fn != NULL);
    117            RXCallback = fn;
    118          }
    119          
    120          /**
    121          @brief Добавляет обработчик заверешения временого слота в список
    122          */
    123          void LLC_TimeAlloc(void (*fn)(void))
    124          {
    125            TimeAllocFunc *ta = re_malloc(sizeof(TimeAllocFunc));
    126            ASSERT(ta != NULL);
    127            ta->next = NULL;
    128            ta->fn = fn;
    129          
    130            // Перебираемся в конец списка
    131            TimeAllocFunc *next = &HeadAllocFunc;
    132            while (next->next != NULL)
    133              next = next->next;
    134            
    135            // Добавляем новый элемент
    136            next->next = ta;
    137          };
    138          
    139          /**
    140          @brief Добавляем задачу в очередь
    141          @brief Взовращает true если задача добавлена в очередь. false, если размер 
    142           очереди достиг максимального размера.
    143          */
    144          bool LLC_AddTask(frame_s* fr)
    145          {
    146             ASSERT(fr != NULL);
    147           
    148              if (nbrTasks == MAX_nbrTASKS)
    149                return false;
    150              
    151             // Ждем пока разблокируется доступ.
    152             while (tasksBLOCK);
    153             tasksBLOCK = true;
    154          
    155             // Создаем новую задачу
    156             LLCTask *new_task = (LLCTask*)re_malloc(sizeof(LLCTask));
    157             ASSERT(new_task !=NULL); 
    158                
    159             new_task->TS = fr->meta.TS;
    160             new_task->CH = fr->meta.CH;
    161             new_task->fr = fr;
    162             
    163            LOG_ON("Add task = %u, CH = %d, TS = %d, OTS = %d. fr = %d",
    164                (uint16_t)new_task,new_task->CH, new_task->TS, fr->meta.TS, (uint16_t)fr);
    165            
    166             // Если в очереди нет задач, добавим первую
    167             if (FirstTask == NULL) 
    168             {
    169               new_task->next = NULL;
    170               FirstTask = new_task;
    171             }
    172             // Если в очереди были задачи то вставим новую в голову списка
    173             else 
    174             {
    175               new_task->next = FirstTask;
    176               FirstTask = new_task;  
    177             }
    178             
    179             nbrTasks ++;
    180             tasksBLOCK = false;
    181          
    182             return true;
    183          }
    184          
    185          
    186          
    187          
    188          /**
    189          @brief Планировщик задач
    190          @details Соотносит задачи в очереди и свободные временные слоты MAC уровня.
    191          При освобождении временных слотов, планировщик устанавливает данные для 
    192          передачи в MAC.
    193          @param[in] TS номер текущего временого слота
    194          */
    195          static void LLC_Shelduler(uint8_t TS)
    196          {
    197            // Если работает функция добавления задачи, то обслуживание очереди не
    198            // производится. Это может привести к необычным последствиям
    199            if (tasksBLOCK)
    200              return;
    201            tasksBLOCK = true;
    202            
    203            // Перебираем попорядку весь список на отправку
    204            // HeadTask только указатель на первый элемент, сам он не подлежит отправке
    205            LLCTask *task = FirstTask;
    206            LLCTask *last = FirstTask;
    207            LLCTask *next = FirstTask;
    208            
    209            while (task != NULL)
    210            {    
    211              if (MAC_GetTXState(task->TS)) // Занят ли временой слот
    212              {
    213                // Если слот занят переходим к следующей задаче
    214                last = task;
    215                task = task->next;
    216                continue; 
    217              }
    218              
    219              //Выбераем количество попыток передачи в зависимости от типа пакета
    220              uint8_t attempts;
    221              if (task->fr->meta.TX_METHOD == UNICAST)
    222                attempts = UNICAST_SEND_ATEMPTS;
    223              else if (task->fr->meta.TX_METHOD == BROADCAST)
    224                attempts = BROADCAST_SEND_ATEMPTS;
    225              else
    226                ASSERT(false);
    227              
    228              MAC_Send(task->fr, attempts);
    229              
    230              next = task->next; // Запомним следующую задачу
    231              
    232              // Удаляем текущую задачу из списка
    233              if (task == FirstTask)
    234              {
    235              // Удаляемым элементом является указателем на голову
    236                 FirstTask = next;
    237                 last = FirstTask;
    238              }
    239              else
    240              {
    241                // Удаляемым элементом является промежуточный элемент
    242                last->next = next;
    243              }
    244              
    245              nbrTasks--;
    246              LOG_OFF("Free task = %u, nbrTasks = %d\r\n",
    247                  (uint16_t)task, nbrTasks); 
    248              re_free(task);
    249              task = next;
    250            }
    251            
    252            tasksBLOCK = false;
    253          }
    254          
    255          /**
    256          @brief Обработчик заверешния временого слота
    257          @details Обратный вызов из TIC. Обработчик вызывает планировщик задач очереди
    258          и передает управление зарегистрированым функциям с помощью LLC_TimeAlloc.
    259          @param[in] TS номер завершенного временого слота
    260          */
    261          static void LLC_SE_HNDL(uint8_t TS)
    262          {
    263            LLC_Shelduler(TS);
    264            LLC_RunTimeAlloc();
    265          }
    266          
    267          static void LLC_RX_HNDL(frame_s *fr)
    268          {
    269            ASSERT(RXCallback !=NULL);
    270            RXCallback(fr);
    271          }
    272          
    273          /**
    274          @brief Передаем управление зарегистрированным функциям
    275          */
    276          static void LLC_RunTimeAlloc(void)
    277          {
    278              TimeAllocFunc *next = &HeadAllocFunc;
    279            // HeadAllocFunc служит только для указания на первый элемент в очереди
    280            // так что его нужно пропустить и переходить сразу к next
    281            while (next->next != NULL)
    282            {
    283              next->next->fn();
    284              next = next->next;
    285            }
    286          }
E:\WMNU\IAR\SHARE_PRJ_SRC\MAC.c
      1          #include "MAC.h"
      2          #include "frame.h"
      3          #include "string.h"
      4          #include "nwdebuger.h"
      5          #include "coder.h"
      6          #include "TIC.h"
      7          #include "stdlib.h"
      8          #include "basic.h"
      9          #include "NTMR.h"  // ОТЛАДКА
     10          // Обработчики прерываний
     11          static void MAC_RX_HNDL(uint8_t TS);
     12          static void MAC_TX_HNDL(uint8_t TS);
     13          static void (*RXCallback)(frame_s *fr);
     14          static void BitRawDecrypt(uint8_t *src, uint8_t size);
     15          static void BitRawCrypt(uint8_t *src, uint8_t size);
     16          static uint8_t xor_calc(frame_s *fr);
     17          
     18          // Публичные методы
     19          void MAC_Init(void);
     20          void MAC_Reset(void);
     21          void MAC_Enable(bool en);
     22          void MAC_OpenRXSlot(uint8_t TS, uint8_t CH);
     23          void MAC_CloseRXSlot(uint8_t TS);
     24          void MAC_Send(frame_s *fr, uint8_t attempts);
     25          bool MAC_ACK_Send(frame_s *fr);
     26          void MAC_SetRXCallback(void (*fn)(frame_s *fr));
     27          bool MAC_GetTXState(uint8_t TS);
     28          bool MAC_GetRXState(uint8_t TS);
     29          
     30          // Ключ потокового шифрования и вектор иницилизации
     31          static uint8_t KEY[16] = DEFAULT_KEY;
     32          static uint8_t IV[16] = DEFAULT_IV;
     33            
     34          #define RECV_TIMEOUT 2500 // Время ожидания приема пакета в мкс с начала слота
     35          #define ACK_RECV_TIMEOUT 1000 // Время ожидания приема подтверждения в мкс
     36          #define TX_DELAY 1*Tmsec // Смещение при передаче пакета. Защита от девиации времени
     37          
     38          typedef struct // Формат структуры пакета ACK
     39          {
     40            uint16_t CRC8;
     41          } __attribute__((packed)) ACK_s;
     42          
     43          typedef struct
     44          {
     45           struct 
     46           {
     47             bool enable;
     48             uint8_t attempts;
     49             uint8_t CH;
     50             frame_s *fr;
     51           } __attribute__((packed)) TX;
     52           
     53           struct
     54           {
     55            bool enable; 
     56            uint8_t CH;
     57           } __attribute__((packed)) RX;
     58          } __attribute__((packed)) MACSState_s; 
     59          
     60          static bool MAC_ENABLE_MODULE = false; //!< Модуль активен
     61          
     62          
     63          // Таблица состояний слотов приема/передачи
     64          MACSState_s MACSlotTable[50];
     65          
     66          /**
     67          @brief Установить вектор иницилизации для шифрования
     68          @param[in] ptr_IV указатель на 16 байтный вектор иницилизации
     69          */
     70          void MAC_setIV(void* ptr_IV)
     71          {
     72            memcpy(IV, ptr_IV, 16);
     73          }
     74          
     75          /**
     76          @brief Установить ключ шифрования
     77          @param[in] ptr_KEY указатель на 16 байтный ключ
     78          */
     79          void MAC_setKEY(void* ptr_KEY)
     80          {
     81            memcpy(KEY, ptr_KEY, 16);
     82          }
     83          
     84          /**
     85          @brief Иницилизация MAC
     86          @detail Инизилизирует TIM, TIC, RI, AES
     87          */
     88          void MAC_Init(void)
     89          {
     90            MAC_ENABLE_MODULE = false;
     91            TIC_SetRXCallback(MAC_RX_HNDL);
     92            TIC_SetTXCallback(MAC_TX_HNDL);  
     93            memset(MACSlotTable, 0x00, 50*sizeof(MACSState_s));
     94          }
     95          
     96          /**
     97          @brief Сброс настроек модуля.
     98          @detail Удаяляет все пакеты для передачи. Активным остается TS1 обработчик sync
     99          */
    100          void MAC_Reset(void)
    101          {
    102            MAC_ENABLE_MODULE = false;
    103            // Удаляем все пакеты на передачу
    104            for (uint8_t i = 0; i < 50; i++)
    105              if (MACSlotTable[i].TX.enable)
    106                frame_delete(MACSlotTable[i].TX.fr);
    107            
    108            memset(MACSlotTable, 0x00, 50*sizeof(MACSState_s));
    109          }
    110          
    111          /**
    112          @brief Открыть временой слот приема данных
    113          @param[in] TS номер слота от 0 до 49
    114          @param[in] CH номер радиоканала
    115          */
    116          void MAC_OpenRXSlot(uint8_t TS, uint8_t CH)
    117          {
    118              ASSERT(TS < 50 || TS !=0 );
    119              MACSlotTable[TS].RX.enable = true;
    120              MACSlotTable[TS].RX.CH = CH;
    121              TIC_SetRXState(TS, true);
    122          }
    123          
    124          /**
    125          @brief Закрыть временой слот приема данных
    126          @param[in] TS номер слота от 0 до 49
    127          */
    128          void MAC_CloseRXSlot(uint8_t TS)
    129          {
    130            ASSERT(TS < 50 || TS !=0);
    131            MACSlotTable[TS].RX.enable = false;
    132            TIC_SetRXState(TS, false);
    133          }
    134          
    135          /**
    136          @brief Поставить пакет в таблицу отправки сообщений
    137          @param[in] fr указатель на пакет
    138          @param[in] attempts количество попыток
    139          */
    140          void MAC_Send(frame_s *fr, uint8_t attempts)
    141          {
    142              ASSERT(fr != NULL);
    143              ASSERT(attempts != 0);
    144              ASSERT(fr->meta.TS != 0);
    145              
    146              uint8_t TS = fr->meta.TS; 
    147              MACSlotTable[TS].TX.attempts = attempts;
    148              MACSlotTable[TS].TX.CH = fr->meta.CH;
    149              MACSlotTable[TS].TX.enable = true;
    150              MACSlotTable[TS].TX.fr = fr;
    151              
    152              #ifdef RARIO_STREAM_ENCRYPT
    153              BitRawCrypt(fr->payload, fr->len);
    154              #endif
    155              
    156              TIC_SetTXState(TS, true);
    157          }
    158          
    159          void MAC_Enable(bool en)
    160          {
    161            MAC_ENABLE_MODULE = en;
    162          }
    163          
    164          /**
    165          @brief Расчитывает CRC8 код
    166          @param[in] fr указатель на кадр
    167          @return CRC8
    168          */
    169          static uint8_t xor_calc(frame_s *fr)
    170          {
    171            uint8_t crc = 0x34; // Начальное значение
    172            uint8_t *val = fr->payload;
    173            
    174            for (uint8_t i = 0; i < fr->len; i++)
    175              crc ^= val[i];
    176            return crc;
    177          }
    178          
    179          /**
    180          @brief Посылает подтверждение приема пакета
    181          @param[in] fr указатель на кадр который нужно подтвердить
    182          @return true если передача подтверждения успешна (канал свободен)
    183          */
    184          static bool MAC_ACK_Send(frame_s *fr)
    185          {
    186            static ACK_s pACK;
    187            frame_s *fr_ACK;
    188            
    189            // Создаем подтверждение кадра
    190            pACK.CRC8 = xor_calc(fr);
    191            
    192            // Создаем кадр для отправки
    193            fr_ACK = frame_create();
    194            frame_addHeader(fr_ACK, &pACK, sizeof(ACK_s));
    195            fr_ACK->meta.SEND_TIME = 0;
    196            
    197           
    198            bool res = RI_Send(fr_ACK);
    199            frame_delete(fr_ACK);
    200            return res;
    201          }
    202          
    203          /**
    204          @brief Ожидает прием пакета подтверждения
    205          @param[in] fr указатель на пакет подтверждение которого ожидаем 
    206          @return true если приняли подтверждение
    207          */
    208          static bool MAC_ACK_Recv(frame_s *fr)
    209          {
    210            // Приемник чуть позднее присылает ACK
    211            // Задержка связана с включением приемника на передачу
    212            TIM_delay(800); 
    213            frame_s *fr_ACK = RI_Receive(ACK_RECV_TIMEOUT);
    214            
    215            // Если пакета нет, выходим из обработчика
    216            if (fr_ACK == NULL)
    217              return false;
    218            
    219            // Проверим размер пакета
    220            if (fr_ACK->len != sizeof(ACK_s))
    221            {
    222              frame_delete(fr_ACK);
    223              return false;
    224            }
    225              
    226            ACK_s *ptrACK;
    227            ptrACK = (ACK_s*)fr_ACK->payload;
    228            
    229            uint8_t crc8 = xor_calc(fr);
    230            uint8_t ack_crc8 = ptrACK->CRC8;
    231            frame_delete(fr_ACK);
    232            
    233            if (crc8 == ack_crc8)
    234              return true;
    235            return false;
    236          }
    237          
    238          /**
    239          @brief Устанавливает функцию обратного вызова при приеме пакета
    240          @param[in] fn указатель на функцию обработчик
    241          */
    242          void MAC_SetRXCallback(void (*fn)(frame_s *fr))
    243          {
    244            RXCallback = fn;
    245          }
    246          
    247          /**
    248          @brief Состояние слота TS передача
    249          @return возвращает true, если слот содержит пакет для передачи
    250          */
    251          bool MAC_GetTXState(uint8_t TS)
    252          {
    253            ASSERT(TS < 50  || TS !=0 );
    254            return MACSlotTable[TS].TX.enable;
    255          }
    256          
    257          /**
    258          @brief Состояние слота TS приема
    259          @return возвращает true, если слот принимает пакет
    260          */
    261          bool MAC_GetRXState(uint8_t TS)
    262          {
    263            ASSERT(TS < 50  || TS !=0);
    264            return MACSlotTable[TS].RX.enable;
    265          }
    266          
    267          /**
    268          @brief Обработчик слота приема пакета
    269          @detail При необходимости подтвеждает пакет
    270          @param[in] TS номер временного слота
    271          */
    272          static void MAC_RX_HNDL(uint8_t TS)
    273          {
    274            ASSERT(TS < 50  || TS !=0);
    275          
    276            if (!MAC_ENABLE_MODULE) // Модуль откючен
    277              return;
    278            
    279            // Задержка перед приемом. Прием начинается через 427мкс и заканчивается в
    280            // 3.2 мс от начала слота. Длительность 2.8мс. Длятельность больше 2мс так
    281            // как SDF приходит позже чем фактическая передача на 400мкс
    282            TIM_delay(200);
    283            RI_SetChannel(MACSlotTable[TS].RX.CH);
    284            frame_s *fr = RI_Receive(RECV_TIMEOUT);
    285          
    286          //volatile uint16_t DBGT= NT_GetTime();  
    287            
    288           // frame_s *fr = RI_Receive(2000);
    289            
    290          //volatile uint16_t DBGT2= NT_GetTime();   
    291            // Если пакета нет, выходим из обработчика
    292            if (fr == NULL)
    293              return;
    294            
    295            fr->meta.TS = TS;
    296            // Пакеты во временные слоты 1..49 требуют подтверждения
    297            // Слоты 0 и 1 для швс и синхронизации соответсвенно
    298            bool acked ;
    299            if (TS > 1)
    300              acked = MAC_ACK_Send(fr);
    301           
    302            // Дешифруем пакет при необходимости
    303            #ifdef RARIO_STREAM_ENCRYPT
    304            BitRawDecrypt(fr->payload, fr->len);
    305            #endif
    306            
    307            RXCallback(fr);   // Передаем пакет на дальнейшую обработку
    308            // Удаление пакета не наша забота
    309          }
    310          
    311          /**
    312          @brief Обработчик слота пердачи пакета
    313          @detail После отправки пакета требуется подтверждение приема если meta.ACK = 1.
    314           После отправки ждем приема ACK. Проверка подлинности ACK происходит с помощью
    315           обратного вызова isACK_OK(*fr, *fr_ACK). Результат true или false.
    316           Передача начинается через 1.5 мс.
    317          @param[in] TS номер временного слота
    318          */
    319          static void MAC_TX_HNDL(uint8_t TS)
    320          {
    321            ASSERT(TS < 50  || TS !=0);
    322            
    323            if (!MAC_ENABLE_MODULE) // Модуль отключен
    324              return;
    325            
    326            // По ошибки вызвали. Такого быть не должно, но подстрахуемся.
    327            if ((!MACSlotTable[TS].TX.enable) || (MACSlotTable[TS].TX.attempts == 0)) 
    328            {
    329              TIC_SetTXState(TS, false);
    330              return;
    331            }
    332            
    333            RI_SetChannel(MACSlotTable[TS].TX.CH); // Устанавливаем канал передачи
    334          //volatile uint16_t DBGT = 5;
    335          //DBGT= NT_GetTime();
    336            // Задержка перед передачей данных необходима для учета отклонения
    337            // времени между узлами из-за рассинхронизации узлов.
    338            // Задержка составляет 1.5 мс (49 тактов сети)
    339            // В delay число 918, оно учитывает время включения радио, контроля CCA
    340            // и начал передачи будет чере 1.5мс
    341          //volatile uint16_t DBGT= NT_GetTime();
    342              TIM_delay(918);
    343            // Пробуем передать данные
    344            bool tx_success = RI_Send(MACSlotTable[TS].TX.fr); 
    345            bool send_success = false;  
    346            
    347            LOG_OFF("RI_Send = %d, CH = %d, TS = %d\r\n",
    348                tx_success, MACSlotTable[TS].TX.CH, TS);
    349          //DBGT= NT_GetTime();    
    350            if (tx_success)
    351            {
    352              if (TS > 1) // требуется подтверждение ACK
    353              {
    354                if (MAC_ACK_Recv(MACSlotTable[TS].TX.fr))
    355                    send_success = true;
    356              }
    357              else // не требуеться подтверждение
    358                send_success = true;
    359            }
    360            
    361          
    362            if (send_success) // В случаи успеха удаляем данные и закрываем слоты 
    363            { 
    364              frame_delete(MACSlotTable[TS].TX.fr);
    365              MACSlotTable[TS].TX.enable = false;
    366              TIC_SetTXState(TS, false);      
    367            }
    368            else // Уменьшаем счетчик попыток передачи и удаляем пакет при достижении 0.
    369            {
    370              MACSlotTable[TS].TX.attempts --;
    371              if (MACSlotTable[TS].TX.attempts == 0)
    372                {
    373                  frame_delete(MACSlotTable[TS].TX.fr);
    374                  MACSlotTable[TS].TX.enable = false;
    375                  TIC_SetTXState(TS, false);  
    376                }
    377            }
    378          }
    379          
    380          /*!
    381          \brief Расшифровка область памяти
    382          \param[in,out] *src Указатель на начало области дешифрования
    383          \param[in] size Размер расшифруемых данных
    384          */
    385          static void BitRawDecrypt(uint8_t *src, uint8_t size)
    386          {
    387            AES_StreamCoder(false, src, src, KEY, IV, size);
    388          }
    389          
    390          /*!
    391          \brief Шифрует область памяти
    392          \param[in,out] *src Указатель на начало области шифрования
    393          \param[in] size Размер шифруемых данных
    394          */
    395          static void BitRawCrypt(uint8_t *src, uint8_t size)
    396          {
    397            AES_StreamCoder(true, src, src, KEY, IV, size);
    398          }
    399          
E:\WMNU\IAR\NeocoreGateway\src\main.c
      1          #include "manager.h"
      2          #include "nwdebuger.h"
      3          #include "ioCC2530.h"
      4          #include "stdint.h"
      5          #include "uart_comm.h"
      6          #include "cmd_parser.h"
      7          
      8          
      9          #ifndef GATEWAY
     10          #warning ENABLE GATEWAY DEFINE
     11          #endif
     12          
     13          // Собирать проект с ключем GATEWAY в файле basic.h
     14          void main(void)
     15          {
     16            neocore_hw_init();
     17            P1DIR |= 0x01;
     18            network_seed_enable(false);
     19            com_uart_init();
     20            parse_uart_stream();
     21          }
E:\WMNU\IAR\SHARE_PRJ_SRC\manager.c
      1          #include "manager.h"
      2          #include "coder.h"
      3          #include "delays.h"
      4          #include "frame.h"
      5          #include "LLC.h"
      6          #include "MAC.h"
      7          #include "NTMR.h"
      8          #include "RADIO.h"
      9          #include "TIC.h"
     10          #include "sync.h"
     11          #include "config.h"
     12          #include "frame.h"
     13          #include "nwdebuger.h"
     14          #include "basic.h"
     15          #include "config.h"
     16          #include "ioCC2530.h"
     17          #include "dma.h"
     18          #include "rx_buff.h"
     19          
     20          static void MG_Init();
     21          
     22          static bool MG_MODULES_INITED = false; //!< Были ли запущенны аппаратные модули
     23          static bool NETWORK_SEED = false; //!< Раздача сети шлюзом
     24          
     25          // Публичные методы
     26          void neocore_hw_init();
     27          bool neocore_stack_reset();
     28          void network_seed_enable(bool en);
     29          bool network_discovery(uint8_t timeout_ms);
     30          bool MG_Connect();
     31          
     32          // Переменные модуля
     33          
     34          /**
     35          @brief Начальная иницилизация стека
     36          */
     37          static void MG_Init()
     38          {
     39            NETWORK_SEED = false;
     40            DMA_init();
     41            CF_init();
     42            NT_Init();
     43            TIM_init();
     44            TIC_Init();
     45            RI_init();
     46            AES_init();
     47            MAC_Init();
     48            SY_Init();
     49            LLC_Init();
     50            
     51          #ifdef GATEWAY
     52            RXB_Init();
     53          #endif
     54            
     55            // Загрузка дефолтных параметров
     56            MAC_setIV(CONFIG.stream_iv);
     57            MAC_setKEY(CONFIG.stream_key);
     58            SY_setIV(CONFIG.stream_iv);
     59            SY_setKEY(CONFIG.stream_key);  
     60            // TODO Необходимо очищать все ранее выделеную память malloc
     61          }
     62          
     63          /**
     64          @brief Иницилизация аппаратуры стека
     65          */
     66          void neocore_hw_init()
     67          {
     68            if (!MG_MODULES_INITED){
     69              MG_Init();
     70              MG_MODULES_INITED = true;
     71            }  
     72          }
     73          
     74          /**
     75          @brief Сброс всех настроек стека и удаление пакетов
     76          */
     77          bool neocore_stack_reset(){
     78            TIC_Reset();
     79            MAC_Reset();
     80            SY_Reset();
     81            LLC_Reset();
     82            RI_Reset();
     83          #ifdef GATEWAY
     84            RXB_Reset();
     85          #endif
     86          
     87            network_seed_enable(false);
     88            
     89            // Проверим все ли пакеты уничтожены
     90            uint8_t nbrF = frame_getCount(); 
     91            ASSERT(nbrF == 0);
     92            if (!nbrF)
     93              return true;
     94            return false;
     95          }
     96          
     97          /**
     98          @brief Алгоритм подключения к сети
     99          @param[in] timeout_ms время поиска сети
    100          */
    101          bool network_discovery(uint8_t timeout_ms)
    102          {
    103            uint16_t panid;
    104            bool con = false;
    105            
    106            // Тупой алгоритм поиска сети.
    107            while (!con)
    108            {
    109              con = SY_SYNC_NETWORK(&panid, timeout_ms);
    110            }
    111            
    112            if (con){ // После синх. разрешаем обработку слотов
    113              NETWORK_SEED = true;
    114              MAC_Enable(true);
    115              SY_Enable(true);
    116            }
    117            return con;
    118          }
    119          
    120          /**
    121          @brief Начинаем раздачу сети
    122          @param[in] en true начать раздачу сети
    123          */
    124          void network_seed_enable(bool en)
    125          {
    126            if (en){
    127              
    128              MAC_setIV(CONFIG.stream_iv);
    129              MAC_setKEY(CONFIG.stream_key);
    130              SY_setIV(CONFIG.stream_iv);
    131              SY_setKEY(CONFIG.stream_key);    
    132              
    133              NETWORK_SEED = true;
    134              MAC_Enable(true);
    135              SY_Enable(true);
    136            }
    137            else{ 
    138              NETWORK_SEED = false;
    139              MAC_Enable(false);
    140              SY_Enable(false);
    141            }
    142          }
    143          
    144          /**
    145          @brief Возвращает состояние сети
    146          @return true если сеть раздается
    147          */
    148          bool get_network_seed_status(void){
    149            return NETWORK_SEED;
    150          }
    151          
    152           
    153            
E:\WMNU\IAR\SHARE_PRJ_SRC\mem.c
      1          #include "ioCC2530.h"
      2          #include "stdlib.h"
      3          #include "stdint.h"
      4          #include "string.h"
      5          #include "nwdebuger.h"
      6          
      7          void re_free(void* ptr);
      8          void* re_malloc(size_t size);
      9          uint16_t heap_ptr(size_t size);
     10          void re_memcpy(void *dst, const void *src, size_t n);
     11          
     12          /**
     13          @brief Возвращает адрес следующего свободного участка памяти
     14          @detail Функция нужна для оценки использования стека
     15          @param[in] size размер запрашиваемой области
     16          @return если памяти нету возвращает 0, иначе адрес свободного участка.
     17          */
     18          uint16_t heap_ptr(size_t size)
     19          {
     20            unsigned short EA_save = EA;
     21            EA = 0; 
     22            uint16_t *heap_ptr;
     23            heap_ptr = (uint16_t*)re_malloc(size);
     24            re_free(heap_ptr);
     25            EA = EA_save;
     26            return (uint16_t)heap_ptr;
     27          }
     28          
     29          /**
     30          @brief Реентерабельное копирование памяти
     31          */
     32          void re_memcpy(void *dst, const void *src, size_t n)
     33          {
     34            unsigned short EA_save = EA;
     35            EA = 0;
     36            memcpy(dst, src, n);
     37            EA = EA_save;  
     38          }
     39          
     40          /**
     41          @brief Реентерабельное выделение памяти
     42          */
     43          void* re_malloc(size_t size)
     44          {
     45            unsigned short EA_save = EA;
     46            void* ptr; 
     47            EA = 0;
     48            ptr = malloc(size);
     49            EA = EA_save;
     50            //LOG(MSG_OFF | MSG_INFO | MSG_TRACE, "malloc = %d, L= %d \r\n", (uint16_t)ptr, size);
     51            return ptr;
     52          }
     53          
     54          /**
     55          @brief Реентерабельное освобождение памяти
     56          */
     57          void re_free(void* ptr)
     58          {
     59            unsigned short EA_save = EA;
     60            EA = 0;
     61            free(ptr);
     62            EA = EA_save;
     63            //LOG(MSG_OFF | MSG_INFO | MSG_TRACE, "free = %d\r\n", (uint16_t)ptr);  
     64          }
E:\WMNU\IAR\SHARE_PRJ_SRC\NTMR.c
      1          #include "NTMR.h"
      2          #include "stdlib.h"
      3          #include "ioCC2530.h"
      4          #include "nwdebuger.h"
      5          
      6          /**
      7          @file 
      8          @brief Модуль управления таймером сна
      9          @details При создании обьекта с помощью NT_Create, производится иницилизация
     10           аппаратного таймера сна и он переходит в активное состояние. Если установлено 
     11           определение #define USE_OSC32K будет использван внешний кварц.
     12           За установку глобального прерывания IE отвечает пользователь.
     13           Для использования модуля необходимо установить обработчик прерывания
     14           NT_SetEventCallback(..). Далее с помощью NT_SetCompare(..) установить
     15           время срабатывания прерывания, она же включит прерывание таймера. 
     16           Перед вызовом пользовательского обработчика, запрещается прерывание таймера,
     17           пользователь должен установить его повторно на необходимое время.
     18           Модуль сна пробуждает МК из режимов PM1,PM2, но не переводит их обратно.
     19           После завершения обработки прерывание, продолжится выполнение основного 
     20           потока программы. Пользователь самостоятельно должен перевести МК в режим сна.
     21           Функция NT_SetTime(..) производит подстройку времени сети и корректирует время
     22           срабатывания прерывания. Что бы было понятнее приведу пример: 
     23           Время сети 400 и установленно прерывание на 700.
     24           Пользователь корректирует время на 300, но из-за разной разрядности счетчиков
     25           прерывание произойдет по "старым часам", так как NT_SetTime только изменит
     26           переменную относительного смещения, а не непосредственно значение счетчика.
     27           Поэтому необходимо пересчитать время прерывания 700 к новому смещению.
     28           Из найденных особенностей: когда вызывается обработчик прерывания, значение
     29           времени всегда больше на 2 тика. Предполагаю из за ожидания синхронизации при
     30           чтении значения таймера. 
     31          */
     32          
     33          
     34          // После вызова EventCallback аппаратное прерывание завершается
     35          // и управление передается в главный цикл main.
     36          // Пользователь сам должен положить систему в сон
     37          // Для работы используется sleep timer.
     38          // Значение таймера изменить нельзя, он автоматически стартует после
     39          // Включения микроконтроллера. Нам нужно выбрать XOSC вместо RCOSC,
     40          // Но на отладочной плате нет резонатора
     41          // Чтение значения ST2:ST1:ST0 первым из ST0
     42          // Таймер работает во всех режимах кроме PM3
     43          // После пробуждения нужно убеиться что SLEEPSTA.CLK32K бит установлен прежде 
     44          // чем считывать ST0-3
     45          
     46          
     47          #define USE_OSC32K // Использовать внешний квац 32.768 кГц
     48          
     49          // Методы модуля
     50          bool NT_SetTime(uint16_t ticks);
     51          void NT_SetCompare(uint16_t ticks);
     52          void NT_SetEventCallback(void (*fn)(uint16_t ticks));
     53          uint16_t NT_GetTime(void);
     54          uint16_t NT_WaitTime(uint16_t ticks);
     55          
     56          // Приватные методы
     57          static uint32_t ReadTimer(void);
     58          static void loadTimerCompare(uint32_t ticks);
     59          static inline bool isIRQEnable(void);
     60          static inline void NT_IRQEnable(bool state);
     61          
     62          // Переменные модуля
     63          static void (*EventCallback)(uint16_t ticks);
     64          static uint32_t COMPARE_TIME; //!< Значение загруженное в регистр compare
     65          
     66          /**
     67          @details Смещение времени сети относительно времени таймера.
     68           NETWORK TIME = TIMER + TOFFSET
     69          */
     70          uint16_t TOFFSET; 
     71          
     72          /**
     73          @brief Инизиализация таймера
     74          */
     75          void NT_Init(void)
     76          {
     77            TOFFSET = 0;
     78            COMPARE_TIME = 0;
     79            EventCallback = NULL;
     80          
     81            // Сначало нужно настроить кварц 32кГц только потом поднимать
     82            // основной квар до 32 Мгц
     83            #ifdef USE_OSC32K
     84            CLKCONCMD &= ~(1<<7); // Сбрасываем бит OSC32K, будет выбран 32.768 кварц
     85            while (CLKCONSTA & (1<<7)); // Ждем пока бит не станет 0
     86            #endif
     87          
     88            // Переходим на 32 Мгц
     89            CLKCONCMD = 0;// (1<<3);
     90            while (CLKCONSTA&(1<<6));
     91            
     92            NT_IRQEnable(false);
     93            EA = 1;
     94          }
     95          
     96          /**
     97          @brief Устанавливаем текущее время сети и переустанавливает capture time
     98          @param[in] ticks время от 0-32767. Один tick 1/32768
     99          @return true если аргумент в диапазоне
    100          */
    101          bool NT_SetTime(uint16_t ticks)
    102          {
    103            ASSERT(ticks < 32768);
    104            if (ticks > 32767)
    105              return false;
    106           
    107            uint16_t timer = ReadTimer();
    108            TOFFSET = ticks - timer;
    109            TOFFSET &= 0x7FFF;
    110          
    111            // После установки времени нужно изменить compare time в таймере
    112            // Но только в случаи если прерывание активно
    113            if (isIRQEnable())
    114            {
    115              NT_SetCompare(COMPARE_TIME);
    116            }
    117          
    118            return true;
    119          }
    120          
    121          /**
    122          @brief Вычисляет значение, которое нужно установить в регистр compare таймера.
    123          @params[in] ticks время сети в тикак
    124          */
    125          static inline uint32_t calcCompareTime(uint16_t ticks)
    126          {   
    127              uint32_t timer = ReadTimer(); // Текущее значение счетчика
    128              
    129              //NETWORK TIME = TIMER + TOFFSET  
    130              // Приводим такты к тактам таймера
    131              uint16_t ticks_offset = (ticks - TOFFSET) & 0x7FFF;
    132              
    133              uint32_t cmp_time = timer & ~0x7FFF; // Убираем младшие 15 бит
    134              cmp_time |= ticks_offset; // Вычисляем новое время
    135              
    136              if (cmp_time <= timer)
    137              {
    138                cmp_time += 0x8000;
    139                cmp_time &=0xFFFFFF;
    140              }
    141                
    142               LOG_OFF("Timer = %lu, Ticks = %d,CMP = %lu \r\n",
    143                    timer, ticks, cmp_time );
    144              return cmp_time;
    145          }
    146          
    147          /**
    148          @brief Устанавливает время прерывания
    149          @details Время прерывания устанавливается относительно времени сети
    150          ,к примеру, что бы проснуться в таймслот номер 0, нужно установить ticks = 0.
    151          Процедура учитывает текущее значение таймера и перерасчитывает значение ticks. 
    152          @params[in] ticks время сети в тиках когда нужно проснуться
    153          */
    154          void NT_SetCompare(uint16_t ticks)
    155          {
    156            ASSERT(ticks < 32768);
    157            
    158            COMPARE_TIME = ticks; // Сохраняем установленное значение
    159           
    160            uint32_t compare_time = calcCompareTime(ticks);
    161           
    162            loadTimerCompare(compare_time);
    163            NT_IRQEnable(true);
    164          }
    165          
    166          /**
    167          @brief Разрешение прерываний таймера сна
    168          @params[in] state = true - разрешить обработку прерываний
    169          */
    170          static inline void NT_IRQEnable(bool state)
    171          {
    172            STIF = 0;
    173            if (state)
    174            {
    175              STIE = 1;
    176            }
    177            else
    178            {
    179              STIE = 0;
    180            }
    181          }
    182          
    183          /**
    184          @brief Проверка активности прерывания таймера
    185          @return true если прерывание установленно
    186          */
    187          static inline bool isIRQEnable(void)
    188          {
    189            if (STIE)
    190              return true;
    191            else 
    192              return false;
    193          }
    194          
    195          /**
    196          @brief Устанавливает обработчик прерывания таймера
    197          @param[in] fn(uint16_t ticks) указатель на функцию-обработчик
    198          */
    199          void NT_SetEventCallback(void (*fn)(uint16_t ticks))
    200          {
    201            EventCallback = fn;
    202          }
    203          
    204          /**
    205          @brief Возвращает время сети 
    206          @return Время сети в тиках
    207          */
    208          uint16_t NT_GetTime(void)
    209          {
    210            uint32_t val = ReadTimer();
    211            // TOFFSET = NETWORK TIME - TIMER
    212            // NETWORK TIME = TIMER + TOFFSET
    213            val +=TOFFSET;
    214            val &= 0x7FFF; // Приводим значения таймера к 0-32767
    215            return val;
    216          }
    217          
    218          /**
    219          @brief Обработчик прерывания таймера сна
    220          */
    221          #pragma vector=ST_VECTOR
    222          __interrupt void TimerCompareInterrupt(void)
    223          {  
    224            uint16_t ticks = NT_GetTime();
    225            if (EventCallback == NULL)
    226              return;
    227            // Отключаем прерывание таймера. Забота пользователя его включить
    228            NT_IRQEnable(false); 
    229            EventCallback(ticks); // Вызываем пользовательский обработчик
    230            STIF = 0; // Очищаем флаг прерывания
    231          }
    232          
    233          /**
    234          @breif Ожидание наступления времени сети
    235          @param[in] ticks время в тактах
    236          @return фактическое время сети
    237          */
    238          uint16_t NT_WaitTime(uint16_t ticks)
    239          {
    240            static union 
    241            {
    242              uint32_t val;
    243              uint8_t fild[4];
    244            } val;
    245            
    246            val.val = 0;
    247            // TOFFSET = NETWORK TIME - TIMER
    248            // NETWORK TIME = TIMER + TOFFSET
    249            
    250            // Ждем синхронизацию таймера после пробуждения
    251            while (!(SLEEPSTA & 0x01));
    252            
    253            do
    254            {
    255              // Соблюдаем порядок чтения регисторов ST  
    256              val.fild[0] = ST0;
    257              val.fild[1] = ST1;
    258              val.fild[2] = ST2;
    259              val.val +=TOFFSET;
    260              val.val &= 0x7FFF; // Приводим значения таймера к 0-32767    
    261            } while (val.val < ticks);
    262            return val.val;
    263          }
    264          
    265          /**
    266          @brief Возвращает текущее значение таймера
    267          @return Текущие ticks
    268          */
    269          static uint32_t ReadTimer(void)
    270          {
    271            static union 
    272            {
    273              uint32_t val;
    274              uint8_t fild[4];
    275            } ret_val;
    276            
    277            ret_val.val = 0;
    278            
    279            // Ждем синхронизацию таймера после пробуждения
    280            while (!(SLEEPSTA & 0x01));
    281            
    282            // Соблюдаем порядок чтения регисторов ST  
    283            ret_val.fild[0] = ST0;
    284            ret_val.fild[1] = ST1;
    285            ret_val.fild[2] = ST2;
    286            return ret_val.val;
    287          }
    288          
    289          /**
    290          @brief Устанавливает время пробуждения микроконтролера
    291          @params[in] ticks 24 битное значение времени пробуждения в ticks
    292          */
    293          static void loadTimerCompare(uint32_t ticks)
    294          {
    295            union 
    296            {
    297              uint32_t val;
    298              uint8_t fild[4];
    299            } value;
    300            
    301            value.val = ticks;
    302            
    303            // Ждем разрешения на запись нового значения
    304            while (!(STLOAD & 0x01));
    305            
    306            // Регистр ST0 должен быть записан в последнию очередь
    307            ST2 = value.fild[2];
    308            ST1 = value.fild[1];
    309            ST0 = value.fild[0];
    310          }
E:\WMNU\IAR\SHARE_PRJ_SRC\nwdebuger.c
      1          #include "nwdebuger.h"
      2          #include "ioCC2530.h"
      3          #include "stdint.h"
      4          #include "stdio.h"
      5          
      6          // Настройка порта uart для отладки
      7          static void uart_init(void)
      8          {
      9            // Выбор расположения UART на выводах
     10            uint8_t U0CFG = 0; // 0={TX=P0_3, RX=P0_2
     11            PERCFG |= (U0CFG<<0); 
     12            
     13            // U0UCR регистр настройки режима uart. меня устраивает по умолчанию
     14            U0CSR = (1<<7); // Выбираем режим uart  
     15            
     16            // Настройка скорости передачи данных на 2М  
     17            U0BAUD = 0;  // табличные значения из pdf
     18            U0GCR =  16;
     19            
     20            // Включаем альтернативные функции выводов
     21            P0SEL = (1<<2)|(1<<3);
     22            U0CSR |= (1<<6);
     23          }
     24          
     25          static void SetCPU32M(void)
     26          {
     27            CLKCONCMD = 0x88;
     28            while (CLKCONSTA&(1<<6));
     29          }
     30          
     31          void nwDebugerInit(void)
     32          {
     33           // SetCPU32M();
     34          #ifdef UART_DEBUG
     35            uart_init();
     36          #endif
     37          }
     38          
     39          __attribute__((weak)) void STACK_FAILURE(char* msg)
     40          {
     41            LOG_ON("STACK FAILURE. HALT");
     42            while(1);
     43          }
     44          
     45          // Переопределяем функцию записи в порт
     46          #ifdef UART_DEBUG
     47          #include <yfuns.h>
     48          
     49          _STD_BEGIN
     50          
     51          #pragma module_name = "?__write"
     52          
     53          int MyLowLevelPutchar(int x);
     54          
     55          int MyLowLevelPutchar(int x){
     56            while( U0CSR&(1<<0));
     57            U0DBUF = x;
     58            return x;
     59          }
     60          /*
     61           * If the __write implementation uses internal buffering, uncomment
     62           * the following line to ensure that we are called with "buffer" as 0
     63           * (i.e. flush) when the application terminates.
     64           */
     65          
     66          size_t __write(int handle, const unsigned char * buffer, size_t size)
     67          {
     68            /* Remove the #if #endif pair to enable the implementation */
     69             
     70          
     71            size_t nChars = 0;
     72          
     73            if (buffer == 0)
     74            {
     75              /*
     76               * This means that we should flush internal buffers.  Since we
     77               * don't we just return.  (Remember, "handle" == -1 means that all
     78               * handles should be flushed.)
     79               */
     80              return 0;
     81            }
     82          
     83            /* This template only writes to "standard out" and "standard err",
     84             * for all other file handles it returns failure. */
     85            if (handle != _LLIO_STDOUT && handle != _LLIO_STDERR)
     86            {
     87              return _LLIO_ERROR;
     88            }
     89          
     90            for (/* Empty */; size != 0; --size)
     91            {
     92              if (MyLowLevelPutchar(*buffer++) < 0)
     93              {
     94                return _LLIO_ERROR;
     95              }
     96          
     97              ++nChars;
     98            }
     99          
    100            return nChars;
    101          
    102          }
    103          
    104          _STD_END
    105          #endif
E:\WMNU\IAR\SHARE_PRJ_SRC\RADIO.c
      1          /*!
      2          \file 
      3          \brief Модуль содержит реализацию интерфейса радио для приема/передачи данных.
      4          */
      5          
      6          #include "RADIO.h"
      7          #include "mem.h"
      8          #include "nwdebuger.h"
      9          #include "Radio_defs.h"
     10          #include "TIC.h"
     11          #include "delays.h"
     12          #include "frame.h"
     13          #include "string.h"
     14          #include "NTMR.h"
     15          #include "config.h"
     16          
     17          // Открытые методы модуля
     18          void RI_init(void);
     19          bool RI_SetChannel(uint8_t CH);
     20          bool RI_Send(frame_s *fr);
     21          frame_s* RI_Receive(uint32_t timeout);
     22          uint32_t RI_GetCRCError(void);
     23          uint32_t RI_GetCCAReject(void);
     24          float RI_GetUptime(void);
     25          void RI_Reset(void);
     26          
     27          // Приватные методы
     28          static void random_core_init(void);
     29          static void RI_cfg(void);
     30          
     31          static inline void setFreq(uint8_t CH); // Установка частоты передатчика
     32          static void LoadTXData(uint8_t *src, uint8_t len); // Загрузка данных в tx buf
     33          static void UnLoadRXData(uint8_t *src, uint8_t len);
     34          static bool SendData(frame_s *fc);
     35          static bool RecvData(uint32_t timeout_us, uint16_t *SFD_TimeStamp);
     36          
     37          // Переменные модуля
     38          static float RI_UPTIME = 0; // Время работы радио в мс. 49 дней максимум
     39          static uint32_t RI_CRC_ERROR = 0; // Количество ошибок CRC
     40          static uint32_t RI_CCA_REJECT = 0; // Количество отказов передач из-за CCA
     41          
     42          
     43          #define IEEE_MODE 0     //!< Режимы фазы сигнала
     44          #define NOT_IEEE_MODE 1 //!< Режимы фазы сигнала
     45          #define RSSI_OFFSET -76 //!< Константа для вычисления реальной мощности
     46          
     47          /*!
     48          \details 
     49           Расчет качества связи. Коэффициенты получаются эксперементально.
     50           Есть предположение, что количество ошибок будет пропорционально квадрату
     51           коеффициента корреляции сигнала.
     52           LIQ = 255 передача 1000 пакетов без ошибок CRC
     53           LIQ = 127 передача 1000 пакетов с 50% ошибок CRC
     54           LIQ = 0   передача 1000 пакетов с 100% ошибок CRC
     55          */ 
     56          #define CONST_A (int8_t)0 //!< Коэффициент A
     57          #define CONST_B (int8_t)1 //!< Коэффициент B
     58          #define LIQ_CALC(corr) ((corr-CONST_A)*CONST_B) //!< Формула вычисление LIQ 
     59          #define FRQ_CALC(x) (11+5*(x-11)) //!< Формул вычисления частоты сигнала
     60          
     61          /// Глобальные параметры модуля
     62          struct
     63          {
     64            uint8_t CH;       //!< Номер канала с 11 до 28 включительно
     65            bool MODULATION_MODE; //!< false - совместимость с IEEE 802.15.4
     66          } RADIO_CFG;
     67          
     68          /*!
     69          \brief Иницилизация радио интерфейса
     70          */
     71          void RI_init(void)
     72          {
     73            // Настройки поумолчанию
     74            RADIO_CFG.CH = CH11;
     75            RADIO_CFG.MODULATION_MODE = IEEE_MODE;
     76            // Пост действия с радио
     77            random_core_init();
     78          }
     79          
     80          void RI_Reset(void){
     81            RI_init();
     82          }
     83          /*!
     84          \brief Переводит радио в активный режим и устанавливает параметры.
     85          */
     86          static void RI_cfg(void)
     87          {
     88          /*
     89          APPEND_DATA_MODE = 0. FCS1 = signed rssi, FCS2.7 CRC OK, FCS2.6-0 Correlation
     90          A correlation value of ~110 indicates a maximum quality frame while a value 
     91          of ~50 is typically the lowest quality frames detectable by CC2520. 
     92          */
     93          /* После включения радио находится в активном режиме но приемник выключен */
     94            
     95            // Устанавливаем частоту радиопередатчика
     96            setFreq(RADIO_CFG.CH);
     97            
     98            // Устанавливаем мощность выходного сигнала
     99            TXPOWER = CONFIG.tx_power;
    100           
    101            FRMFILT0 = 0x00; // Отключаем фильтрацию пакетов
    102            
    103            // Устанавливаем режим модуляции
    104            MDMTEST1_u MDM1;
    105            MDM1.value = MDMTEST1;
    106            MDM1.bits.MODULATION_MODE = RADIO_CFG.MODULATION_MODE;
    107            MDMTEST1 = MDM1.value; 
    108          }
    109          
    110          /*!
    111          \brief Устанавливает канал радиопередатчика.
    112          \param[in] CH Номера каналов [11..28]
    113          \return Возвращает true если аргументы верны
    114          */
    115          bool RI_SetChannel(uint8_t CH)
    116          {
    117            if ((CH >=11) && (CH<=28))
    118            {
    119              RADIO_CFG.CH = CH;
    120              return true;
    121            }
    122            return false;
    123          }
    124          
    125          /*!
    126          \brief Передает данные в эфир
    127          \details Увеличивает  RI_CCA_REJECT при невозможности отправки сообщения, расчитывает время работы 
    128           радио передатчика. Отправка сообщения в заданное сетевое время 
    129           fr->meta.SEND_TIME. Если равно 0, то отправка через случайноу время в мкс.
    130           Данные автоматически оборачиваются в LEN, CRC1,CRC2
    131          \param[in] *fr Указатель на структуру frame_s RAW_LAY
    132          \return Возвращает true в случаи успешной передачи
    133          */
    134          bool RI_Send(frame_s *fr)
    135          {
    136            ASSERT(fr != NULL);
    137            
    138            // Устанавливаем частоту передачи пакета
    139            RI_cfg();
    140            
    141            bool send_res; // Результат передачи данных
    142            TimeStamp_s start,stop; // Измерение времени
    143            
    144            TIM_TimeStamp(&start); // Начало измерения времени
    145            send_res = SendData(fr);
    146            TIM_TimeStamp(&stop); // Конец измерения времени
    147            
    148            uint32_t passed = TIM_passedTime(&start, &stop);
    149            RI_UPTIME += (float)passed/1000; // Микросекунды в милисекунды
    150            
    151            // В случаи ошибки передачи увеличиваем счетчик RI_CCA_REJECT
    152            if (!send_res)
    153              RI_CCA_REJECT++;
    154            
    155            return send_res;
    156          }
    157          
    158          /**
    159          @brief Отправка сообщения
    160          @detail Время отправки с шифрованием 10 байт в мкс. Merge = 155, Crypt = 239,
    161           Load TX = 30, RSSI_OK = 328, ISTXON = 11, SFD(192us+5*8*4us) = 400, TX = 370, Full = 1535.
    162          Время работы радио RSSI_OK+ISTXON+SFD+TX = 1109 us
    163          @return true в случаи успеха
    164          */
    165          static bool SendData(frame_s *fr)
    166          {
    167          ////TimeStamp_s ts_start, ts_frame_merge, ts_crypt, ts_load_tx, 
    168          ////ts_rssistat, ts_istxon, ts_sfd, ts_stop;
    169            
    170          ////TIM_TimeStamp(&ts_start);  
    171                
    172          ////TIM_TimeStamp(&ts_frame_merge);  
    173            bool result = true;
    174            switch(true)
    175            {
    176              case true:
    177          ////TIM_TimeStamp(&ts_crypt); 
    178                // Копируем данные в буфер. Очистка буфера автоматическая
    179                LoadTXData(fr->payload, fr->len);
    180          ////TIM_TimeStamp(&ts_load_tx); 
    181                // Для начала передачи по команде STXONCCA нужно включить приемник
    182                ISRXON();
    183                // Ждем пока статус RSSI_VALID станет true
    184                while(!RSSISTAT);
    185                     
    186          ////TIM_TimeStamp(&ts_rssistat); 
    187                // Очищаем флаг завершения передачи сообщения
    188                RFIRQF1 &= ~RFIRQF1_TXDONE;
    189                RFIRQF0 &= ~RFIRQF0_SFD;
    190                
    191                // Время отправки сообщения измеряется в тактах сетевого времени NTMR
    192                // Он работатаеи намного лучше чем MAC таймер(меньше погрешность)
    193                // Отправка в обозначенное время или по факту готовности
    194                //13 - поправка в тактах сети на передачу преамболы
    195                uint16_t timer = 0; // Для отлалки. 
    196                if (fr->meta.SEND_TIME != 0)
    197                  timer = NT_WaitTime(fr->meta.SEND_TIME - 13); 
    198          
    199                // Начинаем передачу данных
    200                // Transmission of preamble begins 192 μs after the STXON or STXONCCA 
    201                // command strobe
    202                // 192+(4(pream)+1(sfd))*8bit*4us = 352 мкс. Измерил 360мкс
    203                // Измерил в тактах NT_GetTimer() получилось 13 тиков. 396 мкс
    204                // ИЗМЕРЯЛ ПОВТОРНО- правда 13 тиков ))
    205                ISTXONCCA();
    206          ////TIM_TimeStamp(&ts_istxon); 
    207                // Произошла ошибка передачи если SAMPLED_CCA false
    208                if (!(FSMSTAT1 & 1<<3)) //SAMPLED_CCA == 0
    209                {
    210                  result = false;
    211                  break;
    212                }
    213          //volatile uint16_t DBGT= NT_GetTime(); 
    214                // Ждем завершения отправки SFD
    215                while (!(RFIRQF0 & RFIRQF0_SFD));
    216                fr->meta.TIMESTAMP = NT_GetTime(); 
    217          //volatile uint16_t DBGT2= NT_GetTime();        
    218          ////TIM_TimeStamp(&ts_sfd); 
    219                // Проверим переданно ли сообщение TX_FRM_DONE
    220                while (!(RFIRQF1 & RFIRQF1_TXDONE));
    221                break;
    222            }
    223          ////TIM_TimeStamp(&ts_stop);
    224            ISRFOFF();
    225          ////  LOG(MSG_ON | MSG_INFO | MSG_TRACE, 
    226          ////"Merge = %lu. Crypt = %lu. Load TX = %lu. RSSI_OK = %lu. ISTXON = %lu. SFD = %lu. TX = %lu. FULL = %lu \n", 
    227          ////      TIM_passedTime(&ts_start, &ts_frame_merge),
    228          ////      TIM_passedTime(&ts_frame_merge, &ts_crypt),
    229          ////      TIM_passedTime(&ts_crypt, &ts_load_tx),
    230          ////      TIM_passedTime(&ts_load_tx, &ts_rssistat),
    231          ////      TIM_passedTime(&ts_rssistat, &ts_istxon),
    232          ////      TIM_passedTime(&ts_istxon, &ts_sfd),
    233          ////      TIM_passedTime(&ts_sfd, &ts_stop),
    234          ////      TIM_passedTime(&ts_start, &ts_stop)
    235          ////      );
    236            
    237            if (result)
    238              return true;
    239            return false; 
    240          }
    241          
    242          /**
    243          @brief Загрузка данных для передачи в буфер. 
    244          @detail Поля LEN, FCS1, FCS2 добавляются автоматически
    245          @param[in] src указатель на данные
    246          @param[in] len размер данных
    247          */
    248          static void LoadTXData(uint8_t *src, uint8_t len)
    249          {
    250            // Очищаем буфер передатчика
    251            ISFLUSHTX(); 
    252            // Поле LEN на два байта больше
    253            RFD = len + 2;
    254            
    255            for (uint8_t i = 0 ; i < len; i++)
    256              RFD = src[i];
    257            
    258            // Добавляем CRC1,2
    259            RFD = 0x00;
    260            RFD = 0x00;
    261          };
    262          
    263          /**
    264          @brief Выгружаем принятый пакет из радио
    265          @param[out] src указатель на буфер приемника
    266          @param[in] len размер выгружаемых данных
    267          */
    268          static void UnLoadRXData(uint8_t *src, uint8_t len)
    269          {
    270            for (uint8_t i = 0 ; i < len; i++)
    271              src[i] = RFD;
    272          };
    273          
    274          static inline void setFreq(uint8_t CH)
    275          {
    276            ASSERT( (CH >= 11) && (CH <= 28));
    277            // Устанавливаем частоту радиопередатчика
    278            FREQCTRL_u FRQ;
    279            FRQ.value = FRQ_CALC(RADIO_CFG.CH);
    280            FREQCTRL = FRQ.value;  
    281          }
    282          
    283          /*!
    284          \brief Принимает данные из эфира
    285          \details Функция принимает данные из эфира. Проводит проверку CRC, увеличивает
    286          RI_CRC_ERROR. Отмечает время прихода SFD в тактах сетевого времени .
    287          \param[in] timeout Время ожидания данных в микросекундах
    288          \return Возвращает NULL если данных нет
    289          */
    290          frame_s* RI_Receive(uint32_t timeout)
    291          {
    292            // Устанавливаем частоту передачи пакета
    293            RI_cfg();
    294            uint16_t SFD_TimeStamp;
    295            
    296            // Принимаем пакет 
    297            TimeStamp_s start,stop; // Измерение времени
    298            TIM_TimeStamp(&start); // Начало измерения времени работы радио
    299          //volatile uint16_t DBGT1= NT_GetTime(); 
    300            bool recv_res = RecvData(timeout, &SFD_TimeStamp);
    301          //volatile uint16_t DBGT2= NT_GetTime();
    302            TIM_TimeStamp(&stop); // Конец измерения времени радио
    303            uint32_t passed = TIM_passedTime(&start, &stop);
    304            RI_UPTIME += (float)passed/(float)1000; // Микросекунды в милисекунды
    305            
    306            // Если ничего не приняли возвращаем NULL
    307            if (!recv_res)
    308              return NULL;
    309            
    310            uint8_t frame_size = RXFIFOCNT; // Количество принятых данных
    311            
    312            // Минимальный размер FCS1,FCS2 - 2 байта. LEN не включен в подсчет 
    313            if (frame_size <= 2)
    314              return NULL;
    315            
    316            // Выгружаем данные из приемника
    317            uint8_t *frame_raw = re_malloc(frame_size); 
    318            UnLoadRXData(frame_raw, frame_size);
    319            
    320            int8_t  FCS1 = frame_raw[frame_size - 2]; // RSSI
    321            uint8_t FCS2 = frame_raw[frame_size - 1]; // bit7 = CRCOK, bit[6..0] Corr_val
    322            uint8_t LEN_F = frame_raw[0]; // Поле LEN
    323            
    324            // Проверим поле LEN. Размер данных в заголовке должен совпадать
    325            // с фактической длинной принятых данных
    326            if (LEN_F != frame_size - 1)
    327            {
    328              re_free(frame_raw);
    329              RI_CRC_ERROR ++;
    330              return NULL;
    331            }
    332            
    333            // Проверим поле CRCOK
    334            if (!(FCS2 && 1<<7))
    335            {
    336              re_free(frame_raw);
    337              RI_CRC_ERROR ++;
    338              return NULL;
    339            }
    340            
    341            // Создаем буфер, последнии два байта FCS1,2 и поле LEN не копируем
    342            frame_s *raw_frame = frame_create();
    343            frame_addHeader(raw_frame, &frame_raw[1], frame_size - 3);
    344            
    345            // Копируем метку времени SFD
    346            raw_frame->meta.TIMESTAMP = SFD_TimeStamp;
    347            
    348            // Расчитываем мощность принятого сигнала
    349            raw_frame->meta.RSSI_SIG =  FCS1 + RSSI_OFFSET;
    350            // Расчитываем качество сигнала
    351            uint8_t corr = FCS2 & 0x7F;
    352            raw_frame->meta.LIQ = LIQ_CALC(corr); // Значение коэфф. корреляции
    353          
    354            raw_frame->meta.CH = RADIO_CFG.CH;
    355          
    356            re_free(frame_raw);
    357            return raw_frame;
    358          }
    359          
    360          /**
    361          @brief Прием данных из эфира
    362          @param[in] timeout_us время ожидания в микросекундах
    363          @param[out] SFD_TimeStamp отметка времени завершения приема SFD
    364          */
    365          static bool RecvData(uint32_t timeout_us, uint16_t *SFD_TimeStamp)
    366          {
    367            TimeStamp_s start,stop; // Измерение времени  
    368            ISFLUSHRX(); // Очищаем буфер приема
    369            
    370            TIM_TimeStamp(&start);
    371            
    372            // Очищаем флаг завершения передачи сообщения и приема SFD
    373            RFIRQF0 &= ~RFIRQF0_RXPKTDONE;  
    374            RFIRQF0 &= ~RFIRQF0_SFD; 
    375            ISRXON(); // Включаем радиопередатчик
    376          
    377            bool time_out = false; // Истекло время ожидания пакета
    378            bool packet_received = false; // Приняли пакет
    379            bool sfd_received = false; // Приняли sfd
    380            
    381            // Цикл приема пакета
    382            while (true)
    383            {
    384              TIM_TimeStamp(&stop);
    385              if (TIM_passedTime(&start, &stop) >= timeout_us)
    386              {
    387                time_out = true;
    388                break;
    389              }
    390             
    391              // Принят сигнал SFD
    392              if ((RFIRQF0 & RFIRQF0_SFD))
    393              {
    394                *SFD_TimeStamp = NT_GetTime(); 
    395                sfd_received = true;
    396              }
    397              
    398              //  Завершен ли прием сообщения RX_FRM_DONE (RXPKTDONE)
    399              if ((RFIRQF0 & RFIRQF0_RXPKTDONE))
    400              {
    401                packet_received = true;
    402                break;
    403              }
    404            } // while 
    405            
    406            ISRFOFF();
    407            if (packet_received && sfd_received && !time_out)
    408              return true;
    409            else
    410              return false;
    411          }
    412          
    413          /*!
    414          \brief Возвращает количество ошибок возникших с момента иницилизации
    415          \return Количество CRC ошибок
    416          */
    417          uint32_t RI_GetCRCError(void)
    418          {
    419            return RI_CRC_ERROR;
    420          }
    421          
    422          /*!
    423          \brief Возвращает количестов отказов передачи пакета из-за занятости канала.
    424          \return Количество отказов CCA
    425          */
    426          uint32_t RI_GetCCAReject(void)
    427          {
    428            return RI_CCA_REJECT;
    429          }
    430          
    431          /*!
    432          \brief Возвращает суммарное время работы радио в режиме прием/передача
    433          \return Вермя в милисекундах
    434          */
    435          float RI_GetUptime(void)
    436          {
    437            return RI_UPTIME;
    438          }
    439          
    440          /**
    441          @breif Подссчет количества бит в байте
    442          @return Возвращает количество бит
    443          */
    444          static uint8_t bits_count(uint8_t value) {
    445            int ret = 0;
    446            for ( ; value; value = value >> 1 )
    447              ret += value & 1;
    448            return ret;
    449          }
    450          
    451          /**
    452          @brief Возращает 1 байт случайного числа
    453          @details Радио выдает всего лишь дви бита, нам нужно 8 
    454          */
    455          static inline uint8_t getRNDByte(void)
    456          {
    457            uint8_t val = 0;
    458            val |= RFRND << 0;
    459            val |= RFRND << 2;
    460            val |= RFRND << 4;
    461            val |= RFRND << 6;
    462            return val;
    463          }
    464          
    465          /**
    466          @brief Возвращает случайное число с числом включеных бит от 2 до 6 включительно
    467          @details Случайные числа появляются в регистре с частотой 170нс. Функция 
    468          возвращает гарантированно новое значение. 
    469          @return возвращает случайное число.
    470          */
    471          static inline uint8_t readRandom(void)
    472          {
    473            uint8_t rnd_val = 0;
    474            uint8_t bit_cnt = 0;
    475            while ( bit_cnt <= 2 || bit_cnt >= 6 )
    476            {
    477              rnd_val = getRNDByte();
    478              while (rnd_val == getRNDByte());
    479              rnd_val = getRNDByte();
    480              bit_cnt = bits_count(rnd_val);
    481            }
    482            return rnd_val;
    483          }
    484          
    485          /*!
    486          \brief Иницилизирует ядро генератора случайных чисел данными из эфира
    487          */
    488          static void random_core_init(void)  
    489          {
    490            unsigned int rnd_core = 0;;
    491               
    492            RI_cfg();
    493            FREQCTRL = 0x00; // Выбираем не используемую частоту
    494          
    495            // TODO По какой то причине OP_EXE не выполняет команду.
    496            // регистра RFST читается как 0xD0. это его состояние при reset
    497            // Включаем демодулятор
    498            ISRXON();
    499            
    500            // Ждем пока статус RSSI_VALID станет true
    501            while(!RSSISTAT);
    502            
    503            // Ждем случайных чисел
    504            while (RFRND == 0);
    505            
    506            // Настраиваем ядро случайного генератора
    507            rnd_core = readRandom();
    508            rnd_core |= (unsigned int)readRandom()<<8;
    509            srand(rnd_core);
    510            
    511            // Выключаем демодулятор
    512            ISRFOFF();
    513            // Первая генерация случайного числа занимает много времени.
    514            // Влияло на работу радио, так как использовались случайные посылки
    515            rand(); 
    516          }
    517          
    518          /**
    519          @brief Измерение мощности сигнала
    520          @details Частота = 2394+fch. fch = [0..113]. 2394MHz to 2507MHz.
    521           Устройство поддерживает частоты до 2507 МГц
    522          @param[in] fch номер ЧАСТОТНОГО канала
    523          @param[in] timeout_ms время сканирования в мс
    524          @param[out] Максимальная мощность сигнала за время сканирования
    525          @return true если успешно
    526          */
    527          bool RI_Measure_POW(uint8_t fch, uint16_t timeout_ms, int8_t *RSSI_SIG){
    528            
    529            RI_cfg();
    530            
    531            if (fch > 113)
    532              return false;
    533            
    534            //(2394+FREQCTRL.FREQ[6:0])
    535            FREQCTRL = fch; // Выбираем не используемую частоту
    536          
    537            // Включаем демодулятор
    538            ISRXON();
    539            
    540            // Ждем пока статус RSSI_VALID станет true
    541            while(!RSSISTAT);
    542            FRMCTRL0 |= 1<<4; // включаем ENERGY_SCAN, детектор пикового сигнала
    543            
    544            // Ждем пока канал анализируется
    545            TIM_delay(1000*timeout_ms);
    546            
    547            int8_t rssi = RSSI + RSSI_OFFSET;
    548            *RSSI_SIG = rssi;
    549            // Отключаем радио
    550            ISRFOFF();
    551            return true;
    552          }
    553          
E:\WMNU\IAR\SHARE_PRJ_SRC\rx_buff.c
      1          #include "LLC.h"
      2          #include "nwdebuger.h"
      3          #include "stdbool.h"
      4          
      5          /**
      6          @file Буфер приемника пакетов.
      7          @detail Буфер используется шлюзом для временого хранения принятых пакетов
      8           перед передачей компьютеру по уарт.
      9          */
     10          
     11          // Определения
     12          #define RX_BUFF_SIZE 10 //!< Количество пакетов для хранения 
     13          
     14          // Глобальные функции
     15          void RXB_Init(void);
     16          void RXB_Reset(void);
     17          uint8_t RXB_frame_count(void);
     18          frame_s* RXB_get_frame(void);
     19          void RXB_del_frame(frame_s *fr);
     20          
     21          // Статические функции
     22          static void RXB_Callback(frame_s *fr);
     23          static void Delete_frame(uint8_t index);
     24          
     25          typedef struct{
     26              frame_s* fr;
     27              bool need_delete;
     28          } rx_buffer_s;
     29          
     30          // Локальные переменные
     31          static rx_buffer_s FRAME_POOL[RX_BUFF_SIZE]; //!< Хранилище указателей на пакетов. NULL - нет пакета
     32          
     33          /**
     34          @brief Первоначальная настройка
     35          */
     36          void RXB_Init(void){
     37            LLC_SetRXCallback(RXB_Callback);
     38            for (uint8_t i = 0; i < RX_BUFF_SIZE; i++){
     39              FRAME_POOL[i].fr = NULL;
     40              FRAME_POOL[i].need_delete = false;
     41            }
     42          }
     43          
     44          /**
     45          @brief Сброс всех данных и настройка
     46          */
     47          void RXB_Reset(void){
     48            for (uint8_t i = 0; i < RX_BUFF_SIZE; i++)
     49              Delete_frame(i);
     50          }
     51          
     52          /**
     53          @brief Количество принятых пакетов в буфере
     54          @return Количество пакетов
     55          */
     56          uint8_t RXB_frame_count(void){
     57            uint8_t cnt = 0;
     58            for (uint8_t i = 0; i < RX_BUFF_SIZE; i++)
     59              if (FRAME_POOL[i].fr != NULL && !FRAME_POOL[i].need_delete)
     60                cnt ++;
     61            return cnt;
     62          }
     63          
     64          /**
     65          @brief Возращает указатель на принятый пакет
     66          */
     67          frame_s* RXB_get_frame(void){
     68            frame_s *rx_frame = NULL;
     69          
     70            for (uint8_t i = 0; i < RX_BUFF_SIZE; i++)
     71              if (FRAME_POOL[i].fr != NULL && !FRAME_POOL[i].need_delete){
     72                rx_frame = FRAME_POOL[i].fr;
     73                break;
     74              }
     75            return rx_frame;
     76          }
     77          
     78          /**
     79          @brief Удаляет пакет по указателю
     80          */
     81          void RXB_del_frame(frame_s *fr){
     82            int index = -1;
     83            
     84            for (uint8_t i = 0; i < RX_BUFF_SIZE; i++)
     85              if (FRAME_POOL[i].fr == fr){
     86                index = i;
     87                break;
     88              }    
     89          
     90            ASSERT(index >= 0);
     91            Delete_frame(index);
     92            
     93          }
     94          
     95          /**
     96          @brief Удаляет пакет из RX_BUFF_SIZE по индексу
     97          @param[in] индекс пакета в массиве RX_BUFF_SIZE
     98          */
     99          static void Delete_frame(uint8_t index){
    100            ASSERT(index < RX_BUFF_SIZE);
    101            FRAME_POOL[index].need_delete = true;
    102          }
    103          
    104          /**
    105          @brief Обработчик принятого пакета
    106          @detail Если нет места пакет удаляем
    107          */
    108          static void RXB_Callback(frame_s *fr){  
    109            // Удалим ненужные
    110            for (uint8_t i = 0; i < RX_BUFF_SIZE; i++)
    111              if (FRAME_POOL[i].need_delete){
    112                if (FRAME_POOL[i].fr != NULL)
    113                  frame_delete(FRAME_POOL[i].fr);
    114                FRAME_POOL[i].fr = NULL;
    115                FRAME_POOL[i].need_delete = false;
    116              }
    117            
    118            // Ищем куда вставить
    119            for (uint8_t i = 0; i < RX_BUFF_SIZE; i++)
    120              if (FRAME_POOL[i].fr == NULL){
    121                FRAME_POOL[i].fr = fr;
    122                return;
    123              }
    124            
    125            // Вставлять некуда
    126            frame_delete(fr);
    127          }
E:\WMNU\IAR\SHARE_PRJ_SRC\sync.c
      1          #include "stdlib.h"
      2          #include "basic.h"
      3          #include "frame.h"
      4          #include "string.h"
      5          #include "nwdebuger.h"
      6          #include "coder.h"
      7          #include "TIC.h"
      8          #include "RADIO.h"
      9          #include "NTMR.h"
     10          #include "config.h"
     11          #include "ioCC2530.h" // ОТЛАДДКА
     12          
     13          void SY_Init(void);
     14          void SY_Reset(void);
     15          void SY_setIV(void* ptr_IV);
     16          void SY_setKEY(void* ptr_KEY);
     17          bool SY_SYNC_NETWORK(uint16_t *panid,uint16_t timeout);
     18          void SY_Enable(bool en);
     19          uint32_t SY_sync_sended(void);
     20          
     21          static void SY_TS1_HNDL_MASTER(void);
     22          static void SY_TS1_HNDL_SLAVE(void);
     23          static void SY_TIME_ALLOC_SLAVE(void);
     24          static void SY_TIME_ALLOC_MASTER(void);
     25          static void BitRawDecrypt(uint8_t *src, uint8_t size);
     26          static void BitRawCrypt(uint8_t *src, uint8_t size);
     27          static frame_s* get_sync(uint32_t timeout);
     28          static bool send_sync(void);
     29          
     30          static uint32_t LAST_SYNC_TIME = 0; //!< Время последней синхр.
     31          static uint32_t NEXT_SYNC_TIME = 0; //!< Время следующей синхр.
     32          static uint32_t SYNC_SENDED = 0; //!< Количество успешно ретранслированых пакетов
     33          static uint32_t SYNC_SEND_TIME = 0;
     34          static bool NEED_SEND_SYNC = false; //!< Нужно отослать синхропакет
     35          static bool SY_ENABLE_MODULE = false;
     36          
     37          // Ключ потокового шифрования и вектор иницилизации
     38          static uint8_t KEY[16] = DEFAULT_KEY;
     39          static uint8_t IV[16] = DEFAULT_IV;
     40          //@brief Точное время приема/передачи пакета синхронизации времени
     41          // Расчитывается при иницилизации
     42          static uint16_t SYNC_ACCURATE_NETWORK_TIME; 
     43          
     44          #define SYNC_TS 1 //!< Номер временного слота синхросигнала
     45          #define SYNC_RECV_TIMEOUT 2000 // Время ожидания приема пакета в мкс
     46          #define SYNC_TIMEOUT 110//!< Время в сек после которого сеть не синхронна
     47          
     48          
     49          typedef struct // Формат структуры пакета синхронизации
     50          {
     51              uint8_t panid;
     52              uint32_t rtc;
     53              uint32_t magic;
     54          } __attribute__((packed)) SYNC_s;
     55          
     56          #define MAGIC 0x19833891 // Проверка что пакет действительно sync
     57          #define RAND_SYNC_RX_DELAY  9 // Фиксированое время приема rand()%10 + 5
     58          #define RAND_SYNC_TX_DELAY  10 // Фиксированное время передачи сигнала
     59          // Максимальное отклонение при приеме sync в тактах сети
     60          #define SYNC_TIME_DRIFT 35  
     61          
     62          #ifdef GATEWAY
     63            #define SYNC_MASTER     // Если определено, то узел является шлюзом
     64          #endif
     65          
     66          void SY_Init(void)
     67          {
     68            SYNC_SENDED = 0;
     69            LAST_SYNC_TIME = 0;
     70            NEXT_SYNC_TIME = 0;
     71            SY_ENABLE_MODULE = false;
     72            SYNC_ACCURATE_NETWORK_TIME = TIC_SlotTime(SYNC_TS) + TIC_SlotActivityTime()/2;
     73          #ifdef SYNC_MASTER
     74            TIC_SetTS1Callback(SY_TS1_HNDL_MASTER);
     75            TIC_SetSyncTimeAllocCallback(SY_TIME_ALLOC_MASTER);
     76          #else
     77            TIC_SetTS1Callback(SY_TS1_HNDL_SLAVE);
     78            TIC_SetSyncTimeAllocCallback(SY_TIME_ALLOC_SLAVE);
     79          #endif
     80          }
     81          
     82          void SY_Reset(void)
     83          {
     84            SYNC_SENDED = 0;
     85            LAST_SYNC_TIME = 0;
     86            NEXT_SYNC_TIME = 0;
     87            SYNC_SEND_TIME = 0;
     88            SY_ENABLE_MODULE = false;
     89          }
     90          
     91          void SY_Enable(bool en)
     92          {
     93            SY_ENABLE_MODULE = en;
     94          }
     95          
     96          /**
     97          @brief Количество успешно переданных пакетов синхронизации
     98          @return Количечтво пакетов
     99          */
    100          uint32_t SY_sync_sended(void)
    101          {
    102            return SYNC_SENDED;
    103          }
    104          
    105          /**
    106          @brief Установить вектор иницилизации для шифрования
    107          @param[in] ptr_IV указатель на 16 байтный вектор иницилизации
    108          */
    109          void SY_setIV(void* ptr_IV)
    110          {
    111            memcpy(IV, ptr_IV, 16);
    112          }
    113          
    114          /**
    115          @brief Установить ключ шифрования
    116          @param[in] ptr_KEY указатель на 16 байтный ключ
    117          */
    118          void SY_setKEY(void* ptr_KEY)
    119          {
    120            memcpy(KEY, ptr_KEY, 16);
    121          }
    122          
    123          /**
    124          @brief Функция вызывается после каждого завершенного слота времени
    125          @detail Детектирует потерю синхронизации, активирует процесс синхронизации
    126           активирует слот для ретрансляцию сигнала
    127          */
    128          static void SY_TIME_ALLOC_SLAVE(void)
    129          { 
    130            if (!SY_ENABLE_MODULE) // Модуль отключен
    131              return;  
    132            
    133            // Потеря синхронизации
    134            if ( (TIC_GetUptime() - LAST_SYNC_TIME) > SYNC_TIMEOUT)
    135            {
    136                LOG_ON("Network out of sync.");
    137                return;
    138            }
    139            
    140            if (TIC_GetRXState(SYNC_TS)) // Если прием уже активен
    141              return;
    142            
    143            // Ретрансляция синхропакета
    144            if (NEED_SEND_SYNC)
    145            {
    146              LOG_OFF("Need to send resync");
    147              TIC_SetRXState(SYNC_TS, true);
    148              return;
    149            }
    150            
    151            // Необходимо начать процесс синхронизации
    152            if (TIC_GetUptime() > NEXT_SYNC_TIME)
    153            {
    154              LOG_ON("Begin resync");
    155              P1_0 = !true; 
    156              TIC_SetRXState(SYNC_TS, true);
    157            }
    158          }
    159          
    160          /**
    161          @brief Функция вызывается после каждого завершенного слота времени
    162          @detail Запускает процесс передачи синхросигнала в равные промежутки времени
    163          */
    164          static void SY_TIME_ALLOC_MASTER(void)
    165          { 
    166            if (TIC_GetTXState(SYNC_TS)) // Если передача уже активна.
    167              return;
    168            
    169            uint32_t now = TIC_GetUptime();
    170            if ( now < SYNC_SEND_TIME) // Если время новой передачи не наступило
    171              return;
    172            
    173            TIC_SetTXState(SYNC_TS,true); // Разрешаем передачу
    174             
    175             // Определяем следующее время передачи
    176             SYNC_SEND_TIME = now + RAND_SYNC_TX_DELAY;
    177          }
    178          
    179          /**
    180          @brief Вызывает при активности TS1 RX или TX
    181          @detail Выполняет две функции: синхронизацию с сетью или передачу синхр.
    182          */
    183          static void SY_TS1_HNDL_SLAVE(void)
    184          {
    185            if (!SY_ENABLE_MODULE) // Модуль отключен
    186              return;
    187              
    188            // Нужно отослать синхропакет
    189            if (NEED_SEND_SYNC)
    190            {
    191              if (send_sync())
    192                SYNC_SENDED++;
    193              LOG_ON("Resync TX. CNT=%d",(uint16_t)SYNC_SENDED);
    194              NEED_SEND_SYNC = false;
    195              TIC_SetRXState(SYNC_TS, false);
    196            }
    197            
    198            // Ждем начала точного времени начала передачи сигнала заранее
    199            // Время в тактах сети
    200            NT_WaitTime(SYNC_ACCURATE_NETWORK_TIME - SYNC_TIME_DRIFT);
    201           
    202            // Время в мс
    203            frame_s *fr_SYNC = get_sync(SYNC_RECV_TIMEOUT); 
    204            
    205            if (!fr_SYNC)
    206              return;
    207            
    208            SYNC_s *sync;
    209            sync = (SYNC_s*)fr_SYNC->payload;
    210            
    211            // Проверяем принадлежность пакета
    212            if (( sync->panid != CONFIG.panid) && (sync->magic != MAGIC))
    213            {
    214              frame_delete(fr_SYNC);
    215              return;
    216            }
    217            
    218            // Синхронизируемся
    219            // Время прошедшее с момента приема пакета в тактах сети
    220            uint16_t delta = TIC_GetTimer() - fr_SYNC->meta.TIMESTAMP;
    221            TIC_SetTimer(SYNC_ACCURATE_NETWORK_TIME + delta);
    222            TIC_SetRTC(sync->rtc);
    223            
    224            LAST_SYNC_TIME = TIC_GetUptime();
    225            NEXT_SYNC_TIME = LAST_SYNC_TIME + RAND_SYNC_RX_DELAY; 
    226            TIC_SetRXState(SYNC_TS, false);
    227            LOG_ON("Node Synced. TS=%d, AT=%d, DEL=%d, AD=%d, RTC=%d, NRTC=%d, SRTC=%d",
    228                   fr_SYNC->meta.TIMESTAMP,SYNC_ACCURATE_NETWORK_TIME, delta,
    229                   SYNC_ACCURATE_NETWORK_TIME - fr_SYNC->meta.TIMESTAMP, 
    230                   (uint16_t)LAST_SYNC_TIME,
    231                   (uint16_t)NEXT_SYNC_TIME,
    232                   (uint16_t)TIC_GetRTC());
    233            frame_delete(fr_SYNC);
    234            // После приема нужно ретранслировать синхропакет
    235            NEED_SEND_SYNC = true; 
    236          P1_0 = !false; // ОТЛАДКА
    237          }
    238          
    239          /**
    240          @brief Вызывает при активносм TS1 RX или TX
    241          @detail Формирует кадр синхронизации и передает его в строго определенное время
    242          */
    243          static void SY_TS1_HNDL_MASTER(void)
    244          {
    245            if (!SY_ENABLE_MODULE) // Модуль отключен
    246              return;  
    247             
    248          P1_0 = !true; //ОТЛАДКА  
    249            if (send_sync())
    250              SYNC_SENDED++;
    251            
    252            LOG_ON("Sync send."); 
    253          P1_0 = !false; //ОТЛАДКА
    254            
    255            TIC_SetTXState(SYNC_TS, false);
    256          }
    257          
    258          /**
    259          @brief Создать и отправить синхропакет
    260          */
    261          static bool send_sync(void)
    262          {
    263            SYNC_s sync;
    264            sync.panid = CONFIG.panid;
    265            sync.rtc = TIC_GetRTC();
    266            sync.magic = MAGIC;
    267            
    268            frame_s *fr_SYNC = frame_create();
    269            frame_addHeader(fr_SYNC, &sync, sizeof(SYNC_s));
    270            fr_SYNC->meta.SEND_TIME = SYNC_ACCURATE_NETWORK_TIME; // время в тактах сети. ((1/32768)*164)*1000
    271              
    272          #ifdef RARIO_STREAM_ENCRYPT
    273            BitRawCrypt(fr_SYNC->payload, fr_SYNC->len);
    274          #endif
    275            
    276            RI_SetChannel(CONFIG.sync_channel);
    277            bool res = RI_Send(fr_SYNC);
    278            
    279            frame_delete(fr_SYNC);
    280            return res;
    281          }
    282          
    283          /**
    284          @brief Прием пакет синхронизации
    285          @param[in] Время ожидания в мс
    286          @return Указатель на пакет или NULL
    287          */
    288          static frame_s* get_sync(uint32_t timeout)
    289          {
    290            RI_SetChannel(CONFIG.sync_channel);
    291            frame_s *fr_SYNC = RI_Receive(timeout);
    292            
    293            // Если пакета нет, выходим из обработчика
    294            if (fr_SYNC == NULL)
    295              return NULL;
    296            
    297            // Проверим размер пакета
    298            if (fr_SYNC->len != sizeof(SYNC_s))
    299            {
    300              frame_delete(fr_SYNC);
    301              return NULL;
    302            }
    303            
    304            #ifdef RARIO_STREAM_ENCRYPT
    305            BitRawDecrypt(fr_SYNC->payload, fr_SYNC->len);
    306            #endif
    307            return fr_SYNC;
    308          }
    309          
    310          /**
    311          @brief Процедура синхронизации с сетью
    312          @detail Процедура изет сеть в течении времени timeout и синхронизируется с ней
    313          @param[in] timeout время в милисекундах
    314          @param[out] panid указатель на идентификатор найденой сети
    315          @return true если сеть найдета
    316          */
    317          bool SY_SYNC_NETWORK(uint16_t *panid,uint16_t timeout)
    318          {
    319            // TODO Нужно обнулить настройки всех модулей
    320            // Или об этом будет заботиться верхний уровень?
    321            TIC_CloseAllState();
    322            
    323            RI_SetChannel(CONFIG.sync_channel);
    324            
    325            TimeStamp_s begin, end;
    326            TIM_TimeStamp(&begin);
    327            TIM_TimeStamp(&end);
    328            
    329            bool net_found = false;
    330            uint32_t passed = 0;
    331            frame_s *fr_SYNC;
    332            SYNC_s *sync;
    333            uint32_t timeout_us = timeout * 1000;
    334            
    335            while (passed < timeout_us)
    336            {
    337              fr_SYNC = get_sync(timeout_us);
    338              if (fr_SYNC == NULL)
    339              {
    340                passed = TIM_passedTime(&begin, &end);
    341                continue;
    342              }
    343              
    344              // Приняли какойто пакет, декодируем.
    345              sync = (SYNC_s*)fr_SYNC->payload;
    346              
    347              if (sync->magic != MAGIC)
    348              { // Проверим что пакет именно тот а не эфирный мусор
    349                frame_delete(fr_SYNC);
    350                passed = TIM_passedTime(&begin, &end);
    351                continue;
    352              }   
    353              
    354              // Возвращаем результат
    355              *panid = sync->panid;
    356              CONFIG.panid = sync->panid;
    357              net_found = true;
    358              
    359              // Синхронизируемся с сетью
    360              // Время прошедшее с момента приема пакета в тактах сети
    361              uint16_t delta = TIC_GetTimer() - fr_SYNC->meta.TIMESTAMP;
    362              TIC_SetTimer(SYNC_ACCURATE_NETWORK_TIME + delta);
    363              TIC_SetRTC(sync->rtc);
    364              LAST_SYNC_TIME = TIC_GetUptime();
    365              NEXT_SYNC_TIME = LAST_SYNC_TIME + RAND_SYNC_RX_DELAY; 
    366              frame_delete(fr_SYNC);
    367              break;
    368            } 
    369            
    370            return net_found;
    371          }
    372          
    373          /*!
    374          \brief Расшифровка область памяти
    375          \param[in,out] *src Указатель на начало области дешифрования
    376          \param[in] size Размер расшифруемых данных
    377          */
    378          static void BitRawDecrypt(uint8_t *src, uint8_t size)
    379          {
    380            AES_StreamCoder(false, src, src, KEY, IV, size);
    381          }
    382          
    383          /*!
    384          \brief Шифрует область памяти
    385          \param[in,out] *src Указатель на начало области шифрования
    386          \param[in] size Размер шифруемых данных
    387          */
    388          static void BitRawCrypt(uint8_t *src, uint8_t size)
    389          {
    390            AES_StreamCoder(true, src, src, KEY, IV, size);
    391          }
    392          
E:\WMNU\IAR\SHARE_PRJ_SRC\TIC.c
      1          #include "TIC.h"
      2          #include "NTMR.h"
      3          #include "stdlib.h"
      4          #include "nwdebuger.h"
      5          #include "delays.h"
      6          #include "basic.h"
      7          #include "ioCC2530.h" // ОТЛАДДКА
      8          
      9          /**
     10          @file 
     11          @brief 
     12          @details
     13          */
     14          
     15          // Публичные методы
     16          void TIC_Init(void);
     17          void TIC_Reset(void);
     18          
     19          // Методы класса
     20          void TIC_SetTimer(uint16_t ticks);
     21          uint16_t TIC_GetTimer(void);
     22          bool TIC_SetTXState(uint8_t TS, bool state);
     23          bool TIC_SetRXState(uint8_t TS, bool state);
     24          bool TIC_GetTXState(uint8_t TS);
     25          bool TIC_GetRXState(uint8_t TS);
     26          void TIC_CloseAllState();
     27          void TIC_SetRXCallback(void (*fn)(uint8_t TS));
     28          void TIC_SetTXCallback(void (*fn)(uint8_t TS));
     29          void TIC_SetSECallback(void (*fn)(uint8_t TS));
     30          void TIC_SetTS1Callback(void (*fn)(void));
     31          void TIC_SetSyncTimeAllocCallback(void (*fn)(void));
     32          uint32_t TIC_GetUptime(void);
     33          uint32_t TIC_GetRTC(void);
     34          bool TIC_SetRTC(uint32_t RTC);
     35          void TIC_SetNonce(uint32_t nonce);
     36          uint32_t TIC_GetNonce(void);
     37          uint32_t TIC_TimeUsFromTS0();
     38          TimeStamp_s* TIC_GetTimeStampTS0(void);
     39          uint16_t TIC_SleepTime(void);
     40          uint16_t TIC_SlotActivityTime(void);
     41          uint16_t TIC_SlotTime(uint8_t TS);
     42          
     43          // Приватные методы
     44          static uint8_t TIC_getCurrentTS(uint16_t ticks);
     45          static void TIC_TDMAShelduler(uint8_t TS);
     46          static void TIC_HW_Timer_IRQ(uint16_t ticks);
     47          static inline void set_capture_time(uint8_t TS);
     48          static inline void Callback_execution(void (*fn)(uint8_t TS), uint8_t TS);
     49          static inline void incrementTS(uint8_t *TS);
     50          static void clocks_update(void);
     51          
     52          // Переменные модуля
     53          
     54          // Всего 50 слотов. (50 активных и 50 слотов сна)
     55          // Кварц имеет 32768 тактов в секунду. После 100 слотов
     56          // Остается 68 неучтеных тактов. Их нужно учитывать.
     57          #define MAX_TS (uint8_t)50
     58          #define TS_ACTIVE (uint16_t)327 // 9.979 мс
     59          #define TS_SLEEP (uint16_t)327  // 2.075 мс
     60          #define TS_UNACCOUNTED 68
     61          // Целый цикл-это сумма времени активного периода и сна
     62          #define FULL_SLOT  (TS_ACTIVE+TS_SLEEP)
     63          #define NO_TIME_SLOT 0xFF
     64          
     65          #define TS_RX (uint8_t)(1<<0)
     66          #define TS_TX (uint8_t)(1<<1)
     67          #define DAILY_SEC (uint32_t)86400
     68          #define MAX_TICKS (uint16_t)32768
     69          
     70          static uint32_t NODE_UPTIME = 0;
     71          static uint32_t NODE_RTC = 0;
     72          static uint32_t NODE_NONCE = 0;
     73          static void (*RXCallback)(uint8_t TS);
     74          static void (*TXCallback)(uint8_t TS);
     75          static void (*SECallback)(uint8_t TS);
     76          static void (*SyncTimeAllocCallback)(void);
     77          static void (*TS1Callback)(void);
     78          static uint8_t TSStateTable[MAX_TS];
     79          static TimeStamp_s TimeStampTS0;
     80          
     81          
     82          TimeStamp_s* TIC_GetTimeStampTS0(void)
     83          {
     84            return &TimeStampTS0;
     85          }
     86          
     87          void TIC_Init(void)
     88          {    
     89            TIC_CloseAllState();
     90            // Устанавливаем обработчик прерываний таймера
     91            NT_SetEventCallback(TIC_HW_Timer_IRQ);
     92            // Запускаем процесс планировщика
     93            NT_SetCompare(0); 
     94            TIC_SetTimer(0);
     95            TIM_TimeStamp(&TimeStampTS0);
     96          }
     97          
     98          /**
     99          @brief Сброс настроек. 
    100          @detail Модуль генерирует только SECallback и считает время RTC, UPTIME, NONCE.
    101          Так как была переустановка времени, значение RTC не верное на 1с (плюс, минус)
    102          */
    103          void TIC_Reset(void)
    104          {
    105          #ifdef GATEWAY
    106            NODE_RTC = 0;
    107            NODE_NONCE = 0;
    108            NODE_UPTIME = 0;
    109          #endif
    110            TIC_CloseAllState();  
    111            NT_SetCompare(0); 
    112            TIC_SetTimer(0);
    113            TIM_TimeStamp(&TimeStampTS0);
    114          }
    115          
    116          void TIC_CloseAllState()
    117          {
    118            for (uint8_t i = 0 ; i < 50; i++)
    119            {
    120              TIC_SetTXState(i, false);
    121              TIC_SetRXState(i, false);
    122            }
    123          }
    124          uint32_t TIC_TimeUsFromTS0()
    125          {
    126            uint32_t passed;
    127            TimeStamp_s now;
    128            TIM_TimeStamp(&now);
    129            passed = TIM_passedTime(&TimeStampTS0, &now);
    130            return passed;
    131          }
    132          
    133          void TIC_SetTimer(uint16_t ticks)
    134          {
    135            ASSERT(ticks < MAX_TICKS);
    136            if (ticks >= MAX_TICKS)
    137              return ;
    138            
    139            NT_SetTime(ticks);
    140          }
    141          
    142          uint16_t TIC_GetTimer(void)
    143          {
    144            return NT_GetTime();
    145          }
    146          
    147          bool TIC_SetTXState(uint8_t TS, bool state)
    148          {
    149            if (TS>=MAX_TS)
    150            {
    151              return false;
    152            }
    153            ASSERT(TS<MAX_TS);
    154            
    155            if (state)
    156              TSStateTable[TS] |= TS_TX;
    157            else
    158              TSStateTable[TS] &= ~TS_TX;
    159            
    160            return true;
    161          }
    162          
    163          bool TIC_SetRXState(uint8_t TS, bool state)
    164          {
    165            if (TS>=MAX_TS)
    166            {
    167              return false;
    168            }
    169            ASSERT(TS<MAX_TS);
    170            
    171            if (state)
    172              TSStateTable[TS] |= TS_RX;
    173            else
    174              TSStateTable[TS] &= ~TS_RX;
    175            
    176            return true;
    177          }
    178          
    179          bool TIC_GetTXState(uint8_t TS)
    180          {
    181              if (TS>=MAX_TS)
    182            {
    183              return false;
    184            }
    185            ASSERT(TS<MAX_TS);
    186            
    187            return (TSStateTable[TS] & TS_TX) ;
    188          }
    189          
    190          bool TIC_GetRXState(uint8_t TS)
    191          {
    192              if (TS>=MAX_TS)
    193            {
    194              return false;
    195            }
    196            ASSERT(TS<MAX_TS);
    197            
    198            return (TSStateTable[TS] & TS_RX) ;
    199          }
    200          
    201          void TIC_SetTS1Callback(void (*fn)(void))
    202          {
    203            ASSERT (fn != NULL);
    204            TS1Callback = fn;
    205          }
    206          
    207          void TIC_SetRXCallback(void (*fn)(uint8_t TS))
    208          {
    209            ASSERT(fn != NULL);
    210            RXCallback = fn;
    211          }
    212          
    213          void TIC_SetSyncTimeAllocCallback(void (*fn)(void))
    214          {
    215            ASSERT(fn != NULL);
    216            SyncTimeAllocCallback = fn;
    217          }
    218          
    219          void TIC_SetTXCallback(void (*fn)(uint8_t TS))
    220          {
    221            ASSERT(fn != NULL);
    222            TXCallback = fn;
    223          }
    224          
    225          void TIC_SetSECallback(void (*fn)(uint8_t TS))
    226          {
    227            ASSERT(fn != NULL);
    228            SECallback = fn;
    229          }
    230          
    231          uint32_t TIC_GetUptime(void)
    232          {
    233            return NODE_UPTIME;
    234          }
    235          
    236          uint32_t TIC_GetRTC(void)
    237          {
    238            return NODE_RTC;
    239          }
    240          
    241          bool TIC_SetRTC(uint32_t RTC)
    242          {
    243            if (RTC >= DAILY_SEC)
    244              return false;
    245            
    246            NODE_RTC = RTC;
    247            return true;
    248          }
    249          
    250          static uint8_t TIC_getCurrentTS(uint16_t ticks)
    251          {
    252            //uint16_t ticks = nt->NT_GetTime();
    253            // Вычисляем количество целых циклов
    254            uint8_t full_slot_num = ticks/FULL_SLOT;
    255            
    256            // Вычисляем остаток от деления. Остаток - смещение внутри
    257            // временного слота.
    258            uint16_t time_remainder = ticks % FULL_SLOT; 
    259            // Если значение внутри интервала 0..TS_ACTIVE. 
    260            if (time_remainder < TS_ACTIVE)
    261              return full_slot_num;
    262            
    263            return NO_TIME_SLOT;
    264          }
    265          
    266          static inline void incrementTS(uint8_t *TS)
    267          {
    268            // Выбираем следующий тайм слот
    269            (*TS)++;
    270            if (*TS >= MAX_TS)
    271              *TS = 0;
    272          }
    273          
    274          /**
    275          @brief Время активного слота в тактах сети
    276          @return время в тактах сети
    277          */
    278          uint16_t TIC_SlotActivityTime(void)
    279          {
    280            return TS_ACTIVE;
    281          }
    282          
    283          /**
    284          @brief Время неактивного слота в тактах сети
    285          @return время в тактах сети
    286          */
    287          uint16_t TIC_SleepTime(void)
    288          {
    289            return TS_SLEEP;
    290          }
    291          
    292          /**
    293          @brief Время начала временного слота в тактах сети
    294          @param[in] TS номер слота
    295          @return время в тактах сети
    296          */
    297          uint16_t TIC_SlotTime(uint8_t TS)
    298          {
    299            return FULL_SLOT*(uint16_t)TS;
    300          }
    301          
    302          static inline void set_capture_time(uint8_t TS)
    303          {
    304            //uint16_t ct = FULL_SLOT*(uint16_t)TS;
    305            
    306            LOG_OFF("Set compare = %d, TS = %d \r\n", ct, TS);
    307            // Установка прерывания на нужный слот
    308            NT_SetCompare(FULL_SLOT*(uint16_t)TS);
    309          }
    310          
    311          static void TIC_TDMAShelduler(uint8_t TS)
    312          {
    313            // Устанавливает прерывание на ближайший активный слот
    314            // Если слот 0 ближе, то на него. 
    315            // Cлот - обработка секундных таймеров 
    316            
    317            // Ищем следующий активный слот или слот 0
    318            incrementTS(&TS);
    319            while ((TS != 0) && !TSStateTable[TS])  
    320              incrementTS(&TS); 
    321            
    322            set_capture_time(TS);
    323          }
    324          
    325          static inline void Callback_execution(void (*fn)(uint8_t TS), uint8_t TS)
    326          {
    327            // Помошник вызова функций. Упрощает проверки
    328            ASSERT(fn != NULL);
    329            if (fn == NULL)
    330              return;
    331            fn(TS);
    332          }
    333          
    334          static void TIC_HW_Timer_IRQ(uint16_t ticks)
    335          {
    336            // TODO Обработка TS=0xFF
    337            // Номер текущего слота 
    338            uint8_t c_TS = TIC_getCurrentTS(ticks);
    339            
    340            // Обновляем часы NODE_RTC и NODE_UPTIME
    341            if (c_TS == 0)
    342            {
    343              TIM_TimeStamp(&TimeStampTS0); // Первым делом обновим отметку точного времени
    344              clocks_update();
    345           //   P1_0 = !true;
    346              LOG_OFF("TS0");
    347           //   P1_0 = !false;;
    348            }
    349            // Если что то пошло не так и мы промахнулись мимо слота
    350            // запускаем планировщик заново
    351            if (c_TS == NO_TIME_SLOT)
    352            {
    353              TIC_TDMAShelduler(c_TS);
    354              LOG_ON("TS = 255 \r\n");
    355              return;
    356            }
    357              
    358            // Вызываем один из указанных обработчиков.
    359            // Передача имеет приоритет над приемом.
    360            if (c_TS != 1)
    361            {
    362              if (TSStateTable[c_TS] & TS_TX) 
    363                Callback_execution(TXCallback, c_TS);
    364              else if (TSStateTable[c_TS] & TS_RX)
    365                Callback_execution(RXCallback, c_TS);
    366            }  
    367            else // Для TS1 свой обработчик слота
    368            {
    369              if (TS1Callback != NULL)
    370                TS1Callback();
    371            }
    372            
    373            // Выделяем время протоколу синхронизации
    374            if (SyncTimeAllocCallback)
    375              SyncTimeAllocCallback();
    376            
    377            Callback_execution(SECallback, c_TS); // Вызываем обработчик завершения слота
    378            
    379            // Запускаем планировщик таймера
    380            TIC_TDMAShelduler(c_TS);
    381          }
    382          
    383          static void clocks_update(void)
    384          {
    385            NODE_UPTIME++;
    386            NODE_RTC++;
    387            NODE_NONCE++;
    388            if (NODE_RTC >= DAILY_SEC)
    389              NODE_RTC = 0;
    390          }
    391          
    392          void TIC_SetNonce(uint32_t nonce)
    393          {
    394            NODE_NONCE = nonce;
    395          }
    396          
    397          uint32_t TIC_GetNonce(void)
    398          {
    399            return NODE_NONCE;
    400          }
E:\WMNU\IAR\NeocoreGateway\src\uart_comm.c
      1          #include "nwdebuger.h"
      2          #include "ioCC2530.h"
      3          #include "stdint.h"
      4          #include "stdbool.h"
      5          #include "DMA.h"
      6          
      7          /**
      8          @file Настройка UART для приема команд от PC
      9          */
     10          
     11          #define UART_RX_BUF_LEN 0xff //!< Размер приемного буфера
     12          #define TRIG_URX1 16
     13          
     14          static void uart_dma_init(void);
     15          
     16          void uart_write(const char *data, uint8_t size);
     17          uint8_t* uart_recv_cmd(uint8_t *size);
     18          
     19          static uint8_t uart_rx_buff[UART_RX_BUF_LEN]; //1 для поля длинны
     20          static void uart_putchar(char x);
     21          
     22          static void uart_dma_init(void)
     23          {
     24            // Настроим канал 2 DMA для загрузки данных из uart
     25            // DMA0 и 1 заняты кодером AES
     26            
     27            ST_DEF(DMA_CH[2], SRCADDRL, 0xF9); //U1DBUF
     28            ST_DEF(DMA_CH[2], SRCADDRH, 0x70);
     29            ST_DEF(DMA_CH[2], LENL, UART_RX_BUF_LEN); // Максимальный размер данных
     30            ST_DEF(DMA_CH[2], DSTADDRH, HADDR(uart_rx_buff)); // Пишем данные XENCDI = 0xB1 
     31            ST_DEF(DMA_CH[2], DSTADDRL, LADDR(uart_rx_buff)); //  
     32            ST_DEF(DMA_CH[2], PRIORITY, 0x00); // Низкий приоритет
     33            ST_DEF(DMA_CH[2], M8, 0x00); // Используем 8 бит для счетика длинны
     34            ST_DEF(DMA_CH[2], IRQMASK, 0x00); // Запрещаем генерировать перывания
     35            ST_DEF(DMA_CH[2], DESTINC, 0x01); // Увеличиваем адресс назначения
     36            ST_DEF(DMA_CH[2], SRCINC, 0x00); // Не увеличиваем адресс источника
     37            ST_DEF(DMA_CH[2], TRIG, TRIG_URX1); // Тригер по приходу байта UART0
     38            ST_DEF(DMA_CH[2], WORDSIZE, 0x00); // Копируем по 1 байту
     39            ST_DEF(DMA_CH[2], TMODE, 0x00); //  Одиночное копирование по тригеру
     40            ST_DEF(DMA_CH[2], VLEN, 0x01); // Длинна данных определяется 1ым байтом  
     41            ST_DEF(DMA_CH[2], LENH, 0x00); 
     42          }
     43          
     44          /**
     45          @brief Прием команды по uart
     46          @param[out] size размер принятых данных
     47          @return указатель на начало данных или null
     48          */
     49          uint8_t* uart_recv_cmd(uint8_t *size)
     50          {  
     51            // Начинаем прием
     52            DMAARM |= 0x04;
     53            
     54            while (DMAARM&0x04);
     55            
     56            *size = uart_rx_buff[0];
     57            return &uart_rx_buff[1];
     58          }
     59          
     60          /**
     61          @brief Иницилизация uart с компьютером
     62          @detail Скорость 115200 бод. Частота микроконтроллера 32Мгц.
     63          */
     64          void com_uart_init(void)
     65          {
     66            // Выбор расположения UART на выводах
     67            uint8_t U1CFG = 1; // 0={TX=P0_4, RX=P0_5 Локация 1. 1={P1_6=TX P1_7=RX}
     68            PERCFG |= (U1CFG<<1); 
     69            
     70            // U1UCR регистр настройки режима uart. меня устраивает по умолчанию
     71            U1CSR = (1<<7); // Выбираем режим uart  
     72            
     73            // Настройка скорости передачи данных на 115200  
     74            U1BAUD = 216;  // табличные значения из pdf
     75            U1GCR =  11; //16
     76            
     77            // Включаем альтернативные функции выводов
     78            P1SEL |= (1<<6)|(1<<7);
     79            U1CSR |= (1<<6);
     80            uart_dma_init();
     81          }
     82          
     83          /**
     84          @brief Запись в uart
     85          @param[in] data указатель на начало массива данных
     86          @param[in] size размер передаваемых данных
     87          */
     88          void uart_write(const char *data, uint8_t size)
     89          {
     90            for (uint8_t i = 0; i < size; i++)
     91              uart_putchar((char)data[i]);
     92          };
     93          
     94          
     95          static void uart_putchar(char x){
     96            while( U1CSR&(1<<0));
     97            U1DBUF = x;
     98          }
     99          
    100           char uart_getchar(void)
    101          {
    102            char x;
    103            while( !(U1CSR&(1<<2)));
    104            x = U1DBUF;
    105            return x;
    106          }

   Maximum stack usage in bytes:

   ISTACK XSTACK Function
   ------ ------ --------
      1     76   AES_CCMDecrypt
        0     66   -> CBCMAC_buf_encrypt
        0     70   -> CTR_enc_decrypt
        0     68   -> generateAuthData
        0     68   -> memcpy
        0     68   -> memset
      1     60   AES_CCMEncrypt
        0     50   -> CBCMAC_buf_encrypt
        0     54   -> CTR_enc_decrypt
        0     52   -> generateAuthData
        0     52   -> memcpy
        0     52   -> memset
      0     55   AES_StreamCoder
        0     39   -> memcpy
        0     39   -> memset
      2      0   AES_init
      0     28   BitRawCrypt
        0     16   -> AES_StreamCoder
      0     35   BitRawCrypt
        0     16   -> AES_StreamCoder
      0     28   BitRawDecrypt
        0     16   -> AES_StreamCoder
      0     30   BitRawDecrypt
        0     16   -> AES_StreamCoder
      0    116   CBCMAC_buf_encrypt
        0     50   -> memcpy
        0     50   -> memset
      0     12   CF_init
        0     12   -> memcpy
      0    109   CTR_enc_decrypt
        0     39   -> memcpy
        0     39   -> memset
      0     27   Callback_execution
        0     12   -> printf
        0     18   -> printf
      0      0   DMA_init
      0     40   DelayCalibrate
        0     40   -> TIM_TimeStamp
        0     40   -> TIM_delay
        0     40   -> TIM_passedTime
      1     28   Delete_frame
        0     10   -> printf
        0     16   -> printf
      0     54   Interval
      1     34   LLC_AddTask
        0     12   -> printf
        0     18   -> printf
        0     12   -> re_malloc
      2     10   LLC_GetTaskLen
      2      0   LLC_Init
        2      0   -> MAC_SetRXCallback
        2      0   -> TIC_SetSECallback
      0     16   LLC_RX_HNDL
        0     10   -> printf
        0     16   -> printf
      0     20   LLC_Reset
        0     10   -> re_free
      0     18   LLC_RunTimeAlloc
      0      9   LLC_SE_HNDL
        0      9   -> LLC_RunTimeAlloc
        0      9   -> LLC_Shelduler
      0     16   LLC_SetRXCallback
        0     10   -> printf
        0     16   -> printf
      0     31   LLC_Shelduler
        0     16   -> MAC_GetTXState
        0     16   -> MAC_Send
        0     16   -> printf
        0     22   -> printf
        0     16   -> re_free
      0     18   LLC_TimeAlloc
        0     12   -> printf
        0     18   -> printf
        0     12   -> re_malloc
      2     12   LoadTXData
      0     24   MAC_ACK_Recv
        0     14   -> RI_Receive
        0     14   -> TIM_delay
        0     14   -> frame_delete
        0     14   -> xor_calc
      0     24   MAC_ACK_Send
        0     12   -> RI_Send
        0     12   -> frame_addHeader
        0     12   -> frame_create
        0     12   -> frame_delete
        0     12   -> xor_calc
      1     28   MAC_CloseRXSlot
        0     10   -> TIC_SetRXState
        0     10   -> printf
        0     16   -> printf
      2     11   MAC_Enable
      0     16   MAC_GetRXState
        0     10   -> printf
        0     16   -> printf
      0     32   MAC_GetTXState
        0     10   -> printf
        0     16   -> printf
      0     12   MAC_Init
        0     10   -> TIC_SetRXCallback
        0     10   -> TIC_SetTXCallback
        0     12   -> memset
      1     28   MAC_OpenRXSlot
        0     10   -> TIC_SetRXState
        0     10   -> printf
        0     16   -> printf
      1     18   MAC_RX_HNDL
        0     12   -> BitRawDecrypt
        0     12   -> MAC_ACK_Send
        0     12   -> RI_Receive
        0     12   -> RI_SetChannel
        0     12   -> TIM_delay
        0     12   -> printf
        0     18   -> printf
      0     22   MAC_Reset
        0     10   -> frame_delete
        0     12   -> memset
      1     34   MAC_Send
        0     12   -> BitRawCrypt
        0     12   -> TIC_SetTXState
        0     12   -> printf
        0     18   -> printf
      2      0   MAC_SetRXCallback
      1     16   MAC_TX_HNDL
        0     10   -> MAC_ACK_Recv
        0     10   -> RI_Send
        0     10   -> RI_SetChannel
        0     10   -> TIC_SetTXState
        0     10   -> TIM_delay
        0     10   -> frame_delete
        0     10   -> printf
        0     16   -> printf
      0     21   MAC_setIV
        0     12   -> memcpy
      0     21   MAC_setKEY
        0     12   -> memcpy
      2      0   MG_Init
        2      0   -> AES_init
        2      0   -> CF_init
        2      0   -> DMA_init
        2      0   -> LLC_Init
        2      0   -> MAC_Init
        2      0   -> MAC_setIV
        2      0   -> MAC_setKEY
        2      0   -> NT_Init
        2      0   -> RI_init
        2      0   -> RXB_Init
        2      0   -> SY_Init
        2      0   -> SY_setIV
        2      0   -> SY_setKEY
        2      0   -> TIC_Init
        2      0   -> TIM_init
      0     16   MyLowLevelPutchar
      0     48   NT_GetTime
        0     16   -> ReadTimer
      0     15   NT_IRQEnable
      2      0   NT_Init
        2      0   -> NT_IRQEnable
      0     32   NT_SetCompare
        0     12   -> NT_IRQEnable
        0     12   -> calcCompareTime
        0     12   -> loadTimerCompare
        0     12   -> printf
        0     18   -> printf
      2      0   NT_SetEventCallback
      0     30   NT_SetTime
        0     14   -> NT_SetCompare
        0     14   -> ReadTimer
        0     14   -> isIRQEnable
        0     14   -> printf
        0     20   -> printf
      0     24   NT_WaitTime
      2      0   RI_GetCCAReject
      2      0   RI_GetCRCError
      2      0   RI_GetUptime
      1     27   RI_Measure_POW
        0     14   -> RI_cfg
        0     14   -> TIM_delay
      1     58   RI_Receive
        0     42   -> RI_cfg
        0     44   -> RecvData
        0     42   -> TIM_TimeStamp
        0     42   -> TIM_passedTime
        0     42   -> UnLoadRXData
        0     42   -> frame_addHeader
        0     42   -> frame_create
        0     42   -> re_free
        0     42   -> re_malloc
      2     10   RI_Reset
        2      0   -> RI_init
      0     61   RI_Send
        0     36   -> RI_cfg
        0     36   -> SendData
        0     36   -> TIM_TimeStamp
        0     36   -> TIM_passedTime
        0     36   -> printf
        0     42   -> printf
      2     44   RI_SetChannel
      3     43   RI_cfg
        2      1   -> setFreq
      2      0   RI_init
        2      0   -> random_core_init
      1      9   RXB_Callback
        0      9   -> frame_delete
      3      0   RXB_Init
        2      0   -> LLC_SetRXCallback
      0     19   RXB_Reset
        0      9   -> Delete_frame
      0     32   RXB_del_frame
        0     12   -> Delete_frame
        0     12   -> printf
        0     18   -> printf
      2     10   RXB_frame_count
      2     14   RXB_get_frame
      2     22   ReadTimer
      0     76   RecvData
        0     32   -> NT_GetTime
        0     32   -> TIM_TimeStamp
        0     32   -> TIM_passedTime
      0      0   STACK_FAILURE
      2     11   SY_Enable
      0     10   SY_Init
        0     10   -> TIC_SetSyncTimeAllocCallback
        0     10   -> TIC_SetTS1Callback
        0     10   -> TIC_SlotActivityTime
        0     10   -> TIC_SlotTime
      2     10   SY_Reset
      0     55   SY_SYNC_NETWORK
        0     44   -> RI_SetChannel
        0     44   -> TIC_CloseAllState
        0     44   -> TIC_GetTimer
        0     44   -> TIC_GetUptime
        0     44   -> TIC_SetRTC
        0     44   -> TIC_SetTimer
        0     44   -> TIM_TimeStamp
        0     44   -> TIM_passedTime
        0     44   -> frame_delete
        0     44   -> get_sync
      0     16   SY_TIME_ALLOC_MASTER
        0     16   -> TIC_GetTXState
        0     16   -> TIC_GetUptime
        0     16   -> TIC_SetTXState
      0     12   SY_TS1_HNDL_MASTER
        0     12   -> TIC_SetTXState
        0     12   -> send_sync
      0     21   SY_setIV
        0     12   -> memcpy
      0     21   SY_setKEY
        0     12   -> memcpy
      2      0   SY_sync_sended
      0     48   SendData
        0     12   -> LoadTXData
        0     12   -> NT_GetTime
        0     12   -> NT_WaitTime
      0     53   TIC_CloseAllState
        0      9   -> TIC_SetRXState
        0      9   -> TIC_SetTXState
      2      0   TIC_GetNonce
      2     19   TIC_GetRTC
      0     16   TIC_GetRXState
        0     10   -> printf
        0     16   -> printf
      0     32   TIC_GetTXState
        0     10   -> printf
        0     16   -> printf
      0      0   TIC_GetTimeStampTS0
      2     44   TIC_GetTimer
        2      0   -> NT_GetTime
      2     44   TIC_GetUptime
      0      9   TIC_HW_Timer_IRQ
        0      9   -> Callback_execution
        0      9   -> TIC_TDMAShelduler
        0      9   -> TIC_getCurrentTS
        0      9   -> TIM_TimeStamp
        0      9   -> clocks_update
      2      0   TIC_Init
        2      0   -> NT_SetCompare
        2      0   -> NT_SetEventCallback
        2      0   -> TIC_CloseAllState
        2      0   -> TIC_SetTimer
        2      0   -> TIM_TimeStamp
      2     10   TIC_Reset
        2      0   -> NT_SetCompare
        2      0   -> TIC_CloseAllState
        2      0   -> TIC_SetTimer
        2      0   -> TIM_TimeStamp
      0     12   TIC_SetNonce
      0     56   TIC_SetRTC
      0     26   TIC_SetRXCallback
        0     10   -> printf
        0     16   -> printf
      0     26   TIC_SetRXState
        0     10   -> printf
        0     16   -> printf
      0     16   TIC_SetSECallback
        0     10   -> printf
        0     16   -> printf
      0     26   TIC_SetSyncTimeAllocCallback
        0     10   -> printf
        0     16   -> printf
      0     26   TIC_SetTS1Callback
        0     10   -> printf
        0     16   -> printf
      0     26   TIC_SetTXCallback
        0     10   -> printf
        0     16   -> printf
      0     32   TIC_SetTXState
        0     10   -> printf
        0     16   -> printf
      0     60   TIC_SetTimer
        0     10   -> NT_SetTime
        0     10   -> printf
        0     16   -> printf
      0      0   TIC_SleepTime
      0     10   TIC_SlotActivityTime
      0     10   TIC_SlotTime
      3     10   TIC_TDMAShelduler
        2      1   -> incrementTS
        2      1   -> set_capture_time
      0     24   TIC_TimeUsFromTS0
        0     24   -> TIM_TimeStamp
        0     24   -> TIM_passedTime
      0     19   TIC_getCurrentTS
      3     44   TIM_TimeStamp
      0     14   TIM_copy
        0     14   -> memcpy
      0     76   TIM_delay
        0     36   -> Interval
        0     36   -> TIM_TimeStamp
      2      0   TIM_init
        2      0   -> DelayCalibrate
      0     62   TIM_passedTime
        0     18   -> Interval
      0     15   TimerCompareInterrupt
        0     15   -> NT_GetTime
        0     15   -> NT_IRQEnable
      3     42   UnLoadRXData
      0     18   __write
        0     16   -> MyLowLevelPutchar
      0      9   bits_count
      2     34   calcCompareTime
        0     22   -> ReadTimer
      0     13   check_cmd_frame
      0     21   clocks_update
      0     10   cmd_0x00
        0     10   -> cmd_answer
        0     10   -> get_network_seed_status
      0     12   cmd_0x01
        0     12   -> cmd_answer
        0     12   -> cmd_answer_err
        0     12   -> get_network_seed_status
      0     12   cmd_0x02
        0     12   -> TIC_SetRTC
        0     12   -> cmd_answer
        0     12   -> cmd_answer_err
        0     12   -> get_network_seed_status
      0     20   cmd_0x03
        0     14   -> cmd_answer
        0     14   -> cmd_answer_err
        0     14   -> neocore_stack_reset
        0     14   -> network_seed_enable
        0     14   -> printf
        0     20   -> printf
      0     16   cmd_0x04
        0     14   -> cmd_answer
        0     14   -> cmd_answer_err
        0     14   -> get_network_seed_status
        0     16   -> memcpy
      0     16   cmd_0x05
        0     14   -> cmd_answer
        0     14   -> cmd_answer_err
        0     14   -> get_network_seed_status
        0     16   -> memcpy
      0      9   cmd_0x06
        0      9   -> cmd_answer
        0      9   -> cmd_answer_err
      0     12   cmd_0x07
        0     12   -> MAC_OpenRXSlot
        0     12   -> cmd_answer
        0     12   -> cmd_answer_err
        0     12   -> get_network_seed_status
      0     12   cmd_0x08
        0     12   -> MAC_CloseRXSlot
        0     12   -> cmd_answer
        0     12   -> cmd_answer_err
        0     12   -> get_network_seed_status
      1     10   cmd_0x09
        0     10   -> RXB_frame_count
        0     10   -> cmd_answer
        0     10   -> cmd_answer_err
      1     10   cmd_0x0A
        0     10   -> LLC_GetTaskLen
        0     10   -> cmd_answer
        0     10   -> cmd_answer_err
      0     18   cmd_0x0B
        0     16   -> LLC_AddTask
        0     16   -> cmd_answer
        0     16   -> cmd_answer_err
        0     16   -> frame_addHeader
        0     16   -> frame_create
        0     16   -> frame_delete
        0     16   -> get_network_seed_status
        0     18   -> re_memcpy
      0     14   cmd_0x0C
        0     14   -> RXB_del_frame
        0     14   -> RXB_get_frame
        0     14   -> cmd_answer_err
        0     14   -> get_network_seed_status
        0     14   -> upload_frame
      0     13   cmd_0x0D
        0     13   -> RI_Measure_POW
        0     13   -> cmd_answer
        0     13   -> cmd_answer_err
        0     13   -> get_network_seed_status
      0     12   cmd_0x0E
        0     12   -> cmd_answer
        0     12   -> cmd_answer_err
        0     12   -> get_network_seed_status
      0     12   cmd_0x0F
        0     12   -> cmd_answer
        0     12   -> cmd_answer_err
        0     12   -> get_network_seed_status
      0     12   cmd_0x10
        0     12   -> cmd_answer
        0     12   -> cmd_answer_err
        0     12   -> get_network_seed_status
      1     34   cmd_answer
        0     18   -> crc16
        0     18   -> uart_write
      1     27   cmd_answer_err
        0     11   -> stream_write
      0      9   com_uart_init
        0      9   -> uart_dma_init
      0     27   crc16
      1     66   frame_addHeader
        0     18   -> printf
        0     24   -> printf
        0     18   -> re_free
        0     18   -> re_malloc
        0     20   -> re_memcpy
      0     60   frame_create
        0     14   -> memset
        0     12   -> printf
        0     18   -> printf
        0     12   -> re_malloc
      1     20   frame_delHeader
        0     14   -> printf
        0     20   -> printf
        0     14   -> re_free
        0     14   -> re_malloc
        0     16   -> re_memcpy
      0     54   frame_delete
        0     10   -> re_free
      2     10   frame_getCount
      2      0   frame_len
      0     19   free
        0      9   -> __xdata_free
      0     86   generateAuthData
        0     18   -> memcpy
      2      9   getRNDByte
      2     16   get_network_seed_status
      0     58   get_sync
        0     14   -> BitRawDecrypt
        0     14   -> RI_Receive
        0     14   -> RI_SetChannel
        0     14   -> frame_delete
      0     14   heap_ptr
        0     14   -> re_free
        0     14   -> re_malloc
      2      1   incrementTS
      0     14   isIRQEnable
      0     28   loadTimerCompare
      0      0   main
        0      0   -> com_uart_init
        0      0   -> neocore_hw_init
        0      0   -> network_seed_enable
        0      0   -> parse_uart_stream
      0     23   malloc
        0      9   -> __xdata_malloc
      1     18   mem_move
      2      0   neocore_hw_init
        2      0   -> MG_Init
      0     30   neocore_stack_reset
        0     10   -> LLC_Reset
        0     10   -> MAC_Reset
        0     10   -> RI_Reset
        0     10   -> RXB_Reset
        0     10   -> SY_Reset
        0     10   -> TIC_Reset
        0     10   -> frame_getCount
        0     10   -> network_seed_enable
        0     10   -> printf
        0     16   -> printf
      0     11   network_discovery
        0     11   -> MAC_Enable
        0     11   -> SY_Enable
        0     11   -> SY_SYNC_NETWORK
      0     23   network_seed_enable
        0      9   -> MAC_Enable
        0      9   -> MAC_setIV
        0      9   -> MAC_setKEY
        0      9   -> SY_Enable
        0      9   -> SY_setIV
        0      9   -> SY_setKEY
      2      0   nwDebugerInit
        2      0   -> uart_init
      0     13   parse_uart_stream
        0     13   -> check_cmd_frame
        0     13   -> cmd_answer_err
        0     13   -> uart_recv_cmd
      0      9   random_core_init
        0      9   -> RI_cfg
        0      9   -> rand
        0      9   -> readRandom
        0      9   -> srand
      0     52   re_free
        0     10   -> free
      0     56   re_malloc
        0     14   -> malloc
      0     36   re_memcpy
        0     16   -> memcpy
      0     18   readRandom
        0      9   -> bits_count
        0      9   -> getRNDByte
      1     31   send_sync
        0     19   -> BitRawCrypt
        0     19   -> RI_Send
        0     19   -> RI_SetChannel
        0     19   -> TIC_GetRTC
        0     19   -> frame_addHeader
        0     19   -> frame_create
        0     19   -> frame_delete
      1     18   setFreq
        0     11   -> printf
        0     17   -> printf
      0     10   set_capture_time
        0      9   -> NT_SetCompare
      1     32   stream_write
        0     15   -> crc16
        0     15   -> printf
        0     21   -> printf
        0     15   -> uart_write
      2      9   uart_dma_init
      0      0   uart_getchar
      0      0   uart_init
      0     10   uart_putchar
      3     13   uart_recv_cmd
      0     28   uart_write
        0     10   -> uart_putchar
      0     23   upload_frame
        0      9   -> cmd_answer
        0      9   -> mem_move
      0     23   xor_calc


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
      22  ?<Constant "*ASSERT* %s:%d:%s -> ">
      22  ?<Constant "*ASSERT* %s:%d:%s -> ">_1
      22  ?<Constant "*ASSERT* %s:%d:%s -> ">_2
      22  ?<Constant "*ASSERT* %s:%d:%s -> ">_3
      22  ?<Constant "*ASSERT* %s:%d:%s -> ">_4
      22  ?<Constant "*ASSERT* %s:%d:%s -> ">_5
      22  ?<Constant "*ASSERT* %s:%d:%s -> ">_6
      22  ?<Constant "*ASSERT* %s:%d:%s -> ">_7
      22  ?<Constant "*ASSERT* %s:%d:%s -> ">_8
      22  ?<Constant "*ASSERT* %s:%d:%s -> ">_9
      44  ?<Constant "E:\\WMNU\\IAR\\NEOCOREGA...">
      42  ?<Constant "E:\\WMNU\\IAR\\NeocoreGa...">
      34  ?<Constant "E:\\WMNU\\IAR\\SHARE_PRJ...">
      32  ?<Constant "E:\\WMNU\\IAR\\SHARE_PRJ...">_1
      32  ?<Constant "E:\\WMNU\\IAR\\SHARE_PRJ...">_2
      36  ?<Constant "E:\\WMNU\\IAR\\SHARE_PRJ...">_3
      33  ?<Constant "E:\\WMNU\\IAR\\SHARE_PRJ...">_4
      34  ?<Constant "E:\\WMNU\\IAR\\SHARE_PRJ...">_5
      36  ?<Constant "E:\\WMNU\\IAR\\SHARE_PRJ...">_6
      32  ?<Constant "E:\\WMNU\\IAR\\SHARE_PRJ...">_7
       3  ?<Constant "\r\n">
       3  ?<Constant "\r\n">_1
       3  ?<Constant "\r\n">_2
       3  ?<Constant "\r\n">_3
       3  ?<Constant "\r\n">_4
       3  ?<Constant "\r\n">_5
       3  ?<Constant "\r\n">_6
       3  ?<Constant "\r\n">_7
       3  ?<Constant "\r\n">_8
       3  ?<Constant "\r\n">_9
      22  ?<Initializer for <Constant "*ASSERT* %s:%d:%s
      22  ?<Initializer for <Constant "*ASSERT* %s:%d:%s_1
      22  ?<Initializer for <Constant "*ASSERT* %s:%d:%s_2
      22  ?<Initializer for <Constant "*ASSERT* %s:%d:%s_3
      22  ?<Initializer for <Constant "*ASSERT* %s:%d:%s_4
      22  ?<Initializer for <Constant "*ASSERT* %s:%d:%s_5
      22  ?<Initializer for <Constant "*ASSERT* %s:%d:%s_6
      22  ?<Initializer for <Constant "*ASSERT* %s:%d:%s_7
      22  ?<Initializer for <Constant "*ASSERT* %s:%d:%s_8
      22  ?<Initializer for <Constant "*ASSERT* %s:%d:%s_9
      44  ?<Initializer for <Constant "E:\\WMNU\\IAR\\NE
      42  ?<Initializer for <Constant "E:\\WMNU\\IAR\\Ne
      34  ?<Initializer for <Constant "E:\\WMNU\\IAR\\SH
      32  ?<Initializer for <Constant "E:\\WMNU\\IAR\\SH_1
      32  ?<Initializer for <Constant "E:\\WMNU\\IAR\\SH_2
      36  ?<Initializer for <Constant "E:\\WMNU\\IAR\\SH_3
      33  ?<Initializer for <Constant "E:\\WMNU\\IAR\\SH_4
      34  ?<Initializer for <Constant "E:\\WMNU\\IAR\\SH_5
      36  ?<Initializer for <Constant "E:\\WMNU\\IAR\\SH_6
      32  ?<Initializer for <Constant "E:\\WMNU\\IAR\\SH_7
       3  ?<Initializer for <Constant "\r\n">>
       3  ?<Initializer for <Constant "\r\n">>_1
       3  ?<Initializer for <Constant "\r\n">>_2
       3  ?<Initializer for <Constant "\r\n">>_3
       3  ?<Initializer for <Constant "\r\n">>_4
       3  ?<Initializer for <Constant "\r\n">>_5
       3  ?<Initializer for <Constant "\r\n">>_6
       3  ?<Initializer for <Constant "\r\n">>_7
       3  ?<Initializer for <Constant "\r\n">>_8
       3  ?<Initializer for <Constant "\r\n">>_9
      34  ?<Initializer for CMD_LIST>
      16  ?<Initializer for IV>
      16  ?<Initializer for IV>_1
      16  ?<Initializer for KEY>
      16  ?<Initializer for KEY>_1
       4  ?<Initializer for MAC_TIMER_MAX>
       4  ?<Initializer for __Constant_15180>
       4  ?<Initializer for __Constant_19833891>
       4  ?<Initializer for __Constant_1>
       4  ?<Initializer for __Constant_1f4>
       4  ?<Initializer for __Constant_20>
       4  ?<Initializer for __Constant_320>
       4  ?<Initializer for __Constant_396>
       4  ?<Initializer for __Constant_3d000000>
       4  ?<Initializer for __Constant_3e8>
       4  ?<Initializer for __Constant_447a0000>
       4  ?<Initializer for __Constant_7fff>
       4  ?<Initializer for __Constant_8000>
       4  ?<Initializer for __Constant_9>
       4  ?<Initializer for __Constant_9c4>
       4  ?<Initializer for __Constant_a>
       4  ?<Initializer for __Constant_c8>
       4  ?<Initializer for __Constant_ffff8000>
       4  ?<Initializer for __Constant_fffffe0c>
       4  ?<Initializer for __Constant_ffffff>
       9  ?<Initializer for __FUNCTION__>
      13  ?<Initializer for __FUNCTION__>_1
      15  ?<Initializer for __FUNCTION__>_10
      16  ?<Initializer for __FUNCTION__>_11
       9  ?<Initializer for __FUNCTION__>_12
      15  ?<Initializer for __FUNCTION__>_13
      15  ?<Initializer for __FUNCTION__>_14
      12  ?<Initializer for __FUNCTION__>_15
      12  ?<Initializer for __FUNCTION__>_16
      20  ?<Initializer for __FUNCTION__>_17
      11  ?<Initializer for __FUNCTION__>_18
      14  ?<Initializer for __FUNCTION__>_19
      16  ?<Initializer for __FUNCTION__>_2
       8  ?<Initializer for __FUNCTION__>_20
       8  ?<Initializer for __FUNCTION__>_21
      14  ?<Initializer for __FUNCTION__>_22
      13  ?<Initializer for __FUNCTION__>_23
      13  ?<Initializer for __FUNCTION__>_24
      15  ?<Initializer for __FUNCTION__>_25
      15  ?<Initializer for __FUNCTION__>_26
      15  ?<Initializer for __FUNCTION__>_27
      15  ?<Initializer for __FUNCTION__>_28
      19  ?<Initializer for __FUNCTION__>_29
      16  ?<Initializer for __FUNCTION__>_3
      18  ?<Initializer for __FUNCTION__>_30
      29  ?<Initializer for __FUNCTION__>_31
      18  ?<Initializer for __FUNCTION__>_32
      18  ?<Initializer for __FUNCTION__>_33
      19  ?<Initializer for __FUNCTION__>_34
      13  ?<Initializer for __FUNCTION__>_4
      18  ?<Initializer for __FUNCTION__>_5
      14  ?<Initializer for __FUNCTION__>_6
      12  ?<Initializer for __FUNCTION__>_7
      14  ?<Initializer for __FUNCTION__>_8
      12  ?<Initializer for __FUNCTION__>_9
      16  ?<Initializer for default_iv>
      16  ?<Initializer for default_key>
     476  AES_CCMDecrypt
       6  AES_CCMDecrypt::?relay
     446  AES_CCMEncrypt
       6  AES_CCMEncrypt::?relay
     608  AES_StreamCoder
       6  AES_StreamCoder::?relay
     205  AES_init
       6  AES_init::?relay
      58  BitRawCrypt
      58  BitRawCrypt
       6  BitRawCrypt::?relay
       6  BitRawCrypt::?relay
      58  BitRawDecrypt
      58  BitRawDecrypt
       6  BitRawDecrypt::?relay
       6  BitRawDecrypt::?relay
     469  CBCMAC_buf_encrypt
       6  CBCMAC_buf_encrypt::?relay
     100  CF_init
       6  CF_init::?relay
       1  CLKCONCMD
       1  CLKCONSTA
      34  CMD_LIST
       4  COMPARE_TIME
      39  CONFIG
     608  CTR_enc_decrypt
       6  CTR_enc_decrypt::?relay
      87  Callback_execution
       6  Callback_execution::?relay
       4  DELAY_CALIBRATE_TICS
       1  DMA0CFGH
       1  DMA0CFGL
       1  DMA1CFGH
       1  DMA1CFGL
       1  DMAARM
       1  DMAREQ
      40  DMA_CH
      37  DMA_init
       6  DMA_init::?relay
     147  DelayCalibrate
       6  DelayCalibrate::?relay
     114  Delete_frame
       6  Delete_frame::?relay
       1  ENCCS
       2  EventCallback
      30  FRAME_POOL
       2  FirstTask
       4  HeadAllocFunc
      16  IV
      16  IV
     163  Interval
       6  Interval::?relay
      16  KEY
      16  KEY
       4  LAST_SYNC_TIME
     310  LLC_AddTask
       6  LLC_AddTask::?relay
      16  LLC_GetTaskLen
       6  LLC_GetTaskLen::?relay
      47  LLC_Init
       6  LLC_Init::?relay
      98  LLC_RX_HNDL
       6  LLC_RX_HNDL::?relay
      43  LLC_Reset
       6  LLC_Reset::?relay
      67  LLC_RunTimeAlloc
       6  LLC_RunTimeAlloc::?relay
      20  LLC_SE_HNDL
       6  LLC_SE_HNDL::?relay
      80  LLC_SetRXCallback
       6  LLC_SetRXCallback::?relay
     317  LLC_Shelduler
       6  LLC_Shelduler::?relay
     148  LLC_TimeAlloc
       6  LLC_TimeAlloc::?relay
      50  LoadTXData
       6  LoadTXData::?relay
     350  MACSlotTable
     122  MAC_ACK_Recv
       6  MAC_ACK_Recv::?relay
      91  MAC_ACK_Send
       6  MAC_ACK_Send::?relay
     124  MAC_CloseRXSlot
       6  MAC_CloseRXSlot::?relay
       1  MAC_ENABLE_MODULE
      23  MAC_Enable
       6  MAC_Enable::?relay
     113  MAC_GetRXState
       6  MAC_GetRXState::?relay
     113  MAC_GetTXState
       6  MAC_GetTXState::?relay
      57  MAC_Init
       6  MAC_Init::?relay
     167  MAC_OpenRXSlot
       6  MAC_OpenRXSlot::?relay
     229  MAC_RX_HNDL
       6  MAC_RX_HNDL::?relay
     135  MAC_Reset
       6  MAC_Reset::?relay
     422  MAC_Send
       6  MAC_Send::?relay
      19  MAC_SetRXCallback
       6  MAC_SetRXCallback::?relay
       4  MAC_TIMER_MAX
     595  MAC_TX_HNDL
       6  MAC_TX_HNDL::?relay
      41  MAC_setIV
       6  MAC_setIV::?relay
      41  MAC_setKEY
       6  MAC_setKEY::?relay
      78  MG_Init
       6  MG_Init::?relay
       1  MG_MODULES_INITED
      12  MyLowLevelPutchar
       6  MyLowLevelPutchar::?relay
       1  NBR_FRAME
       1  NETWORK_SEED
       4  NEXT_SYNC_TIME
       4  NODE_NONCE
       4  NODE_RTC
       4  NODE_UPTIME
      55  NT_GetTime
       6  NT_GetTime::?relay
      19  NT_IRQEnable
       6  NT_IRQEnable::?relay
      74  NT_Init
       6  NT_Init::?relay
     129  NT_SetCompare
       6  NT_SetCompare::?relay
      19  NT_SetEventCallback
       6  NT_SetEventCallback::?relay
     156  NT_SetTime
       6  NT_SetTime::?relay
     126  NT_WaitTime
       6  NT_WaitTime::?relay
       1  P0SEL
       1  P1DIR
       1  P1SEL
       1  PERCFG
       2  RADIO_CFG
       1  RFD
       1  RFIRQF0
       1  RFIRQF1
       1  RFST
       4  RI_CCA_REJECT
       4  RI_CRC_ERROR
      17  RI_GetCCAReject
       6  RI_GetCCAReject::?relay
      17  RI_GetCRCError
       6  RI_GetCRCError::?relay
      17  RI_GetUptime
       6  RI_GetUptime::?relay
     117  RI_Measure_POW
       6  RI_Measure_POW::?relay
     499  RI_Receive
       6  RI_Receive::?relay
      14  RI_Reset
       6  RI_Reset::?relay
     216  RI_Send
       6  RI_Send::?relay
      32  RI_SetChannel
       6  RI_SetChannel::?relay
       4  RI_UPTIME
     109  RI_cfg
       6  RI_cfg::?relay
      26  RI_init
       6  RI_init::?relay
     353  RXB_Callback
       6  RXB_Callback::?relay
     113  RXB_Init
       6  RXB_Init::?relay
      26  RXB_Reset
       6  RXB_Reset::?relay
     162  RXB_del_frame
       6  RXB_del_frame::?relay
     107  RXB_frame_count
       6  RXB_frame_count::?relay
     158  RXB_get_frame
       6  RXB_get_frame::?relay
       2  RXCallback
       2  RXCallback
       2  RXCallback
      59  ReadTimer
       6  ReadTimer::?relay
     152  RecvData
       6  RecvData::?relay
       2  SECallback
       1  SLEEPSTA
       1  ST0
       1  ST1
       1  ST2
       2  STACK_FAILURE
       6  STACK_FAILURE::?relay
       1  STLOAD
       2  SYNC_ACCURATE_NETWORK_TIME
       4  SYNC_SENDED
       4  SYNC_SEND_TIME
       1  SY_ENABLE_MODULE
      23  SY_Enable
       6  SY_Enable::?relay
     121  SY_Init
       6  SY_Init::?relay
      89  SY_Reset
       6  SY_Reset::?relay
     491  SY_SYNC_NETWORK
       6  SY_SYNC_NETWORK::?relay
      73  SY_TIME_ALLOC_MASTER
       6  SY_TIME_ALLOC_MASTER::?relay
      48  SY_TS1_HNDL_MASTER
       6  SY_TS1_HNDL_MASTER::?relay
      41  SY_setIV
       6  SY_setIV::?relay
      41  SY_setKEY
       6  SY_setKEY::?relay
      17  SY_sync_sended
       6  SY_sync_sended::?relay
     159  SendData
       6  SendData::?relay
       2  SyncTimeAllocCallback
       1  T2CTRL
       1  T2M0
       1  T2M1
       1  T2MOVF0
       1  T2MOVF1
      35  TIC_CloseAllState
       6  TIC_CloseAllState::?relay
      17  TIC_GetNonce
       6  TIC_GetNonce::?relay
      17  TIC_GetRTC
       6  TIC_GetRTC::?relay
      98  TIC_GetRXState
       6  TIC_GetRXState::?relay
      98  TIC_GetTXState
       6  TIC_GetTXState::?relay
       7  TIC_GetTimeStampTS0
       6  TIC_GetTimeStampTS0::?relay
      14  TIC_GetTimer
       6  TIC_GetTimer::?relay
      17  TIC_GetUptime
       6  TIC_GetUptime::?relay
     198  TIC_HW_Timer_IRQ
       6  TIC_HW_Timer_IRQ::?relay
      42  TIC_Init
       6  TIC_Init::?relay
      89  TIC_Reset
       6  TIC_Reset::?relay
      26  TIC_SetNonce
       6  TIC_SetNonce::?relay
      40  TIC_SetRTC
       6  TIC_SetRTC::?relay
      80  TIC_SetRXCallback
       6  TIC_SetRXCallback::?relay
     128  TIC_SetRXState
       6  TIC_SetRXState::?relay
      80  TIC_SetSECallback
       6  TIC_SetSECallback::?relay
      80  TIC_SetSyncTimeAllocCallback
       6  TIC_SetSyncTimeAllocCallback::?relay
      80  TIC_SetTS1Callback
       6  TIC_SetTS1Callback::?relay
      80  TIC_SetTXCallback
       6  TIC_SetTXCallback::?relay
     128  TIC_SetTXState
       6  TIC_SetTXState::?relay
      93  TIC_SetTimer
       6  TIC_SetTimer::?relay
       7  TIC_SleepTime
       6  TIC_SleepTime::?relay
       7  TIC_SlotActivityTime
       6  TIC_SlotActivityTime::?relay
      28  TIC_SlotTime
       6  TIC_SlotTime::?relay
      92  TIC_TDMAShelduler
       6  TIC_TDMAShelduler::?relay
      66  TIC_TimeUsFromTS0
       6  TIC_TimeUsFromTS0::?relay
      61  TIC_getCurrentTS
       6  TIC_getCurrentTS::?relay
      61  TIM_TimeStamp
       6  TIM_TimeStamp::?relay
      45  TIM_copy
       6  TIM_copy::?relay
     133  TIM_delay
       6  TIM_delay::?relay
      17  TIM_init
       6  TIM_init::?relay
      94  TIM_passedTime
       6  TIM_passedTime::?relay
       2  TOFFSET
       2  TS1Callback
      50  TSStateTable
       2  TXCallback
       8  TimeStampTS0
      60  TimerCompareInterrupt
       3  TimerCompareInterrupt::??INTVEC 43
       1  U0BAUD
       1  U0CSR
       1  U0DBUF
       1  U0GCR
       1  U1BAUD
       1  U1DBUF
       1  U1GCR
      40  UnLoadRXData
       6  UnLoadRXData::?relay
       1  _A_IEN0
       1  _A_IRCON
       1  _A_P1
       1  _A_U1CSR
       4  __Constant_1
       4  __Constant_15180
       4  __Constant_19833891
       4  __Constant_1f4
       4  __Constant_20
       4  __Constant_320
       4  __Constant_396
       4  __Constant_3d000000
       4  __Constant_3e8
       4  __Constant_447a0000
       4  __Constant_7fff
       4  __Constant_8000
       4  __Constant_9
       4  __Constant_9c4
       4  __Constant_a
       4  __Constant_c8
       4  __Constant_ffff8000
       4  __Constant_fffffe0c
       4  __Constant_ffffff
     156  __write
       6  __write::?relay
      34  bits_count
       6  bits_count::?relay
     162  buf
     189  calcCompareTime
       6  calcCompareTime::?relay
      13  check_cmd_frame
       6  check_cmd_frame::?relay
      94  clocks_update
       6  clocks_update::?relay
      63  cmd_0x00
       6  cmd_0x00::?relay
      72  cmd_0x01
       6  cmd_0x01::?relay
      76  cmd_0x02
       6  cmd_0x02::?relay
     189  cmd_0x03
       6  cmd_0x03::?relay
      91  cmd_0x04
       6  cmd_0x04::?relay
      91  cmd_0x05
       6  cmd_0x05::?relay
      44  cmd_0x06
       6  cmd_0x06::?relay
      79  cmd_0x07
       6  cmd_0x07::?relay
      72  cmd_0x08
       6  cmd_0x08::?relay
      69  cmd_0x09
       6  cmd_0x09::?relay
      69  cmd_0x0A
       6  cmd_0x0A::?relay
     242  cmd_0x0B
       6  cmd_0x0B::?relay
      91  cmd_0x0C
       6  cmd_0x0C::?relay
     103  cmd_0x0D
       6  cmd_0x0D::?relay
      72  cmd_0x0E
       6  cmd_0x0E::?relay
      72  cmd_0x0F
       6  cmd_0x0F::?relay
      72  cmd_0x10
       6  cmd_0x10::?relay
     104  cmd_answer
       6  cmd_answer::?relay
      56  cmd_answer_err
       6  cmd_answer_err::?relay
      34  com_uart_init
       6  com_uart_init::?relay
      93  crc16
       6  crc16::?relay
      16  default_iv
      16  default_key
     367  frame_addHeader
       6  frame_addHeader::?relay
     168  frame_create
       6  frame_create::?relay
     213  frame_delHeader
       6  frame_delHeader::?relay
      71  frame_delete
       6  frame_delete::?relay
      16  frame_getCount
       6  frame_getCount::?relay
      19  frame_len
       6  frame_len::?relay
      21  free
       6  free::?relay
     241  generateAuthData
       6  generateAuthData::?relay
      53  getRNDByte
       6  getRNDByte::?relay
      17  get_network_seed_status
       6  get_network_seed_status::?relay
     103  get_sync
       6  get_sync::?relay
      56  heap_ptr
       6  heap_ptr::?relay
      36  incrementTS
       6  incrementTS::?relay
      11  isIRQEnable
       6  isIRQEnable::?relay
      70  loadTimerCompare
       6  loadTimerCompare::?relay
      20  main
       6  main::?relay
      21  malloc
       6  malloc::?relay
      50  mem_move
       6  mem_move::?relay
       1  nbrTasks
      26  neocore_hw_init
       6  neocore_hw_init::?relay
     102  neocore_stack_reset
       6  neocore_stack_reset::?relay
      65  network_discovery
       6  network_discovery::?relay
      80  network_seed_enable
       6  network_seed_enable::?relay
      14  nwDebugerInit
       6  nwDebugerInit::?relay
       2  pACK
     148  parse_uart_stream
       6  parse_uart_stream::?relay
      78  random_core_init
       6  random_core_init::?relay
      35  re_free
       6  re_free::?relay
      49  re_malloc
       6  re_malloc::?relay
      65  re_memcpy
       6  re_memcpy::?relay
      54  readRandom
       6  readRandom::?relay
       4  ret_val
     158  send_sync
       6  send_sync::?relay
     120  setFreq
       6  setFreq::?relay
      40  set_capture_time
       6  set_capture_time::?relay
     156  stream_write
       6  stream_write::?relay
       1  tasksBLOCK
     132  uart_dma_init
       6  uart_dma_init::?relay
       9  uart_getchar
       6  uart_getchar::?relay
      23  uart_init
       6  uart_init::?relay
       9  uart_putchar
       6  uart_putchar::?relay
      41  uart_recv_cmd
       6  uart_recv_cmd::?relay
     255  uart_rx_buff
      48  uart_write
       6  uart_write::?relay
     149  upload
      87  upload_frame
       6  upload_frame::?relay
       4  val
      59  xor_calc
       6  xor_calc::?relay
     513  -- Other

 
 18 736 bytes in segment BANKED_CODE
  1 080 bytes in segment BANK_RELAYS
      3 bytes in segment INTVEC
     60 bytes in segment NEAR_CODE
     38 bytes in segment SFR_AN
  1 328 bytes in segment XDATA_I
  1 328 bytes in segment XDATA_ID
  1 176 bytes in segment XDATA_Z
 
  2 374 bytes of CODE     memory (+ 97 bytes shared)
      0 bytes of DATA     memory (+ 38 bytes shared)
 18 692 bytes of HUGECODE memory (+ 44 bytes shared)
  2 428 bytes of XDATA    memory (+ 76 bytes shared)

Errors: none
Warnings: 7
