###############################################################################
#
# IAR C/C++ Compiler V10.10.1.4655 for 8051               17/Jan/2020  12:49:08
# Copyright 2004-2017 IAR Systems AB.
# PC-locked license - IAR Embedded Workbench for 8051
#
#    Core               =  plain
#    Code model         =  banked
#    Data model         =  large
#    Calling convention =  xdata reentrant
#    Constant location  =  data
#    Dptr setup         =  1,16
#                          
#    Source file        =  
#        \\vmware-host\Shared Folders\Projects\WMNU\IAR\SHARE_PRJ_SRC\RADIO.c
#    Command line       =  
#        -f C:\Users\08A4~1\AppData\Local\Temp\EW28D2.tmp
#        ("\\vmware-host\Shared
#        Folders\Projects\WMNU\IAR\SHARE_PRJ_SRC\RADIO.c" -lcN
#        "\\vmware-host\Shared
#        Folders\Projects\WMNU\IAR\NeocoreGateway\Debug\List" -o
#        "\\vmware-host\Shared
#        Folders\Projects\WMNU\IAR\NeocoreGateway\Debug\Obj" -e --debug
#        --core=plain --dptr=16,1 --data_model=large --code_model=banked
#        --calling_convention=xdata_reentrant --place_constants=data
#        --nr_virtual_regs 8 --dlib_config "C:\Program Files (x86)\IAR
#        Systems\Embedded Workbench 8.0\8051\LIB\DLIB\dl8051Normal.h" -I
#        "\\vmware-host\Shared Folders\Projects\WMNU\IAR\SHARE_PRJ_SRC\" -On
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_cross_call)
#    Locale             =  Russian_Russia.1251
#    List file          =  
#        \\vmware-host\Shared
#        Folders\Projects\WMNU\IAR\NeocoreGateway\Debug\List\RADIO.lst
#    Object file        =  
#        \\vmware-host\Shared
#        Folders\Projects\WMNU\IAR\NeocoreGateway\Debug\Obj\RADIO.r51
#
###############################################################################

\\vmware-host\Shared Folders\Projects\WMNU\IAR\SHARE_PRJ_SRC\RADIO.c
      1          /*!
      2          \file 
      3          \brief Модуль содержит реализацию интерфейса радио для приема/передачи данных.
      4          */
      5          
      6          #include "RADIO.h"
      7          #include "mem.h"
      8          #include "nwdebuger.h"
      9          #include "Radio_defs.h"
     10          #include "TIC.h"
     11          #include "delays.h"
     12          #include "frame.h"
     13          #include "string.h"
     14          #include "NTMR.h"
     15          
     16          // Открытые методы модуля
     17          void RI_init(void);
     18          bool RI_SetChannel(uint8_t CH);
     19          bool RI_Send(frame_s *fr);
     20          frame_s* RI_Receive(uint16_t timeout);
     21          uint32_t RI_GetCRCError(void);
     22          uint32_t RI_GetCCAReject(void);
     23          float RI_GetUptime(void);
     24          
     25          // Приватные методы
     26          static void random_core_init(void);
     27          static void RI_cfg(void);
     28          
     29          static inline void setFreq(uint8_t CH); // Установка частоты передатчика
     30          static void LoadTXData(uint8_t *src, uint8_t len); // Загрузка данных в tx buf
     31          static void UnLoadRXData(uint8_t *src, uint8_t len);
     32          static bool SendData(frame_s *fc);
     33          static bool RecvData(uint32_t timeout_us, uint16_t *SFD_TimeStamp);
     34          
     35          // Переменные модуля
     36          static float RI_UPTIME = 0; // Время работы радио в мс. 49 дней максимум
     37          static uint32_t RI_CRC_ERROR = 0; // Количество ошибок CRC
     38          static uint32_t RI_CCA_REJECT = 0; // Количество отказов передач из-за CCA
     39          
     40          /*!
     41          \brief Константы для установки выходной мощности радиопередатчика.
     42          Пример: p4x5 = +4,5 дБ. m0x5 = -0.5 дБ
     43          */
     44          enum TX_POWER_e 
     45          {
     46            // +4.5дБ = p4x5, -1.5дБ = m1x5.
     47            // +4.5 = 34мА, +1 = 29мА, -4 = 26мА, -10 = 25 мА, -22 = 23 мА
     48            p4x5 = 0xF5, p2x5 = 0xE5, p1x0 = 0xD5, m0x5 = 0xC5, m1x5 = 0xB5, m3x0 = 0xA5,
     49            m4x0 = 0x95, m6x0 = 0x85, m8x0 = 0x75, m10x0 = 0x65, m12x0 = 0x55, 
     50            m14x0 = 0x45, m16x0 = 0x35, m20x0 = 0x15, m22x0 = 0x05
     51          };
     52          
     53          
     54          #define IEEE_MODE 0     //!< Режимы фазы сигнала
     55          #define NOT_IEEE_MODE 1 //!< Режимы фазы сигнала
     56          #define RSSI_OFFSET -76 //!< Константа для вычисления реальной мощности
     57          
     58          /*!
     59          \details 
     60           Расчет качества связи. Коэффициенты получаются эксперементально.
     61           Есть предположение, что количество ошибок будет пропорционально квадрату
     62           коеффициента корреляции сигнала.
     63           LIQ = 255 передача 1000 пакетов без ошибок CRC
     64           LIQ = 127 передача 1000 пакетов с 50% ошибок CRC
     65           LIQ = 0   передача 1000 пакетов с 100% ошибок CRC
     66          */ 
     67          #define CONST_A (int8_t)0 //!< Коэффициент A
     68          #define CONST_B (int8_t)1 //!< Коэффициент B
     69          #define LIQ_CALC(corr) ((corr-CONST_A)*CONST_B) //!< Формула вычисление LIQ 
     70          #define FRQ_CALC(x) (11+5*(x-11)) //!< Формул вычисления частоты сигнала
     71          
     72          /// Глобальные параметры модуля
     73          struct
     74          {
     75            uint8_t CH;       //!< Номер канала с 11 до 28 включительно
     76            uint8_t TX_POWER; //!< Мощность радиопередатчика по умолчанию. 7 бит
     77            bool MODULATION_MODE; //!< false - совместимость с IEEE 802.15.4
     78          } RADIO_CFG;
     79          
     80          /*!
     81          \brief Иницилизация радио интерфейса
     82          */
     83          void RI_init(void)
     84          {
     85            // Настройки поумолчанию
     86            RADIO_CFG.CH = CH11;
     87            RADIO_CFG.TX_POWER = m0x5;
     88            RADIO_CFG.MODULATION_MODE = IEEE_MODE;
     89            // Пост действия с радио
     90            random_core_init();
     91          }
     92          
     93          /*!
     94          \brief Переводит радио в активный режим и устанавливает параметры.
     95          */
     96          static void RI_cfg(void)
     97          {
     98          /*
     99          APPEND_DATA_MODE = 0. FCS1 = signed rssi, FCS2.7 CRC OK, FCS2.6-0 Correlation
    100          A correlation value of ~110 indicates a maximum quality frame while a value 
    101          of ~50 is typically the lowest quality frames detectable by CC2520. 
    102          */
    103          /* После включения радио находится в активном режиме но приемник выключен */
    104            
    105            // Устанавливаем частоту радиопередатчика
    106            setFreq(RADIO_CFG.CH);
    107            
    108            // Устанавливаем мощность выходного сигнала
    109            TXPOWER = RADIO_CFG.TX_POWER;
    110           
    111            FRMFILT0 = 0x00; // Отключаем фильтрацию пакетов
    112            
    113            // Устанавливаем режим модуляции
    114            MDMTEST1_u MDM1;
    115            MDM1.value = MDMTEST1;
    116            MDM1.bits.MODULATION_MODE = RADIO_CFG.MODULATION_MODE;
    117            MDMTEST1 = MDM1.value; 
    118          }
    119          
    120          /*!
    121          \brief Устанавливает канал радиопередатчика.
    122          \param[in] CH Номера каналов [11..28]
    123          \return Возвращает true если аргументы верны
    124          */
    125          bool RI_SetChannel(uint8_t CH)
    126          {
    127            if ((CH >=11) && (CH<=28))
    128            {
    129              RADIO_CFG.CH = CH;
    130              return true;
    131            }
    132            return false;
    133          }
    134          
    135          /*!
    136          \brief Передает данные в эфир
    137          \details Увеличивает  RI_CCA_REJECT при невозможности отправки сообщения, расчитывает время работы 
    138           радио передатчика. Отправка сообщения в заданное сетевое время 
    139           fr->meta.SEND_TIME. Если равно 0, то отправка через случайноу время в мкс.
    140           Данные автоматически оборачиваются в LEN, CRC1,CRC2
    141          \param[in] *fr Указатель на структуру frame_s RAW_LAY
    142          \return Возвращает true в случаи успешной передачи
    143          */
    144          bool RI_Send(frame_s *fr)
    145          {
    146            ASSERT(fr != NULL);
    147            
    148            // Устанавливаем частоту передачи пакета
    149            RI_cfg();
    150            
    151            bool send_res; // Результат передачи данных
    152            TimeStamp_s start,stop; // Измерение времени
    153            
    154            TIM_TimeStamp(&start); // Начало измерения времени
    155            send_res = SendData(fr);
    156            TIM_TimeStamp(&stop); // Конец измерения времени
    157            
    158            uint32_t passed = TIM_passedTime(&start, &stop);
    159            RI_UPTIME += (float)passed/1000; // Микросекунды в милисекунды
    160            
    161            // В случаи ошибки передачи увеличиваем счетчик RI_CCA_REJECT
    162            if (!send_res)
    163              RI_CCA_REJECT++;
    164            
    165            return send_res;
    166          }
    167          
    168          /**
    169          @brief Отправка сообщения
    170          @detail Время отправки с шифрованием 10 байт в мкс. Merge = 155, Crypt = 239,
    171           Load TX = 30, RSSI_OK = 328, ISTXON = 11, SFD(192us+5*8*4us) = 400, TX = 370, Full = 1535.
    172          Время работы радио RSSI_OK+ISTXON+SFD+TX = 1109 us
    173          @return true в случаи успеха
    174          */
    175          static bool SendData(frame_s *fr)
    176          {
    177          ////TimeStamp_s ts_start, ts_frame_merge, ts_crypt, ts_load_tx, 
    178          ////ts_rssistat, ts_istxon, ts_sfd, ts_stop;
    179            
    180          ////TIM_TimeStamp(&ts_start);  
    181                
    182          ////TIM_TimeStamp(&ts_frame_merge);  
    183            bool result = true;
    184            switch(true)
    185            {
    186              case true:
    187          ////TIM_TimeStamp(&ts_crypt); 
    188                // Копируем данные в буфер. Очистка буфера автоматическая
    189                LoadTXData(fr->payload, fr->len);
    190          ////TIM_TimeStamp(&ts_load_tx); 
    191                // Для начала передачи по команде STXONCCA нужно включить приемник
    192                ISRXON();
    193                // Ждем пока статус RSSI_VALID станет true
    194                while(!RSSISTAT);
    195          ////TIM_TimeStamp(&ts_rssistat); 
    196                // Очищаем флаг завершения передачи сообщения
    197                RFIRQF1 &= ~RFIRQF1_TXDONE;
    198                RFIRQF0 &= ~RFIRQF0_SFD;
    199                
    200                // Время отправки сообщения измеряется в тактах сетевого времени NTMR
    201                // Он работатаеи намного лучше чем MAC таймер(меньше погрешность)
    202                // Отправка в обозначенное время или по факту готовности
    203                //13 - поправка в тактах сети на передачу преамболы
    204                uint16_t timer = 0; // Для отлалки. 
    205                if (fr->meta.SEND_TIME != 0)
    206                  timer = NT_WaitTime(fr->meta.SEND_TIME - 13); 
    207          
    208                // Начинаем передачу данных
    209                // Transmission of preamble begins 192 μs after the STXON or STXONCCA 
    210                // command strobe
    211                // 192+(4(pream)+1(sfd))*8bit*4us = 352 мкс. Измерил 360мкс
    212                // Измерил в тактах NT_GetTimer() получилось 13 тиков. 396 мкс 
    213                ISTXONCCA();
    214          ////TIM_TimeStamp(&ts_istxon); 
    215                // Произошла ошибка передачи если SAMPLED_CCA false
    216                if (!(FSMSTAT1 & 1<<3)) //SAMPLED_CCA == 0
    217                {
    218                  result = false;
    219                  break;
    220                }
    221          
    222                // Ждем завершения отправки SFD
    223                while (!(RFIRQF0 & RFIRQF0_SFD));
    224                fr->meta.TIMESTAMP = NT_GetTime(); 
    225          ////TIM_TimeStamp(&ts_sfd); 
    226                // Проверим переданно ли сообщение TX_FRM_DONE
    227                while (!(RFIRQF1 & RFIRQF1_TXDONE));
    228                break;
    229            }
    230          ////TIM_TimeStamp(&ts_stop);
    231            
    232            ISRFOFF();
    233          ////  LOG(MSG_ON | MSG_INFO | MSG_TRACE, 
    234          ////"Merge = %lu. Crypt = %lu. Load TX = %lu. RSSI_OK = %lu. ISTXON = %lu. SFD = %lu. TX = %lu. FULL = %lu \n", 
    235          ////      TIM_passedTime(&ts_start, &ts_frame_merge),
    236          ////      TIM_passedTime(&ts_frame_merge, &ts_crypt),
    237          ////      TIM_passedTime(&ts_crypt, &ts_load_tx),
    238          ////      TIM_passedTime(&ts_load_tx, &ts_rssistat),
    239          ////      TIM_passedTime(&ts_rssistat, &ts_istxon),
    240          ////      TIM_passedTime(&ts_istxon, &ts_sfd),
    241          ////      TIM_passedTime(&ts_sfd, &ts_stop),
    242          ////      TIM_passedTime(&ts_start, &ts_stop)
    243          ////      );
    244            
    245            if (result)
    246              return true;
    247            return false; 
    248          }
    249          
    250          /**
    251          @brief Загрузка данных для передачи в буфер. 
    252          @detail Поля LEN, FCS1, FCS2 добавляются автоматически
    253          @param[in] src указатель на данные
    254          @param[in] len размер данных
    255          */
    256          static void LoadTXData(uint8_t *src, uint8_t len)
    257          {
    258            // Очищаем буфер передатчика
    259            ISFLUSHTX(); 
    260            // Поле LEN на два байта больше
    261            RFD = len + 2;
    262            
    263            for (uint8_t i = 0 ; i < len; i++)
    264              RFD = src[i];
    265            
    266            // Добавляем CRC1,2
    267            RFD = 0x00;
    268            RFD = 0x00;
    269          };
    270          
    271          /**
    272          @brief Выгружаем принятый пакет из радио
    273          @param[out] src указатель на буфер приемника
    274          @param[in] len размер выгружаемых данных
    275          */
    276          static void UnLoadRXData(uint8_t *src, uint8_t len)
    277          {
    278            for (uint8_t i = 0 ; i < len; i++)
    279              src[i] = RFD;
    280          };
    281          
    282          static inline void setFreq(uint8_t CH)
    283          {
    284            ASSERT( (CH >= 11) && (CH <= 28));
    285            // Устанавливаем частоту радиопередатчика
    286            FREQCTRL_u FRQ;
    287            FRQ.value = FRQ_CALC(RADIO_CFG.CH);
    288            FREQCTRL = FRQ.value;  
    289          }
    290          
    291          /*!
    292          \brief Принимает данные из эфира
    293          \details Функция принимает данные из эфира. Проводит проверку CRC, увеличивает
    294          RI_CRC_ERROR. Отмечает время прихода SFD в тактах сетевого времени .
    295          \param[in] timeout Время ожидания данных в милисекундах
    296          \return Возвращает NULL если данных нет
    297          */
    298          frame_s* RI_Receive(uint16_t timeout)
    299          {
    300            // Устанавливаем частоту передачи пакета
    301            RI_cfg();
    302            uint16_t SFD_TimeStamp;
    303            
    304            // Принимаем пакет 
    305            uint32_t timeout_us = timeout*1000UL; // Переводим мс->мкс
    306            TimeStamp_s start,stop; // Измерение времени
    307            TIM_TimeStamp(&start); // Начало измерения времени работы радио
    308            bool recv_res = RecvData(timeout_us, &SFD_TimeStamp);
    309            TIM_TimeStamp(&stop); // Конец измерения времени радио
    310            uint32_t passed = TIM_passedTime(&start, &stop);
    311            RI_UPTIME += (float)passed/(float)1000; // Микросекунды в милисекунды
    312            
    313            // Если ничего не приняли возвращаем NULL
    314            if (!recv_res)
    315              return NULL;
    316            
    317            uint8_t frame_size = RXFIFOCNT; // Количество принятых данных
    318            
    319            // Минимальный размер FCS1,FCS2 - 2 байта. LEN не включен в подсчет 
    320            if (frame_size <= 2)
    321              return NULL;
    322            
    323            // Выгружаем данные из приемника
    324            uint8_t *frame_raw = re_malloc(frame_size); 
    325            UnLoadRXData(frame_raw, frame_size);
    326            
    327            int8_t  FCS1 = frame_raw[frame_size - 2]; // RSSI
    328            uint8_t FCS2 = frame_raw[frame_size - 1]; // bit7 = CRCOK, bit[6..0] Corr_val
    329            uint8_t LEN_F = frame_raw[0]; // Поле LEN
    330            
    331            // Проверим поле LEN. Размер данных в заголовке должен совпадать
    332            // с фактической длинной принятых данных
    333            if (LEN_F != frame_size - 1)
    334            {
    335              re_free(frame_raw);
    336              RI_CRC_ERROR ++;
    337              return NULL;
    338            }
    339            
    340            // Проверим поле CRCOK
    341            if (!(FCS2 && 1<<7))
    342            {
    343              re_free(frame_raw);
    344              RI_CRC_ERROR ++;
    345              return NULL;
    346            }
    347            
    348            // Создаем буфер, последнии два байта FCS1,2 и поле LEN не копируем
    349            frame_s *raw_frame = frame_create();
    350            frame_addHeader(raw_frame, &frame_raw[1], frame_size - 3);
    351            
    352            // Копируем метку времени SFD
    353            raw_frame->meta.TIMESTAMP = SFD_TimeStamp;
    354            
    355            // Расчитываем мощность принятого сигнала
    356            raw_frame->meta.RSSI_SIG =  FCS1 + RSSI_OFFSET;
    357            // Расчитываем качество сигнала
    358            uint8_t corr = FCS2 & 0x7F;
    359            raw_frame->meta.LIQ = LIQ_CALC(corr); // Значение коэфф. корреляции
    360          
    361            raw_frame->meta.CH = RADIO_CFG.CH;
    362          
    363            re_free(frame_raw);
    364            return raw_frame;
    365          }
    366          
    367          /**
    368          @brief Прием данных из эфира
    369          @param[in] timeout_us время ожидания в микросекундах
    370          @param[out] SFD_TimeStamp отметка времени завершения приема SFD
    371          */
    372          static bool RecvData(uint32_t timeout_us, uint16_t *SFD_TimeStamp)
    373          {
    374            TimeStamp_s start,stop; // Измерение времени  
    375            ISFLUSHRX(); // Очищаем буфер приема
    376            
    377            TIM_TimeStamp(&start);
    378            
    379            // Очищаем флаг завершения передачи сообщения и приема SFD
    380            RFIRQF0 &= ~RFIRQF0_RXPKTDONE;  
    381            RFIRQF0 &= ~RFIRQF0_SFD; 
    382            ISRXON(); // Включаем радиопередатчик
    383          
    384            bool time_out = false; // Истекло время ожидания пакета
    385            bool packet_received = false; // Приняли пакет
    386            bool sfd_received = false; // Приняли sfd
    387            
    388            // Цикл приема пакета
    389            while (true)
    390            {
    391              TIM_TimeStamp(&stop);
    392              if (TIM_passedTime(&start, &stop) >= timeout_us)
    393              {
    394                time_out = true;
    395                break;
    396              }
    397             
    398              // Принят сигнал SFD
    399              if ((RFIRQF0 & RFIRQF0_SFD))
    400              {
    401                *SFD_TimeStamp = NT_GetTime(); 
    402                sfd_received = true;
    403              }
    404              
    405              //  Завершен ли прием сообщения RX_FRM_DONE (RXPKTDONE)
    406              if ((RFIRQF0 & RFIRQF0_RXPKTDONE))
    407              {
    408                packet_received = true;
    409                break;
    410              }
    411            } // while 
    412            
    413            ISRFOFF();
    414            if (packet_received && sfd_received && !time_out)
    415              return true;
    416            else
    417              return false;
    418          }
    419          
    420          /*!
    421          \brief Возвращает количество ошибок возникших с момента иницилизации
    422          \return Количество CRC ошибок
    423          */
    424          uint32_t RI_GetCRCError(void)
    425          {
    426            return RI_CRC_ERROR;
    427          }
    428          
    429          /*!
    430          \brief Возвращает количестов отказов передачи пакета из-за занятости канала.
    431          \return Количество отказов CCA
    432          */
    433          uint32_t RI_GetCCAReject(void)
    434          {
    435            return RI_CCA_REJECT;
    436          }
    437          
    438          /*!
    439          \brief Возвращает суммарное время работы радио в режиме прием/передача
    440          \return Вермя в милисекундах
    441          */
    442          float RI_GetUptime(void)
    443          {
    444            return RI_UPTIME;
    445          }
    446          
    447          /**
    448          @breif Подссчет количества бит в байте
    449          @return Возвращает количество бит
    450          */
    451          static uint8_t bits_count(uint8_t value) {
    452            int ret = 0;
    453            for ( ; value; value = value >> 1 )
    454              ret += value & 1;
    455            return ret;
    456          }
    457          
    458          /**
    459          @brief Возращает 1 байт случайного числа
    460          @details Радио выдает всего лишь дви бита, нам нужно 8 
    461          */
    462          static inline uint8_t getRNDByte(void)
    463          {
    464            uint8_t val = 0;
    465            val |= RFRND << 0;
    466            val |= RFRND << 2;
    467            val |= RFRND << 4;
    468            val |= RFRND << 6;
    469            return val;
    470          }
    471          
    472          /**
    473          @brief Возвращает случайное число с числом включеных бит от 2 до 6 включительно
    474          @details Случайные числа появляются в регистре с частотой 170нс. Функция 
    475          возвращает гарантированно новое значение. 
    476          @return возвращает случайное число.
    477          */
    478          static inline uint8_t readRandom(void)
    479          {
    480            uint8_t rnd_val = 0;
    481            uint8_t bit_cnt = 0;
    482            while ( bit_cnt <= 2 || bit_cnt >= 6 )
    483            {
    484              rnd_val = getRNDByte();
    485              while (rnd_val == getRNDByte());
    486              rnd_val = getRNDByte();
    487              bit_cnt = bits_count(rnd_val);
    488            }
    489            return rnd_val;
    490          }
    491          
    492          /*!
    493          \brief Иницилизирует ядро генератора случайных чисел данными из эфира
    494          */
    495          static void random_core_init(void)  
    496          {
    497            unsigned int rnd_core = 0;;
    498               
    499            RI_cfg();
    500            FREQCTRL = 0x00; // Выбираем не используемую частоту
    501          
    502            // TODO По какой то причине OP_EXE не выполняет команду.
    503            // регистра RFST читается как 0xD0. это его состояние при reset
    504            // Включаем демодулятор
    505            ISRXON();
    506            
    507            // Ждем пока статус RSSI_VALID станет true
    508            while(!RSSISTAT);
    509            
    510            // Ждем случайных чисел
    511            while (RFRND == 0);
    512            
    513            // Настраиваем ядро случайного генератора
    514            rnd_core = readRandom();
    515            rnd_core |= (unsigned int)readRandom()<<8;
    516            srand(rnd_core);
    517            
    518            // Включаем демодулятор
    519            ISRFOFF();
    520            // Первая генерация случайного числа занимает много времени.
    521            // Влияло на работу радио, так как использовались случайные посылки
    522            rand(); 
    523          }
    524          

   Maximum stack usage in bytes:

   ISTACK XSTACK Function
   ------ ------ --------
      2     12   LoadTXData
      2      0   RI_GetCCAReject
      2      0   RI_GetCRCError
      2      0   RI_GetUptime
      1     46   RI_Receive
        0     44   -> RI_cfg
        0     46   -> RecvData
        0     44   -> TIM_TimeStamp
        0     44   -> TIM_passedTime
        0     44   -> UnLoadRXData
        0     44   -> frame_addHeader
        0     44   -> frame_create
        0     44   -> re_free
        0     44   -> re_malloc
      0     42   RI_Send
        0     36   -> RI_cfg
        0     36   -> SendData
        0     36   -> TIM_TimeStamp
        0     36   -> TIM_passedTime
        0     36   -> printf
        0     42   -> printf
      2      0   RI_SetChannel
      3     45   RI_cfg
        2      1   -> setFreq
      2      0   RI_init
        2      0   -> random_core_init
      0     78   RecvData
        0     32   -> NT_GetTime
        0     32   -> TIM_TimeStamp
        0     32   -> TIM_passedTime
      0     48   SendData
        0     12   -> LoadTXData
        0     12   -> NT_GetTime
        0     12   -> NT_WaitTime
      3     44   UnLoadRXData
      0      9   bits_count
      2      9   getRNDByte
      0      9   random_core_init
        0      9   -> RI_cfg
        0      9   -> rand
        0      9   -> readRandom
        0      9   -> srand
      0     18   readRandom
        0      9   -> bits_count
        0      9   -> getRNDByte
      1     18   setFreq
        0     11   -> printf
        0     17   -> printf


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
      22  ?<Constant "*ASSERT* %s:%d:%s -> ">
      69  ?<Constant "\\\\vmware-host\\Shared ...">
       3  ?<Constant "\r\n">
      22  ?<Initializer for <Constant "*ASSERT* %s:%d:%s
      69  ?<Initializer for <Constant "\\\\vmware-host\\
       3  ?<Initializer for <Constant "\r\n">>
       4  ?<Initializer for __Constant_1>
       4  ?<Initializer for __Constant_3e8>
       4  ?<Initializer for __Constant_447a0000>
       8  ?<Initializer for __FUNCTION__>
       8  ?<Initializer for __FUNCTION__>_1
      50  LoadTXData
       6  LoadTXData::?relay
       3  RADIO_CFG
       1  RFD
       1  RFIRQF0
       1  RFIRQF1
       1  RFST
       4  RI_CCA_REJECT
       4  RI_CRC_ERROR
      17  RI_GetCCAReject
       6  RI_GetCCAReject::?relay
      17  RI_GetCRCError
       6  RI_GetCRCError::?relay
      17  RI_GetUptime
       6  RI_GetUptime::?relay
     535  RI_Receive
       6  RI_Receive::?relay
     216  RI_Send
       6  RI_Send::?relay
      32  RI_SetChannel
       6  RI_SetChannel::?relay
       4  RI_UPTIME
     109  RI_cfg
       6  RI_cfg::?relay
      32  RI_init
       6  RI_init::?relay
     152  RecvData
       6  RecvData::?relay
     159  SendData
       6  SendData::?relay
      40  UnLoadRXData
       6  UnLoadRXData::?relay
       4  __Constant_1
       4  __Constant_3e8
       4  __Constant_447a0000
      34  bits_count
       6  bits_count::?relay
      53  getRNDByte
       6  getRNDByte::?relay
      78  random_core_init
       6  random_core_init::?relay
      54  readRandom
       6  readRandom::?relay
     120  setFreq
       6  setFreq::?relay
      16  -- Other

 
 1 715 bytes in segment BANKED_CODE
   102 bytes in segment BANK_RELAYS
     4 bytes in segment SFR_AN
   122 bytes in segment XDATA_I
   122 bytes in segment XDATA_ID
    15 bytes in segment XDATA_Z
 
   212 bytes of CODE     memory (+ 12 bytes shared)
     0 bytes of DATA     memory (+  4 bytes shared)
 1 715 bytes of HUGECODE memory
   125 bytes of XDATA    memory (+ 12 bytes shared)

Errors: none
Warnings: 1
