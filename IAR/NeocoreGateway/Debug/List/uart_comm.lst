###############################################################################
#
# IAR C/C++ Compiler V10.10.1.4655 for 8051               20/Jan/2020  16:54:04
# Copyright 2004-2017 IAR Systems AB.
# PC-locked license - IAR Embedded Workbench for 8051
#
#    Core               =  plain
#    Code model         =  banked
#    Data model         =  large
#    Calling convention =  xdata reentrant
#    Constant location  =  data
#    Dptr setup         =  1,16
#                          
#    Source file        =  
#        \\vmware-host\Shared
#        Folders\Projects\WMNU\IAR\NeocoreGateway\src\uart_comm.c
#    Command line       =  
#        -f C:\Users\08A4~1\AppData\Local\Temp\EWF286.tmp
#        ("\\vmware-host\Shared
#        Folders\Projects\WMNU\IAR\NeocoreGateway\src\uart_comm.c" -lcN
#        "\\vmware-host\Shared
#        Folders\Projects\WMNU\IAR\NeocoreGateway\Debug\List" -o
#        "\\vmware-host\Shared
#        Folders\Projects\WMNU\IAR\NeocoreGateway\Debug\Obj" -e --debug
#        --core=plain --dptr=16,1 --data_model=large --code_model=banked
#        --calling_convention=xdata_reentrant --place_constants=data
#        --nr_virtual_regs 8 --dlib_config "C:\Program Files (x86)\IAR
#        Systems\Embedded Workbench 8.0\8051\LIB\DLIB\dl8051Normal.h" -I
#        "\\vmware-host\Shared Folders\Projects\WMNU\IAR\SHARE_PRJ_SRC\" -On
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_cross_call)
#    Locale             =  Russian_Russia.1251
#    List file          =  
#        \\vmware-host\Shared
#        Folders\Projects\WMNU\IAR\NeocoreGateway\Debug\List\uart_comm.lst
#    Object file        =  
#        \\vmware-host\Shared
#        Folders\Projects\WMNU\IAR\NeocoreGateway\Debug\Obj\uart_comm.r51
#
###############################################################################

\\vmware-host\Shared Folders\Projects\WMNU\IAR\NeocoreGateway\src\uart_comm.c
      1          #include "nwdebuger.h"
      2          #include "ioCC2530.h"
      3          #include "stdint.h"
      4          #include "stdbool.h"
      5          #include "DMA.h"
      6          
      7          /**
      8          @file Настройка UART для приема команд от PC
      9          */
     10          
     11          #define UART_RX_BUF_LEN 0xff //!< Размер приемного буфера
     12          #define TRIG_URX0 14
     13          
     14          static void uart_dma_init(void);
     15          
     16          void uart_write(const char *data, uint8_t size);
     17          uint8_t* uart_recv_cmd(uint8_t *size);
     18          
     19          static uint8_t uart_rx_buff[UART_RX_BUF_LEN]; //1 для поля длинны
     20          static void uart_putchar(char x);
     21          
     22          static void uart_dma_init(void)
     23          {
     24            // Настроим канал 2 DMA для загрузки данных из uart
     25            // DMA0 и 1 заняты кодером AES
     26            
     27            ST_DEF(DMA_CH[2], SRCADDRL, 0xC1); //U0DBUF
     28            ST_DEF(DMA_CH[2], SRCADDRH, 0x70);
     29            ST_DEF(DMA_CH[2], LENL, UART_RX_BUF_LEN); // Максимальный размер данных
     30            ST_DEF(DMA_CH[2], DSTADDRH, HADDR(uart_rx_buff)); // Пишем данные XENCDI = 0xB1 
     31            ST_DEF(DMA_CH[2], DSTADDRL, LADDR(uart_rx_buff)); //  
     32            ST_DEF(DMA_CH[2], PRIORITY, 0x00); // Низкий приоритет
     33            ST_DEF(DMA_CH[2], M8, 0x00); // Используем 8 бит для счетика длинны
     34            ST_DEF(DMA_CH[2], IRQMASK, 0x00); // Запрещаем генерировать перывания
     35            ST_DEF(DMA_CH[2], DESTINC, 0x01); // Увеличиваем адресс назначения
     36            ST_DEF(DMA_CH[2], SRCINC, 0x00); // Не увеличиваем адресс источника
     37            ST_DEF(DMA_CH[2], TRIG, TRIG_URX0); // Тригер по приходу байта UART0
     38            ST_DEF(DMA_CH[2], WORDSIZE, 0x00); // Копируем по 1 байту
     39            ST_DEF(DMA_CH[2], TMODE, 0x00); //  Одиночное копирование по тригеру
     40            ST_DEF(DMA_CH[2], VLEN, 0x01); // Длинна данных определяется 1ым байтом  
     41            ST_DEF(DMA_CH[2], LENH, 0x00); 
     42          }
     43          
     44          /**
     45          @brief Прием команды по uart
     46          @param[out] size размер принятых данных
     47          @return указатель на начало данных или null
     48          */
     49          uint8_t* uart_recv_cmd(uint8_t *size)
     50          {  
     51            // Начинаем прием
     52            DMAARM |= 0x04;
     53            
     54            while (DMAARM&0x04);
     55            
     56            *size = uart_rx_buff[0];
     57            return &uart_rx_buff[1];
     58          }
     59          
     60          /**
     61          @brief Иницилизация uart с компьютером
     62          @detail Скорость 115200 бод. Частота микроконтроллера 32Мгц.
     63          */
     64          void com_uart_init(void)
     65          {
     66            // Выбор расположения UART на выводах
     67            uint8_t U0CFG = 0; // 0={TX=P0_3, RX=P0_2
     68            PERCFG |= (U0CFG<<0); 
     69            
     70            // U0UCR регистр настройки режима uart. меня устраивает по умолчанию
     71            U0CSR = (1<<7); // Выбираем режим uart  
     72            
     73            // Настройка скорости передачи данных на 115200  
     74            U0BAUD = 216;  // табличные значения из pdf
     75            U0GCR =  11; //16
     76            
     77            // Включаем альтернативные функции выводов
     78            P0SEL = (1<<2)|(1<<3);
     79            U0CSR |= (1<<6);
     80            uart_dma_init();
     81          }
     82          
     83          /**
     84          @brief Запись в uart
     85          @param[in] data указатель на начало массива данных
     86          @param[in] size размер передаваемых данных
     87          */
     88          void uart_write(const char *data, uint8_t size)
     89          {
     90            for (uint8_t i = 0; i < size; i++)
     91              uart_putchar((char)data[i]);
     92          };
     93          
     94          static void uart_putchar(char x){
     95            while( U0CSR&(1<<0));
     96            U0DBUF = x;
     97          }
     98          
     99          static char uart_getchar(void)
    100          {
    101            char x;
    102            while( !(U0CSR&(1<<2)));
    103            x = U0DBUF;
    104            return x;
    105          }

   Maximum stack usage in bytes:

   ISTACK XSTACK Function
   ------ ------ --------
      0      9   com_uart_init
        0      9   -> uart_dma_init
      2      9   uart_dma_init
      0     10   uart_putchar
      3      0   uart_recv_cmd
      0     10   uart_write
        0     10   -> uart_putchar


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
       1  DMAARM
       1  P0SEL
       1  PERCFG
       1  U0BAUD
       1  U0CSR
       1  U0DBUF
       1  U0GCR
      33  com_uart_init
       6  com_uart_init::?relay
     132  uart_dma_init
       6  uart_dma_init::?relay
      11  uart_putchar
       6  uart_putchar::?relay
      41  uart_recv_cmd
       6  uart_recv_cmd::?relay
     255  uart_rx_buff
      48  uart_write
       6  uart_write::?relay

 
 265 bytes in segment BANKED_CODE
  30 bytes in segment BANK_RELAYS
   7 bytes in segment SFR_AN
 255 bytes in segment XDATA_Z
 
  30 bytes of CODE     memory
   0 bytes of DATA     memory (+ 7 bytes shared)
 265 bytes of HUGECODE memory
 255 bytes of XDATA    memory

Errors: none
Warnings: 2
