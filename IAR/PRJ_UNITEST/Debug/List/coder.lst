###############################################################################
#
# IAR C/C++ Compiler V10.10.1.4655 for 8051               15/Jan/2020  21:44:13
# Copyright 2004-2017 IAR Systems AB.
# PC-locked license - IAR Embedded Workbench for 8051
#
#    Core               =  plain
#    Code model         =  banked
#    Data model         =  large
#    Calling convention =  xdata reentrant
#    Constant location  =  data
#    Dptr setup         =  1,16
#                          
#    Source file        =  
#        \\vmware-host\Shared Folders\Projects\WMNU\IAR\SHARE_PRJ_SRC\coder.c
#    Command line       =  
#        -f C:\Users\08A4~1\AppData\Local\Temp\EW1EDE.tmp
#        ("\\vmware-host\Shared
#        Folders\Projects\WMNU\IAR\SHARE_PRJ_SRC\coder.c" -lc
#        "\\vmware-host\Shared
#        Folders\Projects\WMNU\IAR\PRJ_UNITEST\Debug\List" -o
#        "\\vmware-host\Shared Folders\Projects\WMNU\IAR\PRJ_UNITEST\Debug\Obj"
#        -e --debug --core=plain --dptr=16,1 --data_model=large
#        --code_model=banked --calling_convention=xdata_reentrant
#        --place_constants=data --nr_virtual_regs 8 --dlib_config "C:\Program
#        Files (x86)\IAR Systems\Embedded Workbench
#        8.0\8051\LIB\DLIB\dl8051Normal.h" --no_path_in_file_macros -I
#        "\\vmware-host\Shared Folders\Projects\WMNU\IAR\SHARE_PRJ_SRC\" -Oh
#        --mfc "\\vmware-host\Shared
#        Folders\Projects\WMNU\IAR\SHARE_PRJ_SRC\config.c"
#        "\\vmware-host\Shared
#        Folders\Projects\WMNU\IAR\SHARE_PRJ_SRC\delays.c"
#        "\\vmware-host\Shared
#        Folders\Projects\WMNU\IAR\SHARE_PRJ_SRC\ethernet.c"
#        "\\vmware-host\Shared Folders\Projects\WMNU\IAR\SHARE_PRJ_SRC\frame.c"
#        "\\vmware-host\Shared Folders\Projects\WMNU\IAR\SHARE_PRJ_SRC\LLC.c"
#        "\\vmware-host\Shared Folders\Projects\WMNU\IAR\SHARE_PRJ_SRC\MAC.c"
#        "\\vmware-host\Shared
#        Folders\Projects\WMNU\IAR\SHARE_PRJ_SRC\manager.c"
#        "\\vmware-host\Shared Folders\Projects\WMNU\IAR\SHARE_PRJ_SRC\mem.c"
#        "\\vmware-host\Shared Folders\Projects\WMNU\IAR\SHARE_PRJ_SRC\NTMR.c"
#        "\\vmware-host\Shared
#        Folders\Projects\WMNU\IAR\SHARE_PRJ_SRC\nwdebuger.c"
#        "\\vmware-host\Shared Folders\Projects\WMNU\IAR\SHARE_PRJ_SRC\RADIO.c"
#        "\\vmware-host\Shared Folders\Projects\WMNU\IAR\SHARE_PRJ_SRC\sync.c"
#        "\\vmware-host\Shared Folders\Projects\WMNU\IAR\SHARE_PRJ_SRC\TIC.c"
#        "\\vmware-host\Shared
#        Folders\Projects\WMNU\IAR\PRJ_UNITEST\src\utest.c"
#        "\\vmware-host\Shared
#        Folders\Projects\WMNU\IAR\PRJ_UNITEST\src\utest_GW.c"
#        "\\vmware-host\Shared
#        Folders\Projects\WMNU\IAR\PRJ_UNITEST\src\utest_NODE.c"
#        "\\vmware-host\Shared
#        Folders\Projects\WMNU\IAR\PRJ_UNITEST\src\utest_suite.c")
#    Locale             =  Russian_Russia.1251
#    List file          =  
#        \\vmware-host\Shared
#        Folders\Projects\WMNU\IAR\PRJ_UNITEST\Debug\List\coder.lst
#    Object file        =  
#        \\vmware-host\Shared
#        Folders\Projects\WMNU\IAR\PRJ_UNITEST\Debug\Obj\coder.r51
#
###############################################################################

\\vmware-host\Shared Folders\Projects\WMNU\IAR\SHARE_PRJ_SRC\coder.c
      1          /*!
      2          \file Модуль шифрования данных
      3          \brief Функции кодирования данных
      4          */
      5          
      6          #include "coder.h"
      7          #include "ioCC2530.h"
      8          #include "string.h"
      9          #include "delays.h" // Для профилирования, Отладка
     10          
     11          #define AES_START()  {ENCCS |= 0x01;} //!< Запуск выполнения команды  
     12          #define AES_SET_MODE(mode) {ENCCS &= ~0x70; ENCCS |= mode;} //!< Установка режима
     13          #define AES_SET_OPERATION(op) {ENCCS = (ENCCS & ~0x07) | op;} 
     14          #define AES_RDY() (ENCCS & 8) //!< Состояние модуля
     15          
     16          #define ST_DEF(STRUCT, FILD, VAL)  STRUCT.FILD = VAL
     17          #define HADDR(ADDR) ((uint16_t)ADDR >> 8)
     18          #define LADDR(ADDR) ((uint16_t)ADDR)
     19          #define BV(n)                   (1 << (n))
     20          #define MIC_2_MICLEN(m)         (BV((m&3)+1) & ~3)
     21          
     22          // Режимы шифрования
     23          #define AES_MODE_CBC            0x00
     24          #define AES_MODE_CFB            0x10
     25          #define AES_MODE_OFB            0x20
     26          #define AES_MODE_CTR            0x30
     27          #define AES_MODE_ECB            0x40
     28          #define AES_MODE_CBCMAC         0x50
     29          
     30          // Операции 
     31          #define AES_ENCRYPT             0x00
     32          #define AES_DECRYPT             0x02
     33          #define AES_LOAD_KEY            0x04
     34          #define AES_LOAD_IV             0x06
     35          
     36          #define ENC_DW 29 // DMA AES тригер запрос загрузки
     37          #define ENC_UP 30 // DMA AES тригер запрос выгрузки
     38          
     39          #define STREAM_ENC_MODE     AES_MODE_OFB //!< Метод шифрования потока данных
     40          
     41          // Доступные методы
     42          void AES_StreamCoder(bool enc_mode, uint8_t *src, uint8_t *dst, 
     43                               uint8_t *key, uint8_t *nonce, uint8_t len);
     44          
     45          // Приватные функции
     46          static inline uint8_t generateAuthData(uint8_t *src, uint8_t *nonce, uint8_t c,
     47                                                 uint8_t f, uint8_t lm);
     48          static void CBCMAC_buf_encrypt(uint8_t len, uint8_t *key, uint8_t *mac);
     49          
     50          /**
     51          @brief Локальный буфер для работы режима CCM
     52          @detail 128 длина сообщения. 18 длинна блока B0 и строки состояния.
     53           16 длина дополнения нулями
     54          */
     55          static uint8_t buf[128+18+16]; 
     56          
     57          
     58          typedef struct //!< Структура блока B0 для режима CCM
     59          {
     60            struct 
     61            {
     62              uint8_t L:3;
     63              uint8_t M:3;
     64              uint8_t A_Data:1;
     65            } flag;
     66            uint16_t nonce[9];
     67            uint8_t L_M[6];
     68          } __attribute__((packed)) B0_s;
     69          
     70          typedef struct //!< Структура блока A0 для режима CCM
     71          {
     72            struct 
     73            {
     74              uint8_t L:3;
     75            } flag;
     76            uint8_t nonce[11];
     77            uint8_t ctr;
     78          } __attribute__((packed)) A0_s;
     79          
     80          typedef struct //!< Структура с настройками DMA 
     81          {
     82            uint8_t  SRCADDRH;
     83            uint8_t  SRCADDRL;
     84            uint8_t  DSTADDRH;
     85            uint8_t  DSTADDRL;
     86            struct  {
     87            uint8_t   LENH        :5;
     88            uint8_t   VLEN        :3;
     89            };
     90            struct  {
     91            uint8_t   LENL        :8;
     92            };
     93            struct  {
     94            uint8_t   TRIG        :5;
     95            uint8_t   TMODE       :2;
     96            uint8_t   WORDSIZE    :1;
     97            };
     98            struct {
     99            uint8_t   PRIORITY    :2;
    100            uint8_t   M8          :1;
    101            uint8_t   IRQMASK     :1;
    102            uint8_t   DESTINC     :2;
    103            uint8_t   SRCINC      :2;
    104            };
    105          } __attribute__((packed)) DMA_AES_s ;
    106          
    107          DMA_AES_s DMA_AES_DW; //!< DMA на запись
    108          DMA_AES_s DMA_AES_UP; //!< DMA на чтение
    109          
    110          
    111          /**
    112          @brief Иницилизация модуля
    113          @detail Модуль использует DMA каналы 0 и 1
    114          */
    115          void AES_init(void)
    116          {
    117            // Настроим канал 0 DMA для загрузки данных в AES
    118            uint16_t CONF_ADDR = (uint16_t)&DMA_AES_DW;
    119            DMA0CFGH = CONF_ADDR >> 8;
    120            DMA0CFGL = CONF_ADDR & 0xFF;
    121            
    122            // Настроим канал 1 DMA для выгрузки данных из AES
    123            CONF_ADDR = (uint16_t)&DMA_AES_UP;
    124            DMA1CFGH = CONF_ADDR >> 8;
    125            DMA1CFGL = CONF_ADDR & 0xFF;
    126            
    127            ST_DEF(DMA_AES_DW, DSTADDRH, 0x70); // Пишем данные XENCDI = 0xB1 
    128            ST_DEF(DMA_AES_DW, DSTADDRL, 0xB1); //  
    129            ST_DEF(DMA_AES_DW, PRIORITY, 0x00); // Низкий приоритет
    130            ST_DEF(DMA_AES_DW, M8, 0x00); // Используем 8 бит для счетика длинны
    131            ST_DEF(DMA_AES_DW, IRQMASK, 0x00); // Запрещаем генерировать перывания
    132            ST_DEF(DMA_AES_DW, DESTINC, 0x00); // Не увеличиваем адресс назначения
    133            ST_DEF(DMA_AES_DW, SRCINC, 0x01); // Увеличиваем адресс источника
    134            ST_DEF(DMA_AES_DW, TRIG, ENC_DW); // Тригер по загрузке
    135            ST_DEF(DMA_AES_DW, WORDSIZE, 0x00); // Копируем по 1 байту
    136            ST_DEF(DMA_AES_DW, TMODE, 0x01); //  Блочное копирование по тригеру
    137            ST_DEF(DMA_AES_DW, VLEN, 0x00); //  Количество байт определяет поле LEN  
    138            ST_DEF(DMA_AES_DW, LENH, 0x00); 
    139            
    140            ST_DEF(DMA_AES_UP, SRCADDRH, 0x70); // Читаем данные из X_ENCDO  
    141            ST_DEF(DMA_AES_UP, SRCADDRL, 0xB2);  
    142            ST_DEF(DMA_AES_UP, PRIORITY, 0x00); // Низкий приоритет
    143            ST_DEF(DMA_AES_UP, M8, 0x00); // Используем 8 бит для счетика длинны
    144            ST_DEF(DMA_AES_UP, IRQMASK, 0x00); // Запрещаем генерировать перывания
    145            ST_DEF(DMA_AES_UP, DESTINC, 0x01); // Увеличиваем адресс назначения
    146            ST_DEF(DMA_AES_UP, SRCINC, 0x00); // Не увеличиваем адресс источника
    147            ST_DEF(DMA_AES_UP, TRIG, ENC_UP); // Тригер по выгрузке
    148            ST_DEF(DMA_AES_UP, WORDSIZE, 0x00); // Копируем по 1 байту
    149            ST_DEF(DMA_AES_UP, TMODE, 0x01); //  Блочное копирование по тригеру
    150            ST_DEF(DMA_AES_UP, VLEN, 0x00); //  Количество байт определяет поле LEN  
    151            ST_DEF(DMA_AES_UP, LENH, 0x00); 
    152          }
    153          
    154          /**
    155          @brief Шифрует/дешифрует поток данных во время радиопередачи. Без проверки MIC
    156          @param[in] enc_mode Режим работы процедуры. true - шифрование.
    157          @param[in] src Указатель на данные подлежащии шифрованию
    158          @param[in] dst Указтель куда будут помещены зашифрованные данные
    159          @param[in] key Указатье на ключ. 16 байт
    160          @param[in] iv  Указатель на вектор иницилизации. 16 байт 
    161          @param[in] len Длинна данных
    162          */
    163          void AES_StreamCoder(bool enc_mode, uint8_t *src, uint8_t *dst, uint8_t *key,
    164                                   uint8_t *iv, uint8_t len)
    165          {
    166            // Установим метод кодироваения
    167            AES_SET_MODE(STREAM_ENC_MODE);
    168              
    169            // Загружаем ключ
    170            AES_SET_OPERATION(AES_LOAD_KEY);
    171            ST_DEF(DMA_AES_DW, SRCADDRL, LADDR(key));
    172            ST_DEF(DMA_AES_DW, SRCADDRH, HADDR(key));
    173            ST_DEF(DMA_AES_DW, LENL, 16);
    174            DMAARM |= 0x01;
    175            while(!AES_RDY());
    176            AES_START();
    177            while (DMAARM);
    178          
    179            // Загружаем IV
    180            AES_SET_OPERATION(AES_LOAD_IV);
    181            ST_DEF(DMA_AES_DW, SRCADDRL, LADDR(iv));
    182            ST_DEF(DMA_AES_DW, SRCADDRH, HADDR(iv));
    183            ST_DEF(DMA_AES_DW, LENL, 16);
    184            DMAARM |= 0x01;
    185            while(!AES_RDY());
    186            AES_START();
    187            while (DMAARM);
    188          
    189            // Установим необходимую операцию AES
    190            if (enc_mode) 
    191              AES_SET_OPERATION(AES_ENCRYPT)
    192            else 
    193              AES_SET_OPERATION(AES_DECRYPT)
    194            
    195            switch(STREAM_ENC_MODE) 
    196            {
    197            case AES_MODE_ECB: // ECB, CBC не реализованы
    198            case AES_MODE_CBC:
    199              break;
    200            case AES_MODE_CFB:
    201            case AES_MODE_OFB:
    202            case AES_MODE_CTR:
    203              {
    204                // Загрузка блоками по 128 бит с разделением на под-блоки по 32 бита
    205                uint8_t nbrBlocks = len / 16; // Количество целых блоков по 128 бит
    206                uint8_t ptr, sub_ptr; // Смещение
    207                uint8_t *download, *upload;
    208                
    209                // Для этих типов шифрования длина блоков по 4 байта
    210                ST_DEF(DMA_AES_DW, LENL, 4);
    211                ST_DEF(DMA_AES_UP, LENL, 4);
    212                
    213                // Шифруем все целые блоки
    214                for (uint8_t block = 0; block < nbrBlocks; block ++)
    215                {
    216                  ptr = 16 * block;
    217                  while(!AES_RDY());
    218                  AES_START();
    219                  for (uint8_t j = 0; j < 4; j++)
    220                  {
    221                    sub_ptr = ptr + 4*j;
    222                    download = &src[sub_ptr];
    223                    upload = &dst[sub_ptr];
    224                    // Указываем адресс DMA откуда читать данные
    225                    ST_DEF(DMA_AES_DW, SRCADDRL, LADDR(download));
    226                    ST_DEF(DMA_AES_DW, SRCADDRH, HADDR(download));
    227                    // Указываем адрес DMA куда записывать данные          
    228                    ST_DEF(DMA_AES_UP, DSTADDRL, LADDR(upload));
    229                    ST_DEF(DMA_AES_UP, DSTADDRH, HADDR(upload));
    230                    // Активируем DMA
    231                    DMAARM |= 0x03;  
    232                    DMAREQ |= 0x01;
    233                    while (DMAARM);          
    234                  }
    235                }     
    236                // Шифруем последний блок
    237                uint8_t block_len = len % 16; // Размер последнего блока
    238                
    239                // Завершаем работу если блок пустой
    240                if (!block_len)
    241                  return;
    242                
    243                uint8_t padding_block[16]; // Блок заполненый нулями
    244                ptr = 16*nbrBlocks; // Смещение на первый байт последнего блока в src
    245                memset(padding_block, 0x00, sizeof(padding_block)); // Заполняем нулями
    246                memcpy(padding_block, &src[ptr], block_len); // Копируем данные
    247                
    248                while(!AES_RDY());
    249                AES_START();
    250                for (uint8_t j = 0; j < 4; j++)
    251                  {
    252                    sub_ptr = 4*j;
    253                    download = &padding_block[sub_ptr];
    254                    // Указываем адресс DMA откуда читать данные
    255                    ST_DEF(DMA_AES_DW, SRCADDRL, LADDR(download));
    256                    ST_DEF(DMA_AES_DW, SRCADDRH, HADDR(download));
    257                    // Указываем аддрес DMA куда записывать данные          
    258                    ST_DEF(DMA_AES_UP, DSTADDRL, LADDR(download));
    259                    ST_DEF(DMA_AES_UP, DSTADDRH, HADDR(download));
    260                    // Активируем DMA
    261                    DMAARM |= 0x03;  
    262                    DMAREQ |= 0x01;
    263                    while (DMAARM);
    264                  }
    265                memcpy(&dst[ptr], padding_block, block_len); // Копируем в src
    266                
    267              } //CASE
    268              
    269              break;
    270            } 
    271          }
    272          
    273          /**
    274          @brief Шифрует/дешифрует поток данных во время радиопередачи. Без проверки MIC
    275          @param[in] enc_mode Режим работы процедуры. true - шифрование.
    276          @param[in] src Указатель на данные подлежащии шифрованию
    277          @param[in] dst Указтель куда будут помещены зашифрованные данные
    278          @param[in] key Указатье на ключ. 16 байт
    279          @param[in] iv  Указатель на вектор иницилизации. 16 байт 
    280          @param[in] len Длинна данных
    281          */
    282          static void CTR_enc_decrypt(bool enc_mode, uint8_t *src, uint8_t *dst, uint8_t *key,
    283                                   uint8_t *iv, uint8_t len)
    284          {
    285            // Установим метод кодироваения
    286            AES_SET_MODE(AES_MODE_CTR);
    287            
    288            // Загружаем ключ
    289            AES_SET_OPERATION(AES_LOAD_KEY);
    290            ST_DEF(DMA_AES_DW, SRCADDRL, LADDR(key));
    291            ST_DEF(DMA_AES_DW, SRCADDRH, HADDR(key));
    292            ST_DEF(DMA_AES_DW, LENL, 16);
    293            DMAARM |= 0x01;
    294            while(!AES_RDY());
    295            AES_START();
    296            while (DMAARM);
    297          
    298            // Загружаем IV
    299            AES_SET_OPERATION(AES_LOAD_IV);
    300            ST_DEF(DMA_AES_DW, SRCADDRL, LADDR(iv));
    301            ST_DEF(DMA_AES_DW, SRCADDRH, HADDR(iv));
    302            ST_DEF(DMA_AES_DW, LENL, 16);
    303            DMAARM |= 0x01;
    304            while(!AES_RDY());
    305            AES_START();
    306            while (DMAARM);
    307          
    308            // Установим необходимую операцию AES
    309            if (enc_mode) 
    310              AES_SET_OPERATION(AES_ENCRYPT)
    311            else 
    312              AES_SET_OPERATION(AES_DECRYPT)
    313            
    314            // Загрузка блоками по 128 бит с разделением на под-блоки по 32 бита
    315            uint8_t nbrBlocks = len / 16; // Количество целых блоков по 128 бит
    316            uint8_t ptr, sub_ptr; // Смещение
    317            uint8_t *download, *upload;
    318                
    319            // Для этих типов шифрования длина блоков по 4 байта
    320            ST_DEF(DMA_AES_DW, LENL, 4);
    321            ST_DEF(DMA_AES_UP, LENL, 4);
    322                
    323            // Шифруем все целые блоки
    324            for (uint8_t block = 0; block < nbrBlocks; block ++)
    325              {
    326                ptr = 16 * block;
    327                while(!AES_RDY());
    328                AES_START();
    329                for (uint8_t j = 0; j < 4; j++)
    330                  {
    331                    sub_ptr = ptr + 4*j;
    332                    download = &src[sub_ptr];
    333                    upload = &dst[sub_ptr];
    334                    // Указываем адресс DMA откуда читать данные
    335                    ST_DEF(DMA_AES_DW, SRCADDRL, LADDR(download));
    336                    ST_DEF(DMA_AES_DW, SRCADDRH, HADDR(download));
    337                    // Указываем адрес DMA куда записывать данные          
    338                    ST_DEF(DMA_AES_UP, DSTADDRL, LADDR(upload));
    339                    ST_DEF(DMA_AES_UP, DSTADDRH, HADDR(upload));
    340                    // Активируем DMA
    341                    DMAARM |= 0x03;  
    342                    DMAREQ |= 0x01;
    343                    while (DMAARM);          
    344                  }
    345              }     
    346              // Шифруем последний блок
    347              uint8_t block_len = len % 16; // Размер последнего блока
    348                
    349              // Завершаем работу если блок пустой
    350              if (!block_len)
    351                return;
    352                
    353              uint8_t padding_block[16]; // Блок заполненый нулями
    354              ptr = 16*nbrBlocks; // Смещение на первый байт последнего блока в src
    355              memset(padding_block, 0x00, sizeof(padding_block)); // Заполняем нулями
    356              memcpy(padding_block, &src[ptr], block_len); // Копируем данные
    357              
    358              while(!AES_RDY());
    359              AES_START();
    360              for (uint8_t j = 0; j < 4; j++)
    361                {
    362                  sub_ptr = 4*j;
    363                  download = &padding_block[sub_ptr];
    364                  // Указываем адресс DMA откуда читать данные
    365                  ST_DEF(DMA_AES_DW, SRCADDRL, LADDR(download));
    366                  ST_DEF(DMA_AES_DW, SRCADDRH, HADDR(download));
    367                  // Указываем аддрес DMA куда записывать данные          
    368                  ST_DEF(DMA_AES_UP, DSTADDRL, LADDR(download));
    369                  ST_DEF(DMA_AES_UP, DSTADDRH, HADDR(download));
    370                  // Активируем DMA
    371                  DMAARM |= 0x03;  
    372                  DMAREQ |= 0x01;
    373                  while (DMAARM);
    374                }
    375              memcpy(&dst[ptr], padding_block, block_len); // Копируем в src
    376          }
    377          
    378          /**
    379          @brief Зашифровывает buf в режиме CBC-MAC с IV = 0
    380          @param[in] len улинна последовательности для вычисления MAC
    381          @param[out] mac указатель на память куда будет записан mac (до 16 байт)
    382          */
    383          static void CBCMAC_buf_encrypt(uint8_t len, uint8_t *key, uint8_t *mac)
    384          {
    385            uint8_t IV[16];
    386            
    387            // Заполняем вектор нулями
    388            memset(IV, 0x00, sizeof(IV));
    389            
    390            // Установим метод кодироваения
    391            AES_SET_MODE(AES_MODE_CBCMAC);  
    392            
    393            { // Сворачиваем код для улучшения чтения
    394            // Загружаем ключ
    395            AES_SET_OPERATION(AES_LOAD_KEY);
    396            ST_DEF(DMA_AES_DW, SRCADDRL, LADDR(key));
    397            ST_DEF(DMA_AES_DW, SRCADDRH, HADDR(key));
    398            ST_DEF(DMA_AES_DW, LENL, 16);
    399            DMAARM |= 0x01;
    400            while(!AES_RDY());
    401            AES_START();
    402            while (DMAARM);
    403          
    404            // Загружаем IV
    405            AES_SET_OPERATION(AES_LOAD_IV);
    406            ST_DEF(DMA_AES_DW, SRCADDRL, LADDR(IV));
    407            ST_DEF(DMA_AES_DW, SRCADDRH, HADDR(IV));
    408            ST_DEF(DMA_AES_DW, LENL, 16);
    409            DMAARM |= 0x01;
    410            while(!AES_RDY());
    411            AES_START();
    412            while (DMAARM);
    413            };
    414            
    415            // Устанавливаем операцию шифрования
    416            AES_SET_OPERATION(AES_ENCRYPT);
    417            
    418            // Загрузка блоками по 128 бит
    419            uint8_t nbrBlocks = len / 16; // Количество целых блоков по 128 бит
    420            uint8_t block_len = len % 16; // Размер последнего блока
    421            uint8_t ptr; // Смещение
    422                
    423            // Для этого типа шифрования длина блоков по 16 байт
    424            ST_DEF(DMA_AES_DW, LENL, 16);
    425            // Устанавливаем куда будем выгружать вычисленный MAC
    426            ST_DEF(DMA_AES_UP, DSTADDRL, LADDR(mac));
    427            ST_DEF(DMA_AES_UP, DSTADDRH, HADDR(mac));
    428            ST_DEF(DMA_AES_UP, LENL, 16);
    429            
    430            // Шифруем все целые блоки
    431            for (uint8_t block = 0; block < nbrBlocks; block ++)
    432              {
    433                // Последний блок шифруем в режиме CBC при условии что нет блок не 
    434                // кратного 16 байтам.
    435                if (!block_len && (block == nbrBlocks - 1))
    436                  AES_SET_MODE(AES_MODE_CBC);
    437                    
    438                ptr = 16 * block;
    439                while(!AES_RDY());
    440                AES_START();
    441                // Указываем адресс DMA откуда читать данные
    442                ST_DEF(DMA_AES_DW, SRCADDRL, LADDR(buf[ptr]));
    443                ST_DEF(DMA_AES_DW, SRCADDRH, HADDR(buf[ptr]));
    444                // Активируем DMA
    445                DMAARM |= 0x01;  
    446                // Активируем выгрузку только последнего блока
    447                if (!block_len && (block == nbrBlocks - 1))
    448                  DMAARM = 0x03;
    449                
    450                DMAREQ |= 0x01;
    451                while (DMAARM);          
    452               }
    453                 
    454            // Шифруем последний блок в режиме CBC
    455            AES_SET_MODE(AES_MODE_CBC);
    456                    
    457            // Завершаем работу если блок пустой
    458            if (!block_len)
    459              return;
    460                
    461            uint8_t padding_block[16]; // Блок заполненый нулями
    462            ptr = 16*nbrBlocks; // Смещение на первый байт последнего блока в src
    463            memset(padding_block, 0x00, sizeof(padding_block)); // Заполняем нулями
    464            memcpy(padding_block, &buf[ptr], block_len); // Копируем данные
    465                
    466            while(!AES_RDY());
    467            AES_START();
    468            // Указываем адресс DMA откуда читать данные
    469            ST_DEF(DMA_AES_DW, SRCADDRL, LADDR(padding_block));
    470            ST_DEF(DMA_AES_DW, SRCADDRH, HADDR(padding_block));
    471            // Активируем DMA и выгрузку MAC
    472            DMAARM |= 0x03;  
    473            DMAREQ |= 0x01;
    474            while (DMAARM);
    475          }
    476          
    477          static inline uint8_t generateAuthData(uint8_t *src, uint8_t *nonce, uint8_t c,
    478                                                 uint8_t f, uint8_t lm)
    479          {
    480            memcpy(buf, nonce,16);
    481            
    482            // Буфер от 0 до 15 байта специальный блок B0
    483            // Настраиваем флаг. У нас длинна 2 байта. nonce 13 байт => L_M = L-1=0x01
    484            buf[0]=  0x01;  
    485            // Если есть данные для авторизации установим A_Data 
    486            if (f > 0)
    487              buf[0] |= 0x40;
    488            
    489            buf[0] |= ((lm - 2) / 2 ) << 3;   // см. документацию M'= (lm-2) / 2;
    490            
    491            // Устанавливаем длинну сообщения
    492            buf[14] = 0x00;
    493            buf[15] = c;
    494            
    495            // Добавляем строку авторизации L(a). если данных нет, то она пустая. f=0
    496            buf[16]= 0;
    497            buf[17]= f;
    498            
    499            // Копируем данные авторизации в буфер
    500            memcpy(&buf[18], src, f);
    501            
    502            // Смещение на следующий байт после данных авторизации.
    503            // Данные авторизации занимают положение в буфере [18, 18+f]
    504            uint8_t ptr_end= 18 + f;
    505            // Заполняем нулями до границы 16 байт  
    506            while (ptr_end & 0x0f)
    507              buf[ptr_end++] = 0x00;
    508            
    509            // Копируем данные для шифрования в буфер после нулей
    510            memcpy(&buf[ptr_end], &src[f], c);
    511            
    512            // Возвращаем размер данных в буфере
    513            return ptr_end+c;
    514          };
    515          
    516          /**
    517          @brief Шифрует/дешифрует данные с проверкой MIC
    518          @param[in] src Указатель на данные подлежащии шифрованию
    519          @param[in] len Размер данных
    520          @param[in] с Количество байт для шифрования
    521          @param[in] f Количество байт для авторизации
    522          @param[in] m Размер MIC (m=1,2,3 l(m) = 4,8,16 байт)
    523          @param[in] iv  Указатель на вектор иницилизации. 16 байт 
    524          @param[in] len Длинна данных
    525          @param[in,out] MIC Указатель на массив соответсвующий длинне (4,8,16 байт)
    526          */
    527          void AES_CCMEncrypt( uint8_t *src, uint8_t c, uint8_t f, uint8_t m,
    528                              uint8_t *key, uint8_t *nonce, uint8_t *MIC)
    529          {
    530            uint8_t lm = MIC_2_MICLEN(m);
    531            
    532            // Генерируем данные для авторизации
    533            uint8_t dlen = generateAuthData(src, nonce, c, f, lm);
    534            
    535            uint8_t mac[16]; // Сюда пишем мак
    536            CBCMAC_buf_encrypt(dlen, key, mac);
    537            
    538            // Шифруем MAC
    539            uint8_t CTR_IV[16];
    540            memcpy(CTR_IV, nonce, 16);
    541            CTR_IV[0] = 0x01; // Флаг режима CTR
    542            CTR_IV[15] = 0;   // Значение счетчика
    543            CTR_enc_decrypt(true, mac, mac, key, CTR_IV, 16);
    544            
    545            // Шифруем текст. он имеет размер 'c' и находится в буфере начиная с
    546            // dlen-c, dlen
    547            uint8_t ds = dlen - c; // Начало данных для шифрования
    548            
    549            // 0x0F & (16 - (dlen & 0x0f)) оставляет числа от 0 до 15  
    550            memset(buf+dlen, 0x00, 0x0F & (16 - (dlen & 0x0f)) ); // Дополняем нулями
    551            CTR_IV[15] = 1; // Счетчик CTR
    552            CTR_enc_decrypt(true, &buf[ds], &buf[ds], key, CTR_IV, c); // Шифруем
    553            
    554            // Заполняем буфер буфер src. src[0,f] это данные авторизации. 
    555            // src[f, f+c] это шифрованные данные.
    556            memcpy(&src[f], &buf[ds], c); 
    557            memcpy(MIC, mac, lm);
    558            
    559            //https://github.com/zhaohengyi/CC2530Example/blob/
    560            //master/source/components/radios/cc2530/hal_rf_security.c
    561          }
    562          
    563          /**
    564          @brief Дешифрует данные с проверкой MIC
    565          @param[in] src Указатель на данные подлежащии шифрованию
    566          @param[in] len Размер данных
    567          @param[in] с Количество байт для шифрования
    568          @param[in] f Количество байт для авторизации
    569          @param[in] m Размер MIC (m=1,2,3 l(m) = 4,8,16 байт)
    570          @param[in] iv  Указатель на вектор иницилизации. 16 байт 
    571          @param[in] len Длинна данных
    572          @param[in,out] MIC Указатель на массив соответсвующий длинне (4,8,16 байт)
    573          */
    574          bool AES_CCMDecrypt( uint8_t *src, uint8_t c, uint8_t f, uint8_t m,
    575                              uint8_t *key, uint8_t *nonce, uint8_t *MIC)
    576          {
    577            uint8_t lm = MIC_2_MICLEN(m);
    578            
    579            // Расшифровываем MAC
    580            uint8_t mac[16]; // Расшифрованый мак
    581            uint8_t CTR_IV[16];
    582            memcpy(CTR_IV, nonce, 16);
    583            CTR_IV[0] = 0x01; // Флаг режима CTR
    584            CTR_IV[15] = 0;   // Значение счетчика
    585            CTR_enc_decrypt(false, MIC, mac, key, CTR_IV, lm);  
    586            
    587            // Генерируем данные для авторизации
    588            uint8_t dlen = generateAuthData(src, nonce, c, f, lm);
    589            
    590            // Дешифруем текст. он имеет размер 'c' и находится в буфере начиная с
    591            // dlen-c, dlen
    592            uint8_t ds = dlen - c; // Начало данных для дешифрования
    593            
    594            // 0x0F & (16 - (dlen & 0x0f)) оставляет числа от 0 до 15  
    595            memset(buf+dlen, 0x00, 0x0F & (16 - (dlen & 0x0f)) ); // Дополняем нулями
    596            CTR_IV[15] = 1; // Счетчик CTR
    597            CTR_enc_decrypt(false, &buf[ds], &buf[ds], key, CTR_IV, c); // Дешифруем
    598            
    599            uint8_t new_mac[16]; // мак полученный в ходе рашифровки сообщения
    600            CBCMAC_buf_encrypt(dlen, key, new_mac);
    601            
    602            // Проверяем что маки совпадают, значит дешифровано верно
    603            bool mac_equal = true;
    604            for (uint8_t i = 0 ; i < lm ; i++)
    605            {
    606              if (mac[i] != new_mac[i])
    607              mac_equal = false;
    608              break;
    609            }
    610            
    611            // Выходим если MACи не совпали  
    612            if (!mac_equal)
    613              return false;
    614            
    615            // Копируем  расшифрованные данные
    616            memcpy(&src[f], &buf[ds], c); 
    617            return true;
    618          }
\\vmware-host\Shared Folders\Projects\WMNU\IAR\SHARE_PRJ_SRC\config.c
      1          #include "stdint.h"
      2          #include "string.h"
      3          #include "stdbool.h"
      4          #include "string.h"
      5          #include "basic.h"
      6          #include "config.h"
      7          
      8          static uint8_t default_key[16] = DEFAULT_KEY;
      9          static uint8_t default_iv[16] = DEFAULT_IV;
     10          
     11          void CF_init()
     12          {
     13            // Загрузка данных из различных источников
     14            memcpy(CONFIG.stream_key, default_key, 16); 
     15            memcpy(CONFIG.stream_iv,  default_iv, 16);
     16            CONFIG.node_ver = NODE_VER;
     17            CONFIG.node_type = NODE_TYPE;
     18            CONFIG.sync_channel = DEFAULT_SYNC_CHANNEL;
     19            CONFIG.panid = DEFAULT_PANID;
                                  ^
Warning[Pe069]: integer conversion resulted in truncation
          detected during compilation of secondary translation unit
                    "\\vmware-host\Shared
                    Folders\Projects\WMNU\IAR\SHARE_PRJ_SRC\config.c"
     20          }
\\vmware-host\Shared Folders\Projects\WMNU\IAR\SHARE_PRJ_SRC\delays.c
      1          /*!
      2          \file  Модуль измерения интервалов времени и функция задержки времени
      3          \brief Функции измерения времени и задержки
      4          */
      5          
      6          #include "ioCC2530.h"
      7          #include "delays.h"
      8          #include "string.h"
      9          
     10          #define TICK_NS  31.25 // Количество нс в одном такте TIM2
     11          #define TICK_US  0.03125 // Количество мкс в одном такте TIM2
     12          #define TICK_PER_US 32 // Количество тактов в одной микросекунде
     13          
     14          // Максимальное кол-во тактов таймера. Константа 40 бит, 5 байт
     15          static const uint32_t MAC_TIMER_MAX = 0xFFFFFFFFUL; 
     16          static uint32_t DELAY_CALIBRATE_TICS; // Колибровка функции задержки
     17          
     18          // Публичные методы
     19          void TIM_init(void);
     20          void TIM_TimeStamp(TimeStamp_s* timestamp);
     21          void TIM_delay(uint32_t delay);
     22          uint32_t TIM_passedTime(TimeStamp_s* start, TimeStamp_s* stop);
     23          void TIM_copy(TimeStamp_s *src, TimeStamp_s *dst);
     24          
     25          // Приватные
     26          static inline uint32_t Interval(TimeStamp_s* start, TimeStamp_s* stop);
     27          static void DelayCalibrate(void);
     28          
     29          /**
     30          @brief Иницилизация таймера
     31          @brief Используется таймер 2. MAC таймер
     32          */
     33          void TIM_init(void)
     34          {
     35            // Запускаем таймер, LATCH MODE = 1
     36            // Latch mode фиксирует значение таймера переполнения при чтении T2M0
     37            // ЗАпускаем MAC таймер без синхронизации с кварцем 32.768к
     38            T2CTRL = (1<<0) | (1<<3); 
     39            // Калибровка функции задержки
     40            DelayCalibrate();
     41          }
     42          
     43          /**
     44          @brief Возвращает временую метку.
     45          @params[out] timestamp указатель на временную метку 
     46          */
     47          void TIM_TimeStamp(TimeStamp_s* timestamp)
     48          {
     49            timestamp->byte[0] = T2M0;
     50            timestamp->byte[1] = T2M1;
     51            timestamp->byte[2] = T2MOVF0;
     52            timestamp->byte[3] = T2MOVF1;
     53          }
     54          
     55          /**
     56          @brief Калибровка функции задержки TIM_delay
     57          */
     58          static void DelayCalibrate(void)
     59          {
     60            #define ACCURATE_VAL_US 500 
     61            DELAY_CALIBRATE_TICS = 0;
     62            TimeStamp_s start, stop;
     63            uint32_t passed, cal;
     64            
     65            TIM_TimeStamp(&start);
     66            TIM_delay(ACCURATE_VAL_US);
     67            TIM_TimeStamp(&stop);
     68            passed = TIM_passedTime(&start, &stop);
     69            
     70            cal = passed - ACCURATE_VAL_US;
     71            DELAY_CALIBRATE_TICS = cal * TICK_PER_US; 
     72          };
     73          
     74          /**
     75          @brief Вычисляет количество тактов между двумя времеными метками
     76          @return Количество тактов
     77          */
     78          static inline uint32_t Interval(TimeStamp_s* start, TimeStamp_s* stop)
     79          {
     80            uint32_t ret;
     81          
     82            if (stop->timer >= start->timer)
     83              ret = stop->timer - start->timer;
     84            else
     85            { 
     86              ret = (MAC_TIMER_MAX - start->timer) + stop->timer;
     87            }
     88            return ret;
     89          }
     90          
     91          /**
     92          @brief Вычисляет прошедшее время между двумя времеными метками
     93          @return Время в мкс.
     94          */
     95          uint32_t TIM_passedTime(TimeStamp_s* start, TimeStamp_s* stop)
     96          {
     97            uint32_t ret = Interval(start, stop);
     98            
     99            ret = (uint32_t)((float)ret * TICK_US);
    100            return ret;
    101          }
    102          
    103          /**
    104          @brief Задержка на заданное количество мкс. 
    105          @details Погрешность около 20 мкс при значениях выше 150 мкс.
    106           Рекомендуется использовать для организации задержек не менее 200 мкс.
    107          @params[in] delay количество микросекунд. Не более 134217727 мкс (134.2 сек)
    108          */
    109          void TIM_delay(uint32_t delay)
    110          {
    111            uint32_t passed = 0;
    112            TimeStamp_s start, now;
    113            TIM_TimeStamp(&start);
    114            
    115            // Конвертируем мкс в такты и вносим поправку
    116            delay = delay * TICK_PER_US; 
    117            if (delay > DELAY_CALIBRATE_TICS)
    118              delay -= DELAY_CALIBRATE_TICS;
    119            
    120            do
    121            {
    122              TIM_TimeStamp(&now);
    123              passed = Interval(&start, &now);
    124            } while (passed < delay);
    125          }
    126          
    127          /**
    128          @brief Копирование временной метки
    129          @param[in] src указатель на исходную метку для копирование
    130          @param[out] dst указатель на метку назначения
    131          */
    132          void TIM_copy(TimeStamp_s *src, TimeStamp_s *dst)
    133          {
    134            memcpy(src, dst, sizeof(TimeStamp_s));
    135          }
\\vmware-host\Shared Folders\Projects\WMNU\IAR\SHARE_PRJ_SRC\ethernet.c
      1          #include "frame.h"
      2          #include "Net_frames.h"
      3          #include "stdint.h"
      4          #include "nwdebuger.h"
      5          #include "LLC.h"
      6          #include "mem.h"
      7          
      8          void ETH_Send(frame_s *fr);
      9          
     10          static void ETH_RX_HNDL(frame_s *fr);
     11          static void (*RXCallback)(frame_s *fr); //frame_s RAW_LAY, wthout ETH_LAY
     12          static bool validate(ETH_LAY *eth);
     13          static ETH_LAY* extract_header(frame_s *fr);
     14          static void send_ack(ETH_LAY *eth);
     15          static frame_s* strip_header(frame_s *fr);
     16          
     17          /**
     18          @brief Иницилизация модуля
     19          */
     20          void ETH_Init(void)
     21          {
     22            RXCallback = NULL; 
     23            LLC_SetRXCallback(ETH_RX_HNDL);
     24          }
     25          
     26          /**
     27          @brief Установка обработчика приема пакета ETH
     28          */
     29          void ETH_Set_RXCallback(void (*fn)(frame_s *fr))
     30          {
     31            ASSERT(fn != NULL);
     32            RXCallback = fn;
     33          }
     34          
     35          /**
     36          @brief Обработка принятого пакет сети.
     37          @detail После валидации пакета, уничтожается заголовок ETH и пакет передается
     38           на дальнейшую обработку вверх по стеку с помощью обратного вызова RXCallback
     39          */
     40          static void ETH_RX_HNDL(frame_s *fr)
     41          {
     42            ASSERT(fr != NULL);
     43            
     44            bool valid;
     45            frame_s *striped_frame;
     46            
     47            ETH_LAY* eth_h = extract_header(fr);
     48            
     49            // Извлечь заголовок не удалось
     50            if (eth_h == NULL)
     51              goto ERR_FRAME;
     52            
     53            valid = validate(eth_h);
     54           
     55            // Заголовок не верный
     56            if (!valid)
     57              goto ERR_FRAME;
     58           
     59            // Требуется отправить подтверждение приема пакета
     60            if (eth_h->ETH_T.bits.ACK)
     61              send_ack(eth_h);
     62            
     63            // Создаем новый пакет без заголовка и удаляем исходный
     64            striped_frame = strip_header(fr);
     65            frame_delete(fr);
     66            ASSERT(striped_frame != NULL);
     67            
     68            // Передаем обработчику выше по стеку
     69            ASSERT(RXCallback != NULL);
     70            RXCallback(striped_frame);
     71            
     72            re_free(eth_h);
     73            return;
     74            
     75          ERR_FRAME:
     76            frame_delete(fr);
     77            re_free(eth_h);
     78            return;
     79          }
     80          
     81          /**
     82          @brief Создает новый пакет без заголовка ETH_H
     83          @return указатель на новый frame_s*. NULL - не удалось создать пакет
     84          */
     85          static frame_s* strip_header(frame_s *fr)
     86          {
     87          }
                 ^
Warning[Pe940]: missing return statement at end of non-void function
          "strip_header"
          detected during compilation of secondary translation unit
                    "\\vmware-host\Shared
                    Folders\Projects\WMNU\IAR\SHARE_PRJ_SRC\ethernet.c"
     88          
     89          /**
     90          @brief Подготавливает и отпправляет подтверждение приема пакета
     91          */
     92          static void send_ack(ETH_LAY *eth)
     93          {
     94           
     95          }
     96          
     97          static bool validate(ETH_LAY *eth)
     98          {
     99            return true;
    100          }
    101          
    102          static ETH_LAY* extract_header(frame_s *fr)
    103          {
    104            ETH_LAY* eth_h = (ETH_LAY*)re_malloc(ETH_LAY_SIZE);
    105            ASSERT(eth_h != NULL);
    106            
    107            uint8_t len = frame_len(fr);
    108            ASSERT(len >= ETH_LAY_SIZE);
    109            
    110            //fbuf_s *fb = frame_get_fbuf_head(fr);
    111            //re_memcpy(eth_h, fb->payload, ETH_LAY_SIZE);
    112            return eth_h;
    113          }
\\vmware-host\Shared Folders\Projects\WMNU\IAR\SHARE_PRJ_SRC\frame.c
      1          /**
      2          @file Модуль описывает сетевой кадр и связанные с ним буферы данных
      3          @brief Типы frame
      4          */
      5          
      6          #include "frame.h"
      7          #include "string.h"
      8          #include "mem.h"
      9          #include "nwdebuger.h"
     10          #include "ioCC2530.h"
     11          
     12          frame_s* frame_create(void);
     13          void frame_delete(frame_s *fr);
     14          uint8_t frame_len(frame_s *fr);
     15          uint8_t frame_getCount(void);
     16          
     17          static uint8_t NBR_FRAME = 0; //!< Количество фреймов в памяти
     18          
     19          /**
     20          @brief Получить количество фреймов в памяти
     21          @return Возвращает количество фреймов
     22          */
     23          uint8_t frame_getCount(void)
     24          {
     25            return NBR_FRAME;
     26          }
     27          
     28          /**
     29          @brief Добавить заголовок
     30          @param[in] fr указатель на фрейм
     31          @param[in] src данные для добавления
     32          @param[in] len размер данных
     33          */
     34          void frame_addHeader(frame_s *fr, void *src, uint8_t len)
     35          {
     36            unsigned short EA_save = EA;
     37            EA = 0; 
     38            // Ранее небыло создано данных 
     39            if (fr->payload == NULL)
     40              {
     41                fr->payload = re_malloc(len);
     42                fr->len = len;
     43                re_memcpy(fr->payload, src, len);
     44                EA = EA_save;
     45                return;
     46              }
     47            
     48            uint8_t new_len = fr->len + len; // Новый размер
     49            void *new_payload = re_malloc(new_len);
     50            ASSERT(new_payload != NULL);
     51            
     52            // Копируем данные в конец области
     53            re_memcpy((char*)new_payload + len, fr->payload, fr->len);
     54            // Копируем данные спереди в свободную область
     55            re_memcpy(new_payload, src, len);
     56            // Уничтожаем старые данные
     57            re_free(fr->payload);
     58            fr->payload = new_payload;
     59            fr->len = new_len;
     60            EA = EA_save;
     61          }
     62          
     63          /**
     64          @brief Удалить заголовок
     65          @param[in] fr указатель на фрейм
     66          @param[in] len размер  удаляемых данных
     67          */
     68          void frame_delHeader(frame_s *fr, uint8_t len)
     69          {
     70            if (fr->payload == NULL)
     71              return;
     72          
     73            if (fr->len <= len)
     74              return;  
     75            
     76            uint8_t new_len = fr->len - len; // Новый размер
     77            void *new_payload = re_malloc(new_len);
     78            ASSERT(new_payload != NULL);
     79            
     80            // Копируем данные с пропуском первых len байт
     81            re_memcpy((char*)new_payload, (char*)fr->payload + len, new_len);
     82            
     83            // Уничтожаем старые данные
     84            re_free(fr->payload);
     85            fr->payload = new_payload;
     86            fr->len = new_len;
     87          }
     88          
     89          /**
     90          @brief Создание структуры frame
     91          @return Указатель на структуру frame
     92          */
     93          frame_s* frame_create(void)
     94          {
     95              unsigned short EA_save = EA;
     96              EA = 0; 
     97              
     98              frame_s* fr= (frame_s*)re_malloc(FRAME_S_SIZE);
     99              ASSERT(fr != NULL);
    100              
    101              fr->payload = NULL;
    102              fr->len = 0;
    103              memset(&fr->meta, 0x00, META_S_SIZE);
    104              NBR_FRAME++;
    105              
    106              EA = EA_save;
    107              return fr;
    108          };
    109          
    110          /**
    111          @brief Удаление frame
    112          @detail Проуедура так же удаляет все связанные с ней буфера fbuf
    113          @param[in] fr указатель на структуру frame
    114          */
    115          void frame_delete(frame_s *fr)
    116          {
    117            unsigned short EA_save = EA;
    118            EA = 0;  
    119            
    120            if (fr->payload != NULL)
    121              re_free(fr->payload);
    122           
    123            NBR_FRAME--;
    124            re_free(fr);
    125            EA = EA_save;
    126          }
    127          
    128          
    129          /**
    130          @brief Вычисляет размер цепочки fbuf
    131          @param[in] fr указатель на frame_s
    132          @return Количество байт в цепочке буферов
    133          */
    134          uint8_t frame_len(frame_s *fr)
    135          {
    136            return fr->len;
    137          }
\\vmware-host\Shared Folders\Projects\WMNU\IAR\SHARE_PRJ_SRC\LLC.c
      1          /**
      2          @file 
      3          @brief Модуль содержит реализацию интерфейса радио для приема/передачи данных.
      4          */
      5          
      6          #include "LLC.h"
      7          #include "MAC.h"
      8          #include "TIC.h"
      9          #include "mem.h"
     10          #include "nwdebuger.h"
     11          #include "ioCC2530.h"
     12          
     13          // Публичные методы
     14          void LLC_Init(void);
     15          
     16          // Методы модуля
     17          void LLC_SetRXCallback(void (*fn)(frame_s *fr));
     18          void LLC_TimeAlloc(void (*fn)(void)); 
     19          bool LLC_AddTask(frame_s* fr);
     20          uint8_t LLC_GetTaskLen(void);
     21          void LLC_Reset(void);
     22          
     23          // Закрытые методы
     24          static void LLC_SE_HNDL(uint8_t TS); //!< Обработчик завешения слота TIC
     25          static void LLC_Shelduler(uint8_t TS);
     26          static void LLC_RX_HNDL(frame_s *fr); //!< Обработчик примема пакета
     27          static void LLC_RunTimeAlloc(void);
     28          
     29          // Переменные модуля
     30          #define UNICAST_SEND_ATEMPTS 5 //!< Количество попыток передачи пакета 
     31          #define BROADCAST_SEND_ATEMPTS 3 //!< Количество попыток передачи пакета 
     32          #define MAX_nbrTASKS 20 //!< Максимальное количество задач в очередях
     33          
     34          typedef struct LLCTask LLCTask;
     35          typedef struct TimeAllocFunc TimeAllocFunc;
     36          static bool tasksBLOCK; //!< блокировка доступа к LLCTask
     37          
     38          /**
     39          @brief Описание задачи модуля LLC
     40          */
     41          struct LLCTask
     42          {
     43            LLCTask *next; //!< Указатель на следующую задачу. NULL - конец очереди
     44            uint8_t TS; //!< Номер временого канала для передачи сообщения
     45            uint8_t CH; //!< Номера радиоканала для передачи сообщения
     46            frame_s *fr; //!< Указатель на данные для передачи
     47          };
     48          
     49          /**
     50          @brief Список функций вызываемых по завешению временного слота
     51          */
     52          struct TimeAllocFunc
     53          {
     54            TimeAllocFunc *next; //!< Указатель на следующую функцию. NULL - конец списка
     55            void (*fn)(void); //!< Указатель на функцию. NULL - нет обработчика
     56          };
     57          
     58          static LLCTask *FirstTask; //!< Указатель на первый элемент очереди задач
     59          static uint8_t nbrTasks; // Количество задач в очереди
     60          
     61          /**
     62          @brief Обратный вызов при приеме пакета данных
     63          */
     64          static void (*RXCallback)(frame_s *fr);
     65          
     66          /**
     67          @brief Первый элемент обработчика конца временного слота
     68          @details Элемент создается статически, все остальные задачи создаются re_malloc
     69          и добавляются к HeadAllocFunc.
     70          */
     71          static TimeAllocFunc HeadAllocFunc;
     72          
     73          /**
     74          @brief Инициализация модуля
     75          @detail Иницилизирует MAC
     76          */
     77          void LLC_Init(void)
     78          {  
     79            nbrTasks = 0; 
     80            tasksBLOCK = false;
     81            FirstTask = NULL;
     82            // TODO Очистить очередь HeadTask
     83            // Регистрируем обработчики
     84            TIC_SetSECallback(LLC_SE_HNDL); // Завершение временного слота
     85            MAC_SetRXCallback(LLC_RX_HNDL); // Принято сообщение
     86          }
     87          
     88          /**
     89          @brief Сброс модуля
     90          @detail Удаяляем все пакеты в очереди. Аллокатор времени не трогаем
     91          */
     92          void LLC_Reset(void)
     93          {
     94            LLCTask *task = FirstTask;
     95            LLCTask *next;
     96            
     97            while (task != NULL)
     98            {
     99              next = task;
    100              re_free(task);
    101              task = next;
    102            }
    103            
    104          }
    105          
    106          /**
    107          @brief Количество задач в очереди
    108          @return количество задач в очереди
    109          */
    110          uint8_t LLC_GetTaskLen(void)
    111          {
    112            return nbrTasks;
    113          }
    114          
    115          void LLC_SetRXCallback(void (*fn)(frame_s *fr))
    116          {
    117            ASSERT(fn != NULL);
    118            RXCallback = fn;
    119          }
    120          
    121          /**
    122          @brief Добавляет обработчик заверешения временого слота в список
    123          */
    124          void LLC_TimeAlloc(void (*fn)(void))
    125          {
    126            TimeAllocFunc *ta = re_malloc(sizeof(TimeAllocFunc));
    127            ASSERT(ta != NULL);
    128            ta->next = NULL;
    129            ta->fn = fn;
    130          
    131            // Перебираемся в конец списка
    132            TimeAllocFunc *next = &HeadAllocFunc;
    133            while (next->next != NULL)
    134              next = next->next;
    135            
    136            // Добавляем новый элемент
    137            next->next = ta;
    138          };
    139          
    140          /**
    141          @brief Добавляем задачу в очередь
    142          @brief Взовращает true если задача добавлена в очередь. false, если размер 
    143           очереди достиг максимального размера.
    144          */
    145          bool LLC_AddTask(frame_s* fr)
    146          {
    147             ASSERT(fr != NULL);
    148           
    149              if (nbrTasks == MAX_nbrTASKS)
    150                return false;
    151              
    152             // Ждем пока разблокируется доступ.
    153             while (tasksBLOCK);
    154             tasksBLOCK = true;
    155          
    156             // Создаем новую задачу
    157             LLCTask *new_task = (LLCTask*)re_malloc(sizeof(LLCTask));
    158             ASSERT(new_task !=NULL); 
    159                
    160             new_task->TS = fr->meta.TS;
    161             new_task->CH = fr->meta.CH;
    162             new_task->fr = fr;
    163             
    164            LOG_ON("Add task = %u, CH = %d, TS = %d, OTS = %d. fr = %d",
    165                (uint16_t)new_task,new_task->CH, new_task->TS, fr->meta.TS, (uint16_t)fr);
    166            
    167             // Если в очереди нет задач, добавим первую
    168             if (FirstTask == NULL) 
    169             {
    170               new_task->next = NULL;
    171               FirstTask = new_task;
    172             }
    173             // Если в очереди были задачи то вставим новую в голову списка
    174             else 
    175             {
    176               new_task->next = FirstTask;
    177               FirstTask = new_task;  
    178             }
    179             
    180             nbrTasks ++;
    181             tasksBLOCK = false;
    182          
    183             return true;
    184          }
    185          
    186          
    187          
    188          
    189          /**
    190          @brief Планировщик задач
    191          @details Соотносит задачи в очереди и свободные временные слоты MAC уровня.
    192          При освобождении временных слотов, планировщик устанавливает данные для 
    193          передачи в MAC.
    194          @param[in] TS номер текущего временого слота
    195          */
    196          static void LLC_Shelduler(uint8_t TS)
    197          {
    198            // Если работает функция добавления задачи, то обслуживание очереди не
    199            // производится. Это может привести к необычным последствиям
    200            if (tasksBLOCK)
    201              return;
    202            tasksBLOCK = true;
    203            
    204            // Перебираем попорядку весь список на отправку
    205            // HeadTask только указатель на первый элемент, сам он не подлежит отправке
    206            LLCTask *task = FirstTask;
    207            LLCTask *last = FirstTask;
    208            LLCTask *next = FirstTask;
    209            
    210            while (task != NULL)
    211            {    
    212              if (MAC_GetTXState(task->TS)) // Занят ли временой слот
    213              {
    214                // Если слот занят переходим к следующей задаче
    215                last = task;
    216                task = task->next;
    217                continue; 
    218              }
    219              
    220              //Выбераем количество попыток передачи в зависимости от типа пакета
    221              uint8_t attempts;
    222              if (task->fr->meta.TX_METHOD == UNICAST)
    223                attempts = UNICAST_SEND_ATEMPTS;
    224              else if (task->fr->meta.TX_METHOD == BROADCAST)
    225                attempts = BROADCAST_SEND_ATEMPTS;
    226              else
    227                ASSERT(false);
    228              
    229              MAC_Send(task->fr, attempts);
    230              
    231              next = task->next; // Запомним следующую задачу
    232              
    233              // Удаляем текущую задачу из списка
    234              if (task == FirstTask)
    235              {
    236              // Удаляемым элементом является указателем на голову
    237                 FirstTask = next;
    238                 last = FirstTask;
    239              }
    240              else
    241              {
    242                // Удаляемым элементом является промежуточный элемент
    243                last->next = next;
    244              }
    245              
    246              nbrTasks--;
    247              LOG_OFF("Free task = %u, nbrTasks = %d\r\n",
    248                  (uint16_t)task, nbrTasks); 
    249              re_free(task);
    250              task = next;
    251            }
    252            
    253            tasksBLOCK = false;
    254          }
    255          
    256          /**
    257          @brief Обработчик заверешния временого слота
    258          @details Обратный вызов из TIC. Обработчик вызывает планировщик задач очереди
    259          и передает управление зарегистрированым функциям с помощью LLC_TimeAlloc.
    260          @param[in] TS номер завершенного временого слота
    261          */
    262          static void LLC_SE_HNDL(uint8_t TS)
    263          {
    264            LLC_Shelduler(TS);
    265            LLC_RunTimeAlloc();
    266          }
    267          
    268          static void LLC_RX_HNDL(frame_s *fr)
    269          {
    270            ASSERT(RXCallback !=NULL);
    271            RXCallback(fr);
    272          }
    273          
    274          /**
    275          @brief Передаем управление зарегистрированным функциям
    276          */
    277          static void LLC_RunTimeAlloc(void)
    278          {
    279              TimeAllocFunc *next = &HeadAllocFunc;
    280            // HeadAllocFunc служит только для указания на первый элемент в очереди
    281            // так что его нужно пропустить и переходить сразу к next
    282            while (next->next != NULL)
    283            {
    284              next->next->fn();
    285              next = next->next;
    286            }
    287          }
\\vmware-host\Shared Folders\Projects\WMNU\IAR\SHARE_PRJ_SRC\MAC.c
      1          #include "MAC.h"
      2          #include "frame.h"
      3          #include "string.h"
      4          #include "nwdebuger.h"
      5          #include "coder.h"
      6          #include "TIC.h"
      7          #include "stdlib.h"
      8          #include "basic.h"
      9          
     10          // Обработчики прерываний
     11          static void MAC_RX_HNDL(uint8_t TS);
     12          static void MAC_TX_HNDL(uint8_t TS);
     13          static void (*RXCallback)(frame_s *fr);
     14          static void BitRawDecrypt(uint8_t *src, uint8_t size);
     15          static void BitRawCrypt(uint8_t *src, uint8_t size);
     16          static uint8_t xor_calc(frame_s *fr);
     17          
     18          // Публичные методы
     19          void MAC_Init(void);
     20          void MAC_Reset(void);
     21          void MAC_Enable(bool en);
     22          void MAC_OpenRXSlot(uint8_t TS, uint8_t CH);
     23          void MAC_CloseRXSlot(uint8_t TS);
     24          void MAC_Send(frame_s *fr, uint8_t attempts);
     25          bool MAC_ACK_Send(frame_s *fr);
     26          void MAC_SetRXCallback(void (*fn)(frame_s *fr));
     27          bool MAC_GetTXState(uint8_t TS);
     28          bool MAC_GetRXState(uint8_t TS);
     29          
     30          // Ключ потокового шифрования и вектор иницилизации
     31          static uint8_t KEY[16] = DEFAULT_KEY;
     32          static uint8_t IV[16] = DEFAULT_IV;
     33            
     34          #define RECV_TIMEOUT 2 // Время ожидания приема пакета в мс с начала слота
     35          #define ACK_RECV_TIMEOUT 1 // Время ожидания приема подтверждения в мс
     36          #define TX_DELAY 1*Tmsec // Смещение при передаче пакета. Защита от девиации времени
     37          
     38          typedef struct // Формат структуры пакета ACK
     39          {
     40            uint16_t CRC8;
     41          } __attribute__((packed)) ACK_s;
     42          
     43          typedef struct
     44          {
     45           struct 
     46           {
     47             bool enable;
     48             uint8_t attempts;
     49             uint8_t CH;
     50             frame_s *fr;
     51           } __attribute__((packed)) TX;
     52           
     53           struct
     54           {
     55            bool enable; 
     56            uint8_t CH;
     57           } __attribute__((packed)) RX;
     58          } __attribute__((packed)) MACSState_s; 
     59          
     60          static bool MAC_ENABLE_MODULE = false; //!< Модуль активен
     61          
     62          
     63          // Таблица состояний слотов приема/передачи
     64          MACSState_s MACSlotTable[50];
     65          
     66          /**
     67          @brief Установить вектор иницилизации для шифрования
     68          @param[in] ptr_IV указатель на 16 байтный вектор иницилизации
     69          */
     70          void MAC_setIV(void* ptr_IV)
     71          {
     72            memcpy(IV, ptr_IV, 16);
     73          }
     74          
     75          /**
     76          @brief Установить ключ шифрования
     77          @param[in] ptr_KEY указатель на 16 байтный ключ
     78          */
     79          void MAC_setKEY(void* ptr_KEY)
     80          {
     81            memcpy(KEY, ptr_KEY, 16);
     82          }
     83          
     84          /**
     85          @brief Иницилизация MAC
     86          @detail Инизилизирует TIM, TIC, RI, AES
     87          */
     88          void MAC_Init(void)
     89          {
     90            MAC_ENABLE_MODULE = false;
     91            TIC_SetRXCallback(MAC_RX_HNDL);
     92            TIC_SetTXCallback(MAC_TX_HNDL);  
     93            memset(MACSlotTable, 0x00, 50*sizeof(MACSState_s));
     94          }
     95          
     96          /**
     97          @brief Сброс настроек модуля.
     98          @detail Удаяляет все пакеты для передачи. Активным остается TS1 обработчик sync
     99          */
    100          void MAC_Reset(void)
    101          {
    102            MAC_ENABLE_MODULE = false;
    103            // Удаляем все пакеты на передачу
    104            for (uint8_t i = 0; i < 50; i++)
    105              if (MACSlotTable[i].TX.enable)
    106                frame_delete(MACSlotTable[i].TX.fr);
    107            
    108            memset(MACSlotTable, 0x00, 50*sizeof(MACSState_s));
    109          }
    110          
    111          /**
    112          @brief Открыть временой слот приема данных
    113          @param[in] TS номер слота от 0 до 49
    114          @param[in] CH номер радиоканала
    115          */
    116          void MAC_OpenRXSlot(uint8_t TS, uint8_t CH)
    117          {
    118              ASSERT(TS < 50 || TS !=0 );
    119              MACSlotTable[TS].RX.enable = true;
    120              MACSlotTable[TS].RX.CH = CH;
    121              TIC_SetRXState(TS, true);
    122          }
    123          
    124          /**
    125          @brief Закрыть временой слот приема данных
    126          @param[in] TS номер слота от 0 до 49
    127          */
    128          void MAC_CloseRXSlot(uint8_t TS)
    129          {
    130            ASSERT(TS < 50 || TS !=0);
    131            MACSlotTable[TS].RX.enable = false;
    132            TIC_SetRXState(TS, false);
    133          }
    134          
    135          /**
    136          @brief Поставить пакет в таблицу отправки сообщений
    137          @param[in] fr указатель на пакет
    138          @param[in] attempts количество попыток
    139          */
    140          void MAC_Send(frame_s *fr, uint8_t attempts)
    141          {
    142              ASSERT(fr != NULL);
    143              ASSERT(attempts != 0);
    144              ASSERT(fr->meta.TS != 0);
    145              
    146              uint8_t TS = fr->meta.TS; 
    147              MACSlotTable[TS].TX.attempts = attempts;
    148              MACSlotTable[TS].TX.CH = fr->meta.CH;
    149              MACSlotTable[TS].TX.enable = true;
    150              MACSlotTable[TS].TX.fr = fr;
    151              
    152              #ifdef RARIO_STREAM_ENCRYPT
    153              BitRawCrypt(fr->payload, fr->len);
    154              #endif
    155              
    156              TIC_SetTXState(TS, true);
    157          }
    158          
    159          void MAC_Enable(bool en)
    160          {
    161            MAC_ENABLE_MODULE = en;
    162          }
    163          
    164          /**
    165          @brief Расчитывает CRC8 код
    166          @param[in] fr указатель на кадр
    167          @return CRC8
    168          */
    169          static uint8_t xor_calc(frame_s *fr)
    170          {
    171            uint8_t crc = 0x34; // Начальное значение
    172            uint8_t *val = fr->payload;
    173            
    174            for (uint8_t i = 0; i < fr->len; i++)
    175              crc ^= val[i];
    176            return crc;
    177          }
    178          
    179          /**
    180          @brief Посылает подтверждение приема пакета
    181          @param[in] fr указатель на кадр который нужно подтвердить
    182          @return true если передача подтверждения успешна (канал свободен)
    183          */
    184          static bool MAC_ACK_Send(frame_s *fr)
    185          {
    186            static ACK_s pACK;
    187            frame_s *fr_ACK;
    188            
    189            // Создаем подтверждение кадра
    190            pACK.CRC8 = xor_calc(fr);
    191            
    192            // Создаем кадр для отправки
    193            fr_ACK = frame_create();
    194            frame_addHeader(fr_ACK, &pACK, sizeof(ACK_s));
    195            fr_ACK->meta.SEND_TIME = 0;
    196            
    197           
    198            bool res = RI_Send(fr_ACK);
    199            frame_delete(fr_ACK);
    200            return res;
    201          }
    202          
    203          /**
    204          @brief Ожидает прием пакета подтверждения
    205          @param[in] fr указатель на пакет подтверждение которого ожидаем 
    206          @return true если приняли подтверждение
    207          */
    208          static bool MAC_ACK_Recv(frame_s *fr)
    209          {
    210            frame_s *fr_ACK = RI_Receive(ACK_RECV_TIMEOUT);
    211            
    212            // Если пакета нет, выходим из обработчика
    213            if (fr_ACK == NULL)
    214              return false;
    215            
    216            // Проверим размер пакета
    217            if (fr_ACK->len != sizeof(ACK_s))
    218            {
    219              frame_delete(fr_ACK);
    220              return false;
    221            }
    222              
    223            ACK_s *ptrACK;
    224            ptrACK = (ACK_s*)fr_ACK->payload;
    225            
    226            uint8_t crc8 = xor_calc(fr);
    227            uint8_t ack_crc8 = ptrACK->CRC8;
    228            frame_delete(fr_ACK);
    229            
    230            if (crc8 == ack_crc8)
    231              return true;
    232            return false;
    233          }
    234          
    235          /**
    236          @brief Устанавливает функцию обратного вызова при приеме пакета
    237          @param[in] fn указатель на функцию обработчик
    238          */
    239          void MAC_SetRXCallback(void (*fn)(frame_s *fr))
    240          {
    241            RXCallback = fn;
    242          }
    243          
    244          /**
    245          @brief Состояние слота TS передача
    246          @return возвращает true, если слот содержит пакет для передачи
    247          */
    248          bool MAC_GetTXState(uint8_t TS)
    249          {
    250            ASSERT(TS < 50  || TS !=0 );
    251            return MACSlotTable[TS].TX.enable;
    252          }
    253          
    254          /**
    255          @brief Состояние слота TS приема
    256          @return возвращает true, если слот принимает пакет
    257          */
    258          bool MAC_GetRXState(uint8_t TS)
    259          {
    260            ASSERT(TS < 50  || TS !=0);
    261            return MACSlotTable[TS].RX.enable;
    262          }
    263          
    264          /**
    265          @brief Обработчик слота приема пакета
    266          @detail При необходимости подтвеждает пакет
    267          @param[in] TS номер временного слота
    268          */
    269          static void MAC_RX_HNDL(uint8_t TS)
    270          {
    271            ASSERT(TS < 50  || TS !=0);
    272          
    273            if (!MAC_ENABLE_MODULE) // Модуль откючен
    274              return;
    275            
    276            RI_SetChannel(MACSlotTable[TS].RX.CH);
    277            frame_s *fr = RI_Receive(RECV_TIMEOUT);
    278            
    279            // Если пакета нет, выходим из обработчика
    280            if (fr == NULL)
    281              return;
    282            
    283            // Пакеты во временные слоты 1..49 требуют подтверждения
    284            // Слоты 0 и 1 для швс и синхронизации соответсвенно
    285            if (TS > 1)
    286              MAC_ACK_Send(fr);
    287           
    288            #ifdef RARIO_STREAM_ENCRYPT
    289            BitRawDecrypt(fr->payload, fr->len);
    290            #endif
    291            
    292            RXCallback(fr);   // Передаем пакет на дальнейшую обработку
    293            // Удаление пакета не наша забота
    294          }
    295          
    296          /**
    297          @brief Обработчик слота пердачи пакета
    298          @detail После отправки пакета требуется подтверждение приема если meta.ACK = 1.
    299           После отправки ждем приема ACK. Проверка подлинности ACK происходит с помощью
    300           обратного вызова isACK_OK(*fr, *fr_ACK). Результат true или false.
    301          @param[in] TS номер временного слота
    302          */
    303          static void MAC_TX_HNDL(uint8_t TS)
    304          {
    305            ASSERT(TS < 50  || TS !=0);
    306            
    307            if (!MAC_ENABLE_MODULE) // Модуль отключен
    308              return;
    309            
    310            // По ошибки вызвали. Такого быть не должно, но подстрахуемся.
    311            if ((!MACSlotTable[TS].TX.enable) || (MACSlotTable[TS].TX.attempts == 0)) 
    312            {
    313              TIC_SetTXState(TS, false);
    314              return;
    315            }
    316            
    317            RI_SetChannel(MACSlotTable[TS].TX.CH); // Устанавливаем канал передачи
    318          
    319            // Задержка перед передачей данных необходима для учета отклонения
    320            // времени между узлами из-за рассинхронизации узлов
    321            TIM_delay(TX_DELAY);
    322            // Пробуем передать данные
    323            bool tx_success = RI_Send(MACSlotTable[TS].TX.fr); 
    324            bool send_success = false;  
    325            
    326            LOG_OFF("RI_Send = %d, CH = %d, TS = %d\r\n",
    327                tx_success, MACSlotTable[TS].TX.CH, TS);
    328              
    329            if (tx_success)
    330            {
    331              if (TS > 1) // требуется подтверждение ACK
    332              {
    333                if (MAC_ACK_Recv(MACSlotTable[TS].TX.fr))
    334                    send_success = true;
    335              }
    336              else // не требуеться подтверждение
    337                send_success = true;
    338            }
    339            
    340          
    341            if (send_success) // В случаи успеха удаляем данные и закрываем слоты 
    342            { 
    343              frame_delete(MACSlotTable[TS].TX.fr);
    344              MACSlotTable[TS].TX.enable = false;
    345              TIC_SetTXState(TS, false);      
    346            }
    347            else // Уменьшаем счетчик попыток передачи и удаляем пакет при достижении 0.
    348            {
    349              MACSlotTable[TS].TX.attempts --;
    350              if (MACSlotTable[TS].TX.attempts == 0)
    351                {
    352                  frame_delete(MACSlotTable[TS].TX.fr);
    353                  MACSlotTable[TS].TX.enable = false;
    354                  TIC_SetTXState(TS, false);  
    355                }
    356            }
    357          }
    358          
    359          /*!
    360          \brief Расшифровка область памяти
    361          \param[in,out] *src Указатель на начало области дешифрования
    362          \param[in] size Размер расшифруемых данных
    363          */
    364          static void BitRawDecrypt(uint8_t *src, uint8_t size)
    365          {
    366            AES_StreamCoder(false, src, src, KEY, IV, size);
    367          }
    368          
    369          /*!
    370          \brief Шифрует область памяти
    371          \param[in,out] *src Указатель на начало области шифрования
    372          \param[in] size Размер шифруемых данных
    373          */
    374          static void BitRawCrypt(uint8_t *src, uint8_t size)
    375          {
    376            AES_StreamCoder(true, src, src, KEY, IV, size);
    377          }
    378          
\\vmware-host\Shared Folders\Projects\WMNU\IAR\SHARE_PRJ_SRC\manager.c
      1          #include "manager.h"
      2          #include "coder.h"
      3          #include "delays.h"
      4          #include "ethernet.h"
      5          #include "frame.h"
      6          #include "LLC.h"
      7          #include "MAC.h"
      8          #include "NTMR.h"
      9          #include "RADIO.h"
     10          #include "TIC.h"
     11          #include "sync.h"
     12          #include "config.h"
     13          #include "frame.h"
     14          #include "nwdebuger.h"
     15          #include "basic.h"
     16          #include "config.h"
     17          #include "ioCC2530.h"
     18          
     19          static void MG_Init();
     20          static void MG_Reset();
     21          static void re_start();
     22          static bool network_discovery();
     23          
     24          static bool MG_MODULES_INITED = false; //!< Были ли запущенны аппаратные модули
     25          
     26          // Публичные методы
     27          bool MG_Connect();
     28          
     29          // Переменные модуля
     30          
     31          
     32          static void MG_Init()
     33          {
     34            CF_init();
     35            NT_Init();
     36            TIM_init();
     37            TIC_Init();
     38            RI_init();
     39            AES_init();
     40            MAC_Init();
     41            SY_Init();
     42            LLC_Init();
     43            // TODO Необходимо очищать все ранее выделеную память malloc
     44          }
     45          
     46          static void MG_Reset()
     47          {   
     48            TIC_Reset();
     49            MAC_Reset();
     50            SY_Reset();
     51            LLC_Reset();
     52          }
     53          
     54          static void re_start()
     55          {
     56              if (!MG_MODULES_INITED)
     57            {
     58              MG_Init();
     59              MG_MODULES_INITED = true;
     60            }
     61            else
     62              MG_Reset(); 
     63              
     64            CF_init();
     65            MAC_setIV(CONFIG.stream_iv);
     66            MAC_setKEY(CONFIG.stream_key);
     67            SY_setIV(CONFIG.stream_iv);
     68            SY_setKEY(CONFIG.stream_key);
     69          }
     70          
     71          /**
     72          @brief Алгоритм подключения к сети
     73          */
     74          static bool network_discovery()
     75          {
     76            uint16_t panid;
     77            bool con = false;
     78            
     79            // Тупой алгоритм поиска сети.
     80            while (!con)
     81            {
     82              con = SY_SYNC_NETWORK(&panid, 5000);
     83            }
     84            return con;
     85          }
     86          
     87          /**
     88          @brief Создание сети в режиме шлюза
     89          */
     90          static bool master_mode()
     91          {
     92            // Включает обработку начала слота TS1 для программы собранной с ключом 
     93            // GATEWAY. MAC_TS1_HNDL_MASTER будет создавать пакеты синхронизации.
     94            MAC_Enable(true);
     95            SY_Enable(true);
     96            return true;
     97          }
     98          
     99          /**
    100          @brief Создание сети в режиме узла
    101          */
    102          static bool slave_mode()
    103          {
    104            // В режиме slave сначало нужно подключисться к сети
    105            network_discovery();
    106            
    107            // После синхронизации с сетью разрешаем обработку временных слотов
    108            // Программа собрана без ключа GATEWAY и активной функцией обработки TS1
    109            // будет MAC_TS1_HNDL_SLAVE. Она отвечает за поддержание синхронизации
    110            // и периодиескую ректрансляцию пакетов.
    111            
    112            MAC_Enable(true);
    113            SY_Enable(true);
    114            return true;
    115          }
    116          
    117          bool MG_Connect()
    118          {
    119            EA = 0;
    120            re_start();
    121            EA = 1;
    122            if (frame_getCount())
    123            {
    124              LOG_ON("Frame_s count: %d \r\n",frame_getCount());
    125              return false;
    126            }
    127            
    128          #ifdef GATEWAY
    129              bool con = master_mode();
    130          #else
    131              bool con = slave_mode();  
    132          #endif
    133              
    134              return con;
    135          }
    136           
    137            
\\vmware-host\Shared Folders\Projects\WMNU\IAR\SHARE_PRJ_SRC\mem.c
      1          #include "ioCC2530.h"
      2          #include "stdlib.h"
      3          #include "stdint.h"
      4          #include "string.h"
      5          #include "nwdebuger.h"
      6          
      7          void re_free(void* ptr);
      8          void* re_malloc(size_t size);
      9          uint16_t heap_ptr(size_t size);
     10          void re_memcpy(void *dst, const void *src, size_t n);
     11          
     12          /**
     13          @brief Возвращает адрес следующего свободного участка памяти
     14          @detail Функция нужна для оценки использования стека
     15          @param[in] size размер запрашиваемой области
     16          @return если памяти нету возвращает 0, иначе адрес свободного участка.
     17          */
     18          uint16_t heap_ptr(size_t size)
     19          {
     20            unsigned short EA_save = EA;
     21            EA = 0; 
     22            uint16_t *heap_ptr;
     23            heap_ptr = (uint16_t*)re_malloc(size);
     24            re_free(heap_ptr);
     25            EA = EA_save;
     26            return (uint16_t)heap_ptr;
     27          }
     28          
     29          /**
     30          @brief Реентерабельное копирование памяти
     31          */
     32          void re_memcpy(void *dst, const void *src, size_t n)
     33          {
     34            unsigned short EA_save = EA;
     35            EA = 0;
     36            memcpy(dst, src, n);
     37            EA = EA_save;  
     38          }
     39          
     40          /**
     41          @brief Реентерабельное выделение памяти
     42          */
     43          void* re_malloc(size_t size)
     44          {
     45            unsigned short EA_save = EA;
     46            void* ptr; 
     47            EA = 0;
     48            ptr = malloc(size);
     49            EA = EA_save;
     50            //LOG(MSG_OFF | MSG_INFO | MSG_TRACE, "malloc = %d, L= %d \r\n", (uint16_t)ptr, size);
     51            return ptr;
     52          }
     53          
     54          /**
     55          @brief Реентерабельное освобождение памяти
     56          */
     57          void re_free(void* ptr)
     58          {
     59            unsigned short EA_save = EA;
     60            EA = 0;
     61            free(ptr);
     62            EA = EA_save;
     63            //LOG(MSG_OFF | MSG_INFO | MSG_TRACE, "free = %d\r\n", (uint16_t)ptr);  
     64          }
\\vmware-host\Shared Folders\Projects\WMNU\IAR\SHARE_PRJ_SRC\NTMR.c
      1          #include "NTMR.h"
      2          #include "stdlib.h"
      3          #include "ioCC2530.h"
      4          #include "nwdebuger.h"
      5          
      6          /**
      7          @file 
      8          @brief Модуль управления таймером сна
      9          @details При создании обьекта с помощью NT_Create, производится иницилизация
     10           аппаратного таймера сна и он переходит в активное состояние. Если установлено 
     11           определение #define USE_OSC32K будет использван внешний кварц.
     12           За установку глобального прерывания IE отвечает пользователь.
     13           Для использования модуля необходимо установить обработчик прерывания
     14           NT_SetEventCallback(..). Далее с помощью NT_SetCompare(..) установить
     15           время срабатывания прерывания, она же включит прерывание таймера. 
     16           Перед вызовом пользовательского обработчика, запрещается прерывание таймера,
     17           пользователь должен установить его повторно на необходимое время.
     18           Модуль сна пробуждает МК из режимов PM1,PM2, но не переводит их обратно.
     19           После завершения обработки прерывание, продолжится выполнение основного 
     20           потока программы. Пользователь самостоятельно должен перевести МК в режим сна.
     21           Функция NT_SetTime(..) производит подстройку времени сети и корректирует время
     22           срабатывания прерывания. Что бы было понятнее приведу пример: 
     23           Время сети 400 и установленно прерывание на 700.
     24           Пользователь корректирует время на 300, но из-за разной разрядности счетчиков
     25           прерывание произойдет по "старым часам", так как NT_SetTime только изменит
     26           переменную относительного смещения, а не непосредственно значение счетчика.
     27           Поэтому необходимо пересчитать время прерывания 700 к новому смещению.
     28           Из найденных особенностей: когда вызывается обработчик прерывания, значение
     29           времени всегда больше на 2 тика. Предполагаю из за ожидания синхронизации при
     30           чтении значения таймера. 
     31          */
     32          
     33          
     34          // После вызова EventCallback аппаратное прерывание завершается
     35          // и управление передается в главный цикл main.
     36          // Пользователь сам должен положить систему в сон
     37          // Для работы используется sleep timer.
     38          // Значение таймера изменить нельзя, он автоматически стартует после
     39          // Включения микроконтроллера. Нам нужно выбрать XOSC вместо RCOSC,
     40          // Но на отладочной плате нет резонатора
     41          // Чтение значения ST2:ST1:ST0 первым из ST0
     42          // Таймер работает во всех режимах кроме PM3
     43          // После пробуждения нужно убеиться что SLEEPSTA.CLK32K бит установлен прежде 
     44          // чем считывать ST0-3
     45          
     46          
     47          #define USE_OSC32K // Использовать внешний квац 32.768 кГц
     48          
     49          // Методы модуля
     50          bool NT_SetTime(uint16_t ticks);
     51          void NT_SetCompare(uint16_t ticks);
     52          void NT_SetEventCallback(void (*fn)(uint16_t ticks));
     53          uint16_t NT_GetTime(void);
     54          uint16_t NT_WaitTime(uint16_t ticks);
     55          
     56          // Приватные методы
     57          static uint32_t ReadTimer(void);
     58          static void loadTimerCompare(uint32_t ticks);
     59          static inline bool isIRQEnable(void);
     60          static inline void NT_IRQEnable(bool state);
     61          
     62          // Переменные модуля
     63          static void (*EventCallback)(uint16_t ticks);
     64          static uint32_t COMPARE_TIME; //!< Значение загруженное в регистр compare
     65          
     66          /**
     67          @details Смещение времени сети относительно времени таймера.
     68           NETWORK TIME = TIMER + TOFFSET
     69          */
     70          uint16_t TOFFSET; 
     71          
     72          /**
     73          @brief Инизиализация таймера
     74          */
     75          void NT_Init(void)
     76          {
     77            TOFFSET = 0;
     78            COMPARE_TIME = 0;
     79            EventCallback = NULL;
     80          
     81            // Сначало нужно настроить кварц 32кГц только потом поднимать
     82            // основной квар до 32 Мгц
     83            #ifdef USE_OSC32K
     84            CLKCONCMD &= ~(1<<7); // Сбрасываем бит OSC32K, будет выбран 32.768 кварц
     85            while (CLKCONSTA & (1<<7)); // Ждем пока бит не станет 0
     86            #endif
     87          
     88            // Переходим на 32 Мгц
     89            CLKCONCMD = (1<<3);
     90            while (CLKCONSTA&(1<<6));
     91            
     92            NT_IRQEnable(false);
     93          }
     94          
     95          /**
     96          @brief Устанавливаем текущее время сети и переустанавливает capture time
     97          @param[in] ticks время от 0-32767. Один tick 1/32768
     98          @return true если аргумент в диапазоне
     99          */
    100          bool NT_SetTime(uint16_t ticks)
    101          {
    102            ASSERT(ticks < 32768);
    103            if (ticks > 32767)
    104              return false;
    105           
    106            uint16_t timer = ReadTimer();
    107            TOFFSET = ticks - timer;
    108            TOFFSET &= 0x7FFF;
    109          
    110            // После установки времени нужно изменить compare time в таймере
    111            // Но только в случаи если прерывание активно
    112            if (isIRQEnable())
    113            {
    114              NT_SetCompare(COMPARE_TIME);
    115            }
    116          
    117            return true;
    118          }
    119          
    120          /**
    121          @brief Вычисляет значение, которое нужно установить в регистр compare таймера.
    122          @params[in] ticks время сети в тикак
    123          */
    124          static inline uint32_t calcCompareTime(uint16_t ticks)
    125          {   
    126              uint32_t timer = ReadTimer(); // Текущее значение счетчика
    127              
    128              //NETWORK TIME = TIMER + TOFFSET  
    129              // Приводим такты к тактам таймера
    130              uint16_t ticks_offset = (ticks - TOFFSET) & 0x7FFF;
    131              
    132              uint32_t cmp_time = timer & ~0x7FFF; // Убираем младшие 15 бит
    133              cmp_time |= ticks_offset; // Вычисляем новое время
    134              
    135              if (cmp_time <= timer)
    136              {
    137                cmp_time += 0x8000;
    138                cmp_time &=0xFFFFFF;
    139              }
    140                
    141               LOG_OFF("Timer = %lu, Ticks = %d,CMP = %lu \r\n",
    142                    timer, ticks, cmp_time );
    143              return cmp_time;
    144          }
    145          
    146          /**
    147          @brief Устанавливает время прерывания
    148          @details Время прерывания устанавливается относительно времени сети
    149          ,к примеру, что бы проснуться в таймслот номер 0, нужно установить ticks = 0.
    150          Процедура учитывает текущее значение таймера и перерасчитывает значение ticks. 
    151          @params[in] ticks время сети в тиках когда нужно проснуться
    152          */
    153          void NT_SetCompare(uint16_t ticks)
    154          {
    155            ASSERT(ticks < 32768);
    156            
    157            COMPARE_TIME = ticks; // Сохраняем установленное значение
    158           
    159            uint32_t compare_time = calcCompareTime(ticks);
    160           
    161            loadTimerCompare(compare_time);
    162            NT_IRQEnable(true);
    163          }
    164          
    165          /**
    166          @brief Разрешение прерываний таймера сна
    167          @params[in] state = true - разрешить обработку прерываний
    168          */
    169          static inline void NT_IRQEnable(bool state)
    170          {
    171            STIF = 0;
    172            if (state)
    173            {
    174              STIE = 1;
    175            }
    176            else
    177            {
    178              STIE = 0;
    179            }
    180          }
    181          
    182          /**
    183          @brief Проверка активности прерывания таймера
    184          @return true если прерывание установленно
    185          */
    186          static inline bool isIRQEnable(void)
    187          {
    188            if (STIE)
    189              return true;
    190            else 
    191              return false;
    192          }
    193          
    194          /**
    195          @brief Устанавливает обработчик прерывания таймера
    196          @param[in] fn(uint16_t ticks) указатель на функцию-обработчик
    197          */
    198          void NT_SetEventCallback(void (*fn)(uint16_t ticks))
    199          {
    200            EventCallback = fn;
    201          }
    202          
    203          /**
    204          @brief Возвращает время сети 
    205          @return Время сети в тиках
    206          */
    207          uint16_t NT_GetTime(void)
    208          {
    209            uint32_t val = ReadTimer();
    210            // TOFFSET = NETWORK TIME - TIMER
    211            // NETWORK TIME = TIMER + TOFFSET
    212            val +=TOFFSET;
    213            val &= 0x7FFF; // Приводим значения таймера к 0-32767
    214            return val;
    215          }
    216          
    217          /**
    218          @brief Обработчик прерывания таймера сна
    219          */
    220          #pragma vector=ST_VECTOR
    221          __interrupt void TimerCompareInterrupt(void)
    222          {  
    223            uint16_t ticks = NT_GetTime();
    224            if (EventCallback == NULL)
    225              return;
    226            // Отключаем прерывание таймера. Забота пользователя его включить
    227            NT_IRQEnable(false); 
    228            EventCallback(ticks); // Вызываем пользовательский обработчик
    229            STIF = 0; // Очищаем флаг прерывания
    230          }
    231          
    232          /**
    233          @breif Ожидание наступления времени сети
    234          @param[in] ticks время в тактах
    235          @return фактическое время сети
    236          */
    237          uint16_t NT_WaitTime(uint16_t ticks)
    238          {
    239            static union 
    240            {
    241              uint32_t val;
    242              uint8_t fild[4];
    243            } val;
    244            
    245            val.val = 0;
    246            // TOFFSET = NETWORK TIME - TIMER
    247            // NETWORK TIME = TIMER + TOFFSET
    248            
    249            // Ждем синхронизацию таймера после пробуждения
    250            while (!(SLEEPSTA & 0x01));
    251            
    252            do
    253            {
    254              // Соблюдаем порядок чтения регисторов ST  
    255              val.fild[0] = ST0;
    256              val.fild[1] = ST1;
    257              val.fild[2] = ST2;
    258              val.val +=TOFFSET;
    259              val.val &= 0x7FFF; // Приводим значения таймера к 0-32767    
    260            } while (val.val < ticks);
    261            return val.val;
    262          }
    263          
    264          /**
    265          @brief Возвращает текущее значение таймера
    266          @return Текущие ticks
    267          */
    268          static uint32_t ReadTimer(void)
    269          {
    270            static union 
    271            {
    272              uint32_t val;
    273              uint8_t fild[4];
    274            } ret_val;
    275            
    276            ret_val.val = 0;
    277            
    278            // Ждем синхронизацию таймера после пробуждения
    279            while (!(SLEEPSTA & 0x01));
    280            
    281            // Соблюдаем порядок чтения регисторов ST  
    282            ret_val.fild[0] = ST0;
    283            ret_val.fild[1] = ST1;
    284            ret_val.fild[2] = ST2;
    285            return ret_val.val;
    286          }
    287          
    288          /**
    289          @brief Устанавливает время пробуждения микроконтролера
    290          @params[in] ticks 24 битное значение времени пробуждения в ticks
    291          */
    292          static void loadTimerCompare(uint32_t ticks)
    293          {
    294            union 
    295            {
    296              uint32_t val;
    297              uint8_t fild[4];
    298            } value;
    299            
    300            value.val = ticks;
    301            
    302            // Ждем разрешения на запись нового значения
    303            while (!(STLOAD & 0x01));
    304            
    305            // Регистр ST0 должен быть записан в последнию очередь
    306            ST2 = value.fild[2];
    307            ST1 = value.fild[1];
    308            ST0 = value.fild[0];
    309          }
\\vmware-host\Shared Folders\Projects\WMNU\IAR\SHARE_PRJ_SRC\nwdebuger.c
      1          #include "nwdebuger.h"
      2          #include "ioCC2530.h"
      3          #include "stdint.h"
      4          #include "stdio.h"
      5          
      6          // Настройка порта uart для отладки
      7          static void uart_init(void)
      8          {
      9            // Выбор расположения UART на выводах
     10            uint8_t U0CFG = 0; // 0={TX=P0_3, RX=P0_2
     11            PERCFG |= (U0CFG<<0); 
     12            
     13            // U0UCR регистр настройки режима uart. меня устраивает по умолчанию
     14            U0CSR = (1<<7); // Выбираем режим uart 
     15            
     16            // Настройка скорости передачи данных на 2М  
     17            U0BAUD = 0;  // табличные значения из pdf
     18            U0GCR =  16;
     19            
     20            // Включаем альтернативные функции выводов
     21            P0SEL = (1<<2)|(1<<3);
     22          }
     23          
     24          static void SetCPU32M(void)
     25          {
     26            CLKCONCMD = 0x88;
     27            while (CLKCONSTA&(1<<6));
     28          }
     29          
     30          void nwDebugerInit(void)
     31          {
     32           // SetCPU32M();
     33          #ifdef UART_DEBUG
     34            uart_init();
     35          #endif
     36          }
     37          
     38          __attribute__((weak)) void STACK_FAILURE(char* msg)
     39          {
     40            LOG_ON("STACK FAILURE. HALT");
     41            while(1);
     42          }
     43          
     44          // Переопределяем функцию записи в порт
     45          #ifdef UART_DEBUG
     46          #include <yfuns.h>
     47          
     48          _STD_BEGIN
     49          
     50          #pragma module_name = "?__write"
     51          
     52          int MyLowLevelPutchar(int x);
     53          
     54          int MyLowLevelPutchar(int x){
     55            while( U0CSR&(1<<0));
     56            U0DBUF = x;
     57            return x;
     58          }
     59          /*
     60           * If the __write implementation uses internal buffering, uncomment
     61           * the following line to ensure that we are called with "buffer" as 0
     62           * (i.e. flush) when the application terminates.
     63           */
     64          
     65          size_t __write(int handle, const unsigned char * buffer, size_t size)
     66          {
     67            /* Remove the #if #endif pair to enable the implementation */
     68             
     69          
     70            size_t nChars = 0;
     71          
     72            if (buffer == 0)
     73            {
     74              /*
     75               * This means that we should flush internal buffers.  Since we
     76               * don't we just return.  (Remember, "handle" == -1 means that all
     77               * handles should be flushed.)
     78               */
     79              return 0;
     80            }
     81          
     82            /* This template only writes to "standard out" and "standard err",
     83             * for all other file handles it returns failure. */
     84            if (handle != _LLIO_STDOUT && handle != _LLIO_STDERR)
     85            {
     86              return _LLIO_ERROR;
     87            }
     88          
     89            for (/* Empty */; size != 0; --size)
     90            {
     91              if (MyLowLevelPutchar(*buffer++) < 0)
     92              {
     93                return _LLIO_ERROR;
     94              }
     95          
     96              ++nChars;
     97            }
     98          
     99            return nChars;
    100          
    101          }
    102          
    103          _STD_END
    104          #endif
\\vmware-host\Shared Folders\Projects\WMNU\IAR\SHARE_PRJ_SRC\RADIO.c
      1          /*!
      2          \file 
      3          \brief Модуль содержит реализацию интерфейса радио для приема/передачи данных.
      4          */
      5          
      6          #include "RADIO.h"
      7          #include "mem.h"
      8          #include "nwdebuger.h"
      9          #include "Radio_defs.h"
     10          #include "TIC.h"
     11          #include "delays.h"
     12          #include "frame.h"
     13          #include "string.h"
     14          #include "NTMR.h"
     15          
     16          // Открытые методы модуля
     17          void RI_init(void);
     18          bool RI_SetChannel(uint8_t CH);
     19          bool RI_Send(frame_s *fr);
     20          frame_s* RI_Receive(uint16_t timeout);
     21          uint32_t RI_GetCRCError(void);
     22          uint32_t RI_GetCCAReject(void);
     23          float RI_GetUptime(void);
     24          
     25          // Приватные методы
     26          static void random_core_init(void);
     27          static void RI_cfg(void);
     28          
     29          static inline void setFreq(uint8_t CH); // Установка частоты передатчика
     30          static void LoadTXData(uint8_t *src, uint8_t len); // Загрузка данных в tx buf
     31          static void UnLoadRXData(uint8_t *src, uint8_t len);
     32          static bool SendData(frame_s *fc);
     33          static bool RecvData(uint32_t timeout_us, uint16_t *SFD_TimeStamp);
     34          
     35          // Переменные модуля
     36          static float RI_UPTIME = 0; // Время работы радио в мс. 49 дней максимум
     37          static uint32_t RI_CRC_ERROR = 0; // Количество ошибок CRC
     38          static uint32_t RI_CCA_REJECT = 0; // Количество отказов передач из-за CCA
     39          
     40          /*!
     41          \brief Константы для установки выходной мощности радиопередатчика.
     42          Пример: p4x5 = +4,5 дБ. m0x5 = -0.5 дБ
     43          */
     44          enum TX_POWER_e 
     45          {
     46            // +4.5дБ = p4x5, -1.5дБ = m1x5.
     47            // +4.5 = 34мА, +1 = 29мА, -4 = 26мА, -10 = 25 мА, -22 = 23 мА
     48            p4x5 = 0xF5, p2x5 = 0xE5, p1x0 = 0xD5, m0x5 = 0xC5, m1x5 = 0xB5, m3x0 = 0xA5,
     49            m4x0 = 0x95, m6x0 = 0x85, m8x0 = 0x75, m10x0 = 0x65, m12x0 = 0x55, 
     50            m14x0 = 0x45, m16x0 = 0x35, m20x0 = 0x15, m22x0 = 0x05
     51          };
     52          
     53          
     54          #define IEEE_MODE 0     //!< Режимы фазы сигнала
     55          #define NOT_IEEE_MODE 1 //!< Режимы фазы сигнала
     56          #define RSSI_OFFSET -76 //!< Константа для вычисления реальной мощности
     57          
     58          /*!
     59          \details 
     60           Расчет качества связи. Коэффициенты получаются эксперементально.
     61           Есть предположение, что количество ошибок будет пропорционально квадрату
     62           коеффициента корреляции сигнала.
     63           LIQ = 255 передача 1000 пакетов без ошибок CRC
     64           LIQ = 127 передача 1000 пакетов с 50% ошибок CRC
     65           LIQ = 0   передача 1000 пакетов с 100% ошибок CRC
     66          */ 
     67          #define CONST_A (int8_t)0 //!< Коэффициент A
     68          #define CONST_B (int8_t)1 //!< Коэффициент B
     69          #define LIQ_CALC(corr) ((corr-CONST_A)*CONST_B) //!< Формула вычисление LIQ 
     70          #define FRQ_CALC(x) (11+5*(x-11)) //!< Формул вычисления частоты сигнала
     71          
     72          /// Глобальные параметры модуля
     73          struct
     74          {
     75            uint8_t CH;       //!< Номер канала с 11 до 28 включительно
     76            uint8_t TX_POWER; //!< Мощность радиопередатчика по умолчанию. 7 бит
     77            bool MODULATION_MODE; //!< false - совместимость с IEEE 802.15.4
     78          } RADIO_CFG;
     79          
     80          /*!
     81          \brief Иницилизация радио интерфейса
     82          */
     83          void RI_init(void)
     84          {
     85            // Настройки поумолчанию
     86            RADIO_CFG.CH = CH11;
     87            RADIO_CFG.TX_POWER = m0x5;
     88            RADIO_CFG.MODULATION_MODE = IEEE_MODE;
     89            // Пост действия с радио
     90            random_core_init();
     91          }
     92          
     93          /*!
     94          \brief Переводит радио в активный режим и устанавливает параметры.
     95          */
     96          static void RI_cfg(void)
     97          {
     98          /*
     99          APPEND_DATA_MODE = 0. FCS1 = signed rssi, FCS2.7 CRC OK, FCS2.6-0 Correlation
    100          A correlation value of ~110 indicates a maximum quality frame while a value 
    101          of ~50 is typically the lowest quality frames detectable by CC2520. 
    102          */
    103          /* После включения радио находится в активном режиме но приемник выключен */
    104            
    105            // Устанавливаем частоту радиопередатчика
    106            setFreq(RADIO_CFG.CH);
    107            
    108            // Устанавливаем мощность выходного сигнала
    109            TXPOWER = RADIO_CFG.TX_POWER;
    110           
    111            FRMFILT0 = 0x00; // Отключаем фильтрацию пакетов
    112            
    113            // Устанавливаем режим модуляции
    114            MDMTEST1_u MDM1;
    115            MDM1.value = MDMTEST1;
    116            MDM1.bits.MODULATION_MODE = RADIO_CFG.MODULATION_MODE;
    117            MDMTEST1 = MDM1.value; 
    118          }
    119          
    120          /*!
    121          \brief Устанавливает канал радиопередатчика.
    122          \param[in] CH Номера каналов [11..28]
    123          \return Возвращает true если аргументы верны
    124          */
    125          bool RI_SetChannel(uint8_t CH)
    126          {
    127            if ((CH >=11) && (CH<=28))
    128            {
    129              RADIO_CFG.CH = CH;
    130              return true;
    131            }
    132            return false;
    133          }
    134          
    135          /*!
    136          \brief Передает данные в эфир
    137          \details Увеличивает  RI_CCA_REJECT при невозможности отправки сообщения, расчитывает время работы 
    138           радио передатчика. Отправка сообщения в заданное сетевое время 
    139           fr->meta.SEND_TIME. Если равно 0, то отправка через случайноу время в мкс.
    140           Данные автоматически оборачиваются в LEN, CRC1,CRC2
    141          \param[in] *fr Указатель на структуру frame_s RAW_LAY
    142          \return Возвращает true в случаи успешной передачи
    143          */
    144          bool RI_Send(frame_s *fr)
    145          {
    146            ASSERT(fr != NULL);
    147            
    148            // Устанавливаем частоту передачи пакета
    149            RI_cfg();
    150            
    151            bool send_res; // Результат передачи данных
    152            TimeStamp_s start,stop; // Измерение времени
    153            
    154            TIM_TimeStamp(&start); // Начало измерения времени
    155            send_res = SendData(fr);
    156            TIM_TimeStamp(&stop); // Конец измерения времени
    157            
    158            uint32_t passed = TIM_passedTime(&start, &stop);
    159            RI_UPTIME += (float)passed/1000; // Микросекунды в милисекунды
    160            
    161            // В случаи ошибки передачи увеличиваем счетчик RI_CCA_REJECT
    162            if (!send_res)
    163              RI_CCA_REJECT++;
    164            
    165            return send_res;
    166          }
    167          
    168          /**
    169          @brief Отправка сообщения
    170          @detail Время отправки с шифрованием 10 байт в мкс. Merge = 155, Crypt = 239,
    171           Load TX = 30, RSSI_OK = 328, ISTXON = 11, SFD(192us+5*8*4us) = 400, TX = 370, Full = 1535.
    172          Время работы радио RSSI_OK+ISTXON+SFD+TX = 1109 us
    173          @return true в случаи успеха
    174          */
    175          static bool SendData(frame_s *fr)
    176          {
    177          ////TimeStamp_s ts_start, ts_frame_merge, ts_crypt, ts_load_tx, 
    178          ////ts_rssistat, ts_istxon, ts_sfd, ts_stop;
    179            
    180          ////TIM_TimeStamp(&ts_start);  
    181                
    182          ////TIM_TimeStamp(&ts_frame_merge);  
    183            bool result = true;
    184            switch(true)
    185            {
    186              case true:
    187          ////TIM_TimeStamp(&ts_crypt); 
    188                // Копируем данные в буфер. Очистка буфера автоматическая
    189                LoadTXData(fr->payload, fr->len);
    190          ////TIM_TimeStamp(&ts_load_tx); 
    191                // Для начала передачи по команде STXONCCA нужно включить приемник
    192                ISRXON();
    193                // Ждем пока статус RSSI_VALID станет true
    194                while(!RSSISTAT);
    195          ////TIM_TimeStamp(&ts_rssistat); 
    196                // Очищаем флаг завершения передачи сообщения
    197                RFIRQF1 &= ~RFIRQF1_TXDONE;
    198                RFIRQF0 &= ~RFIRQF0_SFD;
    199                
    200                // Время отправки сообщения измеряется в тактах сетевого времени NTMR
    201                // Он работатаеи намного лучше чем MAC таймер(меньше погрешность)
    202                // Отправка в обозначенное время или по факту готовности
    203                //13 - поправка в тактах сети на передачу преамболы
    204                uint16_t timer = 0; // Для отлалки. 
                                ^
Warning[Pe550]: variable "timer" was set but never used
          detected during compilation of secondary translation unit
                    "\\vmware-host\Shared
                    Folders\Projects\WMNU\IAR\SHARE_PRJ_SRC\RADIO.c"

  static bool slave_mode()
              ^
"\\vmware-host\Shared Folders\Projects\WMNU\IAR\SHARE_PRJ_SRC\manager.c",102  Warning[Pe177]: 
          function "slave_mode" was declared but never referenced
          detected during compilation of secondary translation unit
                    "\\vmware-host\Shared
                    Folders\Projects\WMNU\IAR\SHARE_PRJ_SRC\manager.c"

  static void SetCPU32M(void)
              ^
"\\vmware-host\Shared Folders\Projects\WMNU\IAR\SHARE_PRJ_SRC\nwdebuger.c",24  Warning[Pe177]: 
          function "SetCPU32M" was declared but never referenced
          detected during compilation of secondary translation unit
                    "\\vmware-host\Shared
                    Folders\Projects\WMNU\IAR\SHARE_PRJ_SRC\nwdebuger.c"
    205                if (fr->meta.SEND_TIME != 0)
    206                  timer = NT_WaitTime(fr->meta.SEND_TIME - 13); 
    207          
    208                // Начинаем передачу данных
    209                // Transmission of preamble begins 192 μs after the STXON or STXONCCA 
    210                // command strobe
    211                // 192+(4(pream)+1(sfd))*8bit*4us = 352 мкс. Измерил 360мкс
    212                // Измерил в тактах NT_GetTimer() получилось 13 тиков. 396 мкс 
    213                ISTXONCCA();
    214          ////TIM_TimeStamp(&ts_istxon); 
    215                // Произошла ошибка передачи если SAMPLED_CCA false
    216                if (!(FSMSTAT1 & 1<<3)) //SAMPLED_CCA == 0
    217                {
    218                  result = false;
    219                  break;
    220                }
    221          
    222                // Ждем завершения отправки SFD
    223                while (!(RFIRQF0 & RFIRQF0_SFD));
    224                fr->meta.TIMESTAMP = NT_GetTime(); 
    225          ////TIM_TimeStamp(&ts_sfd); 
    226                // Проверим переданно ли сообщение TX_FRM_DONE
    227                while (!(RFIRQF1 & RFIRQF1_TXDONE));
    228                break;
    229            }
    230          ////TIM_TimeStamp(&ts_stop);
    231            
    232            ISRFOFF();
    233          ////  LOG(MSG_ON | MSG_INFO | MSG_TRACE, 
    234          ////"Merge = %lu. Crypt = %lu. Load TX = %lu. RSSI_OK = %lu. ISTXON = %lu. SFD = %lu. TX = %lu. FULL = %lu \n", 
    235          ////      TIM_passedTime(&ts_start, &ts_frame_merge),
    236          ////      TIM_passedTime(&ts_frame_merge, &ts_crypt),
    237          ////      TIM_passedTime(&ts_crypt, &ts_load_tx),
    238          ////      TIM_passedTime(&ts_load_tx, &ts_rssistat),
    239          ////      TIM_passedTime(&ts_rssistat, &ts_istxon),
    240          ////      TIM_passedTime(&ts_istxon, &ts_sfd),
    241          ////      TIM_passedTime(&ts_sfd, &ts_stop),
    242          ////      TIM_passedTime(&ts_start, &ts_stop)
    243          ////      );
    244            
    245            if (result)
    246              return true;
    247            return false; 
    248          }
    249          
    250          /**
    251          @brief Загрузка данных для передачи в буфер. 
    252          @detail Поля LEN, FCS1, FCS2 добавляются автоматически
    253          @param[in] src указатель на данные
    254          @param[in] len размер данных
    255          */
    256          static void LoadTXData(uint8_t *src, uint8_t len)
    257          {
    258            // Очищаем буфер передатчика
    259            ISFLUSHTX(); 
    260            // Поле LEN на два байта больше
    261            RFD = len + 2;
    262            
    263            for (uint8_t i = 0 ; i < len; i++)
    264              RFD = src[i];
    265            
    266            // Добавляем CRC1,2
    267            RFD = 0x00;
    268            RFD = 0x00;
    269          };
    270          
    271          /**
    272          @brief Выгружаем принятый пакет из радио
    273          @param[out] src указатель на буфер приемника
    274          @param[in] len размер выгружаемых данных
    275          */
    276          static void UnLoadRXData(uint8_t *src, uint8_t len)
    277          {
    278            for (uint8_t i = 0 ; i < len; i++)
    279              src[i] = RFD;
    280          };
    281          
    282          static inline void setFreq(uint8_t CH)
    283          {
    284            ASSERT( (CH >= 11) && (CH <= 28));
    285            // Устанавливаем частоту радиопередатчика
    286            FREQCTRL_u FRQ;
    287            FRQ.value = FRQ_CALC(RADIO_CFG.CH);
    288            FREQCTRL = FRQ.value;  
    289          }
    290          
    291          /*!
    292          \brief Принимает данные из эфира
    293          \details Функция принимает данные из эфира. Проводит проверку CRC, увеличивает
    294          RI_CRC_ERROR. Отмечает время прихода SFD в тактах сетевого времени .
    295          \param[in] timeout Время ожидания данных в милисекундах
    296          \return Возвращает NULL если данных нет
    297          */
    298          frame_s* RI_Receive(uint16_t timeout)
    299          {
    300            // Устанавливаем частоту передачи пакета
    301            RI_cfg();
    302            uint16_t SFD_TimeStamp;
    303            
    304            // Принимаем пакет 
    305            uint32_t timeout_us = timeout*1000UL; // Переводим мс->мкс
    306            TimeStamp_s start,stop; // Измерение времени
    307            TIM_TimeStamp(&start); // Начало измерения времени работы радио
    308            bool recv_res = RecvData(timeout_us, &SFD_TimeStamp);
    309            TIM_TimeStamp(&stop); // Конец измерения времени радио
    310            uint32_t passed = TIM_passedTime(&start, &stop);
    311            RI_UPTIME += (float)passed/(float)1000; // Микросекунды в милисекунды
    312            
    313            // Если ничего не приняли возвращаем NULL
    314            if (!recv_res)
    315              return NULL;
    316            
    317            uint8_t frame_size = RXFIFOCNT; // Количество принятых данных
    318            
    319            // Минимальный размер FCS1,FCS2 - 2 байта. LEN не включен в подсчет 
    320            if (frame_size <= 2)
    321              return NULL;
    322            
    323            // Выгружаем данные из приемника
    324            uint8_t *frame_raw = re_malloc(frame_size); 
    325            UnLoadRXData(frame_raw, frame_size);
    326            
    327            int8_t  FCS1 = frame_raw[frame_size - 2]; // RSSI
    328            uint8_t FCS2 = frame_raw[frame_size - 1]; // bit7 = CRCOK, bit[6..0] Corr_val
    329            uint8_t LEN_F = frame_raw[0]; // Поле LEN
    330            
    331            // Проверим поле LEN. Размер данных в заголовке должен совпадать
    332            // с фактической длинной принятых данных
    333            if (LEN_F != frame_size - 1)
    334            {
    335              re_free(frame_raw);
    336              RI_CRC_ERROR ++;
    337              return NULL;
    338            }
    339            
    340            // Проверим поле CRCOK
    341            if (!(FCS2 && 1<<7))
    342            {
    343              re_free(frame_raw);
    344              RI_CRC_ERROR ++;
    345              return NULL;
    346            }
    347            
    348            // Создаем буфер, последнии два байта FCS1,2 и поле LEN не копируем
    349            frame_s *raw_frame = frame_create();
    350            frame_addHeader(raw_frame, &frame_raw[1], frame_size - 3);
    351            
    352            // Копируем метку времени SFD
    353            raw_frame->meta.TIMESTAMP = SFD_TimeStamp;
    354            
    355            // Расчитываем мощность принятого сигнала
    356            raw_frame->meta.RSSI_SIG =  FCS1 + RSSI_OFFSET;
    357            // Расчитываем качество сигнала
    358            uint8_t corr = FCS2 & 0x7F;
    359            raw_frame->meta.LIQ = LIQ_CALC(corr); // Значение коэфф. корреляции
    360          
    361            raw_frame->meta.CH = RADIO_CFG.CH;
    362          
    363            re_free(frame_raw);
    364            return raw_frame;
    365          }
    366          
    367          /**
    368          @brief Прием данных из эфира
    369          @param[in] timeout_us время ожидания в микросекундах
    370          @param[out] SFD_TimeStamp отметка времени завершения приема SFD
    371          */
    372          static bool RecvData(uint32_t timeout_us, uint16_t *SFD_TimeStamp)
    373          {
    374            TimeStamp_s start,stop; // Измерение времени  
    375            ISFLUSHRX(); // Очищаем буфер приема
    376            
    377            TIM_TimeStamp(&start);
    378            
    379            // Очищаем флаг завершения передачи сообщения и приема SFD
    380            RFIRQF0 &= ~RFIRQF0_RXPKTDONE;  
    381            RFIRQF0 &= ~RFIRQF0_SFD; 
    382            ISRXON(); // Включаем радиопередатчик
    383          
    384            bool time_out = false; // Истекло время ожидания пакета
    385            bool packet_received = false; // Приняли пакет
    386            bool sfd_received = false; // Приняли sfd
    387            
    388            // Цикл приема пакета
    389            while (true)
    390            {
    391              TIM_TimeStamp(&stop);
    392              if (TIM_passedTime(&start, &stop) >= timeout_us)
    393              {
    394                time_out = true;
    395                break;
    396              }
    397             
    398              // Принят сигнал SFD
    399              if ((RFIRQF0 & RFIRQF0_SFD))
    400              {
    401                *SFD_TimeStamp = NT_GetTime(); 
    402                sfd_received = true;
    403              }
    404              
    405              //  Завершен ли прием сообщения RX_FRM_DONE (RXPKTDONE)
    406              if ((RFIRQF0 & RFIRQF0_RXPKTDONE))
    407              {
    408                packet_received = true;
    409                break;
    410              }
    411            } // while 
    412            
    413            ISRFOFF();
    414            if (packet_received && sfd_received && !time_out)
    415              return true;
    416            else
    417              return false;
    418          }
    419          
    420          /*!
    421          \brief Возвращает количество ошибок возникших с момента иницилизации
    422          \return Количество CRC ошибок
    423          */
    424          uint32_t RI_GetCRCError(void)
    425          {
    426            return RI_CRC_ERROR;
    427          }
    428          
    429          /*!
    430          \brief Возвращает количестов отказов передачи пакета из-за занятости канала.
    431          \return Количество отказов CCA
    432          */
    433          uint32_t RI_GetCCAReject(void)
    434          {
    435            return RI_CCA_REJECT;
    436          }
    437          
    438          /*!
    439          \brief Возвращает суммарное время работы радио в режиме прием/передача
    440          \return Вермя в милисекундах
    441          */
    442          float RI_GetUptime(void)
    443          {
    444            return RI_UPTIME;
    445          }
    446          
    447          /**
    448          @breif Подссчет количества бит в байте
    449          @return Возвращает количество бит
    450          */
    451          static uint8_t bits_count(uint8_t value) {
    452            int ret = 0;
    453            for ( ; value; value = value >> 1 )
    454              ret += value & 1;
    455            return ret;
    456          }
    457          
    458          /**
    459          @brief Возращает 1 байт случайного числа
    460          @details Радио выдает всего лишь дви бита, нам нужно 8 
    461          */
    462          static inline uint8_t getRNDByte(void)
    463          {
    464            uint8_t val = 0;
    465            val |= RFRND << 0;
    466            val |= RFRND << 2;
    467            val |= RFRND << 4;
    468            val |= RFRND << 6;
    469            return val;
    470          }
    471          
    472          /**
    473          @brief Возвращает случайное число с числом включеных бит от 2 до 6 включительно
    474          @details Случайные числа появляются в регистре с частотой 170нс. Функция 
    475          возвращает гарантированно новое значение. 
    476          @return возвращает случайное число.
    477          */
    478          static inline uint8_t readRandom(void)
    479          {
    480            uint8_t rnd_val = 0;
    481            uint8_t bit_cnt = 0;
    482            while ( bit_cnt <= 2 || bit_cnt >= 6 )
    483            {
    484              rnd_val = getRNDByte();
    485              while (rnd_val == getRNDByte());
    486              rnd_val = getRNDByte();
    487              bit_cnt = bits_count(rnd_val);
    488            }
    489            return rnd_val;
    490          }
    491          
    492          /*!
    493          \brief Иницилизирует ядро генератора случайных чисел данными из эфира
    494          */
    495          static void random_core_init(void)  
    496          {
    497            unsigned int rnd_core = 0;;
    498               
    499            RI_cfg();
    500            FREQCTRL = 0x00; // Выбираем не используемую частоту
    501          
    502            // TODO По какой то причине OP_EXE не выполняет команду.
    503            // регистра RFST читается как 0xD0. это его состояние при reset
    504            // Включаем демодулятор
    505            ISRXON();
    506            
    507            // Ждем пока статус RSSI_VALID станет true
    508            while(!RSSISTAT);
    509            
    510            // Ждем случайных чисел
    511            while (RFRND == 0);
    512            
    513            // Настраиваем ядро случайного генератора
    514            rnd_core = readRandom();
    515            rnd_core |= (unsigned int)readRandom()<<8;
    516            srand(rnd_core);
    517            
    518            // Включаем демодулятор
    519            ISRFOFF();
    520            // Первая генерация случайного числа занимает много времени.
    521            // Влияло на работу радио, так как использовались случайные посылки
    522            rand(); 
    523          }
    524          
\\vmware-host\Shared Folders\Projects\WMNU\IAR\SHARE_PRJ_SRC\sync.c
      1          #include "stdlib.h"
      2          #include "basic.h"
      3          #include "frame.h"
      4          #include "string.h"
      5          #include "nwdebuger.h"
      6          #include "coder.h"
      7          #include "TIC.h"
      8          #include "RADIO.h"
      9          #include "NTMR.h"
     10          #include "config.h"
     11          #include "ioCC2530.h" // ОТЛАДДКА
     12          
     13          void SY_Init(void);
     14          void SY_Reset(void);
     15          void SY_setIV(void* ptr_IV);
     16          void SY_setKEY(void* ptr_KEY);
     17          bool SY_SYNC_NETWORK(uint16_t *panid,uint16_t timeout);
     18          void SY_Enable(bool en);
     19          uint32_t SY_sync_sended(void);
     20          
     21          static void SY_TS1_HNDL_MASTER(void);
     22          static void SY_TS1_HNDL_SLAVE(void);
     23          static void SY_TIME_ALLOC_SLAVE(void);
     24          static void SY_TIME_ALLOC_MASTER(void);
     25          static void BitRawDecrypt(uint8_t *src, uint8_t size);
     26          static void BitRawCrypt(uint8_t *src, uint8_t size);
     27          static frame_s* get_sync(uint16_t timeout);
     28          static bool send_sync(void);
     29          
     30          static uint32_t LAST_SYNC_TIME = 0; //!< Время последней синхр.
     31          static uint32_t NEXT_SYNC_TIME = 0; //!< Время следующей синхр.
     32          static uint32_t SYNC_SENDED = 0; //!< Количество успешно ретранслированых пакетов
     33          static bool NEED_SEND_SYNC = false; //!< Нужно отослать синхропакет
     34          static bool SY_ENABLE_MODULE = false;
     35          
     36          // Ключ потокового шифрования и вектор иницилизации
     37          static uint8_t KEY[16] = DEFAULT_KEY;
     38          static uint8_t IV[16] = DEFAULT_IV;
     39          //@brief Точное время приема/передачи пакета синхронизации времени
     40          // Расчитывается при иницилизации
     41          static uint16_t SYNC_ACCURATE_NETWORK_TIME; 
     42          
     43          #define SYNC_TS 1 //!< Номер временного слота синхросигнала
     44          #define SYNC_RECV_TIMEOUT 2 // Время ожидания приема пакета в мс
     45          #define SYNC_TIMEOUT 110//!< Время в сек после которого сеть не синхронна
     46          
     47          typedef struct // Формат структуры пакета синхронизации
     48          {
     49              uint16_t panid;
     50              uint32_t rtc;
     51              uint32_t magic;
     52          } __attribute__((packed)) SYNC_s;
     53          
     54          #define MAGIC 0x19833891 // Проверка что пакет действительно sync
     55          #define RAND_SYNC_RX_DELAY  9 // Фиксированое время приема rand()%10 + 5
     56          #define RAND_SYNC_TX_DELAY  10 // Фиксированное время передачи сигнала
     57          // Максимальное отклонение при приеме sync в тактах сети
     58          #define SYNC_TIME_DRIFT 35  
     59          
     60          #ifdef GATEWAY
     61            #define SYNC_MASTER     // Если определено, то узел является шлюзом
     62          #endif
     63          
     64          void SY_Init(void)
     65          {
     66            SYNC_SENDED = 0;
     67            LAST_SYNC_TIME = 0;
     68            NEXT_SYNC_TIME = 0;
     69            SY_ENABLE_MODULE = false;
     70            SYNC_ACCURATE_NETWORK_TIME = TIC_SlotTime(SYNC_TS) + TIC_SlotActivityTime()/2;
     71          #ifdef SYNC_MASTER
     72            TIC_SetTS1Callback(SY_TS1_HNDL_MASTER);
     73            TIC_SetSyncTimeAllocCallback(SY_TIME_ALLOC_MASTER);
     74          #else
     75            TIC_SetTS1Callback(SY_TS1_HNDL_SLAVE);
     76            TIC_SetSyncTimeAllocCallback(SY_TIME_ALLOC_SLAVE);
     77          #endif
     78          }
     79          
     80          void SY_Reset(void)
     81          {
     82            SYNC_SENDED = 0;
     83            LAST_SYNC_TIME = 0;
     84            NEXT_SYNC_TIME = 0;
     85            SY_ENABLE_MODULE = false;
     86          }
     87          
     88          void SY_Enable(bool en)
     89          {
     90            SY_ENABLE_MODULE = en;
     91          }
     92          
     93          /**
     94          @brief Количество успешно переданных пакетов синхронизации
     95          @return Количечтво пакетов
     96          */
     97          uint32_t SY_sync_sended(void)
     98          {
     99            return SYNC_SENDED;
    100          }
    101          
    102          /**
    103          @brief Установить вектор иницилизации для шифрования
    104          @param[in] ptr_IV указатель на 16 байтный вектор иницилизации
    105          */
    106          void SY_setIV(void* ptr_IV)
    107          {
    108            memcpy(IV, ptr_IV, 16);
    109          }
    110          
    111          /**
    112          @brief Установить ключ шифрования
    113          @param[in] ptr_KEY указатель на 16 байтный ключ
    114          */
    115          void SY_setKEY(void* ptr_KEY)
    116          {
    117            memcpy(KEY, ptr_KEY, 16);
    118          }
    119          
    120          /**
    121          @brief Функция вызывается после каждого завершенного слота времени
    122          @detail Детектирует потерю синхронизации, активирует процесс синхронизации
    123           активирует слот для ретрансляцию сигнала
    124          */
    125          static void SY_TIME_ALLOC_SLAVE(void)
    126          { 
    127            if (!SY_ENABLE_MODULE) // Модуль отключен
    128              return;  
    129            
    130            // Потеря синхронизации
    131            if ( (TIC_GetUptime() - LAST_SYNC_TIME) > SYNC_TIMEOUT)
    132            {
    133                LOG_ON("Network out of sync.");
    134                return;
    135            }
    136            
    137            if (TIC_GetRXState(SYNC_TS)) // Если прием уже активен
    138              return;
    139            
    140            // Ретрансляция синхропакета
    141            if (NEED_SEND_SYNC)
    142            {
    143              LOG_OFF("Need to send resync");
    144              TIC_SetRXState(SYNC_TS, true);
    145              return;
    146            }
    147            
    148            // Необходимо начать процесс синхронизации
    149            if (TIC_GetUptime() > NEXT_SYNC_TIME)
    150            {
    151              LOG_ON("Begin resync");
    152              P1_0 = !true; 
    153              TIC_SetRXState(SYNC_TS, true);
    154            }
    155          }
    156          
    157          /**
    158          @brief Функция вызывается после каждого завершенного слота времени
    159          @detail Запускает процесс передачи синхросигнала в равные промежутки времени
    160          */
    161          static void SY_TIME_ALLOC_MASTER(void)
    162          { 
    163            static uint32_t sync_send_time = 0;
    164           
    165            if (!SY_ENABLE_MODULE) // Модуль отключен
    166            {
    167              sync_send_time = 0;
    168              return;  
    169            }
    170            
    171            if (TIC_GetTXState(SYNC_TS)) // Если передача уже активна.
    172              return;
    173            
    174            uint32_t now = TIC_GetUptime();
    175            if ( now < sync_send_time) // Если время новой передачи не наступило
    176              return;
    177            
    178            TIC_SetTXState(SYNC_TS,true); // Разрешаем передачу
    179             
    180             // Определяем следующее время передачи
    181             sync_send_time = now + RAND_SYNC_TX_DELAY;
    182          }
    183          
    184          /**
    185          @brief Вызывает при активности TS1 RX или TX
    186          @detail Выполняет две функции: синхронизацию с сетью или передачу синхр.
    187          */
    188          static void SY_TS1_HNDL_SLAVE(void)
                             ^
Warning[Pe177]: function "SY_TS1_HNDL_SLAVE" was declared but never referenced
          detected during compilation of secondary translation unit
                    "\\vmware-host\Shared
                    Folders\Projects\WMNU\IAR\SHARE_PRJ_SRC\sync.c"

  static void SY_TIME_ALLOC_SLAVE(void)
              ^
"\\vmware-host\Shared Folders\Projects\WMNU\IAR\SHARE_PRJ_SRC\sync.c",125  Warning[Pe177]: 
          function "SY_TIME_ALLOC_SLAVE" was declared but never referenced
          detected during compilation of secondary translation unit
                    "\\vmware-host\Shared
                    Folders\Projects\WMNU\IAR\SHARE_PRJ_SRC\sync.c"
    189          {
    190            if (!SY_ENABLE_MODULE) // Модуль отключен
    191              return;
    192              
    193            // Нужно отослать синхропакет
    194            if (NEED_SEND_SYNC)
    195            {
    196              if (send_sync())
    197                SYNC_SENDED++;
    198              LOG_ON("Resync TX. CNT=%d",(uint16_t)SYNC_SENDED);
    199              NEED_SEND_SYNC = false;
    200              TIC_SetRXState(SYNC_TS, false);
    201            }
    202            
    203            // Ждем начала точного времени начала передачи сигнала заранее
    204            // Время в тактах сети
    205            NT_WaitTime(SYNC_ACCURATE_NETWORK_TIME - SYNC_TIME_DRIFT);
    206           
    207            // Время в мс
    208            frame_s *fr_SYNC = get_sync(SYNC_RECV_TIMEOUT); 
    209            
    210            if (!fr_SYNC)
    211              return;
    212            
    213            SYNC_s *sync;
    214            sync = (SYNC_s*)fr_SYNC->payload;
    215            
    216            // Проверяем принадлежность пакета
    217            if (( sync->panid != CONFIG.panid) && (sync->magic != MAGIC))
    218            {
    219              frame_delete(fr_SYNC);
    220              return;
    221            }
    222            
    223            // Синхронизируемся
    224            // Время прошедшее с момента приема пакета в тактах сети
    225            uint16_t delta = TIC_GetTimer() - fr_SYNC->meta.TIMESTAMP;
    226            TIC_SetTimer(SYNC_ACCURATE_NETWORK_TIME + delta);
    227            TIC_SetRTC(sync->rtc);
    228            
    229            LAST_SYNC_TIME = TIC_GetUptime();
    230            NEXT_SYNC_TIME = LAST_SYNC_TIME + RAND_SYNC_RX_DELAY; 
    231            TIC_SetRXState(SYNC_TS, false);
    232            LOG_ON("Node Synced. TS=%d, AT=%d, DEL=%d, AD=%d, RTC=%d, NRTC=%d, SRTC=%d",
    233                   fr_SYNC->meta.TIMESTAMP,SYNC_ACCURATE_NETWORK_TIME, delta,
    234                   SYNC_ACCURATE_NETWORK_TIME - fr_SYNC->meta.TIMESTAMP, 
    235                   (uint16_t)LAST_SYNC_TIME,
    236                   (uint16_t)NEXT_SYNC_TIME,
    237                   (uint16_t)TIC_GetRTC());
    238            frame_delete(fr_SYNC);
    239            // После приема нужно ретранслировать синхропакет
    240            NEED_SEND_SYNC = true; 
    241          P1_0 = !false; // ОТЛАДКА
    242          }
    243          
    244          /**
    245          @brief Вызывает при активносм TS1 RX или TX
    246          @detail Формирует кадр синхронизации и передает его в строго определенное время
    247          */
    248          static void SY_TS1_HNDL_MASTER(void)
    249          {
    250            if (!SY_ENABLE_MODULE) // Модуль отключен
    251              return;  
    252             
    253          P1_0 = !true; //ОТЛАДКА  
    254            if (send_sync())
    255              SYNC_SENDED++;
    256            
    257            LOG_ON("Sync send."); 
    258          P1_0 = !false; //ОТЛАДКА
    259            
    260            TIC_SetTXState(SYNC_TS, false);
    261          }
    262          
    263          /**
    264          @brief Создать и отправить синхропакет
    265          */
    266          static bool send_sync(void)
    267          {
    268            SYNC_s sync;
    269            sync.panid = CONFIG.panid;
    270            sync.rtc = TIC_GetRTC();
    271            sync.magic = MAGIC;
    272            
    273            frame_s *fr_SYNC = frame_create();
    274            frame_addHeader(fr_SYNC, &sync, sizeof(SYNC_s));
    275            fr_SYNC->meta.SEND_TIME = SYNC_ACCURATE_NETWORK_TIME; // время в тактах сети. ((1/32768)*164)*1000
    276              
    277          #ifdef RARIO_STREAM_ENCRYPT
    278            BitRawCrypt(fr_SYNC->payload, fr_SYNC->len);
    279          #endif
    280            
    281            RI_SetChannel(CONFIG.sync_channel);
    282            bool res = RI_Send(fr_SYNC);
    283            
    284            frame_delete(fr_SYNC);
    285            return res;
    286          }
    287          
    288          /**
    289          @brief Прием пакет синхронизации
    290          @param[in] Время ожидания в мс
    291          @return Указатель на пакет или NULL
    292          */
    293          static frame_s* get_sync(uint16_t timeout)
    294          {
    295            RI_SetChannel(CONFIG.sync_channel);
    296            frame_s *fr_SYNC = RI_Receive(timeout);
    297            
    298            // Если пакета нет, выходим из обработчика
    299            if (fr_SYNC == NULL)
    300              return NULL;
    301            
    302            // Проверим размер пакета
    303            if (fr_SYNC->len != sizeof(SYNC_s))
    304            {
    305              frame_delete(fr_SYNC);
    306              return NULL;
    307            }
    308            
    309            #ifdef RARIO_STREAM_ENCRYPT
    310            BitRawDecrypt(fr_SYNC->payload, fr_SYNC->len);
    311            #endif
    312            return fr_SYNC;
    313          }
    314          
    315          /**
    316          @brief Процедура синхронизации с сетью
    317          @detail Процедура изет сеть в течении времени timeout и синхронизируется с ней
    318          @param[in] timeout время в милисекундах
    319          @param[out] panid указатель на идентификатор найденой сети
    320          @return true если сеть найдета
    321          */
    322          bool SY_SYNC_NETWORK(uint16_t *panid,uint16_t timeout)
    323          {
    324            // TODO Нужно обнулить настройки всех модулей
    325            // Или об этом будет заботиться верхний уровень?
    326            TIC_CloseAllState();
    327            
    328            RI_SetChannel(CONFIG.sync_channel);
    329            
    330            TimeStamp_s begin, end;
    331            TIM_TimeStamp(&begin);
    332            TIM_TimeStamp(&end);
    333            
    334            bool net_found = false;
    335            uint32_t passed = 0;
    336            frame_s *fr_SYNC;
    337            SYNC_s *sync;
    338            uint32_t timeout_us = timeout * 1000;
    339            
    340            while (passed < timeout_us)
    341            {
    342              fr_SYNC = get_sync(timeout);
    343              if (fr_SYNC == NULL)
    344              {
    345                passed = TIM_passedTime(&begin, &end);
    346                continue;
    347              }
    348              
    349              // Приняли какойто пакет, декодируем.
    350              sync = (SYNC_s*)fr_SYNC->payload;
    351              
    352              if (sync->magic != MAGIC)
    353              { // Проверим что пакет именно тот а не эфирный мусор
    354                frame_delete(fr_SYNC);
    355                passed = TIM_passedTime(&begin, &end);
    356                continue;
    357              }   
    358              
    359              // Возвращаем результат
    360              *panid = sync->panid;
    361              CONFIG.panid = sync->panid;
    362              net_found = true;
    363              
    364              // Синхронизируемся с сетью
    365              // Время прошедшее с момента приема пакета в тактах сети
    366              uint16_t delta = TIC_GetTimer() - fr_SYNC->meta.TIMESTAMP;
    367              TIC_SetTimer(SYNC_ACCURATE_NETWORK_TIME + delta);
    368              TIC_SetRTC(sync->rtc);
    369              LAST_SYNC_TIME = TIC_GetUptime();
    370              NEXT_SYNC_TIME = LAST_SYNC_TIME + RAND_SYNC_RX_DELAY; 
    371              frame_delete(fr_SYNC);
    372              break;
    373            } 
    374            
    375            return net_found;
    376          }
    377          
    378          /*!
    379          \brief Расшифровка область памяти
    380          \param[in,out] *src Указатель на начало области дешифрования
    381          \param[in] size Размер расшифруемых данных
    382          */
    383          static void BitRawDecrypt(uint8_t *src, uint8_t size)
    384          {
    385            AES_StreamCoder(false, src, src, KEY, IV, size);
    386          }
    387          
    388          /*!
    389          \brief Шифрует область памяти
    390          \param[in,out] *src Указатель на начало области шифрования
    391          \param[in] size Размер шифруемых данных
    392          */
    393          static void BitRawCrypt(uint8_t *src, uint8_t size)
    394          {
    395            AES_StreamCoder(true, src, src, KEY, IV, size);
    396          }
    397          
\\vmware-host\Shared Folders\Projects\WMNU\IAR\SHARE_PRJ_SRC\TIC.c
      1          #include "TIC.h"
      2          #include "NTMR.h"
      3          #include "stdlib.h"
      4          #include "nwdebuger.h"
      5          #include "delays.h"
      6          #include "basic.h"
      7          #include "ioCC2530.h" // ОТЛАДДКА
      8          
      9          /**
     10          @file 
     11          @brief 
     12          @details
     13          */
     14          
     15          // Публичные методы
     16          void TIC_Init(void);
     17          void TIC_Reset(void);
     18          
     19          // Методы класса
     20          void TIC_SetTimer(uint16_t ticks);
     21          uint16_t TIC_GetTimer(void);
     22          bool TIC_SetTXState(uint8_t TS, bool state);
     23          bool TIC_SetRXState(uint8_t TS, bool state);
     24          bool TIC_GetTXState(uint8_t TS);
     25          bool TIC_GetRXState(uint8_t TS);
     26          void TIC_CloseAllState();
     27          void TIC_SetRXCallback(void (*fn)(uint8_t TS));
     28          void TIC_SetTXCallback(void (*fn)(uint8_t TS));
     29          void TIC_SetSECallback(void (*fn)(uint8_t TS));
     30          void TIC_SetTS1Callback(void (*fn)(void));
     31          void TIC_SetSyncTimeAllocCallback(void (*fn)(void));
     32          uint32_t TIC_GetUptime(void);
     33          uint32_t TIC_GetRTC(void);
     34          bool TIC_SetRTC(uint32_t RTC);
     35          void TIC_SetNonce(uint32_t nonce);
     36          uint32_t TIC_GetNonce(void);
     37          uint32_t TIC_TimeUsFromTS0();
     38          TimeStamp_s* TIC_GetTimeStampTS0(void);
     39          uint16_t TIC_SleepTime(void);
     40          uint16_t TIC_SlotActivityTime(void);
     41          uint16_t TIC_SlotTime(uint8_t TS);
     42          
     43          // Приватные методы
     44          static uint8_t TIC_getCurrentTS(uint16_t ticks);
     45          static void TIC_TDMAShelduler(uint8_t TS);
     46          static void TIC_HW_Timer_IRQ(uint16_t ticks);
     47          static inline void set_capture_time(uint8_t TS);
     48          static inline void Callback_execution(void (*fn)(uint8_t TS), uint8_t TS);
     49          static inline void incrementTS(uint8_t *TS);
     50          static void clocks_update(void);
     51          
     52          // Переменные модуля
     53          
     54          // Всего 50 слотов. (50 активных и 50 слотов сна)
     55          // Кварц имеет 32768 тактов в секунду. После 100 слотов
     56          // Остается 68 неучтеных тактов. Их нужно учитывать.
     57          #define MAX_TS (uint8_t)50
     58          #define TS_ACTIVE (uint16_t)327 // 9.979 мс
     59          #define TS_SLEEP (uint16_t)327  // 2.075 мс
     60          #define TS_UNACCOUNTED 68
     61          // Целый цикл-это сумма времени активного периода и сна
     62          #define FULL_SLOT  (TS_ACTIVE+TS_SLEEP)
     63          #define NO_TIME_SLOT 0xFF
     64          
     65          #define TS_RX (uint8_t)(1<<0)
     66          #define TS_TX (uint8_t)(1<<1)
     67          #define DAILY_SEC (uint32_t)86400
     68          #define MAX_TICKS (uint16_t)32768
     69          
     70          static uint32_t NODE_UPTIME = 0;
     71          static uint32_t NODE_RTC = 0;
     72          static uint32_t NODE_NONCE = 0;
     73          static void (*RXCallback)(uint8_t TS);
     74          static void (*TXCallback)(uint8_t TS);
     75          static void (*SECallback)(uint8_t TS);
     76          static void (*SyncTimeAllocCallback)(void);
     77          static void (*TS1Callback)(void);
     78          static uint8_t TSStateTable[MAX_TS];
     79          static TimeStamp_s TimeStampTS0;
     80          
     81          
     82          TimeStamp_s* TIC_GetTimeStampTS0(void)
     83          {
     84            return &TimeStampTS0;
     85          }
     86          
     87          void TIC_Init(void)
     88          {    
     89            TIC_CloseAllState();
     90            // Устанавливаем обработчик прерываний таймера
     91            NT_SetEventCallback(TIC_HW_Timer_IRQ);
     92            // Запускаем процесс планировщика
     93            NT_SetCompare(0); 
     94            TIC_SetTimer(0);
     95            TIM_TimeStamp(&TimeStampTS0);
     96          }
     97          
     98          /**
     99          @brief Сброс настроек. 
    100          @detail Модуль генерирует только SECallback и считает время RTC, UPTIME, NONCE.
    101          Так как была переустановка времени, значение RTC не верное на 1с (плюс, минус)
    102          */
    103          void TIC_Reset(void)
    104          {
    105          #ifdef GATEWAY
    106            NODE_RTC = 0;
    107            NODE_NONCE = 0;
    108            NODE_UPTIME = 0;
    109          #endif
    110            TIC_CloseAllState();  
    111            NT_SetCompare(0); 
    112            TIC_SetTimer(0);
    113            TIM_TimeStamp(&TimeStampTS0);
    114          }
    115          
    116          void TIC_CloseAllState()
    117          {
    118            for (uint8_t i = 0 ; i < 50; i++)
    119            {
    120              TIC_SetTXState(i, false);
    121              TIC_SetRXState(i, false);
    122            }
    123          }
    124          uint32_t TIC_TimeUsFromTS0()
    125          {
    126            uint32_t passed;
    127            TimeStamp_s now;
    128            TIM_TimeStamp(&now);
    129            passed = TIM_passedTime(&TimeStampTS0, &now);
    130            return passed;
    131          }
    132          
    133          void TIC_SetTimer(uint16_t ticks)
    134          {
    135            ASSERT(ticks < MAX_TICKS);
    136            if (ticks >= MAX_TICKS)
    137              return ;
    138            
    139            NT_SetTime(ticks);
    140          }
    141          
    142          uint16_t TIC_GetTimer(void)
    143          {
    144            return NT_GetTime();
    145          }
    146          
    147          bool TIC_SetTXState(uint8_t TS, bool state)
    148          {
    149            if (TS>=MAX_TS)
    150            {
    151              return false;
    152            }
    153            ASSERT(TS<MAX_TS);
    154            
    155            if (state)
    156              TSStateTable[TS] |= TS_TX;
    157            else
    158              TSStateTable[TS] &= ~TS_TX;
    159            
    160            return true;
    161          }
    162          
    163          bool TIC_SetRXState(uint8_t TS, bool state)
    164          {
    165            if (TS>=MAX_TS)
    166            {
    167              return false;
    168            }
    169            ASSERT(TS<MAX_TS);
    170            
    171            if (state)
    172              TSStateTable[TS] |= TS_RX;
    173            else
    174              TSStateTable[TS] &= ~TS_RX;
    175            
    176            return true;
    177          }
    178          
    179          bool TIC_GetTXState(uint8_t TS)
    180          {
    181              if (TS>=MAX_TS)
    182            {
    183              return false;
    184            }
    185            ASSERT(TS<MAX_TS);
    186            
    187            return (TSStateTable[TS] & TS_TX) ;
    188          }
    189          
    190          bool TIC_GetRXState(uint8_t TS)
    191          {
    192              if (TS>=MAX_TS)
    193            {
    194              return false;
    195            }
    196            ASSERT(TS<MAX_TS);
    197            
    198            return (TSStateTable[TS] & TS_RX) ;
    199          }
    200          
    201          void TIC_SetTS1Callback(void (*fn)(void))
    202          {
    203            ASSERT (fn != NULL);
    204            TS1Callback = fn;
    205          }
    206          
    207          void TIC_SetRXCallback(void (*fn)(uint8_t TS))
    208          {
    209            ASSERT(fn != NULL);
    210            RXCallback = fn;
    211          }
    212          
    213          void TIC_SetSyncTimeAllocCallback(void (*fn)(void))
    214          {
    215            ASSERT(fn != NULL);
    216            SyncTimeAllocCallback = fn;
    217          }
    218          
    219          void TIC_SetTXCallback(void (*fn)(uint8_t TS))
    220          {
    221            ASSERT(fn != NULL);
    222            TXCallback = fn;
    223          }
    224          
    225          void TIC_SetSECallback(void (*fn)(uint8_t TS))
    226          {
    227            ASSERT(fn != NULL);
    228            SECallback = fn;
    229          }
    230          
    231          uint32_t TIC_GetUptime(void)
    232          {
    233            return NODE_UPTIME;
    234          }
    235          
    236          uint32_t TIC_GetRTC(void)
    237          {
    238            return NODE_RTC;
    239          }
    240          
    241          bool TIC_SetRTC(uint32_t RTC)
    242          {
    243            if (RTC >= DAILY_SEC)
    244              return false;
    245            
    246            NODE_RTC = RTC;
    247            return true;
    248          }
    249          
    250          static uint8_t TIC_getCurrentTS(uint16_t ticks)
    251          {
    252            //uint16_t ticks = nt->NT_GetTime();
    253            // Вычисляем количество целых циклов
    254            uint8_t full_slot_num = ticks/FULL_SLOT;
    255            
    256            // Вычисляем остаток от деления. Остаток - смещение внутри
    257            // временного слота.
    258            uint16_t time_remainder = ticks % FULL_SLOT; 
    259            // Если значение внутри интервала 0..TS_ACTIVE. 
    260            if (time_remainder < TS_ACTIVE)
    261              return full_slot_num;
    262            
    263            return NO_TIME_SLOT;
    264          }
    265          
    266          static inline void incrementTS(uint8_t *TS)
    267          {
    268            // Выбираем следующий тайм слот
    269            (*TS)++;
    270            if (*TS >= MAX_TS)
    271              *TS = 0;
    272          }
    273          
    274          /**
    275          @brief Время активного слота в тактах сети
    276          @return время в тактах сети
    277          */
    278          uint16_t TIC_SlotActivityTime(void)
    279          {
    280            return TS_ACTIVE;
    281          }
    282          
    283          /**
    284          @brief Время неактивного слота в тактах сети
    285          @return время в тактах сети
    286          */
    287          uint16_t TIC_SleepTime(void)
    288          {
    289            return TS_SLEEP;
    290          }
    291          
    292          /**
    293          @brief Время начала временного слота в тактах сети
    294          @param[in] TS номер слота
    295          @return время в тактах сети
    296          */
    297          uint16_t TIC_SlotTime(uint8_t TS)
    298          {
    299            return FULL_SLOT*(uint16_t)TS;
    300          }
    301          
    302          static inline void set_capture_time(uint8_t TS)
    303          {
    304            //uint16_t ct = FULL_SLOT*(uint16_t)TS;
    305            
    306            LOG_OFF("Set compare = %d, TS = %d \r\n", ct, TS);
    307            // Установка прерывания на нужный слот
    308            NT_SetCompare(FULL_SLOT*(uint16_t)TS);
    309          }
    310          
    311          static void TIC_TDMAShelduler(uint8_t TS)
    312          {
    313            // Устанавливает прерывание на ближайший активный слот
    314            // Если слот 0 ближе, то на него. 
    315            // Cлот - обработка секундных таймеров 
    316            
    317            // Ищем следующий активный слот или слот 0
    318            incrementTS(&TS);
    319            while ((TS != 0) && !TSStateTable[TS])  
    320              incrementTS(&TS); 
    321            
    322            set_capture_time(TS);
    323          }
    324          
    325          static inline void Callback_execution(void (*fn)(uint8_t TS), uint8_t TS)
    326          {
    327            // Помошник вызова функций. Упрощает проверки
    328            ASSERT(fn != NULL);
    329            if (fn == NULL)
    330              return;
    331            fn(TS);
    332          }
    333          
    334          static void TIC_HW_Timer_IRQ(uint16_t ticks)
    335          {
    336            // TODO Обработка TS=0xFF
    337            // Номер текущего слота 
    338            uint8_t c_TS = TIC_getCurrentTS(ticks);
    339            
    340            // Обновляем часы NODE_RTC и NODE_UPTIME
    341            if (c_TS == 0)
    342            {
    343              TIM_TimeStamp(&TimeStampTS0); // Первым делом обновим отметку точного времени
    344              clocks_update();
    345           //   P1_0 = !true;
    346              LOG_OFF("TS0");
    347           //   P1_0 = !false;;
    348            }
    349            // Если что то пошло не так и мы промахнулись мимо слота
    350            // запускаем планировщик заново
    351            if (c_TS == NO_TIME_SLOT)
    352            {
    353              TIC_TDMAShelduler(c_TS);
    354              LOG_ON("TS = 255 \r\n");
    355              return;
    356            }
    357              
    358            // Вызываем один из указанных обработчиков.
    359            // Передача имеет приоритет над приемом.
    360            if (c_TS != 1)
    361            {
    362              if (TSStateTable[c_TS] & TS_TX) 
    363                Callback_execution(TXCallback, c_TS);
    364              else if (TSStateTable[c_TS] & TS_RX)
    365                Callback_execution(RXCallback, c_TS);
    366            }  
    367            else // Для TS1 свой обработчик слота
    368            {
    369              if (TS1Callback != NULL)
    370                TS1Callback();
    371            }
    372            
    373            // Выделяем время протоколу синхронизации
    374            if (SyncTimeAllocCallback)
    375              SyncTimeAllocCallback();
    376            
    377            Callback_execution(SECallback, c_TS); // Вызываем обработчик завершения слота
    378            
    379            // Запускаем планировщик таймера
    380            TIC_TDMAShelduler(c_TS);
    381          }
    382          
    383          static void clocks_update(void)
    384          {
    385            NODE_UPTIME++;
    386            NODE_RTC++;
    387            NODE_NONCE++;
    388            if (NODE_RTC >= DAILY_SEC)
    389              NODE_RTC = 0;
    390          }
    391          
    392          void TIC_SetNonce(uint32_t nonce)
    393          {
    394            NODE_NONCE = nonce;
    395          }
    396          
    397          uint32_t TIC_GetNonce(void)
    398          {
    399            return NODE_NONCE;
    400          }
\\vmware-host\Shared Folders\Projects\WMNU\IAR\PRJ_UNITEST\src\utest.c
      1          #include "utest_suite.h"
      2          #include "nwdebuger.h"
      3          #include "assert.h"
      4          #include "basic.h"
      5          
      6          extern void suite_GW(void);
      7          extern void suite_NODE(void);
      8          
      9          int main()
     10          {
     11            nwDebugerInit();
     12            utestSigTraceInit();
     13            LOG_OFF("");
     14            LOG_OFF("Test start");
     15          
     16          #ifdef GATEWAY
     17            suite_GW();
     18          #else
     19            suite_NODE();
     20          #endif
     21          // Добавляем результаты тестов
     22          	umsg_summary();
     23           //     while(1);
     24          	return 0;
     25          }
\\vmware-host\Shared Folders\Projects\WMNU\IAR\PRJ_UNITEST\src\utest_GW.c
      1          #include "utest_suite.h"
      2          #include "manager.h"
      3          #include "nwdebuger.h"
      4          
      5          // Собирать проект с ключем GATEWAY в файле basic.h
      6          
      7          
      8          
      9          void suite_GW(void)
     10          {
     11            bool con = MG_Connect();
     12            if (con)
     13            {
     14              LOG_ON("Network created\r\n");
     15            }  
     16            else
     17            {
     18              LOG_ON("Network creation failed\r\n");
     19            }
     20            
     21            while(1);
     22          }
\\vmware-host\Shared Folders\Projects\WMNU\IAR\PRJ_UNITEST\src\utest_NODE.c
      1          #include "utest_suite.h"
      2          #include "manager.h"
      3          #include "nwdebuger.h"
      4          
      5          // Собирать проект без ключем GATEWAY в файле basic.h
      6          
      7          void suite_NODE(void)
      8          {
      9             bool con = MG_Connect();
     10            if (con)
     11            {
     12              LOG_ON("Network sycronized");
     13            }  
     14            else
     15            {
     16              LOG_ON("Network connect faild");
     17            }
     18            
     19            while(1);
     20          }
\\vmware-host\Shared Folders\Projects\WMNU\IAR\PRJ_UNITEST\src\utest_suite.c
      1          #include "stdio.h"
      2          #include "utest_suite.h"
      3          #include "ioCC2530.h"
      4          
      5          /**
      6          @brief Иницилизируем выводы светодидов
      7          */
      8          void utestSigTraceInit(void)
      9          {
     10            P1DIR = 0x13; // Включаем светодиоды
     11          }
     12          
     13          void LED(uint8_t led, bool state)
     14          {
     15            switch(led)
     16            {
     17              case D1:
     18                P1_0 = !state;
     19                break;
     20              case D2:
     21                P1_1 = !state;
     22                break;
     23              case D3:
     24                P1_4 = !state;
     25                break;
     26            }
     27          }
     28          
     29          
     30          static struct utest_summary_s
     31          {
     32          	uint16_t passed;
     33          	uint16_t failed;
     34          } utest_summary = {.passed =0, .failed = 0};;
     35          
     36          //utest_summary_s utest_summary = {.passed =0, .failed = 0};
     37          
     38          // Требует много програмной памяти
     39          size_t heap_size(void)
     40          { 
     41            return 0;
     42          }
     43          
     44          bool memory_compare(char* area1, char* area2, uint16_t size)
     45          {
     46          	while (size > 0)
     47          	{
     48          		if (*area1 != *area2)
     49          			return false;
     50          		area1++;
     51          		area2++;
     52                  size--;
     53          	} 
     54          	return true;
     55          }
     56          
     57          void umsg(char* module, char* name, bool status)
     58          {
     59          	if (status){
     60          		utest_summary.passed++;
     61          		printf("Module: %-15s Name: %-50s Status: %-10s\r\n", module, name, "PASSED");
     62          		}
     63          	else{
     64          		utest_summary.failed++;
     65          		printf("Module: %-15s Name: %-50s Status: %-10s\r\n", module, name, "FAILED <----");
     66          		}
     67          }
     68          
     69          void umsg_line(char* name)
     70          {
     71          	printf("**************************************\r\n");
     72          	printf("%s\r\n", name);
     73          	printf("**************************************\r\n");
     74          }
     75          
     76          void umsg_summary()
     77          {
     78          	umsg_line("Unit test symmary");
     79          	printf("PASSED: %d\r\n", utest_summary.passed);
     80          	printf("FAILD : %d\r\n", utest_summary.failed);
     81          	if (utest_summary.failed == 0)
     82                printf("Tests PASSED\r\n");
     83          	else
     84          		printf("Tests FAILED\r\n");
     85          }

   Maximum stack usage in bytes:

   ISTACK XSTACK Function
   ------ ------ --------
      1     77   AES_CCMDecrypt
        0     67   -> CBCMAC_buf_encrypt
        0     71   -> CTR_enc_decrypt
        0     69   -> generateAuthData
        0     69   -> memcpy
        0     69   -> memset
      1     61   AES_CCMEncrypt
        0     51   -> CBCMAC_buf_encrypt
        0     55   -> CTR_enc_decrypt
        0     53   -> generateAuthData
        0     53   -> memcpy
        0     53   -> memset
      0     88   AES_StreamCoder
        0     36   -> memcpy
        0     36   -> memset
      2     10   AES_init
      0    111   CBCMAC_buf_encrypt
      0     22   CF_init
        0     12   -> memcpy
      0    107   CTR_enc_decrypt
        0     36   -> memcpy
        0     36   -> memset
      0     28   Callback_execution
        0     10   -> printf
        0     16   -> printf
      0     16   ETH_Init
        0     10   -> printf
        0     16   -> printf
      0     22   ETH_RX_HNDL
        0     16   -> __xdata_malloc
        0     16   -> frame_delete
        0     16   -> printf
        0     22   -> printf
        0     16   -> re_free
      0     16   ETH_Set_RXCallback
        0     10   -> printf
        0     16   -> printf
      0      0   LED
      1     26   LLC_AddTask
        0     16   -> __xdata_malloc
        0     16   -> printf
        0     22   -> printf
        0     26   -> printf
      2      0   LLC_GetTaskLen
      0     26   LLC_Init
        0     10   -> printf
        0     16   -> printf
      0     16   LLC_RX_HNDL
        0     10   -> printf
        0     16   -> printf
      0      9   LLC_Reset
        0      9   -> __xdata_free
      0      9   LLC_SE_HNDL
        0      9   -> LLC_Shelduler
      0     16   LLC_SetRXCallback
        0     10   -> printf
        0     16   -> printf
      0     28   LLC_Shelduler
        0     13   -> MAC_Send
        0     13   -> __xdata_free
        0     13   -> printf
        0     19   -> printf
      0     18   LLC_TimeAlloc
        0     12   -> __xdata_malloc
        0     12   -> printf
        0     18   -> printf
      1      9   MAC_CloseRXSlot
        0      9   -> TIC_SetRXState
      2      0   MAC_Enable
      2      0   MAC_GetRXState
      2      0   MAC_GetTXState
      0     22   MAC_Init
        0     10   -> TIC_SetRXCallback
        0     10   -> TIC_SetTXCallback
        0     12   -> memset
      1      9   MAC_OpenRXSlot
        0      9   -> TIC_SetRXState
      0     18   MAC_RX_HNDL
        0     18   -> AES_StreamCoder
        0     14   -> RI_Receive
        0     14   -> RI_Send
        0     14   -> frame_addHeader
        0     14   -> frame_create
        0     14   -> frame_delete
        0     14   -> xor_calc
      0     22   MAC_Reset
        0     10   -> frame_delete
        0     12   -> memset
      1     29   MAC_Send
        0     14   -> AES_StreamCoder
        0     10   -> TIC_SetTXState
        0     10   -> printf
        0     16   -> printf
      2      0   MAC_SetRXCallback
      1     18   MAC_TX_HNDL
        0     18   -> RI_Receive
        0     18   -> RI_Send
        0     18   -> TIC_SetTXState
        0     18   -> TIM_delay
        0     18   -> frame_delete
        0     18   -> xor_calc
      0     12   MAC_setIV
        0     12   -> memcpy
      0     12   MAC_setKEY
        0     12   -> memcpy
      0     26   MG_Connect
        0     10   -> AES_init
        0     10   -> CF_init
        0     10   -> LLC_Init
        0     10   -> MAC_Init
        0     10   -> MAC_Reset
        0     10   -> NT_Init
        0     10   -> RI_init
        0     10   -> SY_Init
        0     10   -> SY_Reset
        0     10   -> TIC_Init
        0     10   -> TIC_Reset
        0     10   -> TIM_init
        0     10   -> __xdata_free
        0     12   -> memcpy
        0     10   -> printf
        0     12   -> printf
        0     16   -> printf
      0      0   MyLowLevelPutchar
      0     12   NT_GetTime
      2     10   NT_Init
      0     42   NT_SetCompare
        0     24   -> ReadTimer
        0     24   -> printf
        0     30   -> printf
      2      0   NT_SetEventCallback
      0     28   NT_SetTime
        0     12   -> NT_SetCompare
        0     12   -> ReadTimer
        0     12   -> printf
        0     18   -> printf
      0     25   NT_WaitTime
      2      0   RI_GetCCAReject
      2      0   RI_GetCRCError
      2      0   RI_GetUptime
      2    109   RI_Receive
        0     61   -> RI_cfg
        0     61   -> ReadTimer
        0     61   -> __xdata_malloc
        0     61   -> frame_addHeader
        0     61   -> frame_create
        0     61   -> re_free
      1     60   RI_Send
        0     32   -> RI_cfg
        0     32   -> SendData
        0     32   -> printf
        0     38   -> printf
      2      0   RI_SetChannel
      0     77   RI_cfg
        0     10   -> printf
        0     16   -> printf
      0     19   RI_init
        0      9   -> RI_cfg
        0      9   -> rand
        0      9   -> readRandom
        0      9   -> srand
      2     61   ReadTimer
      0     16   STACK_FAILURE
        0     10   -> printf
        0     16   -> printf
      2      0   SY_Enable
      0     26   SY_Init
        0     10   -> printf
        0     16   -> printf
      2     10   SY_Reset
      2     52   SY_SYNC_NETWORK
        0     52   -> AES_StreamCoder
        0     48   -> RI_Receive
        0     48   -> TIC_CloseAllState
        0     48   -> TIC_SetTimer
        0     48   -> frame_delete
      0     12   SY_TIME_ALLOC_MASTER
      0     28   SY_TS1_HNDL_MASTER
        0     26   -> AES_StreamCoder
        0     22   -> RI_Send
        0     22   -> frame_addHeader
        0     22   -> frame_create
        0     22   -> frame_delete
        0     22   -> printf
        0     28   -> printf
      0     12   SY_setIV
        0     12   -> memcpy
      0     12   SY_setKEY
        0     12   -> memcpy
      2      0   SY_sync_sended
      0     45   SendData
        0     13   -> NT_WaitTime
      2     48   TIC_CloseAllState
      2      0   TIC_GetNonce
      2      0   TIC_GetRTC
      2      0   TIC_GetRXState
      2      0   TIC_GetTXState
      0      0   TIC_GetTimeStampTS0
      0     12   TIC_GetTimer
      2      0   TIC_GetUptime
      0     18   TIC_HW_Timer_IRQ
        0     12   -> Callback_execution
        0     12   -> TIC_TDMAShelduler
        0     12   -> TIM_TimeStamp
        0     12   -> printf
        0     18   -> printf
      2     10   TIC_Init
        2      0   -> NT_SetCompare
        2      0   -> NT_SetTime
        2      0   -> TIC_CloseAllState
        2      0   -> TIM_TimeStamp
      2     10   TIC_Reset
        2      0   -> NT_SetCompare
        2      0   -> NT_SetTime
        2      0   -> TIC_CloseAllState
        2      0   -> TIM_TimeStamp
      0     12   TIC_SetNonce
      0     12   TIC_SetRTC
      0     26   TIC_SetRXCallback
        0     10   -> printf
        0     16   -> printf
      2      9   TIC_SetRXState
      0     16   TIC_SetSECallback
        0     10   -> printf
        0     16   -> printf
      0     16   TIC_SetSyncTimeAllocCallback
        0     10   -> printf
        0     16   -> printf
      0     16   TIC_SetTS1Callback
        0     10   -> printf
        0     16   -> printf
      0     26   TIC_SetTXCallback
        0     10   -> printf
        0     16   -> printf
      2     18   TIC_SetTXState
      0     64   TIC_SetTimer
        0     10   -> NT_SetTime
        0     10   -> printf
        0     16   -> printf
      0      0   TIC_SleepTime
      0      0   TIC_SlotActivityTime
      0      0   TIC_SlotTime
      0     21   TIC_TDMAShelduler
        0      9   -> NT_SetCompare
      1     24   TIC_TimeUsFromTS0
      3     12   TIM_TimeStamp
      0     12   TIM_copy
        0     12   -> memcpy
      1     64   TIM_delay
      1     42   TIM_init
        0     32   -> TIM_delay
      0     20   TIM_passedTime
      0     17   TimerCompareInterrupt
      0     11   __write
      1     88   frame_addHeader
        0     21   -> __xdata_malloc
        0     21   -> printf
        0     27   -> printf
        0     21   -> re_free
        0     23   -> re_memcpy
      0     79   frame_create
        0     12   -> __xdata_malloc
        0     14   -> memset
        0     12   -> printf
        0     18   -> printf
      1     21   frame_delHeader
        0     15   -> __xdata_malloc
        0     15   -> printf
        0     21   -> printf
        0     15   -> re_free
        0     17   -> re_memcpy
      0     59   frame_delete
        0     11   -> __xdata_free
      2      0   frame_getCount
      2      0   frame_len
      0     85   generateAuthData
        0     16   -> memcpy
      0     12   heap_ptr
        0     12   -> __xdata_free
        0     12   -> __xdata_malloc
      0      0   heap_size
      0      0   main
        0      0   -> nwDebugerInit
        0      0   -> suite_GW
        0      0   -> umsg_summary
      0     11   memory_compare
      0      0   nwDebugerInit
      0     70   re_free
        0      9   -> __xdata_free
      0     10   re_malloc
        0     10   -> __xdata_malloc
      0     34   re_memcpy
        0     11   -> memcpy
      2      9   readRandom
      0     16   suite_GW
        0     10   -> MG_Connect
        0     10   -> printf
        0     16   -> printf
      0     16   suite_NODE
        0     10   -> MG_Connect
        0     10   -> printf
        0     16   -> printf
      0     16   umsg
        0     16   -> printf
      0     12   umsg_line
        0     10   -> printf
        0     12   -> printf
      0     12   umsg_summary
        0     10   -> printf
        0     12   -> printf
      0      0   utestSigTraceInit
      0     27   xor_calc


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
       5  ?<Constant "%s\r\n">
      41  ?<Constant "*********************...">
      22  ?<Constant "*ASSERT* %s:%d:%s -> ">
      22  ?<Constant "*ASSERT* %s:%d:%s -> ">_1
      22  ?<Constant "*ASSERT* %s:%d:%s -> ">_2
      22  ?<Constant "*ASSERT* %s:%d:%s -> ">_3
      22  ?<Constant "*ASSERT* %s:%d:%s -> ">_4
      22  ?<Constant "*ASSERT* %s:%d:%s -> ">_5
      22  ?<Constant "*ASSERT* %s:%d:%s -> ">_6
      19  ?<Constant "*LOG* %s:%d:%s -> ">
      19  ?<Constant "*LOG* %s:%d:%s -> ">_1
      19  ?<Constant "*LOG* %s:%d:%s -> ">_2
      19  ?<Constant "*LOG* %s:%d:%s -> ">_3
      19  ?<Constant "*LOG* %s:%d:%s -> ">_4
      19  ?<Constant "*LOG* %s:%d:%s -> ">_5
      19  ?<Constant "*LOG* %s:%d:%s -> ">_6
      51  ?<Constant "Add task = %u, CH = %...">
      13  ?<Constant "FAILD : %d\r\n">
      13  ?<Constant "FAILED <----">
      21  ?<Constant "Frame_s count: %d \r\n">
       6  ?<Constant "LLC.c">
       6  ?<Constant "MAC.c">
      42  ?<Constant "Module: %-15s Name: %...">
       7  ?<Constant "NTMR.c">
      22  ?<Constant "Network connect faild">
      18  ?<Constant "Network created\r\n">
      26  ?<Constant "Network creation fail...">
      19  ?<Constant "Network sycronized">
       7  ?<Constant "PASSED">
      13  ?<Constant "PASSED: %d\r\n">
       8  ?<Constant "RADIO.c">
      20  ?<Constant "STACK FAILURE. HALT">
      11  ?<Constant "Sync send.">
       6  ?<Constant "TIC.c">
      12  ?<Constant "TS = 255 \r\n">
      15  ?<Constant "Tests FAILED\r\n">
      15  ?<Constant "Tests PASSED\r\n">
      18  ?<Constant "Unit test symmary">
       3  ?<Constant "\r\n">
       3  ?<Constant "\r\n">_1
       3  ?<Constant "\r\n">_10
       3  ?<Constant "\r\n">_11
       3  ?<Constant "\r\n">_2
       3  ?<Constant "\r\n">_3
       3  ?<Constant "\r\n">_4
       3  ?<Constant "\r\n">_5
       3  ?<Constant "\r\n">_6
       3  ?<Constant "\r\n">_7
       3  ?<Constant "\r\n">_8
       3  ?<Constant "\r\n">_9
      11  ?<Constant "ethernet.c">
       8  ?<Constant "frame.c">
      10  ?<Constant "manager.c">
      12  ?<Constant "nwdebuger.c">
       7  ?<Constant "sync.c">
      11  ?<Constant "utest_GW.c">
      13  ?<Constant "utest_NODE.c">
       5  ?<Initializer for <Constant "%s\r\n">>
      41  ?<Initializer for <Constant "*****************
      22  ?<Initializer for <Constant "*ASSERT* %s:%d:%s
      22  ?<Initializer for <Constant "*ASSERT* %s:%d:%s_1
      22  ?<Initializer for <Constant "*ASSERT* %s:%d:%s_2
      22  ?<Initializer for <Constant "*ASSERT* %s:%d:%s_3
      22  ?<Initializer for <Constant "*ASSERT* %s:%d:%s_4
      22  ?<Initializer for <Constant "*ASSERT* %s:%d:%s_5
      22  ?<Initializer for <Constant "*ASSERT* %s:%d:%s_6
      19  ?<Initializer for <Constant "*LOG* %s:%d:%s ->
      19  ?<Initializer for <Constant "*LOG* %s:%d:%s ->_1
      19  ?<Initializer for <Constant "*LOG* %s:%d:%s ->_2
      19  ?<Initializer for <Constant "*LOG* %s:%d:%s ->_3
      19  ?<Initializer for <Constant "*LOG* %s:%d:%s ->_4
      19  ?<Initializer for <Constant "*LOG* %s:%d:%s ->_5
      19  ?<Initializer for <Constant "*LOG* %s:%d:%s ->_6
      51  ?<Initializer for <Constant "Add task = %u, CH
      13  ?<Initializer for <Constant "FAILD : %d\r\n">>
      13  ?<Initializer for <Constant "FAILED <----">>
      21  ?<Initializer for <Constant "Frame_s count: %d
       6  ?<Initializer for <Constant "LLC.c">>
       6  ?<Initializer for <Constant "MAC.c">>
      42  ?<Initializer for <Constant "Module: %-15s Nam
       7  ?<Initializer for <Constant "NTMR.c">>
      22  ?<Initializer for <Constant "Network connect f
      18  ?<Initializer for <Constant "Network created\r
      26  ?<Initializer for <Constant "Network creation
      19  ?<Initializer for <Constant "Network sycronize
       7  ?<Initializer for <Constant "PASSED">>
      13  ?<Initializer for <Constant "PASSED: %d\r\n">>
       8  ?<Initializer for <Constant "RADIO.c">>
      20  ?<Initializer for <Constant "STACK FAILURE. HA
      11  ?<Initializer for <Constant "Sync send.">>
       6  ?<Initializer for <Constant "TIC.c">>
      12  ?<Initializer for <Constant "TS = 255 \r\n">>
      15  ?<Initializer for <Constant "Tests FAILED\r\n"
      15  ?<Initializer for <Constant "Tests PASSED\r\n"
      18  ?<Initializer for <Constant "Unit test symmary
       3  ?<Initializer for <Constant "\r\n">>
       3  ?<Initializer for <Constant "\r\n">>_1
       3  ?<Initializer for <Constant "\r\n">>_10
       3  ?<Initializer for <Constant "\r\n">>_11
       3  ?<Initializer for <Constant "\r\n">>_2
       3  ?<Initializer for <Constant "\r\n">>_3
       3  ?<Initializer for <Constant "\r\n">>_4
       3  ?<Initializer for <Constant "\r\n">>_5
       3  ?<Initializer for <Constant "\r\n">>_6
       3  ?<Initializer for <Constant "\r\n">>_7
       3  ?<Initializer for <Constant "\r\n">>_8
       3  ?<Initializer for <Constant "\r\n">>_9
      11  ?<Initializer for <Constant "ethernet.c">>
       8  ?<Initializer for <Constant "frame.c">>
      10  ?<Initializer for <Constant "manager.c">>
      12  ?<Initializer for <Constant "nwdebuger.c">>
       7  ?<Initializer for <Constant "sync.c">>
      11  ?<Initializer for <Constant "utest_GW.c">>
      13  ?<Initializer for <Constant "utest_NODE.c">>
      16  ?<Initializer for IV>
      16  ?<Initializer for IV>_1
      16  ?<Initializer for KEY>
      16  ?<Initializer for KEY>_1
       4  ?<Initializer for __Constant_15180>
       4  ?<Initializer for __Constant_19833891>
       4  ?<Initializer for __Constant_1>
       4  ?<Initializer for __Constant_1f4>
       4  ?<Initializer for __Constant_3d000000>
       4  ?<Initializer for __Constant_3e8>
       4  ?<Initializer for __Constant_447a0000>
       4  ?<Initializer for __Constant_7fff>
       4  ?<Initializer for __Constant_8000>
       4  ?<Initializer for __Constant_9>
       4  ?<Initializer for __Constant_a>
       4  ?<Initializer for __Constant_ffff8000>
       4  ?<Initializer for __Constant_fffffe0c>
       4  ?<Initializer for __Constant_ffffff>
      19  ?<Initializer for __FUNCTION__>
      12  ?<Initializer for __FUNCTION__>_1
      12  ?<Initializer for __FUNCTION__>_10
       9  ?<Initializer for __FUNCTION__>_11
      11  ?<Initializer for __FUNCTION__>_12
      11  ?<Initializer for __FUNCTION__>_13
      14  ?<Initializer for __FUNCTION__>_14
      14  ?<Initializer for __FUNCTION__>_15
       8  ?<Initializer for __FUNCTION__>_16
       8  ?<Initializer for __FUNCTION__>_17
      19  ?<Initializer for __FUNCTION__>_18
      13  ?<Initializer for __FUNCTION__>_19
      15  ?<Initializer for __FUNCTION__>_2
      15  ?<Initializer for __FUNCTION__>_20
      15  ?<Initializer for __FUNCTION__>_21
      15  ?<Initializer for __FUNCTION__>_22
      15  ?<Initializer for __FUNCTION__>_23
      19  ?<Initializer for __FUNCTION__>_24
      18  ?<Initializer for __FUNCTION__>_25
      29  ?<Initializer for __FUNCTION__>_26
      18  ?<Initializer for __FUNCTION__>_27
      18  ?<Initializer for __FUNCTION__>_28
      19  ?<Initializer for __FUNCTION__>_29
      16  ?<Initializer for __FUNCTION__>_3
      17  ?<Initializer for __FUNCTION__>_30
       9  ?<Initializer for __FUNCTION__>_31
      11  ?<Initializer for __FUNCTION__>_32
      16  ?<Initializer for __FUNCTION__>_4
      13  ?<Initializer for __FUNCTION__>_5
      18  ?<Initializer for __FUNCTION__>_6
      14  ?<Initializer for __FUNCTION__>_7
      12  ?<Initializer for __FUNCTION__>_8
      14  ?<Initializer for __FUNCTION__>_9
      16  ?<Initializer for default_iv>
      16  ?<Initializer for default_key>
       2  ??Subroutine72_0
      19  ??Subroutine73_0
       8  ??Subroutine74_0
       4  ??Subroutine75_0
       6  ??Subroutine76_0
       6  ??Subroutine77_0
       2  ??Subroutine78_0
       3  ??Subroutine79_0
       5  ??Subroutine80_0
       4  ??Subroutine81_0
       3  ??Subroutine82_0
       5  ??Subroutine83_0
       5  ??Subroutine84_0
       6  ??Subroutine85_0
       1  ??Subroutine86_0
       5  ??Subroutine87_0
       8  ??Subroutine88_0
       4  ??Subroutine89_0
       7  ??Subroutine90_0
       9  ??Subroutine91_0
       4  ??Subroutine92_0
       6  ??Subroutine93_0
       1  ??Subroutine94_0
       4  ??Subroutine95_0
      21  ?Subroutine0
       7  ?Subroutine1
       4  ?Subroutine10
       6  ?Subroutine11
       5  ?Subroutine12
       6  ?Subroutine13
       5  ?Subroutine14
       5  ?Subroutine15
       4  ?Subroutine16
       6  ?Subroutine17
       6  ?Subroutine18
       6  ?Subroutine19
       7  ?Subroutine2
       7  ?Subroutine20
       6  ?Subroutine21
       5  ?Subroutine22
      20  ?Subroutine23
       3  ?Subroutine24
      47  ?Subroutine25
      25  ?Subroutine26
      18  ?Subroutine27
      16  ?Subroutine28
      14  ?Subroutine29
       2  ?Subroutine3
       5  ?Subroutine30
      21  ?Subroutine31
      11  ?Subroutine32
       6  ?Subroutine33
      17  ?Subroutine34
      11  ?Subroutine35
      11  ?Subroutine36
       6  ?Subroutine37
       9  ?Subroutine38
       3  ?Subroutine39
      15  ?Subroutine4
       3  ?Subroutine40
      14  ?Subroutine41
       6  ?Subroutine42
       9  ?Subroutine43
      12  ?Subroutine44
       3  ?Subroutine45
       7  ?Subroutine46
       3  ?Subroutine47
      10  ?Subroutine48
       5  ?Subroutine49
       5  ?Subroutine5
       4  ?Subroutine50
      10  ?Subroutine51
      11  ?Subroutine52
       9  ?Subroutine53
       9  ?Subroutine54
       9  ?Subroutine55
      19  ?Subroutine56
      14  ?Subroutine57
      12  ?Subroutine58
      13  ?Subroutine59
      22  ?Subroutine6
       7  ?Subroutine60
       5  ?Subroutine61
       9  ?Subroutine62
       8  ?Subroutine63
       3  ?Subroutine64
      10  ?Subroutine65
      13  ?Subroutine66
      13  ?Subroutine67
       6  ?Subroutine68
      12  ?Subroutine69
       5  ?Subroutine7
       9  ?Subroutine70
      11  ?Subroutine71
       5  ?Subroutine8
       9  ?Subroutine9
     355  AES_CCMDecrypt
       6  AES_CCMDecrypt::?relay
     349  AES_CCMEncrypt
       6  AES_CCMEncrypt::?relay
     270  AES_StreamCoder
       6  AES_StreamCoder::?relay
      76  AES_init
       6  AES_init::?relay
     254  CBCMAC_buf_encrypt
       6  CBCMAC_buf_encrypt::?relay
      75  CF_init
       6  CF_init::?relay
       1  CLKCONCMD
       1  CLKCONSTA
       4  COMPARE_TIME
      36  CONFIG
     270  CTR_enc_decrypt
       6  CTR_enc_decrypt::?relay
      70  Callback_execution
       6  Callback_execution::?relay
       4  DELAY_CALIBRATE_TICS
       1  DMA0CFGH
       1  DMA0CFGL
       1  DMA1CFGH
       1  DMA1CFGL
       1  DMAARM
       1  DMAREQ
       8  DMA_AES_DW
       8  DMA_AES_UP
       1  ENCCS
      84  ETH_Init
       6  ETH_Init::?relay
     363  ETH_RX_HNDL
       6  ETH_RX_HNDL::?relay
      69  ETH_Set_RXCallback
       6  ETH_Set_RXCallback::?relay
       2  EventCallback
       2  FirstTask
       4  HeadAllocFunc
      16  IV
      16  IV
      16  KEY
      16  KEY
       4  LAST_SYNC_TIME
      33  LED
       6  LED::?relay
     403  LLC_AddTask
       6  LLC_AddTask::?relay
      10  LLC_GetTaskLen
       6  LLC_GetTaskLen::?relay
     102  LLC_Init
       6  LLC_Init::?relay
      70  LLC_RX_HNDL
       6  LLC_RX_HNDL::?relay
      35  LLC_Reset
       6  LLC_Reset::?relay
      41  LLC_SE_HNDL
       6  LLC_SE_HNDL::?relay
      69  LLC_SetRXCallback
       6  LLC_SetRXCallback::?relay
     239  LLC_Shelduler
       6  LLC_Shelduler::?relay
     137  LLC_TimeAlloc
       6  LLC_TimeAlloc::?relay
     350  MACSlotTable
      36  MAC_CloseRXSlot
       6  MAC_CloseRXSlot::?relay
       1  MAC_ENABLE_MODULE
      14  MAC_Enable
       6  MAC_Enable::?relay
      21  MAC_GetRXState
       6  MAC_GetRXState::?relay
      19  MAC_GetTXState
       6  MAC_GetTXState::?relay
      27  MAC_Init
       6  MAC_Init::?relay
      54  MAC_OpenRXSlot
       6  MAC_OpenRXSlot::?relay
     185  MAC_RX_HNDL
       6  MAC_RX_HNDL::?relay
      37  MAC_Reset
       6  MAC_Reset::?relay
     297  MAC_Send
       6  MAC_Send::?relay
      10  MAC_SetRXCallback
       6  MAC_SetRXCallback::?relay
     243  MAC_TX_HNDL
       6  MAC_TX_HNDL::?relay
      26  MAC_setIV
       6  MAC_setIV::?relay
      24  MAC_setKEY
       6  MAC_setKEY::?relay
     275  MG_Connect
       6  MG_Connect::?relay
       1  MG_MODULES_INITED
      12  MyLowLevelPutchar
       6  MyLowLevelPutchar::?relay
       1  NBR_FRAME
       4  NEXT_SYNC_TIME
       4  NODE_NONCE
       4  NODE_RTC
       4  NODE_UPTIME
      17  NT_GetTime
       6  NT_GetTime::?relay
      48  NT_Init
       6  NT_Init::?relay
     262  NT_SetCompare
       6  NT_SetCompare::?relay
      10  NT_SetEventCallback
       6  NT_SetEventCallback::?relay
     114  NT_SetTime
       6  NT_SetTime::?relay
      94  NT_WaitTime
       6  NT_WaitTime::?relay
       1  P0SEL
       1  P1DIR
       1  PERCFG
       3  RADIO_CFG
       1  RFD
       1  RFIRQF0
       1  RFIRQF1
       1  RFST
       4  RI_CCA_REJECT
       4  RI_CRC_ERROR
      10  RI_GetCCAReject
       6  RI_GetCCAReject::?relay
      10  RI_GetCRCError
       6  RI_GetCRCError::?relay
      10  RI_GetUptime
       6  RI_GetUptime::?relay
     893  RI_Receive
       6  RI_Receive::?relay
     349  RI_Send
       6  RI_Send::?relay
      24  RI_SetChannel
       6  RI_SetChannel::?relay
       4  RI_UPTIME
     124  RI_cfg
       6  RI_cfg::?relay
      67  RI_init
       6  RI_init::?relay
       2  RXCallback
       2  RXCallback
       2  RXCallback
       2  RXCallback
      22  ReadTimer
       6  ReadTimer::?relay
       2  SECallback
       1  SLEEPSTA
       1  ST0
       1  ST1
       1  ST2
      66  STACK_FAILURE
       6  STACK_FAILURE::?relay
       1  STLOAD
       2  SYNC_ACCURATE_NETWORK_TIME
       4  SYNC_SENDED
       1  SY_ENABLE_MODULE
      10  SY_Enable
       6  SY_Enable::?relay
     164  SY_Init
       6  SY_Init::?relay
       7  SY_Reset
       6  SY_Reset::?relay
     680  SY_SYNC_NETWORK
       6  SY_SYNC_NETWORK::?relay
      71  SY_TIME_ALLOC_MASTER
       6  SY_TIME_ALLOC_MASTER::?relay
     256  SY_TS1_HNDL_MASTER
       6  SY_TS1_HNDL_MASTER::?relay
      27  SY_setIV
       6  SY_setIV::?relay
      27  SY_setKEY
       6  SY_setKEY::?relay
       7  SY_sync_sended
       6  SY_sync_sended::?relay
     159  SendData
       6  SendData::?relay
       2  SyncTimeAllocCallback
       1  T2CTRL
       1  T2M0
       1  T2M1
       1  T2MOVF0
       1  T2MOVF1
      27  TIC_CloseAllState
       6  TIC_CloseAllState::?relay
      10  TIC_GetNonce
       6  TIC_GetNonce::?relay
      10  TIC_GetRTC
       6  TIC_GetRTC::?relay
      21  TIC_GetRXState
       6  TIC_GetRXState::?relay
      21  TIC_GetTXState
       6  TIC_GetTXState::?relay
       7  TIC_GetTimeStampTS0
       6  TIC_GetTimeStampTS0::?relay
      17  TIC_GetTimer
       6  TIC_GetTimer::?relay
      10  TIC_GetUptime
       6  TIC_GetUptime::?relay
     343  TIC_HW_Timer_IRQ
       6  TIC_HW_Timer_IRQ::?relay
      20  TIC_Init
       6  TIC_Init::?relay
      28  TIC_Reset
       6  TIC_Reset::?relay
      24  TIC_SetNonce
       6  TIC_SetNonce::?relay
      38  TIC_SetRTC
       6  TIC_SetRTC::?relay
      69  TIC_SetRXCallback
       6  TIC_SetRXCallback::?relay
      29  TIC_SetRXState
       6  TIC_SetRXState::?relay
      66  TIC_SetSECallback
       6  TIC_SetSECallback::?relay
      69  TIC_SetSyncTimeAllocCallback
       6  TIC_SetSyncTimeAllocCallback::?relay
      69  TIC_SetTS1Callback
       6  TIC_SetTS1Callback::?relay
      68  TIC_SetTXCallback
       6  TIC_SetTXCallback::?relay
      29  TIC_SetTXState
       6  TIC_SetTXState::?relay
      71  TIC_SetTimer
       6  TIC_SetTimer::?relay
       2  TIC_SleepTime
       6  TIC_SleepTime::?relay
       0  TIC_SlotActivityTime
       6  TIC_SlotActivityTime::?relay
      18  TIC_SlotTime
       6  TIC_SlotTime::?relay
      61  TIC_TDMAShelduler
       6  TIC_TDMAShelduler::?relay
     164  TIC_TimeUsFromTS0
       6  TIC_TimeUsFromTS0::?relay
      35  TIM_TimeStamp
       6  TIM_TimeStamp::?relay
      19  TIM_copy
       6  TIM_copy::?relay
     230  TIM_delay
       6  TIM_delay::?relay
     248  TIM_init
       6  TIM_init::?relay
     136  TIM_passedTime
       6  TIM_passedTime::?relay
       2  TOFFSET
       2  TS1Callback
      50  TSStateTable
       2  TXCallback
       8  TimeStampTS0
     101  TimerCompareInterrupt
       3  TimerCompareInterrupt::??INTVEC 43
       1  U0BAUD
       1  U0CSR
       1  U0DBUF
       1  U0GCR
       1  _A_IEN0
       1  _A_IRCON
       1  _A_P1
       4  __Constant_1
       4  __Constant_15180
       4  __Constant_19833891
       4  __Constant_1f4
       4  __Constant_3d000000
       4  __Constant_3e8
       4  __Constant_447a0000
       4  __Constant_7fff
       4  __Constant_8000
       4  __Constant_9
       4  __Constant_a
       4  __Constant_ffff8000
       4  __Constant_fffffe0c
       4  __Constant_ffffff
      97  __write
       6  __write::?relay
     162  buf
      16  default_iv
      16  default_key
     348  frame_addHeader
       6  frame_addHeader::?relay
     156  frame_create
       6  frame_create::?relay
     219  frame_delHeader
       6  frame_delHeader::?relay
      75  frame_delete
       6  frame_delete::?relay
       7  frame_getCount
       6  frame_getCount::?relay
      13  frame_len
       6  frame_len::?relay
     183  generateAuthData
       6  generateAuthData::?relay
      55  heap_ptr
       6  heap_ptr::?relay
       3  heap_size
       6  heap_size::?relay
      12  main
       6  main::?relay
      67  memory_compare
       6  memory_compare::?relay
       1  nbrTasks
      18  nwDebugerInit
       6  nwDebugerInit::?relay
       2  pACK
      14  re_free
       6  re_free::?relay
      20  re_malloc
       6  re_malloc::?relay
      25  re_memcpy
       6  re_memcpy::?relay
      64  readRandom
       6  readRandom::?relay
       4  ret_val
     114  suite_GW
       6  suite_GW::?relay
     114  suite_NODE
       6  suite_NODE::?relay
       4  sync_send_time
       1  tasksBLOCK
      70  umsg
       6  umsg::?relay
      37  umsg_line
       6  umsg_line::?relay
      98  umsg_summary
       6  umsg_summary::?relay
       6  utestSigTraceInit
       6  utestSigTraceInit::?relay
       4  utest_summary
       4  val
      56  xor_calc
       6  xor_calc::?relay
     486  -- Other

 
 12 839 bytes in segment BANKED_CODE
    702 bytes in segment BANK_RELAYS
      3 bytes in segment INTVEC
    101 bytes in segment NEAR_CODE
     33 bytes in segment SFR_AN
  1 448 bytes in segment XDATA_I
  1 448 bytes in segment XDATA_ID
    721 bytes in segment XDATA_Z
 
  2 189 bytes of CODE     memory (+ 65 bytes shared)
      0 bytes of DATA     memory (+ 33 bytes shared)
 12 773 bytes of HUGECODE memory (+ 66 bytes shared)
  2 113 bytes of XDATA    memory (+ 56 bytes shared)

Errors: none
Warnings: 7
