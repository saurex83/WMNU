###############################################################################
#
# IAR C/C++ Compiler V10.10.1.4655 for 8051               02/Dec/2019  12:47:47
# Copyright 2004-2017 IAR Systems AB.
# PC-locked license - IAR Embedded Workbench for 8051
#
#    Core               =  plain
#    Code model         =  banked
#    Data model         =  large
#    Calling convention =  xdata reentrant
#    Constant location  =  data
#    Dptr setup         =  1,16
#                          
#    Source file        =  
#        \\vmware-host\Shared Folders\Projects\WMNU\IAR\SHARE_PRJ_SRC\coder.c
#    Command line       =  
#        -f C:\Users\08A4~1\AppData\Local\Temp\EW16B8.tmp
#        ("\\vmware-host\Shared
#        Folders\Projects\WMNU\IAR\SHARE_PRJ_SRC\coder.c" -lc
#        "\\vmware-host\Shared
#        Folders\Projects\WMNU\IAR\PRJ_UNITEST\Debug\List" -o
#        "\\vmware-host\Shared Folders\Projects\WMNU\IAR\PRJ_UNITEST\Debug\Obj"
#        -e --debug --core=plain --dptr=16,1 --data_model=large
#        --code_model=banked --calling_convention=xdata_reentrant
#        --place_constants=data --nr_virtual_regs 8 --dlib_config "C:\Program
#        Files (x86)\IAR Systems\Embedded Workbench
#        8.0\8051\LIB\DLIB\dl8051Normal.h" --no_path_in_file_macros -I
#        "\\vmware-host\Shared Folders\Projects\WMNU\IAR\SHARE_PRJ_SRC\" -On
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_cross_call --mfc "\\vmware-host\Shared
#        Folders\Projects\WMNU\IAR\SHARE_PRJ_SRC\delays.c"
#        "\\vmware-host\Shared
#        Folders\Projects\WMNU\IAR\SHARE_PRJ_SRC\ethernet.c"
#        "\\vmware-host\Shared Folders\Projects\WMNU\IAR\SHARE_PRJ_SRC\frame.c"
#        "\\vmware-host\Shared Folders\Projects\WMNU\IAR\SHARE_PRJ_SRC\LLC.c"
#        "\\vmware-host\Shared Folders\Projects\WMNU\IAR\SHARE_PRJ_SRC\MAC.c"
#        "\\vmware-host\Shared Folders\Projects\WMNU\IAR\SHARE_PRJ_SRC\mem.c"
#        "\\vmware-host\Shared Folders\Projects\WMNU\IAR\SHARE_PRJ_SRC\NTMR.c"
#        "\\vmware-host\Shared
#        Folders\Projects\WMNU\IAR\SHARE_PRJ_SRC\nwdebuger.c"
#        "\\vmware-host\Shared Folders\Projects\WMNU\IAR\SHARE_PRJ_SRC\RADIO.c"
#        "\\vmware-host\Shared Folders\Projects\WMNU\IAR\SHARE_PRJ_SRC\TIC.c"
#        "\\vmware-host\Shared
#        Folders\Projects\WMNU\IAR\PRJ_UNITEST\src\utest.c"
#        "\\vmware-host\Shared
#        Folders\Projects\WMNU\IAR\PRJ_UNITEST\src\utest_coder.c"
#        "\\vmware-host\Shared
#        Folders\Projects\WMNU\IAR\PRJ_UNITEST\src\utest_delays.c"
#        "\\vmware-host\Shared
#        Folders\Projects\WMNU\IAR\PRJ_UNITEST\src\utest_frame.c"
#        "\\vmware-host\Shared
#        Folders\Projects\WMNU\IAR\PRJ_UNITEST\src\utest_Frames.c"
#        "\\vmware-host\Shared
#        Folders\Projects\WMNU\IAR\PRJ_UNITEST\src\utest_LLC.c"
#        "\\vmware-host\Shared
#        Folders\Projects\WMNU\IAR\PRJ_UNITEST\src\utest_MAC.c"
#        "\\vmware-host\Shared
#        Folders\Projects\WMNU\IAR\PRJ_UNITEST\src\utest_malloc.c"
#        "\\vmware-host\Shared
#        Folders\Projects\WMNU\IAR\PRJ_UNITEST\src\utest_NTMR.c"
#        "\\vmware-host\Shared
#        Folders\Projects\WMNU\IAR\PRJ_UNITEST\src\utest_printf_uart.c"
#        "\\vmware-host\Shared
#        Folders\Projects\WMNU\IAR\PRJ_UNITEST\src\utest_radio.c"
#        "\\vmware-host\Shared
#        Folders\Projects\WMNU\IAR\PRJ_UNITEST\src\utest_suite.c"
#        "\\vmware-host\Shared
#        Folders\Projects\WMNU\IAR\PRJ_UNITEST\src\utest_TIC.c")
#    Locale             =  Russian_Russia.1251
#    List file          =  
#        \\vmware-host\Shared
#        Folders\Projects\WMNU\IAR\PRJ_UNITEST\Debug\List\coder.lst
#    Object file        =  
#        \\vmware-host\Shared
#        Folders\Projects\WMNU\IAR\PRJ_UNITEST\Debug\Obj\coder.r51
#
###############################################################################

\\vmware-host\Shared Folders\Projects\WMNU\IAR\SHARE_PRJ_SRC\coder.c
      1          /*!
      2          \file Модуль шифрования данных
      3          \brief Функции кодирования данных
      4          */
      5          
      6          #include "coder.h"
      7          #include "ioCC2530.h"
      8          #include "string.h"
      9          #include "delays.h" // Для профилирования, Отладка
     10          
     11          #define AES_START()  {ENCCS |= 0x01;} //!< Запуск выполнения команды  
     12          #define AES_SET_MODE(mode) {ENCCS &= ~0x70; ENCCS |= mode;} //!< Установка режима
     13          #define AES_SET_OPERATION(op) {ENCCS = (ENCCS & ~0x07) | op;} 
     14          #define AES_RDY() (ENCCS & 8) //!< Состояние модуля
     15          
     16          #define ST_DEF(STRUCT, FILD, VAL)  STRUCT.FILD = VAL
     17          #define HADDR(ADDR) ((uint16_t)ADDR >> 8)
     18          #define LADDR(ADDR) ((uint16_t)ADDR)
     19          #define BV(n)                   (1 << (n))
     20          #define MIC_2_MICLEN(m)         (BV((m&3)+1) & ~3)
     21          
     22          // Режимы шифрования
     23          #define AES_MODE_CBC            0x00
     24          #define AES_MODE_CFB            0x10
     25          #define AES_MODE_OFB            0x20
     26          #define AES_MODE_CTR            0x30
     27          #define AES_MODE_ECB            0x40
     28          #define AES_MODE_CBCMAC         0x50
     29          
     30          // Операции 
     31          #define AES_ENCRYPT             0x00
     32          #define AES_DECRYPT             0x02
     33          #define AES_LOAD_KEY            0x04
     34          #define AES_LOAD_IV             0x06
     35          
     36          #define ENC_DW 29 // DMA AES тригер запрос загрузки
     37          #define ENC_UP 30 // DMA AES тригер запрос выгрузки
     38          
     39          #define STREAM_ENC_MODE     AES_MODE_OFB //!< Метод шифрования потока данных
     40          
     41          // Доступные методы
     42          void AES_StreamCoder(bool enc_mode, uint8_t *src, uint8_t *dst, 
     43                               uint8_t *key, uint8_t *nonce, uint8_t len);
     44          
     45          // Приватные функции
     46          static inline uint8_t generateAuthData(uint8_t *src, uint8_t *nonce, uint8_t c,
     47                                                 uint8_t f, uint8_t lm);
     48          static void CBCMAC_buf_encrypt(uint8_t len, uint8_t *key, uint8_t *mac);
     49          
     50          /**
     51          @brief Локальный буфер для работы режима CCM
     52          @detail 128 длина сообщения. 18 длинна блока B0 и строки состояния.
     53           16 длина дополнения нулями
     54          */
     55          static uint8_t buf[128+18+16]; 
     56          
     57          
     58          typedef struct //!< Структура блока B0 для режима CCM
     59          {
     60            struct 
     61            {
     62              uint8_t L:3;
     63              uint8_t M:3;
     64              uint8_t A_Data:1;
     65            } flag;
     66            uint16_t nonce[9];
     67            uint8_t L_M[6];
     68          } __attribute__((packed)) B0_s;
     69          
     70          typedef struct //!< Структура блока A0 для режима CCM
     71          {
     72            struct 
     73            {
     74              uint8_t L:3;
     75            } flag;
     76            uint8_t nonce[11];
     77            uint8_t ctr;
     78          } __attribute__((packed)) A0_s;
     79          
     80          typedef struct //!< Структура с настройками DMA 
     81          {
     82            uint8_t  SRCADDRH;
     83            uint8_t  SRCADDRL;
     84            uint8_t  DSTADDRH;
     85            uint8_t  DSTADDRL;
     86            struct  {
     87            uint8_t   LENH        :5;
     88            uint8_t   VLEN        :3;
     89            };
     90            struct  {
     91            uint8_t   LENL        :8;
     92            };
     93            struct  {
     94            uint8_t   TRIG        :5;
     95            uint8_t   TMODE       :2;
     96            uint8_t   WORDSIZE    :1;
     97            };
     98            struct {
     99            uint8_t   PRIORITY    :2;
    100            uint8_t   M8          :1;
    101            uint8_t   IRQMASK     :1;
    102            uint8_t   DESTINC     :2;
    103            uint8_t   SRCINC      :2;
    104            };
    105          } __attribute__((packed)) DMA_AES_s ;
    106          
    107          DMA_AES_s DMA_AES_DW; //!< DMA на запись
    108          DMA_AES_s DMA_AES_UP; //!< DMA на чтение
    109          
    110          
    111          /**
    112          @brief Иницилизация модуля
    113          @detail Модуль использует DMA каналы 0 и 1
    114          */
    115          void AES_init(void)
    116          {
    117            // Настроим канал 0 DMA для загрузки данных в AES
    118            uint16_t CONF_ADDR = (uint16_t)&DMA_AES_DW;
    119            DMA0CFGH = CONF_ADDR >> 8;
    120            DMA0CFGL = CONF_ADDR & 0xFF;
    121            
    122            // Настроим канал 1 DMA для выгрузки данных из AES
    123            CONF_ADDR = (uint16_t)&DMA_AES_UP;
    124            DMA1CFGH = CONF_ADDR >> 8;
    125            DMA1CFGL = CONF_ADDR & 0xFF;
    126            
    127            ST_DEF(DMA_AES_DW, DSTADDRH, 0x70); // Пишем данные XENCDI = 0xB1 
    128            ST_DEF(DMA_AES_DW, DSTADDRL, 0xB1); //  
    129            ST_DEF(DMA_AES_DW, PRIORITY, 0x00); // Низкий приоритет
    130            ST_DEF(DMA_AES_DW, M8, 0x00); // Используем 8 бит для счетика длинны
    131            ST_DEF(DMA_AES_DW, IRQMASK, 0x00); // Запрещаем генерировать перывания
    132            ST_DEF(DMA_AES_DW, DESTINC, 0x00); // Не увеличиваем адресс назначения
    133            ST_DEF(DMA_AES_DW, SRCINC, 0x01); // Увеличиваем адресс источника
    134            ST_DEF(DMA_AES_DW, TRIG, ENC_DW); // Тригер по загрузке
    135            ST_DEF(DMA_AES_DW, WORDSIZE, 0x00); // Копируем по 1 байту
    136            ST_DEF(DMA_AES_DW, TMODE, 0x01); //  Блочное копирование по тригеру
    137            ST_DEF(DMA_AES_DW, VLEN, 0x00); //  Количество байт определяет поле LEN  
    138            ST_DEF(DMA_AES_DW, LENH, 0x00); 
    139            
    140            ST_DEF(DMA_AES_UP, SRCADDRH, 0x70); // Читаем данные из X_ENCDO  
    141            ST_DEF(DMA_AES_UP, SRCADDRL, 0xB2);  
    142            ST_DEF(DMA_AES_UP, PRIORITY, 0x00); // Низкий приоритет
    143            ST_DEF(DMA_AES_UP, M8, 0x00); // Используем 8 бит для счетика длинны
    144            ST_DEF(DMA_AES_UP, IRQMASK, 0x00); // Запрещаем генерировать перывания
    145            ST_DEF(DMA_AES_UP, DESTINC, 0x01); // Увеличиваем адресс назначения
    146            ST_DEF(DMA_AES_UP, SRCINC, 0x00); // Не увеличиваем адресс источника
    147            ST_DEF(DMA_AES_UP, TRIG, ENC_UP); // Тригер по выгрузке
    148            ST_DEF(DMA_AES_UP, WORDSIZE, 0x00); // Копируем по 1 байту
    149            ST_DEF(DMA_AES_UP, TMODE, 0x01); //  Блочное копирование по тригеру
    150            ST_DEF(DMA_AES_UP, VLEN, 0x00); //  Количество байт определяет поле LEN  
    151            ST_DEF(DMA_AES_UP, LENH, 0x00); 
    152          }
    153          
    154          /**
    155          @brief Шифрует/дешифрует поток данных во время радиопередачи. Без проверки MIC
    156          @param[in] enc_mode Режим работы процедуры. true - шифрование.
    157          @param[in] src Указатель на данные подлежащии шифрованию
    158          @param[in] dst Указтель куда будут помещены зашифрованные данные
    159          @param[in] key Указатье на ключ. 16 байт
    160          @param[in] iv  Указатель на вектор иницилизации. 16 байт 
    161          @param[in] len Длинна данных
    162          */
    163          void AES_StreamCoder(bool enc_mode, uint8_t *src, uint8_t *dst, uint8_t *key,
    164                                   uint8_t *iv, uint8_t len)
    165          {
    166            // Установим метод кодироваения
    167            AES_SET_MODE(STREAM_ENC_MODE);
    168              
    169            // Загружаем ключ
    170            AES_SET_OPERATION(AES_LOAD_KEY);
    171            ST_DEF(DMA_AES_DW, SRCADDRL, LADDR(key));
    172            ST_DEF(DMA_AES_DW, SRCADDRH, HADDR(key));
    173            ST_DEF(DMA_AES_DW, LENL, 16);
    174            DMAARM |= 0x01;
    175            while(!AES_RDY());
    176            AES_START();
    177            while (DMAARM);
    178          
    179            // Загружаем IV
    180            AES_SET_OPERATION(AES_LOAD_IV);
    181            ST_DEF(DMA_AES_DW, SRCADDRL, LADDR(iv));
    182            ST_DEF(DMA_AES_DW, SRCADDRH, HADDR(iv));
    183            ST_DEF(DMA_AES_DW, LENL, 16);
    184            DMAARM |= 0x01;
    185            while(!AES_RDY());
    186            AES_START();
    187            while (DMAARM);
    188          
    189            // Установим необходимую операцию AES
    190            if (enc_mode) 
    191              AES_SET_OPERATION(AES_ENCRYPT)
    192            else 
    193              AES_SET_OPERATION(AES_DECRYPT)
    194            
    195            switch(STREAM_ENC_MODE) 
    196            {
    197            case AES_MODE_ECB: // ECB, CBC не реализованы
    198            case AES_MODE_CBC:
    199              break;
    200            case AES_MODE_CFB:
    201            case AES_MODE_OFB:
    202            case AES_MODE_CTR:
    203              {
    204                // Загрузка блоками по 128 бит с разделением на под-блоки по 32 бита
    205                uint8_t nbrBlocks = len / 16; // Количество целых блоков по 128 бит
    206                uint8_t ptr, sub_ptr; // Смещение
    207                uint8_t *download, *upload;
    208                
    209                // Для этих типов шифрования длина блоков по 4 байта
    210                ST_DEF(DMA_AES_DW, LENL, 4);
    211                ST_DEF(DMA_AES_UP, LENL, 4);
    212                
    213                // Шифруем все целые блоки
    214                for (uint8_t block = 0; block < nbrBlocks; block ++)
    215                {
    216                  ptr = 16 * block;
    217                  while(!AES_RDY());
    218                  AES_START();
    219                  for (uint8_t j = 0; j < 4; j++)
    220                  {
    221                    sub_ptr = ptr + 4*j;
    222                    download = &src[sub_ptr];
    223                    upload = &dst[sub_ptr];
    224                    // Указываем адресс DMA откуда читать данные
    225                    ST_DEF(DMA_AES_DW, SRCADDRL, LADDR(download));
    226                    ST_DEF(DMA_AES_DW, SRCADDRH, HADDR(download));
    227                    // Указываем адрес DMA куда записывать данные          
    228                    ST_DEF(DMA_AES_UP, DSTADDRL, LADDR(upload));
    229                    ST_DEF(DMA_AES_UP, DSTADDRH, HADDR(upload));
    230                    // Активируем DMA
    231                    DMAARM |= 0x03;  
    232                    DMAREQ |= 0x01;
    233                    while (DMAARM);          
    234                  }
    235                }     
    236                // Шифруем последний блок
    237                uint8_t block_len = len % 16; // Размер последнего блока
    238                
    239                // Завершаем работу если блок пустой
    240                if (!block_len)
    241                  return;
    242                
    243                uint8_t padding_block[16]; // Блок заполненый нулями
    244                ptr = 16*nbrBlocks; // Смещение на первый байт последнего блока в src
    245                memset(padding_block, 0x00, sizeof(padding_block)); // Заполняем нулями
    246                memcpy(padding_block, &src[ptr], block_len); // Копируем данные
    247                
    248                while(!AES_RDY());
    249                AES_START();
    250                for (uint8_t j = 0; j < 4; j++)
    251                  {
    252                    sub_ptr = 4*j;
    253                    download = &padding_block[sub_ptr];
    254                    // Указываем адресс DMA откуда читать данные
    255                    ST_DEF(DMA_AES_DW, SRCADDRL, LADDR(download));
    256                    ST_DEF(DMA_AES_DW, SRCADDRH, HADDR(download));
    257                    // Указываем аддрес DMA куда записывать данные          
    258                    ST_DEF(DMA_AES_UP, DSTADDRL, LADDR(download));
    259                    ST_DEF(DMA_AES_UP, DSTADDRH, HADDR(download));
    260                    // Активируем DMA
    261                    DMAARM |= 0x03;  
    262                    DMAREQ |= 0x01;
    263                    while (DMAARM);
    264                  }
    265                memcpy(&dst[ptr], padding_block, block_len); // Копируем в src
    266                
    267              } //CASE
    268              
    269              break;
    270            } 
    271          }
    272          
    273          /**
    274          @brief Шифрует/дешифрует поток данных во время радиопередачи. Без проверки MIC
    275          @param[in] enc_mode Режим работы процедуры. true - шифрование.
    276          @param[in] src Указатель на данные подлежащии шифрованию
    277          @param[in] dst Указтель куда будут помещены зашифрованные данные
    278          @param[in] key Указатье на ключ. 16 байт
    279          @param[in] iv  Указатель на вектор иницилизации. 16 байт 
    280          @param[in] len Длинна данных
    281          */
    282          static void CTR_enc_decrypt(bool enc_mode, uint8_t *src, uint8_t *dst, uint8_t *key,
    283                                   uint8_t *iv, uint8_t len)
    284          {
    285            // Установим метод кодироваения
    286            AES_SET_MODE(AES_MODE_CTR);
    287            
    288            // Загружаем ключ
    289            AES_SET_OPERATION(AES_LOAD_KEY);
    290            ST_DEF(DMA_AES_DW, SRCADDRL, LADDR(key));
    291            ST_DEF(DMA_AES_DW, SRCADDRH, HADDR(key));
    292            ST_DEF(DMA_AES_DW, LENL, 16);
    293            DMAARM |= 0x01;
    294            while(!AES_RDY());
    295            AES_START();
    296            while (DMAARM);
    297          
    298            // Загружаем IV
    299            AES_SET_OPERATION(AES_LOAD_IV);
    300            ST_DEF(DMA_AES_DW, SRCADDRL, LADDR(iv));
    301            ST_DEF(DMA_AES_DW, SRCADDRH, HADDR(iv));
    302            ST_DEF(DMA_AES_DW, LENL, 16);
    303            DMAARM |= 0x01;
    304            while(!AES_RDY());
    305            AES_START();
    306            while (DMAARM);
    307          
    308            // Установим необходимую операцию AES
    309            if (enc_mode) 
    310              AES_SET_OPERATION(AES_ENCRYPT)
    311            else 
    312              AES_SET_OPERATION(AES_DECRYPT)
    313            
    314            // Загрузка блоками по 128 бит с разделением на под-блоки по 32 бита
    315            uint8_t nbrBlocks = len / 16; // Количество целых блоков по 128 бит
    316            uint8_t ptr, sub_ptr; // Смещение
    317            uint8_t *download, *upload;
    318                
    319            // Для этих типов шифрования длина блоков по 4 байта
    320            ST_DEF(DMA_AES_DW, LENL, 4);
    321            ST_DEF(DMA_AES_UP, LENL, 4);
    322                
    323            // Шифруем все целые блоки
    324            for (uint8_t block = 0; block < nbrBlocks; block ++)
    325              {
    326                ptr = 16 * block;
    327                while(!AES_RDY());
    328                AES_START();
    329                for (uint8_t j = 0; j < 4; j++)
    330                  {
    331                    sub_ptr = ptr + 4*j;
    332                    download = &src[sub_ptr];
    333                    upload = &dst[sub_ptr];
    334                    // Указываем адресс DMA откуда читать данные
    335                    ST_DEF(DMA_AES_DW, SRCADDRL, LADDR(download));
    336                    ST_DEF(DMA_AES_DW, SRCADDRH, HADDR(download));
    337                    // Указываем адрес DMA куда записывать данные          
    338                    ST_DEF(DMA_AES_UP, DSTADDRL, LADDR(upload));
    339                    ST_DEF(DMA_AES_UP, DSTADDRH, HADDR(upload));
    340                    // Активируем DMA
    341                    DMAARM |= 0x03;  
    342                    DMAREQ |= 0x01;
    343                    while (DMAARM);          
    344                  }
    345              }     
    346              // Шифруем последний блок
    347              uint8_t block_len = len % 16; // Размер последнего блока
    348                
    349              // Завершаем работу если блок пустой
    350              if (!block_len)
    351                return;
    352                
    353              uint8_t padding_block[16]; // Блок заполненый нулями
    354              ptr = 16*nbrBlocks; // Смещение на первый байт последнего блока в src
    355              memset(padding_block, 0x00, sizeof(padding_block)); // Заполняем нулями
    356              memcpy(padding_block, &src[ptr], block_len); // Копируем данные
    357              
    358              while(!AES_RDY());
    359              AES_START();
    360              for (uint8_t j = 0; j < 4; j++)
    361                {
    362                  sub_ptr = 4*j;
    363                  download = &padding_block[sub_ptr];
    364                  // Указываем адресс DMA откуда читать данные
    365                  ST_DEF(DMA_AES_DW, SRCADDRL, LADDR(download));
    366                  ST_DEF(DMA_AES_DW, SRCADDRH, HADDR(download));
    367                  // Указываем аддрес DMA куда записывать данные          
    368                  ST_DEF(DMA_AES_UP, DSTADDRL, LADDR(download));
    369                  ST_DEF(DMA_AES_UP, DSTADDRH, HADDR(download));
    370                  // Активируем DMA
    371                  DMAARM |= 0x03;  
    372                  DMAREQ |= 0x01;
    373                  while (DMAARM);
    374                }
    375              memcpy(&dst[ptr], padding_block, block_len); // Копируем в src
    376          }
    377          
    378          /**
    379          @brief Зашифровывает buf в режиме CBC-MAC с IV = 0
    380          @param[in] len улинна последовательности для вычисления MAC
    381          @param[out] mac указатель на память куда будет записан mac (до 16 байт)
    382          */
    383          static void CBCMAC_buf_encrypt(uint8_t len, uint8_t *key, uint8_t *mac)
    384          {
    385            uint8_t IV[16];
    386            
    387            // Заполняем вектор нулями
    388            memset(IV, 0x00, sizeof(IV));
    389            
    390            // Установим метод кодироваения
    391            AES_SET_MODE(AES_MODE_CBCMAC);  
    392            
    393            { // Сворачиваем код для улучшения чтения
    394            // Загружаем ключ
    395            AES_SET_OPERATION(AES_LOAD_KEY);
    396            ST_DEF(DMA_AES_DW, SRCADDRL, LADDR(key));
    397            ST_DEF(DMA_AES_DW, SRCADDRH, HADDR(key));
    398            ST_DEF(DMA_AES_DW, LENL, 16);
    399            DMAARM |= 0x01;
    400            while(!AES_RDY());
    401            AES_START();
    402            while (DMAARM);
    403          
    404            // Загружаем IV
    405            AES_SET_OPERATION(AES_LOAD_IV);
    406            ST_DEF(DMA_AES_DW, SRCADDRL, LADDR(IV));
    407            ST_DEF(DMA_AES_DW, SRCADDRH, HADDR(IV));
    408            ST_DEF(DMA_AES_DW, LENL, 16);
    409            DMAARM |= 0x01;
    410            while(!AES_RDY());
    411            AES_START();
    412            while (DMAARM);
    413            };
    414            
    415            // Устанавливаем операцию шифрования
    416            AES_SET_OPERATION(AES_ENCRYPT);
    417            
    418            // Загрузка блоками по 128 бит
    419            uint8_t nbrBlocks = len / 16; // Количество целых блоков по 128 бит
    420            uint8_t block_len = len % 16; // Размер последнего блока
    421            uint8_t ptr; // Смещение
    422                
    423            // Для этого типа шифрования длина блоков по 16 байт
    424            ST_DEF(DMA_AES_DW, LENL, 16);
    425            // Устанавливаем куда будем выгружать вычисленный MAC
    426            ST_DEF(DMA_AES_UP, DSTADDRL, LADDR(mac));
    427            ST_DEF(DMA_AES_UP, DSTADDRH, HADDR(mac));
    428            ST_DEF(DMA_AES_UP, LENL, 16);
    429            
    430            // Шифруем все целые блоки
    431            for (uint8_t block = 0; block < nbrBlocks; block ++)
    432              {
    433                // Последний блок шифруем в режиме CBC при условии что нет блок не 
    434                // кратного 16 байтам.
    435                if (!block_len && (block == nbrBlocks - 1))
    436                  AES_SET_MODE(AES_MODE_CBC);
    437                    
    438                ptr = 16 * block;
    439                while(!AES_RDY());
    440                AES_START();
    441                // Указываем адресс DMA откуда читать данные
    442                ST_DEF(DMA_AES_DW, SRCADDRL, LADDR(buf[ptr]));
    443                ST_DEF(DMA_AES_DW, SRCADDRH, HADDR(buf[ptr]));
    444                // Активируем DMA
    445                DMAARM |= 0x01;  
    446                // Активируем выгрузку только последнего блока
    447                if (!block_len && (block == nbrBlocks - 1))
    448                  DMAARM = 0x03;
    449                
    450                DMAREQ |= 0x01;
    451                while (DMAARM);          
    452               }
    453                 
    454            // Шифруем последний блок в режиме CBC
    455            AES_SET_MODE(AES_MODE_CBC);
    456                    
    457            // Завершаем работу если блок пустой
    458            if (!block_len)
    459              return;
    460                
    461            uint8_t padding_block[16]; // Блок заполненый нулями
    462            ptr = 16*nbrBlocks; // Смещение на первый байт последнего блока в src
    463            memset(padding_block, 0x00, sizeof(padding_block)); // Заполняем нулями
    464            memcpy(padding_block, &buf[ptr], block_len); // Копируем данные
    465                
    466            while(!AES_RDY());
    467            AES_START();
    468            // Указываем адресс DMA откуда читать данные
    469            ST_DEF(DMA_AES_DW, SRCADDRL, LADDR(padding_block));
    470            ST_DEF(DMA_AES_DW, SRCADDRH, HADDR(padding_block));
    471            // Активируем DMA и выгрузку MAC
    472            DMAARM |= 0x03;  
    473            DMAREQ |= 0x01;
    474            while (DMAARM);
    475          }
    476          
    477          static inline uint8_t generateAuthData(uint8_t *src, uint8_t *nonce, uint8_t c,
    478                                                 uint8_t f, uint8_t lm)
    479          {
    480            memcpy(buf, nonce,16);
    481            
    482            // Буфер от 0 до 15 байта специальный блок B0
    483            // Настраиваем флаг. У нас длинна 2 байта. nonce 13 байт => L_M = L-1=0x01
    484            buf[0]=  0x01;  
    485            // Если есть данные для авторизации установим A_Data 
    486            if (f > 0)
    487              buf[0] |= 0x40;
    488            
    489            buf[0] |= ((lm - 2) / 2 ) << 3;   // см. документацию M'= (lm-2) / 2;
    490            
    491            // Устанавливаем длинну сообщения
    492            buf[14] = 0x00;
    493            buf[15] = c;
    494            
    495            // Добавляем строку авторизации L(a). если данных нет, то она пустая. f=0
    496            buf[16]= 0;
    497            buf[17]= f;
    498            
    499            // Копируем данные авторизации в буфер
    500            memcpy(&buf[18], src, f);
    501            
    502            // Смещение на следующий байт после данных авторизации.
    503            // Данные авторизации занимают положение в буфере [18, 18+f]
    504            uint8_t ptr_end= 18 + f;
    505            // Заполняем нулями до границы 16 байт  
    506            while (ptr_end & 0x0f)
    507              buf[ptr_end++] = 0x00;
    508            
    509            // Копируем данные для шифрования в буфер после нулей
    510            memcpy(&buf[ptr_end], &src[f], c);
    511            
    512            // Возвращаем размер данных в буфере
    513            return ptr_end+c;
    514          };
    515          
    516          /**
    517          @brief Шифрует/дешифрует данные с проверкой MIC
    518          @param[in] src Указатель на данные подлежащии шифрованию
    519          @param[in] len Размер данных
    520          @param[in] с Количество байт для шифрования
    521          @param[in] f Количество байт для авторизации
    522          @param[in] m Размер MIC (m=1,2,3 l(m) = 4,8,16 байт)
    523          @param[in] iv  Указатель на вектор иницилизации. 16 байт 
    524          @param[in] len Длинна данных
    525          @param[in,out] MIC Указатель на массив соответсвующий длинне (4,8,16 байт)
    526          */
    527          void AES_CCMEncrypt( uint8_t *src, uint8_t c, uint8_t f, uint8_t m,
    528                              uint8_t *key, uint8_t *nonce, uint8_t *MIC)
    529          {
    530            uint8_t lm = MIC_2_MICLEN(m);
    531            
    532            // Генерируем данные для авторизации
    533            uint8_t dlen = generateAuthData(src, nonce, c, f, lm);
    534            
    535            uint8_t mac[16]; // Сюда пишем мак
    536            CBCMAC_buf_encrypt(dlen, key, mac);
    537            
    538            // Шифруем MAC
    539            uint8_t CTR_IV[16];
    540            memcpy(CTR_IV, nonce, 16);
    541            CTR_IV[0] = 0x01; // Флаг режима CTR
    542            CTR_IV[15] = 0;   // Значение счетчика
    543            CTR_enc_decrypt(true, mac, mac, key, CTR_IV, 16);
    544            
    545            // Шифруем текст. он имеет размер 'c' и находится в буфере начиная с
    546            // dlen-c, dlen
    547            uint8_t ds = dlen - c; // Начало данных для шифрования
    548            
    549            // 0x0F & (16 - (dlen & 0x0f)) оставляет числа от 0 до 15  
    550            memset(buf+dlen, 0x00, 0x0F & (16 - (dlen & 0x0f)) ); // Дополняем нулями
    551            CTR_IV[15] = 1; // Счетчик CTR
    552            CTR_enc_decrypt(true, &buf[ds], &buf[ds], key, CTR_IV, c); // Шифруем
    553            
    554            // Заполняем буфер буфер src. src[0,f] это данные авторизации. 
    555            // src[f, f+c] это шифрованные данные.
    556            memcpy(&src[f], &buf[ds], c); 
    557            memcpy(MIC, mac, lm);
    558            
    559            //https://github.com/zhaohengyi/CC2530Example/blob/
    560            //master/source/components/radios/cc2530/hal_rf_security.c
    561          }
    562          
    563          /**
    564          @brief Дешифрует данные с проверкой MIC
    565          @param[in] src Указатель на данные подлежащии шифрованию
    566          @param[in] len Размер данных
    567          @param[in] с Количество байт для шифрования
    568          @param[in] f Количество байт для авторизации
    569          @param[in] m Размер MIC (m=1,2,3 l(m) = 4,8,16 байт)
    570          @param[in] iv  Указатель на вектор иницилизации. 16 байт 
    571          @param[in] len Длинна данных
    572          @param[in,out] MIC Указатель на массив соответсвующий длинне (4,8,16 байт)
    573          */
    574          bool AES_CCMDecrypt( uint8_t *src, uint8_t c, uint8_t f, uint8_t m,
    575                              uint8_t *key, uint8_t *nonce, uint8_t *MIC)
    576          {
    577            uint8_t lm = MIC_2_MICLEN(m);
    578            
    579            // Расшифровываем MAC
    580            uint8_t mac[16]; // Расшифрованый мак
    581            uint8_t CTR_IV[16];
    582            memcpy(CTR_IV, nonce, 16);
    583            CTR_IV[0] = 0x01; // Флаг режима CTR
    584            CTR_IV[15] = 0;   // Значение счетчика
    585            CTR_enc_decrypt(false, MIC, mac, key, CTR_IV, lm);  
    586            
    587            // Генерируем данные для авторизации
    588            uint8_t dlen = generateAuthData(src, nonce, c, f, lm);
    589            
    590            // Дешифруем текст. он имеет размер 'c' и находится в буфере начиная с
    591            // dlen-c, dlen
    592            uint8_t ds = dlen - c; // Начало данных для дешифрования
    593            
    594            // 0x0F & (16 - (dlen & 0x0f)) оставляет числа от 0 до 15  
    595            memset(buf+dlen, 0x00, 0x0F & (16 - (dlen & 0x0f)) ); // Дополняем нулями
    596            CTR_IV[15] = 1; // Счетчик CTR
    597            CTR_enc_decrypt(false, &buf[ds], &buf[ds], key, CTR_IV, c); // Дешифруем
    598            
    599            uint8_t new_mac[16]; // мак полученный в ходе рашифровки сообщения
    600            CBCMAC_buf_encrypt(dlen, key, new_mac);
    601            
    602            // Проверяем что маки совпадают, значит дешифровано верно
    603            bool mac_equal = true;
    604            for (uint8_t i = 0 ; i < lm ; i++)
    605            {
    606              if (mac[i] != new_mac[i])
    607              mac_equal = false;
    608              break;
    609            }
    610            
    611            // Выходим если MACи не совпали  
    612            if (!mac_equal)
    613              return false;
    614            
    615            // Копируем  расшифрованные данные
    616            memcpy(&src[f], &buf[ds], c); 
    617            return true;
    618          }
\\vmware-host\Shared Folders\Projects\WMNU\IAR\SHARE_PRJ_SRC\delays.c
      1          /*!
      2          \file  Модуль измерения интервалов времени и функция задержки времени
      3          \brief Функции измерения времени и задержки
      4          */
      5          
      6          #include "ioCC2530.h"
      7          #include "delays.h"
      8          #include "string.h"
      9          
     10          #define TICK_NS  31.25 // Количество нс в одном такте TIM2
     11          #define TICK_US  0.03125 // Количество мкс в одном такте TIM2
     12          #define TICK_PER_US 32 // Количество тактов в одной микросекунде
     13          
     14          // Максимальное кол-во тактов таймера. Константа 40 бит, 5 байт
     15          static const uint32_t MAC_TIMER_MAX = 0xFFFFFFFFUL; 
     16          static uint32_t DELAY_CALIBRATE_TICS; // Колибровка функции задержки
     17          
     18          // Публичные методы
     19          void TIM_init(void);
     20          void TIM_TimeStamp(TimeStamp_s* timestamp);
     21          void TIM_delay(uint32_t delay);
     22          uint32_t TIM_passedTime(TimeStamp_s* start, TimeStamp_s* stop);
     23          void TIM_copy(TimeStamp_s *src, TimeStamp_s *dst);
     24          
     25          // Приватные
     26          static inline uint32_t Interval(TimeStamp_s* start, TimeStamp_s* stop);
     27          static void DelayCalibrate(void);
     28          
     29          /**
     30          @brief Иницилизация таймера
     31          @brief Используется таймер 2. MAC таймер
     32          */
     33          void TIM_init(void)
     34          {
     35            // Запускаем таймер, LATCH MODE = 1
     36            // Latch mode фиксирует значение таймера переполнения при чтении T2M0
     37            // ЗАпускаем MAC таймер без синхронизации с кварцем 32.768к
     38            T2CTRL = (1<<0) | (1<<3); 
     39            // Калибровка функции задержки
     40            DelayCalibrate();
     41          }
     42          
     43          /**
     44          @brief Возвращает временую метку.
     45          @params[out] timestamp указатель на временную метку 
     46          */
     47          void TIM_TimeStamp(TimeStamp_s* timestamp)
     48          {
     49            timestamp->byte[0] = T2M0;
     50            timestamp->byte[1] = T2M1;
     51            timestamp->byte[2] = T2MOVF0;
     52            timestamp->byte[3] = T2MOVF1;
     53          }
     54          
     55          /**
     56          @brief Калибровка функции задержки TIM_delay
     57          */
     58          static void DelayCalibrate(void)
     59          {
     60            #define ACCURATE_VAL_US 500 
     61            DELAY_CALIBRATE_TICS = 0;
     62            TimeStamp_s start, stop;
     63            uint32_t passed, cal;
     64            
     65            TIM_TimeStamp(&start);
     66            TIM_delay(ACCURATE_VAL_US);
     67            TIM_TimeStamp(&stop);
     68            passed = TIM_passedTime(&start, &stop);
     69            
     70            cal = passed - ACCURATE_VAL_US;
     71            DELAY_CALIBRATE_TICS = cal * TICK_PER_US; 
     72          };
     73          
     74          /**
     75          @brief Вычисляет количество тактов между двумя времеными метками
     76          @return Количество тактов
     77          */
     78          static inline uint32_t Interval(TimeStamp_s* start, TimeStamp_s* stop)
     79          {
     80            uint32_t ret;
     81          
     82            if (stop->timer >= start->timer)
     83              ret = stop->timer - start->timer;
     84            else
     85            { 
     86              ret = (MAC_TIMER_MAX - start->timer) + stop->timer;
     87            }
     88            return ret;
     89          }
     90          
     91          /**
     92          @brief Вычисляет прошедшее время между двумя времеными метками
     93          @return Время в мкс.
     94          */
     95          uint32_t TIM_passedTime(TimeStamp_s* start, TimeStamp_s* stop)
     96          {
     97            uint32_t ret = Interval(start, stop);
     98            
     99            ret = (uint32_t)((float)ret * TICK_US);
    100            return ret;
    101          }
    102          
    103          /**
    104          @brief Задержка на заданное количество мкс. 
    105          @details Погрешность около 20 мкс при значениях выше 150 мкс.
    106           Рекомендуется использовать для организации задержек не менее 200 мкс.
    107          @params[in] delay количество микросекунд. Не более 134217727 мкс (134.2 сек)
    108          */
    109          void TIM_delay(uint32_t delay)
    110          {
    111            uint32_t passed = 0;
    112            TimeStamp_s start, now;
    113            TIM_TimeStamp(&start);
    114            
    115            // Конвертируем мкс в такты и вносим поправку
    116            delay = delay * TICK_PER_US; 
    117            if (delay > DELAY_CALIBRATE_TICS)
    118              delay -= DELAY_CALIBRATE_TICS;
    119            
    120            do
    121            {
    122              TIM_TimeStamp(&now);
    123              passed = Interval(&start, &now);
    124            } while (passed < delay);
    125          }
    126          
    127          /**
    128          @brief Копирование временной метки
    129          @param[in] src указатель на исходную метку для копирование
    130          @param[out] dst указатель на метку назначения
    131          */
    132          void TIM_copy(TimeStamp_s *src, TimeStamp_s *dst)
    133          {
    134            memcpy(src, dst, sizeof(TimeStamp_s));
    135          }
\\vmware-host\Shared Folders\Projects\WMNU\IAR\SHARE_PRJ_SRC\ethernet.c
      1          #include "frame.h"
      2          #include "Net_frames.h"
      3          #include "stdint.h"
      4          #include "nwdebuger.h"
      5          #include "LLC.h"
      6          #include "mem.h"
      7          
      8          void ETH_Send(frame_s *fr);
      9          
     10          static void ETH_RX_HNDL(frame_s *fr);
     11          static void (*RXCallback)(frame_s *fr); //frame_s RAW_LAY, wthout ETH_LAY
     12          static bool validate(ETH_LAY *eth);
     13          static ETH_LAY* extract_header(frame_s *fr);
     14          static void send_ack(ETH_LAY *eth);
     15          static frame_s* strip_header(frame_s *fr);
     16          
     17          /**
     18          @brief Иницилизация модуля
     19          */
     20          void ETH_Init(void)
     21          {
     22            RXCallback = NULL; 
     23            LLC_SetRXCallback(ETH_RX_HNDL);
     24          }
     25          
     26          /**
     27          @brief Установка обработчика приема пакета ETH
     28          */
     29          void ETH_Set_RXCallback(void (*fn)(frame_s *fr))
     30          {
     31            ASSERT_HALT(fn != NULL, "NULL pointer not allow");
     32            RXCallback = fn;
     33          }
     34          
     35          /**
     36          @brief Обработка принятого пакет сети.
     37          @detail После валидации пакета, уничтожается заголовок ETH и пакет передается
     38           на дальнейшую обработку вверх по стеку с помощью обратного вызова RXCallback
     39          */
     40          static void ETH_RX_HNDL(frame_s *fr)
     41          {
     42            ASSERT_HALT(fr != NULL, "fr is NULL");
     43            
     44            bool valid;
     45            frame_s *striped_frame;
     46            
     47            ETH_LAY* eth_h = extract_header(fr);
     48            
     49            // Извлечь заголовок не удалось
     50            if (eth_h == NULL)
     51              goto ERR_FRAME;
     52            
     53            valid = validate(eth_h);
     54           
     55            // Заголовок не верный
     56            if (!valid)
     57              goto ERR_FRAME;
     58           
     59            // Требуется отправить подтверждение приема пакета
     60            if (eth_h->ETH_T.bits.ACK)
     61              send_ack(eth_h);
     62            
     63            // Создаем новый пакет без заголовка и удаляем исходный
     64            striped_frame = strip_header(fr);
     65            frame_delete(fr);
     66            ASSERT_HALT(striped_frame != NULL, "Striped_frame is NULL");
     67            
     68            // Передаем обработчику выше по стеку
     69            ASSERT_HALT(RXCallback != NULL, "RXCallback is NULL");
     70            RXCallback(striped_frame);
     71            
     72            re_free(eth_h);
     73            return;
     74            
     75          ERR_FRAME:
     76            frame_delete(fr);
     77            re_free(eth_h);
     78            return;
     79          }
     80          
     81          /**
     82          @brief Создает новый пакет без заголовка ETH_H
     83          @return указатель на новый frame_s*. NULL - не удалось создать пакет
     84          */
     85          static frame_s* strip_header(frame_s *fr)
     86          {
     87          }
                 ^
Warning[Pe940]: missing return statement at end of non-void function
          "strip_header"
          detected during compilation of secondary translation unit
                    "\\vmware-host\Shared
                    Folders\Projects\WMNU\IAR\SHARE_PRJ_SRC\ethernet.c"
     88          
     89          /**
     90          @brief Подготавливает и отпправляет подтверждение приема пакета
     91          */
     92          static void send_ack(ETH_LAY *eth)
     93          {
     94           
     95          }
     96          
     97          static bool validate(ETH_LAY *eth)
     98          {
     99            return true;
    100          }
    101          
    102          static ETH_LAY* extract_header(frame_s *fr)
    103          {
    104            ETH_LAY* eth_h = (ETH_LAY*)re_malloc(ETH_LAY_SIZE);
    105            ASSERT_HALT(eth_h != NULL, "No memory");
    106            
    107            uint8_t len = frame_len(fr);
    108            ASSERT_HALT(len >= ETH_LAY_SIZE, "Incorrect eth size");
    109            
    110            //fbuf_s *fb = frame_get_fbuf_head(fr);
    111            //re_memcpy(eth_h, fb->payload, ETH_LAY_SIZE);
    112            return eth_h;
    113          }
\\vmware-host\Shared Folders\Projects\WMNU\IAR\SHARE_PRJ_SRC\frame.c
      1          /**
      2          @file Модуль описывает сетевой кадр и связанные с ним буферы данных
      3          @brief Типы frame
      4          */
      5          
      6          #include "frame.h"
      7          #include "string.h"
      8          #include "mem.h"
      9          #include "nwdebuger.h"
     10          #include "ioCC2530.h"
     11          
     12          frame_s* frame_create(void);
     13          void frame_delete(frame_s *fr);
     14          uint8_t frame_len(frame_s *fr);
     15          uint8_t frame_getCount(void);
     16          
     17          static uint8_t NBR_FRAME = 0; //!< Количество фреймов в памяти
     18          
     19          /**
     20          @brief Получить количество фреймов в памяти
     21          @return Возвращает количество фреймов
     22          */
     23          uint8_t frame_getCount(void)
     24          {
     25            return NBR_FRAME;
     26          }
     27          
     28          /**
     29          @brief Добавить заголовок
     30          @param[in] fr указатель на фрейм
     31          @param[in] src данные для добавления
     32          @param[in] len размер данных
     33          */
     34          void frame_addHeader(frame_s *fr, void *src, uint8_t len)
     35          {
     36            unsigned short EA_save = EA;
     37            EA = 0; 
     38            // Ранее небыло создано данных 
     39            if (fr->payload == NULL)
     40              {
     41                fr->payload = re_malloc(len);
     42                fr->len = len;
     43                re_memcpy(fr->payload, src, len);
     44                EA = EA_save;
     45                return;
     46              }
     47            
     48            uint8_t new_len = fr->len + len; // Новый размер
     49            void *new_payload = re_malloc(new_len);
     50            ASSERT_HALT(new_payload != NULL, "No memory");
     51            
     52            // Копируем данные в конец области
     53            re_memcpy((char*)new_payload + len, fr->payload, fr->len);
     54            // Копируем данные спереди в свободную область
     55            re_memcpy(new_payload, src, len);
     56            // Уничтожаем старые данные
     57            re_free(fr->payload);
     58            fr->payload = new_payload;
     59            fr->len = new_len;
     60            EA = EA_save;
     61          }
     62          
     63          /**
     64          @brief Удалить заголовок
     65          @param[in] fr указатель на фрейм
     66          @param[in] len размер  удаляемых данных
     67          */
     68          void frame_delHeader(frame_s *fr, uint8_t len)
     69          {
     70            if (fr->payload == NULL)
     71              return;
     72          
     73            if (fr->len <= len)
     74              return;  
     75            
     76            uint8_t new_len = fr->len - len; // Новый размер
     77            void *new_payload = re_malloc(new_len);
     78            ASSERT_HALT(new_payload != NULL, "No memory");
     79            
     80            // Копируем данные с пропуском первых len байт
     81            re_memcpy((char*)new_payload, (char*)fr->payload + len, new_len);
     82            
     83            // Уничтожаем старые данные
     84            re_free(fr->payload);
     85            fr->payload = new_payload;
     86            fr->len = new_len;
     87          }
     88          
     89          /**
     90          @brief Создание структуры frame
     91          @return Указатель на структуру frame
     92          */
     93          frame_s* frame_create(void)
     94          {
     95              unsigned short EA_save = EA;
     96              EA = 0; 
     97              
     98              frame_s* fr= (frame_s*)re_malloc(FRAME_S_SIZE);
     99              ASSERT_HALT(fr != NULL, "No memory");
    100              
    101              fr->payload = NULL;
    102              fr->len = 0;
    103              memset(&fr->meta, 0x00, META_S_SIZE);
    104              NBR_FRAME++;
    105              
    106              EA = EA_save;
    107              return fr;
    108          };
    109          
    110          /**
    111          @brief Удаление frame
    112          @detail Проуедура так же удаляет все связанные с ней буфера fbuf
    113          @param[in] fr указатель на структуру frame
    114          */
    115          void frame_delete(frame_s *fr)
    116          {
    117            unsigned short EA_save = EA;
    118            EA = 0;  
    119            
    120            if (fr->payload != NULL)
    121              re_free(fr->payload);
    122           
    123            NBR_FRAME--;
    124            re_free(fr);
    125            EA = EA_save;
    126          }
    127          
    128          
    129          /**
    130          @brief Вычисляет размер цепочки fbuf
    131          @param[in] fr указатель на frame_s
    132          @return Количество байт в цепочке буферов
    133          */
    134          uint8_t frame_len(frame_s *fr)
    135          {
    136            return fr->len;
    137          }
\\vmware-host\Shared Folders\Projects\WMNU\IAR\SHARE_PRJ_SRC\LLC.c
      1          /**
      2          @file 
      3          @brief Модуль содержит реализацию интерфейса радио для приема/передачи данных.
      4          */
      5          
      6          #include "LLC.h"
      7          #include "MAC.h"
      8          #include "TIC.h"
      9          #include "mem.h"
     10          #include "nwdebuger.h"
     11          #include "ioCC2530.h"
     12          
     13          // Публичные методы
     14          void LLC_Init(void);
     15          
     16          // Методы модуля
     17          void LLC_SetRXCallback(void (*fn)(frame_s *fr));
     18          void LLC_TimeAlloc(void (*fn)(void)); 
     19          bool LLC_AddTask(frame_s* fr);
     20          uint8_t LLC_GetTaskLen(void);
     21          
     22          // Закрытые методы
     23          static void LLC_SE_HNDL(uint8_t TS); //!< Обработчик завешения слота TIC
     24          static void LLC_Shelduler(uint8_t TS);
     25          static void LLC_RX_HNDL(frame_s *fr); //!< Обработчик примема пакета
     26          static void LLC_RunTimeAlloc(void);
     27          
     28          // Переменные модуля
     29          #define UNICAST_SEND_ATEMPTS 5 //!< Количество попыток передачи пакета 
     30          #define MAX_nbrTASKS 20 //!< Максимальное количество задач в очередях
     31          
     32          typedef struct LLCTask LLCTask;
     33          typedef struct TimeAllocFunc TimeAllocFunc;
     34          static bool tasksBLOCK; //!< блокировка доступа к LLCTask
     35          
     36          /**
     37          @brief Описание задачи модуля LLC
     38          */
     39          struct LLCTask
     40          {
     41            LLCTask *next; //!< Указатель на следующую задачу. NULL - конец очереди
     42            uint8_t TS; //!< Номер временого канала для передачи сообщения
     43            uint8_t CH; //!< Номера радиоканала для передачи сообщения
     44            frame_s *fr; //!< Указатель на данные для передачи
     45          };
     46          
     47          /**
     48          @brief Список функций вызываемых по завешению временного слота
     49          */
     50          struct TimeAllocFunc
     51          {
     52            TimeAllocFunc *next; //!< Указатель на следующую функцию. NULL - конец списка
     53            void (*fn)(void); //!< Указатель на функцию. NULL - нет обработчика
     54          };
     55          
     56          static LLCTask *FirstTask; //!< Указатель на первый элемент очереди задач
     57          static uint8_t nbrTasks; // Количество задач в очереди
     58          
     59          /**
     60          @brief Обратный вызов при приеме пакета данных
     61          */
     62          static void (*RXCallback)(frame_s *fr);
     63          
     64          /**
     65          @brief Первый элемент обработчика конца временного слота
     66          @details Элемент создается статически, все остальные задачи создаются re_malloc
     67          и добавляются к HeadAllocFunc.
     68          */
     69          static TimeAllocFunc HeadAllocFunc;
     70          
     71          /**
     72          @brief Инициализация модуля
     73          @detail Иницилизирует MAC
     74          */
     75          void LLC_Init(void)
     76          {  
     77            MAC_Init();
     78            nbrTasks = 0; 
     79            tasksBLOCK = false;
     80            FirstTask = NULL;
     81            // TODO Очистить очередь HeadTask
     82            // Регистрируем обработчики
     83            TIC_SetSECallback(LLC_SE_HNDL); // Завершение временного слота
     84            MAC_SetRXCallback(LLC_RX_HNDL); // Принято сообщение
     85          }
     86          
     87          /**
     88          @brief Количество задач в очереди
     89          @return количество задач в очереди
     90          */
     91          uint8_t LLC_GetTaskLen(void)
     92          {
     93            return nbrTasks;
     94          }
     95          
     96          void LLC_SetRXCallback(void (*fn)(frame_s *fr))
     97          {
     98            ASSERT_HALT(fn != NULL, "NULL pointer not allow");
     99            RXCallback = fn;
    100          }
    101          
    102          /**
    103          @brief Добавляет обработчик заверешения временого слота в список
    104          */
    105          void LLC_TimeAlloc(void (*fn)(void))
    106          {
    107            TimeAllocFunc *ta = re_malloc(sizeof(TimeAllocFunc));
    108            ASSERT_HALT(ta != NULL, "Memory allocation fails");
    109            ta->next = NULL;
    110            ta->fn = fn;
    111          
    112            // Перебираемся в конец списка
    113            TimeAllocFunc *next = &HeadAllocFunc;
    114            while (next->next != NULL)
    115              next = next->next;
    116            
    117            // Добавляем новый элемент
    118            next->next = ta;
    119          };
    120          
    121          /**
    122          @brief Добавляем задачу в очередь
    123          @brief Взовращает true если задача добавлена в очередь. false, если размер 
    124           очереди достиг максимального размера.
    125          */
    126          bool LLC_AddTask(frame_s* fr)
    127          {
    128             ASSERT_HALT(fr != NULL, "fr NULL");
    129           
    130              if (nbrTasks == MAX_nbrTASKS)
    131                return false;
    132              
    133             // Ждем пока разбокируется доступ.
    134             while (tasksBLOCK);
    135             tasksBLOCK = true;
    136             
    137             // Создаем новую задачу
    138             LLCTask *new_task = (LLCTask*)re_malloc(sizeof(LLCTask));
    139             ASSERT_HALT(new_task !=NULL, "LLC re_malloc for new_task"); 
    140                
    141             new_task->TS = fr->meta.TS;
    142             new_task->CH = fr->meta.CH;
    143             new_task->fr = fr;
    144             
    145            LOG(MSG_OFF | MSG_INFO | MSG_TRACE, "Add task = %u, CH = %d, TS = %d, OTS = %d. fr = %d\r\n",
    146                (uint16_t)new_task,new_task->CH, new_task->TS, fr->meta.TS, (uint16_t)fr);
    147            
    148             // Если в очереди нет задач, добавим первую
    149             if (FirstTask == NULL) 
    150             {
    151               new_task->next = NULL;
    152               FirstTask = new_task;
    153             }
    154             // Если в очереди были задачи то вставим новую в голову списка
    155             else 
    156             {
    157               new_task->next = FirstTask;
    158               FirstTask = new_task;  
    159             }
    160             
    161             nbrTasks ++;
    162             tasksBLOCK = false;
    163             return true;
    164          }
    165          
    166          /**
    167          @brief Планировщик задач
    168          @details Соотносит задачи в очереди и свободные временные слоты MAC уровня.
    169          При освобождении временных слотов, планировщик устанавливает данные для 
    170          передачи в MAC.
    171          @param[in] TS номер текущего временого слота
    172          */
    173          static void LLC_Shelduler(uint8_t TS)
    174          {
    175            // Если работает функция добавления задачи, то обслуживание очереди не
    176            // производится. Это может привести к необычным последствиям
    177            if (tasksBLOCK)
    178              return;
    179            
    180            tasksBLOCK = true;
    181            // Перебираем попорядку весь список на отправку
    182            // HeadTask только указатель на первый элемент, сам он не подлежит отправке
    183            LLCTask *task = FirstTask;
    184            LLCTask *last = FirstTask;
    185            LLCTask *next = FirstTask;
    186            
    187            while (task != NULL)
    188            {    
    189              
    190              if (MAC_GetTXState(task->TS)) // Занят ли временой слот
    191              {
    192                // Если слот занят переходим к следующей задаче
    193                last = task;
    194                task = task->next;
    195                continue; 
    196              }
    197              
    198              MAC_Send(task->fr, UNICAST_SEND_ATEMPTS);
    199              
    200              next = task->next; // Запомним следующую задачу
    201              
    202              // Удаляем текущую задачу из списка
    203              if (task == FirstTask)
    204              {
    205              // Удаляемым элементом является указателем на голову
    206                 FirstTask = next;
    207                 last = FirstTask;
    208              }
    209              else
    210              {
    211                // Удаляемым элементом является промежуточный элемент
    212                last->next = next;
    213              }
    214              
    215              nbrTasks--;
    216              LOG(MSG_OFF | MSG_INFO | MSG_TRACE, "Free task = %u, nbrTasks = %d\r\n",
    217                  (uint16_t)task, nbrTasks); 
    218              re_free(task);
    219              task = next;
    220            }
    221            
    222            tasksBLOCK = false;
    223          }
    224          
    225          /**
    226          @brief Обработчик заверешния временого слота
    227          @details Обратный вызов из TIC. Обработчик вызывает планировщик задач очереди
    228          и передает управление зарегистрированым функциям с помощью LLC_TimeAlloc.
    229          @param[in] TS номер завершенного временого слота
    230          */
    231          static void LLC_SE_HNDL(uint8_t TS)
    232          {
    233            LLC_Shelduler(TS);
    234            LLC_RunTimeAlloc();
    235          }
    236          
    237          static void LLC_RX_HNDL(frame_s *fr)
    238          {
    239            ASSERT_HALT(RXCallback !=NULL, "RXCallback func NULL");
    240            RXCallback(fr);
    241          }
    242          
    243          /**
    244          @brief Передаем управление зарегистрированным функциям
    245          */
    246          static void LLC_RunTimeAlloc(void)
    247          {
    248              TimeAllocFunc *next = &HeadAllocFunc;
    249            // HeadAllocFunc служит только для указания на первый элемент в очереди
    250            // так что его нужно пропустить и переходить сразу к next
    251            while (next->next != NULL)
    252            {
    253              next->next->fn();
    254              next = next->next;
    255            }
    256          }
\\vmware-host\Shared Folders\Projects\WMNU\IAR\SHARE_PRJ_SRC\MAC.c
      1          #include "MAC.h"
      2          #include "frame.h"
      3          #include "string.h"
      4          #include "nwdebuger.h"
      5          #include "coder.h"
      6          #include "TIC.h"
      7          
      8          // Обработчики прерываний
      9          static void MAC_RX_HNDL(uint8_t TS);
     10          static void MAC_TX_HNDL(uint8_t TS);
     11          static void (*RXCallback)(frame_s *fr);
     12          bool (*isACK_OK)(frame_s *fr, frame_s *fr_ack);
     13          
     14          // Публичные методы
     15          void MAC_Init(void);
     16          void MAC_OpenRXSlot(uint8_t TS, uint8_t CH);
     17          void MAC_CloseRXSlot(uint8_t TS);
     18          void MAC_Send(frame_s *fr, uint8_t attempts);
     19          bool MAC_ACK_Send(frame_s *fr);
     20          void MAC_SetRXCallback(void (*fn)(frame_s *fr));
     21          void MAC_Set_isACK_OK_Callback(bool(*fn)(frame_s *fr, frame_s *fr_ack));
     22          bool MAC_GetTXState(uint8_t TS);
     23          bool MAC_GetRXState(uint8_t TS);
     24          
     25          // Ключ потокового шифрования и вектор иницилизации
     26          uint8_t KEY[16] = {18,11,12,13,14,15,16,17,10,11,12,13,14,15,16,17};
     27          uint8_t IV[16] = {18,11,12,13,14,15,16,17,10,11,12,13,14,15,16,17};
     28            
     29          #define RECV_TIMEOUT 3000UL // Время ожидания приема пакета в мкс
     30          #define ACK_RECV_TIMEOUT 1000UL // Время ожидания приема подтверждения в мкс
     31          // Задержка перед приемом ACK в мкс если данные шифруются
     32          #define DELAY_BEFORE_ACK_RECV_CRYPT 2000UL 
     33          // Задержка перед приемом ACK в мкс если данные не шифруются
     34          #define DELAY_BEFORE_ACK_RECV_NOCRYPT 1000UL
     35          
     36          #define RARIO_STREAM_ENCRYPT true // Шифрование данных включенно 
     37          
     38          typedef struct
     39          {
     40           struct 
     41           {
     42             bool enable;
     43             uint8_t attempts;
     44             uint8_t CH;
     45             frame_s *fr;
     46           } __attribute__((packed)) TX;
     47           
     48           struct
     49           {
     50            bool enable; 
     51            uint8_t CH;
     52           } __attribute__((packed)) RX;
     53          } __attribute__((packed)) MACSState_s; 
     54          
     55          
     56          // Таблица состояний слотов приема/передачи
     57          MACSState_s MACSlotTable[50];
     58          
     59          
     60          /**
     61          @brief Установка обработчика функции  isACK_OK
     62          @param[in] fn(frame_s *fr, frame_s *fr_ack) указатель на функцию
     63          */
     64          void MAC_Set_isACK_OK_Callback(bool(*fn)(frame_s *fr, frame_s *fr_ack))
     65          {
     66            isACK_OK = fn;
     67          }
     68          
     69          /**
     70          @brief Иницилизация MAC
     71          @detail Инизилизирует TIM, TIC, RI, AES
     72          */
     73          void MAC_Init(void)
     74          {
     75            TIM_init();
     76            TIC_Init();
     77            RI_init();
     78            AES_init();
     79            
     80            TIC_SetRXCallback(MAC_RX_HNDL);
     81            TIC_SetTXCallback(MAC_TX_HNDL);
     82            RI_StreamCrypt(RARIO_STREAM_ENCRYPT);
     83            RI_setKEY(KEY);
     84            RI_setIV(IV);  
     85            memset(MACSlotTable, 0x00, 50*sizeof(MACSState_s));
     86          }
     87          
     88          /**
     89          @brief Открыть временой слот приема данных
     90          @param[in] TS номер слота от 0 до 49
     91          @param[in] CH номер радиоканала
     92          */
     93          void MAC_OpenRXSlot(uint8_t TS, uint8_t CH)
     94          {
     95              ASSERT_HALT(TS < 50, "Incorrect TS");
     96              MACSlotTable[TS].RX.enable = true;
     97              MACSlotTable[TS].RX.CH = CH;
     98              TIC_SetRXState(TS, true);
     99          }
    100          
    101          /**
    102          @brief Закрыть временой слот приема данных
    103          @param[in] TS номер слота от 0 до 49
    104          */
    105          void MAC_CloseRXSlot(uint8_t TS)
    106          {
    107            ASSERT_HALT(TS < 50, "Incorrect TS");
    108            MACSlotTable[TS].RX.enable = false;
    109            TIC_SetRXState(TS, false);
    110          }
    111          
    112          /**
    113          @brief Поставить пакет в таблицу отправки сообщений
    114          @param[in] fr указатель на пакет
    115          @param[in] attempts количество попыток
    116          */
    117          void MAC_Send(frame_s *fr, uint8_t attempts)
    118          {
    119              ASSERT_HALT(fr != NULL, "*fr null");
    120              ASSERT_HALT(attempts != 0, "attempts = 0");
    121              
    122              uint8_t TS = fr->meta.TS; 
    123              MACSlotTable[TS].TX.attempts = attempts;
    124              MACSlotTable[TS].TX.CH = fr->meta.CH;
    125              MACSlotTable[TS].TX.enable = true;
    126              MACSlotTable[TS].TX.fr = fr;
    127              TIC_SetTXState(TS, true);
    128          }
    129          
    130          /**
    131          @brief Посылает подтверждение приема пакета
    132          @param[in] fr указатель на кадр подтверждения
    133          */
    134          bool MAC_ACK_Send(frame_s *fr)
    135          {
    136            RI_SetChannel(fr->meta.CH);
    137            bool res = RI_Send(fr);
    138            frame_delete(fr);
    139            return res;
    140          }
    141          
    142          /**          *********** TODO ************ прием из Ethernet протокола
    143          @brief Посылает подтверждение приема пакета
    144          @param[in] fr указатель на кадр подтверждения
    145          */
    146          frame_s* MAC_ACK_Recv(void)
    147          {
    148            // ACK RECV TIMEOUT
    149            //RI_SetChannel(fr->meta.CH);
    150            //RI_Send(fr);
    151            //frame_delete(fr);
    152            return NULL;
    153          }
    154          
    155          /**
    156          @brief Устанавливает функцию обратного вызова при приеме пакета
    157          @param[in] fn указатель на функцию обработчик
    158          */
    159          void MAC_SetRXCallback(void (*fn)(frame_s *fr))
    160          {
    161            RXCallback = fn;
    162          }
    163          
    164          /**
    165          @brief Состояние слота TS передача
    166          @return возвращает true, если слот содержит пакет для передачи
    167          */
    168          bool MAC_GetTXState(uint8_t TS)
    169          {
    170            ASSERT_HALT(TS < 50, "Incorrect TS");
    171            return MACSlotTable[TS].TX.enable;
    172          }
    173          
    174          /**
    175          @brief Состояние слота TS приема
    176          @return возвращает true, если слот принимает пакет
    177          */
    178          bool MAC_GetRXState(uint8_t TS)
    179          {
    180            ASSERT_HALT(TS < 50, "Incorrect TS");
    181            return MACSlotTable[TS].RX.enable;
    182          }
    183          
    184          /**
    185          @brief Обработчик слота приема пакета
    186          @detail Отправкой подтвеждения приема пакета занимается ethernet протокол
    187          @param[in] TS номер временного слота
    188          */
    189          static void MAC_RX_HNDL(uint8_t TS)
    190          {
    191            ASSERT_HALT(TS < 50, "Incorrect TS");
    192            
    193            RI_SetChannel(MACSlotTable[TS].RX.CH);
    194            frame_s *fr = RI_Receive(RECV_TIMEOUT);
    195            
    196            // Если пакета нет, выходим из обработчика
    197            if (fr == NULL)
    198              return;
    199            
    200            RXCallback(fr);   // Передаем пакет на дальнейшую обработку
    201            // Удаление пакета не наша забота
    202          }
    203          
    204          /**
    205          @brief Обработчик слота пердачи пакета
    206          @detail После отправки пакета требуется подтверждение приема если meta.ACK = 1.
    207           После отправки ждем приема ACK. Проверка подлинности ACK происходит с помощью
    208           обратного вызова isACK_OK(*fr, *fr_ACK). Результат true или false.
    209          @param[in] TS номер временного слота
    210          */
    211          static void MAC_TX_HNDL(uint8_t TS)
    212          {
    213            ASSERT_HALT(TS < 50, "Incorrect TS");
    214            
    215            // По ошибки вызвали. Такого быть не должно, но подстрахуемся.
    216            if ((!MACSlotTable[TS].TX.enable) || (MACSlotTable[TS].TX.attempts == 0)) 
    217              TIC_SetTXState(TS, false);
    218             
    219            RI_SetChannel(MACSlotTable[TS].TX.CH); // Устанавливаем канал передачи
    220          
    221            // Пробуем передать данные
    222            bool tx_success = RI_Send(MACSlotTable[TS].TX.fr); 
    223            bool send_success = false;  
    224            
    225            LOG(MSG_OFF | MSG_INFO | MSG_TRACE, "RI_Send = %d, CH = %d, TS = %d\r\n",
    226                tx_success, MACSlotTable[TS].TX.CH, TS);
    227              
    228            // Если отправка была успешна и требуется прием подтверждения ACK
    229            if (tx_success && MACSlotTable[TS].TX.fr->meta.ACK)
    230            {
    231              // TODO ждем пакета ACK
    232              // Задержка отправки подтверждения пока что не известна.
    233              // Если есть шифрование это на 1 мс дольше чем без него
    234              // Можно подумать над тем , что бы пакет ACK был не ETH формата.
    235              // К примеру ACK = LEN, FRAME_LEN, FCS1, FCS2 и он существовал
    236              // на уровне MAC и не использовал ETH. Отправка ACK без шифрования.
    237              // Это увеличит время работы узла. Или вместо FRAME_LEN отправлять
    238              // FCS1, FCS2 отправленного пакета что бы его подтвердить или использовать
    239              // свой алгоритм расчета CRC
    240              
    241              // Если включено шифрование, то можно выключать радиоприемник для экономии
    242              // Шифрование данных занимает некоторое время (минимум 1 мс)
    243              if (RARIO_STREAM_ENCRYPT)
    244                TIM_delay(DELAY_BEFORE_ACK_RECV_CRYPT);
    245              else
    246                TIM_delay(DELAY_BEFORE_ACK_RECV_NOCRYPT);
    247              
    248              frame_s *fr_ACK = RI_Receive(ACK_RECV_TIMEOUT);
    249            
    250              if (fr_ACK == NULL) // Не приняли ACK
    251                goto LABEL_MAC_TX_HNDL_END;
    252              
    253              else // Приняли ACK
    254              {
    255                ASSERT_HALT(isACK_OK !=NULL, "isACK_OK func NULL");
    256               
    257                // Проверим является ли принятый пакет ACK подтверждением 
    258                // переданного пакета 
    259                bool isACK = isACK_OK(MACSlotTable[TS].TX.fr, fr_ACK); 
    260               
    261                if (isACK) // Пакет подтвержден
    262                  send_success = true;
    263                
    264                frame_delete(fr_ACK); // Удаляем принятый пакет ACK
    265                goto LABEL_MAC_TX_HNDL_END;
    266              }
    267            }
    268           
    269            // Если отправка была успешна и НЕ требуется подтверждение ACK
    270            if (tx_success && !MACSlotTable[TS].TX.fr->meta.ACK) 
    271              send_success = true;
    272            
    273            
    274          LABEL_MAC_TX_HNDL_END:  
    275            if (send_success) // В случаи успеха удаляем данные и закрываем слоты 
    276            { 
    277              frame_delete(MACSlotTable[TS].TX.fr);
    278              MACSlotTable[TS].TX.enable = false;
    279              TIC_SetTXState(TS, false);      
    280            }
    281            else // Уменьшаем счетчик попыток передачи и удаляем пакет при достижении 0.
    282            {
    283              MACSlotTable[TS].TX.attempts --;
    284              if (MACSlotTable[TS].TX.attempts == 0)
    285                {
    286                  frame_delete(MACSlotTable[TS].TX.fr);
    287                  MACSlotTable[TS].TX.enable = false;
    288                  TIC_SetTXState(TS, false);  
    289                }
    290            }
    291          }
\\vmware-host\Shared Folders\Projects\WMNU\IAR\SHARE_PRJ_SRC\mem.c
      1          #include "ioCC2530.h"
      2          #include "stdlib.h"
      3          #include "stdint.h"
      4          #include "string.h"
      5          
      6          void re_free(void* ptr);
      7          void* re_malloc(size_t size);
      8          uint16_t heap_ptr(size_t size);
      9          void re_memcpy(void *dst, const void *src, size_t n);
     10          
     11          /**
     12          @brief Возвращает адрес следующего свободного участка памяти
     13          @detail Функция нужна для оценки использования стека
     14          @param[in] size размер запрашиваемой области
     15          @return если памяти нету возвращает 0, иначе адрес свободного участка.
     16          */
     17          uint16_t heap_ptr(size_t size)
     18          {
     19            uint16_t *heap_ptr;
     20            heap_ptr = (uint16_t*)re_malloc(size);
     21            re_free(heap_ptr);
     22            return (uint16_t)heap_ptr;
     23          }
     24          
     25          /**
     26          @brief Реентерабельное копирование памяти
     27          */
     28          void re_memcpy(void *dst, const void *src, size_t n)
     29          {
     30            unsigned short EA_save = EA;
     31            
     32            EA = 0;
     33            memcpy(dst, src, n);
     34            EA = EA_save;  
     35          }
     36          
     37          /**
     38          @brief Реентерабельное выделение памяти
     39          */
     40          void* re_malloc(size_t size)
     41          {
     42            void* ptr;
     43            unsigned short EA_save = EA;
     44            
     45            EA = 0;
     46            ptr = malloc(size);
     47            EA = EA_save;
     48            
     49            return ptr;
     50          }
     51          
     52          /**
     53          @brief Реентерабельное освобождение памяти
     54          */
     55          void re_free(void* ptr)
     56          {
     57            unsigned short EA_save = EA;
     58            
     59            EA = 0;
     60            free(ptr);
     61            EA = EA_save;
     62          }
\\vmware-host\Shared Folders\Projects\WMNU\IAR\SHARE_PRJ_SRC\NTMR.c
      1          #include "NTMR.h"
      2          #include "stdlib.h"
      3          #include "ioCC2530.h"
      4          #include "nwdebuger.h"
      5          
      6          /**
      7          @file 
      8          @brief Модуль управления таймером сна
      9          @details При создании обьекта с помощью NT_Create, производится иницилизация
     10           аппаратного таймера сна и он переходит в активное состояние. Если установлено 
     11           определение #define USE_OSC32K будет использван внешний кварц.
     12           За установку глобального прерывания IE отвечает пользователь.
     13           Для использования модуля необходимо установить обработчик прерывания
     14           NT_SetEventCallback(..). Далее с помощью NT_SetCompare(..) установить
     15           время срабатывания прерывания, она же включит прерывание таймера. 
     16           Перед вызовом пользовательского обработчика, запрещается прерывание таймера,
     17           пользователь должен установить его повторно на необходимое время.
     18           Модуль сна пробуждает МК из режимов PM1,PM2, но не переводит их обратно.
     19           После завершения обработки прерывание, продолжится выполнение основного 
     20           потока программы. Пользователь самостоятельно должен перевести МК в режим сна.
     21           Функция NT_SetTime(..) производит подстройку времени сети и корректирует время
     22           срабатывания прерывания. Что бы было понятнее приведу пример: 
     23           Время сети 400 и установленно прерывание на 700.
     24           Пользователь корректирует время на 300, но из-за разной разрядности счетчиков
     25           прерывание произойдет по "старым часам", так как NT_SetTime только изменит
     26           переменную относительного смещения, а не непосредственно значение счетчика.
     27           Поэтому необходимо пересчитать время прерывания 700 к новому смещению.
     28           Из найденных особенностей: когда вызывается обработчик прерывания, значение
     29           времени всегда больше на 2 тика. Предполагаю из за ожидания синхронизации при
     30           чтении значения таймера. 
     31          */
     32          
     33          
     34          // После вызова EventCallback аппаратное прерывание завершается
     35          // и управление передается в главный цикл main.
     36          // Пользователь сам должен положить систему в сон
     37          // Для работы используется sleep timer.
     38          // Значение таймера изменить нельзя, он автоматически стартует после
     39          // Включения микроконтроллера. Нам нужно выбрать XOSC вместо RCOSC,
     40          // Но на отладочной плате нет резонатора
     41          // Чтение значения ST2:ST1:ST0 первым из ST0
     42          // Таймер работает во всех режимах кроме PM3
     43          // После пробуждения нужно убеиться что SLEEPSTA.CLK32K бит установлен прежде 
     44          // чем считывать ST0-3
     45          
     46          
     47          //#define USE_OSC32K // Использовать внешний квац 32.768 кГц
     48          
     49          // Методы модуля
     50          bool NT_SetTime(uint16_t ticks);
     51          void NT_SetCompare(uint16_t ticks);
     52          void NT_SetEventCallback(void (*fn)(uint16_t ticks));
     53          uint16_t NT_GetTime(void);
     54          uint16_t NT_WaitTime(uint16_t ticks);
     55          
     56          // Приватные методы
     57          static uint32_t ReadTimer(void);
     58          static void loadTimerCompare(uint32_t ticks);
     59          static inline bool isIRQEnable(void);
     60          static inline void NT_IRQEnable(bool state);
     61          
     62          // Переменные модуля
     63          static void (*EventCallback)(uint16_t ticks);
     64          static uint32_t COMPARE_TIME; //!< Значение загруженное в регистр compare
     65          
     66          /**
     67          @details Смещение времени сети относительно времени таймера.
     68           NETWORK TIME = TIMER + TOFFSET
     69          */
     70          uint16_t TOFFSET; 
     71          
     72          /**
     73          @brief Инизиализация таймера
     74          */
     75          void NT_Init(void)
     76          {
     77            TOFFSET = 0;
     78            COMPARE_TIME = 0;
     79            EventCallback = NULL;
     80          
     81            #ifdef USE_OSC32K
     82            CLKCONCMD &= ~(1<<7); // Сбрасываем бит OSC32K, будет выбран 32.768 кварц
     83            while (CLKCONSTA & (1<<7)); // Ждем пока бит не станет 0
     84            #endif
     85          
     86            NT_IRQEnable(false);
     87          }
     88          
     89          /**
     90          @brief Устанавливаем текущее время сети и переустанавливает capture time
     91          @param[in] ticks время от 0-32767. Один tick 1/32768
     92          @return true если аргумент в диапазоне
     93          */
     94          bool NT_SetTime(uint16_t ticks)
     95          {
     96            ASSERT_HALT(ticks < 32768, "Incorrect ticks");
     97            if (ticks > 32767)
     98              return false;
     99           
    100            uint16_t timer = ReadTimer();
    101            TOFFSET = ticks - timer;
    102            TOFFSET &= 0x7FFF;
    103          
    104            // После установки времени нужно изменить compare time в таймере
    105            // Но только в случаи если прерывание активно
    106            if (isIRQEnable())
    107            {
    108              NT_SetCompare(COMPARE_TIME);
    109            }
    110          
    111            return true;
    112          }
    113          
    114          /**
    115          @brief Вычисляет значение, которое нужно установить в регистр compare таймера.
    116          @params[in] ticks время сети в тикак
    117          */
    118          static inline uint32_t calcCompareTime(uint16_t ticks)
    119          {   
    120              uint32_t timer = ReadTimer(); // Текущее значение счетчика
    121              
    122              //NETWORK TIME = TIMER + TOFFSET  
    123              // Приводим такты к тактам таймера
    124              uint16_t ticks_offset = (ticks - TOFFSET) & 0x7FFF;
    125              
    126              uint32_t cmp_time = timer & ~0x7FFF; // Убираем младшие 15 бит
    127              cmp_time |= ticks_offset; // Вычисляем новое время
    128              
    129              if (cmp_time <= timer)
    130              {
    131                cmp_time += 0x8000;
    132                cmp_time &=0xFFFFFF;
    133              }
    134                
    135               LOG(MSG_OFF | MSG_INFO | MSG_TRACE, 
    136                   "Timer = %lu, Ticks = %d,CMP = %lu \r\n",
    137                    timer, ticks, cmp_time );
    138              return cmp_time;
    139          }
    140          
    141          /**
    142          @brief Устанавливает время прерывания
    143          @details Время прерывания устанавливается относительно времени сети
    144          ,к примеру, что бы проснуться в таймслот номер 0, нужно установить ticks = 0.
    145          Процедура учитывает текущее значение таймера и перерасчитывает значение ticks. 
    146          @params[in] ticks время сети в тиках когда нужно проснуться
    147          */
    148          void NT_SetCompare(uint16_t ticks)
    149          {
    150            ASSERT_HALT(ticks < 32768, "Incorrect ticks");
    151            
    152            COMPARE_TIME = ticks; // Сохраняем установленное значение
    153           
    154            uint32_t compare_time = calcCompareTime(ticks);
    155           
    156            loadTimerCompare(compare_time);
    157            NT_IRQEnable(true);
    158          }
    159          
    160          /**
    161          @brief Разрешение прерываний таймера сна
    162          @params[in] state = true - разрешить обработку прерываний
    163          */
    164          static inline void NT_IRQEnable(bool state)
    165          {
    166            STIF = 0;
    167            if (state)
    168            {
    169              STIE = 1;
    170            }
    171            else
    172            {
    173              STIE = 0;
    174            }
    175          }
    176          
    177          /**
    178          @brief Проверка активности прерывания таймера
    179          @return true если прерывание установленно
    180          */
    181          static inline bool isIRQEnable(void)
    182          {
    183            if (STIE)
    184              return true;
    185            else 
    186              return false;
    187          }
    188          
    189          /**
    190          @brief Устанавливает обработчик прерывания таймера
    191          @param[in] fn(uint16_t ticks) указатель на функцию-обработчик
    192          */
    193          void NT_SetEventCallback(void (*fn)(uint16_t ticks))
    194          {
    195            EventCallback = fn;
    196          }
    197          
    198          /**
    199          @brief Возвращает время сети 
    200          @return Время сети в тиках
    201          */
    202          uint16_t NT_GetTime(void)
    203          {
    204            uint32_t val = ReadTimer();
    205            // TOFFSET = NETWORK TIME - TIMER
    206            // NETWORK TIME = TIMER + TOFFSET
    207            val +=TOFFSET;
    208            val &= 0x7FFF; // Приводим значения таймера к 0-32767
    209            return val;
    210          }
    211          
    212          /**
    213          @brief Обработчик прерывания таймера сна
    214          */
    215          #pragma vector=ST_VECTOR
    216          __interrupt void TimerCompareInterrupt(void)
    217          {  
    218            uint16_t ticks = NT_GetTime();
    219            if (EventCallback == NULL)
    220              return;
    221            // Отключаем прерывание таймера. Забота пользователя его включить
    222            NT_IRQEnable(false); 
    223            EventCallback(ticks); // Вызываем пользовательский обработчик
    224            STIF = 0; // Очищаем флаг прерывания
    225          }
    226          
    227          /**
    228          @breif Ожидание наступления времени сети
    229          @param[in] ticks время в тактах
    230          @return фактическое время сети
    231          */
    232          uint16_t NT_WaitTime(uint16_t ticks)
    233          {
    234            static union 
    235            {
    236              uint32_t val;
    237              uint8_t fild[4];
    238            } val;
    239            
    240            val.val = 0;
    241            // TOFFSET = NETWORK TIME - TIMER
    242            // NETWORK TIME = TIMER + TOFFSET
    243            
    244            // Ждем синхронизацию таймера после пробуждения
    245            while (!(SLEEPSTA & 0x01));
    246            
    247            do
    248            {
    249              // Соблюдаем порядок чтения регисторов ST  
    250              val.fild[0] = ST0;
    251              val.fild[1] = ST1;
    252              val.fild[2] = ST2;
    253              val.val +=TOFFSET;
    254              val.val &= 0x7FFF; // Приводим значения таймера к 0-32767    
    255            } while (val.val < ticks);
    256            return val.val;
    257          }
    258          
    259          /**
    260          @brief Возвращает текущее значение таймера
    261          @return Текущие ticks
    262          */
    263          static uint32_t ReadTimer(void)
    264          {
    265            static union 
    266            {
    267              uint32_t val;
    268              uint8_t fild[4];
    269            } ret_val;
    270            
    271            ret_val.val = 0;
    272            
    273            // Ждем синхронизацию таймера после пробуждения
    274            while (!(SLEEPSTA & 0x01));
    275            
    276            // Соблюдаем порядок чтения регисторов ST  
    277            ret_val.fild[0] = ST0;
    278            ret_val.fild[1] = ST1;
    279            ret_val.fild[2] = ST2;
    280            return ret_val.val;
    281          }
    282          
    283          /**
    284          @brief Устанавливает время пробуждения микроконтролера
    285          @params[in] ticks 24 битное значение времени пробуждения в ticks
    286          */
    287          static void loadTimerCompare(uint32_t ticks)
    288          {
    289            union 
    290            {
    291              uint32_t val;
    292              uint8_t fild[4];
    293            } value;
    294            
    295            value.val = ticks;
    296            
    297            // Ждем разрешения на запись нового значения
    298            while (!(STLOAD & 0x01));
    299            
    300            // Регистр ST0 должен быть записан в последнию очередь
    301            ST2 = value.fild[2];
    302            ST1 = value.fild[1];
    303            ST0 = value.fild[0];
    304          }
\\vmware-host\Shared Folders\Projects\WMNU\IAR\SHARE_PRJ_SRC\nwdebuger.c
      1          #include "nwdebuger.h"
      2          #include "ioCC2530.h"
      3          #include "stdint.h"
      4          #include "stdio.h"
      5          
      6          
      7          #define UART_DEBUG // Если определено, то вывод в uart
      8          
      9          // Настройка выводов SIG и порта uart для отладки
     10          
     11          static void uart_init(void)
     12          {
     13            // Выбор расположения UART на выводах
     14            uint8_t U0CFG = 0; // 0={TX=P0_3, RX=P0_2
     15            PERCFG |= (U0CFG<<0); 
     16            
     17            // U0UCR регистр настройки режима uart. меня устраивает по умолчанию
     18            U0CSR = (1<<7); // Выбираем режим uart 
     19            
     20            // Настройка скорости передачи данных на 2М  
     21            U0BAUD = 0;  // табличные значения из pdf
     22            U0GCR =  16;
     23            
     24            // Включаем альтернативные функции выводов
     25            P0SEL = (1<<2)|(1<<3);
     26          }
     27          
     28          static void SetCPU32M(void)
     29          {
     30            CLKCONCMD = 0x88;
     31            while (CLKCONSTA&(1<<6));
     32          }
     33          
     34          void nwDebugerInit(void)
     35          {
     36            SetCPU32M();
     37          #ifdef UART_DEBUG
     38            uart_init();
     39          #endif
     40          }
     41          
     42          __attribute__((weak)) void STACK_FAILURE(char* msg)
     43          {
     44            LOG(MSG_ON | MSG_ALARM | MSG_ALL, "STACK FAILURE. HALT\n");
     45            while(1);
     46          }
     47          
     48          // Переопределяем функцию записи в порт
     49          #ifdef UART_DEBUG
     50          #include <yfuns.h>
     51          
     52          _STD_BEGIN
     53          
     54          #pragma module_name = "?__write"
     55          
     56          int MyLowLevelPutchar(int x);
     57          
     58          int MyLowLevelPutchar(int x){
     59            while( U0CSR&(1<<0));
     60            U0DBUF = x;
     61            return x;
     62          }
     63          /*
     64           * If the __write implementation uses internal buffering, uncomment
     65           * the following line to ensure that we are called with "buffer" as 0
     66           * (i.e. flush) when the application terminates.
     67           */
     68          
     69          size_t __write(int handle, const unsigned char * buffer, size_t size)
     70          {
     71            /* Remove the #if #endif pair to enable the implementation */
     72             
     73          
     74            size_t nChars = 0;
     75          
     76            if (buffer == 0)
     77            {
     78              /*
     79               * This means that we should flush internal buffers.  Since we
     80               * don't we just return.  (Remember, "handle" == -1 means that all
     81               * handles should be flushed.)
     82               */
     83              return 0;
     84            }
     85          
     86            /* This template only writes to "standard out" and "standard err",
     87             * for all other file handles it returns failure. */
     88            if (handle != _LLIO_STDOUT && handle != _LLIO_STDERR)
     89            {
     90              return _LLIO_ERROR;
     91            }
     92          
     93            for (/* Empty */; size != 0; --size)
     94            {
     95              if (MyLowLevelPutchar(*buffer++) < 0)
     96              {
     97                return _LLIO_ERROR;
     98              }
     99          
    100              ++nChars;
    101            }
    102          
    103            return nChars;
    104          
    105          }
    106          
    107          _STD_END
    108          #endif
\\vmware-host\Shared Folders\Projects\WMNU\IAR\SHARE_PRJ_SRC\RADIO.c
      1          /*!
      2          \file 
      3          \brief Модуль содержит реализацию интерфейса радио для приема/передачи данных.
      4          */
      5          
      6          #include "RADIO.h"
      7          #include "mem.h"
      8          #include "nwdebuger.h"
      9          #include "Radio_defs.h"
     10          #include "TIC.h"
     11          #include "delays.h"
     12          #include "frame.h"
     13          #include "string.h"
     14          #include "coder.h"
     15          #include "NTMR.h"
     16          
     17          // Открытые методы модуля
     18          void RI_init(void);
     19          bool RI_SetChannel(uint8_t CH);
     20          bool RI_Send(frame_s *fr);
     21          frame_s* RI_Receive(uint16_t timeout);
     22          uint32_t RI_GetCRCError(void);
     23          uint32_t RI_GetCCAReject(void);
     24          float RI_GetUptime(void);
     25          void RI_StreamCrypt(bool state);
     26          void RI_setKEY(void* ptr_KEY);
     27          void RI_setIV(void* ptr_IV);
     28          
     29          // Приватные методы
     30          static void random_core_init(void);
     31          static void RI_cfg(void);
     32          
     33          // TODO можно добавть простой алгоритм перестановки для сокрытия данных 
     34          // при передаче RAW формата. Алгоритм должен быть достаточно простой и 
     35          // перестанавливать биты, смешивать их с ключом. Алгорим не производит 
     36          // контроль дешифровки с помощью цифровых подписей.
     37          // Шифрование можно включаеть/отключаеть
     38          // Возможно попробовать аппаратный модуль, так как к уже зашифрованому пакету
     39          // IP добавятся данные и зашифруются еще одним ключем, надежность возрастет.
     40          // Думаю это не будет являтся двойным шифрованием и будет устойчиво к взлому
     41          static void RI_BitRawCrypt(uint8_t *src, uint8_t size); // Шифрование передачи
     42          static void RI_BitRawDecrypt(uint8_t *src, uint8_t size); // Дешифрока приема
     43          static inline void setFreq(uint8_t CH); // Установка частоты передатчика
     44          static void LoadTXData(uint8_t *src, uint8_t len); // Загрузка данных в tx buf
     45          static void UnLoadRXData(uint8_t *src, uint8_t len);
     46          static bool SendData(frame_s *fc);
     47          static bool RecvData(uint32_t timeout_us, uint16_t *SFD_TimeStamp);
     48          
     49          // Переменные модуля
     50          static float RI_UPTIME = 0; // Время работы радио в мс. 49 дней максимум
     51          static uint32_t RI_CRC_ERROR = 0; // Количество ошибок CRC
     52          static uint32_t RI_CCA_REJECT = 0; // Количество отказов передач из-за CCA
     53          static uint8_t IV[16];  // Вектор иницилизации для кодирования
     54          static uint8_t KEY[16]; // Ключ для кодирования
     55          
     56          /*!
     57          \brief Константы для установки выходной мощности радиопередатчика.
     58          Пример: p4x5 = +4,5 дБ. m0x5 = -0.5 дБ
     59          */
     60          enum TX_POWER_e 
     61          {
     62            // +4.5дБ = p4x5, -1.5дБ = m1x5.
     63            // +4.5 = 34мА, +1 = 29мА, -4 = 26мА, -10 = 25 мА, -22 = 23 мА
     64            p4x5 = 0xF5, p2x5 = 0xE5, p1x0 = 0xD5, m0x5 = 0xC5, m1x5 = 0xB5, m3x0 = 0xA5,
     65            m4x0 = 0x95, m6x0 = 0x85, m8x0 = 0x75, m10x0 = 0x65, m12x0 = 0x55, 
     66            m14x0 = 0x45, m16x0 = 0x35, m20x0 = 0x15, m22x0 = 0x05
     67          };
     68          
     69          
     70          #define IEEE_MODE 0     //!< Режимы фазы сигнала
     71          #define NOT_IEEE_MODE 1 //!< Режимы фазы сигнала
     72          #define RSSI_OFFSET -76 //!< Константа для вычисления реальной мощности
     73          
     74          /*!
     75          \details 
     76           Расчет качества связи. Коэффициенты получаются эксперементально.
     77           Есть предположение, что количество ошибок будет пропорционально квадрату
     78           коеффициента корреляции сигнала.
     79           LIQ = 255 передача 1000 пакетов без ошибок CRC
     80           LIQ = 127 передача 1000 пакетов с 50% ошибок CRC
     81           LIQ = 0   передача 1000 пакетов с 100% ошибок CRC
     82          */ 
     83          #define CONST_A (int8_t)0 //!< Коэффициент A
     84          #define CONST_B (int8_t)1 //!< Коэффициент B
     85          #define LIQ_CALC(corr) ((corr-CONST_A)*CONST_B) //!< Формула вычисление LIQ 
     86          #define FRQ_CALC(x) (11+5*(x-11)) //!< Формул вычисления частоты сигнала
     87          
     88          /// Глобальные параметры модуля
     89          struct
     90          {
     91            uint8_t CH;       //!< Номер канала с 11 до 26 включительно
     92            uint8_t TX_POWER; //!< Мощность радиопередатчика по умолчанию. 7 бит
     93            bool MODULATION_MODE; //!< false - совместимость с IEEE 802.15.4
     94            bool STREAM_CRYPT_ENABLE; //!< Шифрование выходного потока данных
     95          } RADIO_CFG;
     96          
     97          /**
     98          @brief Установить вектор иницилизации для шифрования
     99          @param[in] ptr_IV указатель на 16 байтный вектор иницилизации
    100          */
    101          void RI_setIV(void* ptr_IV)
    102          {
    103            memcpy(IV, ptr_IV, 16);
    104          }
    105          
    106          /**
    107          @brief Установить ключ шифрования
    108          @param[in] ptr_KEY указатель на 16 байтный ключ
    109          */
    110          void RI_setKEY(void* ptr_KEY)
    111          {
    112            memcpy(KEY, ptr_KEY, 16);
    113          }
    114          
    115          /*!
    116          \brief Иницилизация радио интерфейса
    117          */
    118          void RI_init(void)
    119          {
    120            // Настройки поумолчанию
    121            RADIO_CFG.CH = CH11;
    122            RADIO_CFG.TX_POWER = m0x5;
    123            RADIO_CFG.MODULATION_MODE = IEEE_MODE;
    124            RADIO_CFG.STREAM_CRYPT_ENABLE = true;
    125            // Пост действия с радио
    126            random_core_init();
    127          }
    128          
    129          /*!
    130          \brief Переводит радио в активный режим и устанавливает параметры.
    131          */
    132          static void RI_cfg(void)
    133          {
    134          /*
    135          APPEND_DATA_MODE = 0. FCS1 = signed rssi, FCS2.7 CRC OK, FCS2.6-0 Correlation
    136          A correlation value of ~110 indicates a maximum quality frame while a value 
    137          of ~50 is typically the lowest quality frames detectable by CC2520. 
    138          */
    139          /* После включения радио находится в активном режиме но приемник выключен */
    140            
    141            // Устанавливаем частоту радиопередатчика
    142            setFreq(RADIO_CFG.CH);
    143            
    144            // Устанавливаем мощность выходного сигнала
    145            TXPOWER = RADIO_CFG.TX_POWER;
    146           
    147            FRMFILT0 = 0x00; // Отключаем фильтрацию пакетов
    148            
    149            // Устанавливаем режим модуляции
    150            MDMTEST1_u MDM1;
    151            MDM1.value = MDMTEST1;
    152            MDM1.bits.MODULATION_MODE = RADIO_CFG.MODULATION_MODE;
    153            MDMTEST1 = MDM1.value; 
    154          }
    155          
    156          /*!
    157          \brief Устанавливает канал радиопередатчика.
    158          \param[in] CH Номера каналов [11..26]
    159          \return Возвращает true если аргументы верны
    160          */
    161          bool RI_SetChannel(uint8_t CH)
    162          {
    163            if ((CH >=11) && (CH<=26))
    164            {
    165              RADIO_CFG.CH = CH;
    166              return true;
    167            }
    168            return false;
    169          }
    170          
    171          /*!
    172          \brief Передает данные в эфир
    173          \details Функция может самостоятельно шифровать поток данных, увеличивает 
    174           RI_CCA_REJECT при невозможности отправки сообщения, расчитывает время работы 
    175           радио передатчика. Отправка сообщения в заданное сетевое время 
    176           fr->meta.SEND_TIME. Если равно 0, то отправка через случайноу время в мкс.
    177           Данные автоматически оборачиваются в LEN, CRC1,CRC2
    178          \param[in] *fr Указатель на структуру frame_s RAW_LAY
    179          \return Возвращает true в случаи успешной передачи
    180          */
    181          bool RI_Send(frame_s *fr)
    182          {
    183            ASSERT_HALT(fr != NULL, "fr NULL");
    184            
    185            // Устанавливаем частоту передачи пакета
    186            RI_cfg();
    187            
    188            bool send_res; // Результат передачи данных
    189            TimeStamp_s start,stop; // Измерение времени
    190            
    191            TIM_TimeStamp(&start); // Начало измерения времени
    192            send_res = SendData(fr);
    193            TIM_TimeStamp(&stop); // Конец измерения времени
    194            
    195            uint32_t passed = TIM_passedTime(&start, &stop);
    196            RI_UPTIME += (float)passed/1000; // Микросекунды в милисекунды
    197            
    198            // В случаи ошибки передачи увеличиваем счетчик RI_CCA_REJECT
    199            if (!send_res)
    200              RI_CCA_REJECT++;
    201            
    202            return send_res;
    203          }
    204          
    205          /**
    206          @brief Отправка сообщения
    207          @detail Время отправки с шифрованием 10 байт в мкс. Merge = 155, Crypt = 239,
    208           Load TX = 30, RSSI_OK = 328, ISTXON = 11, SFD(192us+5*8*4us) = 400, TX = 370, Full = 1535.
    209          Время работы радио RSSI_OK+ISTXON+SFD+TX = 1109 us
    210          @return true в случаи успеха
    211          */
    212          static bool SendData(frame_s *fr)
    213          {
    214          ////TimeStamp_s ts_start, ts_frame_merge, ts_crypt, ts_load_tx, 
    215          ////ts_rssistat, ts_istxon, ts_sfd, ts_stop;
    216            
    217          ////TIM_TimeStamp(&ts_start);  
    218            uint8_t data_size = fr->len;
    219            uint8_t *data = (uint8_t*)fr->payload; 
    220          ////TIM_TimeStamp(&ts_frame_merge);  
    221            bool result = true;
    222            switch(true)
    223            {
    224              case true:
    225                // Шифруем данные при необходимости
    226                RI_BitRawCrypt(data, data_size);
    227          ////TIM_TimeStamp(&ts_crypt); 
    228                // Копируем данные в буфер. Очистка буфера автоматическая
    229                LoadTXData(data, data_size);
    230          ////TIM_TimeStamp(&ts_load_tx); 
    231                // Для начала передачи по команде STXONCCA нужно включить приемник
    232                ISRXON();
    233                // Ждем пока статус RSSI_VALID станет true
    234                while(!RSSISTAT);
    235          ////TIM_TimeStamp(&ts_rssistat); 
    236                // Очищаем флаг завершения передачи сообщения
    237                RFIRQF1 &= ~RFIRQF1_TXDONE;
    238                RFIRQF0 &= ~RFIRQF0_SFD;
    239                
    240                // Время отправки сообщения измеряется в тактах сетевого времени NTMR
    241                // Он работатаеи намного лучше чем MAC таймер(меньше погрешность)
    242                // Отправка в обозначенное время или по факту готовности
    243                uint16_t timer = 0; // Для отлалки. 
                                ^
Warning[Pe550]: variable "timer" was set but never used
          detected during compilation of secondary translation unit
                    "\\vmware-host\Shared
                    Folders\Projects\WMNU\IAR\SHARE_PRJ_SRC\RADIO.c"
    244                if (fr->meta.SEND_TIME != 0)
    245                  timer = NT_WaitTime(fr->meta.SEND_TIME);
    246          
    247                // Начинаем передачу данных
    248                // Transmission of preamble begins 192 μs after the STXON or STXONCCA 
    249                // command strobe
    250                // 192+(4(pream)+1(sfd))*8bit*4us = 352 мкс. Измерил 360мкс
    251                // Измерил в тактах NT_GetTimer() получилось 13 тиков. 396 мкс 
    252                ISTXONCCA();
    253          ////TIM_TimeStamp(&ts_istxon); 
    254                // Произошла ошибка передачи если SAMPLED_CCA false
    255                if (!(FSMSTAT1 & 1<<3)) //SAMPLED_CCA == 0
    256                {
    257                  result = false;
    258                  break;
    259                }
    260          
    261                // Ждем завершения отправки SFD
    262                while (!(RFIRQF0 & RFIRQF0_SFD));
    263                fr->meta.TIMESTAMP = NT_GetTime(); 
    264          ////TIM_TimeStamp(&ts_sfd); 
    265                // Проверим переданно ли сообщение TX_FRM_DONE
    266                while (!(RFIRQF1 & RFIRQF1_TXDONE));
    267                break;
    268            }
    269          ////TIM_TimeStamp(&ts_stop);
    270          
    271            re_free(data);
    272            ISRFOFF();
    273          ////  LOG(MSG_ON | MSG_INFO | MSG_TRACE, 
    274          ////"Merge = %lu. Crypt = %lu. Load TX = %lu. RSSI_OK = %lu. ISTXON = %lu. SFD = %lu. TX = %lu. FULL = %lu \n", 
    275          ////      TIM_passedTime(&ts_start, &ts_frame_merge),
    276          ////      TIM_passedTime(&ts_frame_merge, &ts_crypt),
    277          ////      TIM_passedTime(&ts_crypt, &ts_load_tx),
    278          ////      TIM_passedTime(&ts_load_tx, &ts_rssistat),
    279          ////      TIM_passedTime(&ts_rssistat, &ts_istxon),
    280          ////      TIM_passedTime(&ts_istxon, &ts_sfd),
    281          ////      TIM_passedTime(&ts_sfd, &ts_stop),
    282          ////      TIM_passedTime(&ts_start, &ts_stop)
    283          ////      );
    284            
    285            if (result)
    286              return true;
    287            return false; 
    288          }
    289          
    290          /**
    291          @brief Загрузка данных для передачи в буфер. 
    292          @detail Поля LEN, FCS1, FCS2 добавляются автоматически
    293          @param[in] src указатель на данные
    294          @param[in] len размер данных
    295          */
    296          static void LoadTXData(uint8_t *src, uint8_t len)
    297          {
    298            // Очищаем буфер передатчика
    299            ISFLUSHTX(); 
    300            // Поле LEN на два байта больше
    301            RFD = len + 2;
    302            
    303            for (uint8_t i = 0 ; i < len; i++)
    304              RFD = src[i];
    305            
    306            // Добавляем CRC1,2
    307            RFD = 0x00;
    308            RFD = 0x00;
    309          };
    310          
    311          /**
    312          @brief Выгружаем принятый пакет из радио
    313          @param[out] src указатель на буфер приемника
    314          @param[in] len размер выгружаемых данных
    315          */
    316          static void UnLoadRXData(uint8_t *src, uint8_t len)
    317          {
    318            for (uint8_t i = 0 ; i < len; i++)
    319              src[i] = RFD;
    320          };
    321          
    322          static inline void setFreq(uint8_t CH)
    323          {
    324            ASSERT_HALT( (CH >= 11) && (CH <= 26), "Incorrect radio channel");
    325            // Устанавливаем частоту радиопередатчика
    326            FREQCTRL_u FRQ;
    327            FRQ.value = FRQ_CALC(RADIO_CFG.CH);
    328            FREQCTRL = FRQ.value;  
    329          }
    330          
    331          /*!
    332          \brief Принимает данные из эфира
    333          \details Функция принимает данные из эфира. Проводит проверку CRC, увеличивает
    334          RI_CRC_ERROR. Дешифрует данные при необходимости. Отмечает время прихода SFD 
    335           в тактах сетевого времени .
    336          \param[in] timeout Время ожидания данных в милисекундах
    337          \return Возвращает NULL если данных нет
    338          */
    339          frame_s* RI_Receive(uint16_t timeout)
    340          {
    341            // Устанавливаем частоту передачи пакета
    342            RI_cfg();
    343            uint16_t SFD_TimeStamp;
    344            
    345            // Принимаем пакет 
    346            uint32_t timeout_us = timeout*1000UL; // Переводим мс->мкс
    347            TimeStamp_s start,stop; // Измерение времени
    348            TIM_TimeStamp(&start); // Начало измерения времени работы радио
    349            bool recv_res = RecvData(timeout_us, &SFD_TimeStamp);
    350            TIM_TimeStamp(&stop); // Конец измерения времени радио
    351            uint32_t passed = TIM_passedTime(&start, &stop);
    352            RI_UPTIME += (float)passed/(float)1000; // Микросекунды в милисекунды
    353            
    354            // Если ничего не приняли возвращаем NULL
    355            if (!recv_res)
    356              return NULL;
    357            
    358            uint8_t frame_size = RXFIFOCNT; // Количество принятых данных
    359            
    360            // Минимальный размер FCS1,FCS2 - 2 байта. LEN не включен в подсчет 
    361            if (frame_size <= 2)
    362              return NULL;
    363            
    364            // Выгружаем данные из приемника
    365            uint8_t *frame_raw = re_malloc(frame_size); 
    366            UnLoadRXData(frame_raw, frame_size);
    367            
    368            int8_t  FCS1 = frame_raw[frame_size - 2]; // RSSI
    369            uint8_t FCS2 = frame_raw[frame_size - 1]; // bit7 = CRCOK, bit[6..0] Corr_val
    370            uint8_t LEN_F = frame_raw[0]; // Поле LEN
    371            
    372            // Проверим поле LEN. Размер данных в заголовке должен совпадать
    373            // с фактической длинной принятых данных
    374            if (LEN_F != frame_size - 1)
    375            {
    376              re_free(frame_raw);
    377              RI_CRC_ERROR ++;
    378              return NULL;
    379            }
    380            
    381            // Проверим поле CRCOK
    382            if (!(FCS2 && 1<<7))
    383            {
    384              re_free(frame_raw);
    385              RI_CRC_ERROR ++;
    386              return NULL;
    387            }
    388            
    389            // Создаем буфер, последнии два байта FCS1,2 и поле LEN не копируем
    390            frame_s *raw_frame = frame_create();
    391            frame_addHeader(raw_frame, &frame_raw[1], frame_size - 2);
    392            // Декодируем поток если нужно
    393            RI_BitRawDecrypt(raw_frame->payload, raw_frame->len);
    394            
    395            // Копируем метку времени SFD
    396            raw_frame->meta.TIMESTAMP = SFD_TimeStamp;
    397            
    398            // Расчитываем мощность принятого сигнала
    399            raw_frame->meta.RSSI_SIG =  FCS1 + RSSI_OFFSET;
    400            // Расчитываем качество сигнала
    401            uint8_t corr = FCS2 & 0x7F;
    402            raw_frame->meta.LIQ = LIQ_CALC(corr); // Значение коэфф. корреляции
    403          
    404            raw_frame->meta.CH = RADIO_CFG.CH;
    405          
    406            re_free(frame_raw);
    407            return raw_frame;
    408          }
    409          
    410          /**
    411          @brief Прием данных из эфира
    412          @param[in] timeout_us время ожидания в микросекундах
    413          @param[out] SFD_TimeStamp отметка времени завершения приема SFD
    414          */
    415          static bool RecvData(uint32_t timeout_us, uint16_t *SFD_TimeStamp)
    416          {
    417            TimeStamp_s start,stop; // Измерение времени  
    418            ISFLUSHRX(); // Очищаем буфер приема
    419            
    420            TIM_TimeStamp(&start);
    421            
    422            // Очищаем флаг завершения передачи сообщения и приема SFD
    423            RFIRQF0 &= ~RFIRQF0_RXPKTDONE;  
    424            RFIRQF0 &= ~RFIRQF0_SFD; 
    425            ISRXON(); // Включаем радиопередатчик
    426          
    427            bool time_out = false; // Истекло время ожидания пакета
    428            bool packet_received = false; // Приняли пакет
    429            bool sfd_received = false; // Приняли sfd
    430            
    431            // Цикл приема пакета
    432            while (true)
    433            {
    434              TIM_TimeStamp(&stop);
    435              if (TIM_passedTime(&start, &stop) >= timeout_us)
    436              {
    437                time_out = true;
    438                break;
    439              }
    440             
    441              // Принят сигнал SFD
    442              if ((RFIRQF0 & RFIRQF0_SFD))
    443              {
    444                *SFD_TimeStamp = NT_GetTime(); 
    445                sfd_received = true;
    446              }
    447              
    448              //  Завершен ли прием сообщения RX_FRM_DONE (RXPKTDONE)
    449              if ((RFIRQF0 & RFIRQF0_RXPKTDONE))
    450              {
    451                packet_received = true;
    452                break;
    453              }
    454            } // while 
    455            
    456            ISRFOFF();
    457            if (packet_received && sfd_received && !time_out)
    458              return true;
    459            else
    460              return false;
    461          }
    462          
    463          /*!
    464          \brief Возвращает количество ошибок возникших с момента иницилизации
    465          \return Количество CRC ошибок
    466          */
    467          uint32_t RI_GetCRCError(void)
    468          {
    469            return RI_CRC_ERROR;
    470          }
    471          
    472          /*!
    473          \brief Возвращает количестов отказов передачи пакета из-за занятости канала.
    474          \return Количество отказов CCA
    475          */
    476          uint32_t RI_GetCCAReject(void)
    477          {
    478            return RI_CCA_REJECT;
    479          }
    480          
    481          /*!
    482          \brief Возвращает суммарное время работы радио в режиме прием/передача
    483          \return Вермя в милисекундах
    484          */
    485          float RI_GetUptime(void)
    486          {
    487            return RI_UPTIME;
    488          }
    489          
    490          /**
    491          @breif Подссчет количества бит в байте
    492          @return Возвращает количество бит
    493          */
    494          static uint8_t bits_count(uint8_t value) {
    495            int ret = 0;
    496            for ( ; value; value = value >> 1 )
    497              ret += value & 1;
    498            return ret;
    499          }
    500          
    501          /**
    502          @brief Возращает 1 байт случайного числа
    503          @details Радио выдает всего лишь дви бита, нам нужно 8 
    504          */
    505          static inline uint8_t getRNDByte(void)
    506          {
    507            uint8_t val = 0;
    508            val |= RFRND << 0;
    509            val |= RFRND << 2;
    510            val |= RFRND << 4;
    511            val |= RFRND << 6;
    512            return val;
    513          }
    514          
    515          /**
    516          @brief Возвращает случайное число с числом включеных бит от 2 до 6 включительно
    517          @details Случайные числа появляются в регистре с частотой 170нс. Функция 
    518          возвращает гарантированно новое значение. 
    519          @return возвращает случайное число.
    520          */
    521          static inline uint8_t readRandom(void)
    522          {
    523            uint8_t rnd_val = 0;
    524            uint8_t bit_cnt = 0;
    525            while ( bit_cnt <= 2 || bit_cnt >= 6 )
    526            {
    527              rnd_val = getRNDByte();
    528              while (rnd_val == getRNDByte());
    529              rnd_val = getRNDByte();
    530              bit_cnt = bits_count(rnd_val);
    531            }
    532            return rnd_val;
    533          }
    534          
    535          /*!
    536          \brief Иницилизирует ядро генератора случайных чисел данными из эфира
    537          */
    538          static void random_core_init(void)  
    539          {
    540            unsigned int rnd_core = 0;;
    541               
    542            RI_cfg();
    543            FREQCTRL = 0x00; // Выбираем не используемую частоту
    544          
    545            // TODO По какой то причине OP_EXE не выполняет команду.
    546            // регистра RFST читается как 0xD0. это его состояние при reset
    547            // Включаем демодулятор
    548            ISRXON();
    549            
    550            // Ждем пока статус RSSI_VALID станет true
    551            while(!RSSISTAT);
    552            
    553            // Ждем случайных чисел
    554            while (RFRND == 0);
    555            
    556            // Настраиваем ядро случайного генератора
    557            rnd_core = readRandom();
    558            rnd_core |= (unsigned int)readRandom()<<8;
    559            srand(rnd_core);
    560            
    561            // Включаем демодулятор
    562            ISRFOFF();
    563            // Первая генерация случайного числа занимает много времени.
    564            // Влияло на работу радио, так как использовались случайные посылки
    565            rand(); 
    566          }
    567          
    568          /*!
    569          \brief Установка разрешения шифрования потока данных
    570          \param[in] true - включить шифрование
    571          */
    572          void RI_StreamCrypt(bool state)
    573          {
    574            RADIO_CFG.STREAM_CRYPT_ENABLE = state;
    575          }
    576          
    577          /*!
    578          \brief Шифрует область памяти если шифрование разрешено
    579          \param[in,out] *src Указатель на начало области шифрования
    580          \param[in] size Размер шифруемых данных
    581          */
    582          static void RI_BitRawCrypt(uint8_t *src, uint8_t size)
    583          {
    584            if (!RADIO_CFG.STREAM_CRYPT_ENABLE)
    585              return;
    586            
    587            AES_StreamCoder(true, src, src, KEY, IV, size);
    588          }
    589          
    590          /*!
    591          \brief Расшифровка область памяти если шифрование разрешено
    592          \param[in,out] *src Указатель на начало области дешифрования
    593          \param[in] size Размер расшифруемых данных
    594          */
    595          static void RI_BitRawDecrypt(uint8_t *src, uint8_t size)
    596          {
    597             if (!RADIO_CFG.STREAM_CRYPT_ENABLE)
    598              return;
    599             
    600            AES_StreamCoder(false, src, src, KEY, IV, size);
    601          }
\\vmware-host\Shared Folders\Projects\WMNU\IAR\SHARE_PRJ_SRC\TIC.c
      1          #include "TIC.h"
      2          #include "NTMR.h"
      3          #include "stdlib.h"
      4          #include "nwdebuger.h"
      5          #include "delays.h"
      6          
      7          /**
      8          @file 
      9          @brief 
     10          @details
     11          */
     12          
     13          // Публичные методы
     14          void TIC_Init(void);
     15          
     16          // Методы класса
     17          void TIC_SetTimer(uint16_t ticks);
     18          uint16_t TIC_GetTimer(void);
     19          bool TIC_SetTXState(uint8_t TS, bool state);
     20          bool TIC_SetRXState(uint8_t TS, bool state);
     21          bool TIC_GetTXState(uint8_t TS);
     22          bool TIC_GetRXState(uint8_t TS);
     23          void TIC_SetRXCallback(void (*fn)(uint8_t TS));
     24          void TIC_SetTXCallback(void (*fn)(uint8_t TS));
     25          void TIC_SetSECallback(void (*fn)(uint8_t TS));
     26          uint32_t TIC_GetUptime(void);
     27          uint32_t TIC_GetRTC(void);
     28          bool TIC_SetRTC(uint32_t RTC);
     29          void TIC_SetNonce(uint32_t nonce);
     30          uint32_t TIC_GetNonce(void);
     31          uint32_t TIC_TimeUsFromTS0();
     32          TimeStamp_s* TIC_GetTimeStampTS0(void);
     33           
     34          // Приватные методы
     35          static uint8_t TIC_getCurrentTS(uint16_t ticks);
     36          static void TIC_TDMAShelduler(uint8_t TS);
     37          static void TIC_HW_Timer_IRQ(uint16_t ticks);
     38          static inline void set_capture_time(uint8_t TS);
     39          static inline void Callback_execution(void (*fn)(uint8_t TS), uint8_t TS);
     40          static inline void incrementTS(uint8_t *TS);
     41          static void clocks_update(void);
     42          
     43          // Переменные модуля
     44          
     45          // Всего 50 слотов. (50 активных и 50 слотов сна)
     46          // Кварц имеет 32768 тактов в секунду. После 100 слотов
     47          // Остается 68 неучтеных тактов. Их нужно учитывать.
     48          #define MAX_TS (uint8_t)50
     49          #define TS_ACTIVE (uint16_t)327 // 9.979 мс
     50          #define TS_SLEEP (uint16_t)327  // 2.075 мс
     51          #define TS_UNACCOUNTED 68
     52          // Целый цикл-это сумма времени активного периода и сна
     53          #define FULL_SLOT  (TS_ACTIVE+TS_SLEEP)
     54          #define NO_TIME_SLOT 0xFF
     55          
     56          #define TS_RX (uint8_t)(1<<0)
     57          #define TS_TX (uint8_t)(1<<1)
     58          #define DAILY_SEC (uint32_t)86400
     59          #define MAX_TICKS (uint16_t)32768
     60          
     61          static uint32_t NODE_UPTIME = 0;
     62          static uint32_t NODE_RTC = 0;
     63          static uint32_t NODE_NONCE = 0;
     64          static void (*RXCallback)(uint8_t TS);
     65          static void (*TXCallback)(uint8_t TS);
     66          static void (*SECallback)(uint8_t TS);
     67          static uint8_t TSStateTable[MAX_TS];
     68          static TimeStamp_s TimeStampTS0;
     69          
     70          
     71          TimeStamp_s* TIC_GetTimeStampTS0(void)
     72          {
     73            return &TimeStampTS0;
     74          }
     75          
     76          void TIC_Init(void)
     77          {    
     78            // Устанавливаем обработчик прерываний таймера
     79            NT_SetEventCallback(TIC_HW_Timer_IRQ);
     80            // Запускаем процесс планировщика
     81            NT_SetCompare(0); 
     82            TIC_SetTimer(0);
     83            TIM_TimeStamp(&TimeStampTS0);
     84          }
     85          
     86          uint32_t TIC_TimeUsFromTS0()
     87          {
     88            uint32_t passed;
     89            TimeStamp_s now;
     90            TIM_TimeStamp(&now);
     91            passed = TIM_passedTime(&TimeStampTS0, &now);
     92            return passed;
     93          }
     94          
     95          void TIC_SetTimer(uint16_t ticks)
     96          {
     97            ASSERT_HALT(ticks < MAX_TICKS, "Ticks not in range");
     98            if (ticks >= MAX_TICKS)
     99              return ;
    100            
    101            NT_SetTime(ticks);
    102          }
    103          
    104          uint16_t TIC_GetTimer(void)
    105          {
    106            return NT_GetTime();
    107          }
    108          
    109          bool TIC_SetTXState(uint8_t TS, bool state)
    110          {
    111            if (TS>=MAX_TS)
    112            {
    113              return false;
    114            }
    115            ASSERT_HALT(TS<MAX_TS, "TS not in range");
    116            
    117            if (state)
    118              TSStateTable[TS] |= TS_TX;
    119            else
    120              TSStateTable[TS] &= ~TS_TX;
    121            
    122            return true;
    123          }
    124          
    125          bool TIC_SetRXState(uint8_t TS, bool state)
    126          {
    127            if (TS>=MAX_TS)
    128            {
    129              return false;
    130            }
    131            ASSERT_HALT(TS<MAX_TS, "TS not in range");
    132            
    133            if (state)
    134              TSStateTable[TS] |= TS_RX;
    135            else
    136              TSStateTable[TS] &= ~TS_RX;
    137            
    138            return true;
    139          }
    140          
    141          bool TIC_GetTXState(uint8_t TS)
    142          {
    143              if (TS>=MAX_TS)
    144            {
    145              return false;
    146            }
    147            ASSERT_HALT(TS<MAX_TS, "TS not in range");
    148            
    149            return (TSStateTable[TS] & TS_TX) ;
    150          }
    151          
    152          bool TIC_GetRXState(uint8_t TS)
    153          {
    154              if (TS>=MAX_TS)
    155            {
    156              return false;
    157            }
    158            ASSERT_HALT(TS<MAX_TS, "TS not in range");
    159            
    160            return (TSStateTable[TS] & TS_RX) ;
    161          }
    162          
    163          void TIC_SetRXCallback(void (*fn)(uint8_t TS))
    164          {
    165            ASSERT_HALT(fn != NULL, "Fn is NULL");
    166            RXCallback = fn;
    167          }
    168          
    169          void TIC_SetTXCallback(void (*fn)(uint8_t TS))
    170          {
    171            ASSERT_HALT(fn != NULL, "Fn is NULL");
    172            TXCallback = fn;
    173          }
    174          
    175          void TIC_SetSECallback(void (*fn)(uint8_t TS))
    176          {
    177            ASSERT_HALT(fn != NULL, "Fn is NULL");
    178            SECallback = fn;
    179          }
    180          
    181          uint32_t TIC_GetUptime(void)
    182          {
    183            return NODE_UPTIME;
    184          }
    185          
    186          uint32_t TIC_GetRTC(void)
    187          {
    188            return NODE_RTC;
    189          }
    190          
    191          bool TIC_SetRTC(uint32_t RTC)
    192          {
    193            if (RTC >= DAILY_SEC)
    194              return false;
    195            
    196            NODE_RTC = RTC;
    197            return true;
    198          }
    199          
    200          static uint8_t TIC_getCurrentTS(uint16_t ticks)
    201          {
    202            //uint16_t ticks = nt->NT_GetTime();
    203            // Вычисляем количество целых циклов
    204            uint8_t full_slot_num = ticks/FULL_SLOT;
    205            
    206            // Вычисляем остаток от деления. Остаток - смещение внутри
    207            // временного слота.
    208            uint16_t time_remainder = ticks % FULL_SLOT; 
    209            // Если значение внутри интервала 0..TS_ACTIVE. 
    210            if (time_remainder < TS_ACTIVE)
    211              return full_slot_num;
    212            
    213            return NO_TIME_SLOT;
    214          }
    215          
    216          static inline void incrementTS(uint8_t *TS)
    217          {
    218            // Выбираем следующий тайм слот
    219            (*TS)++;
    220            if (*TS >= MAX_TS)
    221              *TS = 0;
    222          }
    223          
    224          static inline void set_capture_time(uint8_t TS)
    225          {
    226            uint16_t ct = FULL_SLOT*(uint16_t)TS;
    227            
    228            LOG(MSG_OFF | MSG_INFO | MSG_TRACE, "Set compare = %d, TS = %d \r\n", ct, TS);
    229            // Установка прерывания на нужный слот
    230            NT_SetCompare(FULL_SLOT*(uint16_t)TS);
    231          }
    232          
    233          static void TIC_TDMAShelduler(uint8_t TS)
    234          {
    235            // Устанавливает прерывание на ближайший активный слот
    236            // Если слот 0 ближе, то на него. 
    237            // Cлот - обработка секундных таймеров 
    238            
    239            // Ищем следующий активный слот или слот 0
    240            incrementTS(&TS);
    241            while ((TS != 0) && !TSStateTable[TS])  
    242              incrementTS(&TS); 
    243            
    244            set_capture_time(TS);
    245          }
    246          
    247          static inline void Callback_execution(void (*fn)(uint8_t TS), uint8_t TS)
    248          {
    249            // Помошник вызова функций. Упрощает проверки
    250            ASSERT_HALT(fn != NULL, "Callback is NULL");
    251            if (fn == NULL)
    252              return;
    253            fn(TS);
    254          }
    255          
    256          static void TIC_HW_Timer_IRQ(uint16_t ticks)
    257          {
    258            // TODO Обработка TS=0xFF
    259            // Номер текущего слота 
    260            uint8_t c_TS = TIC_getCurrentTS(ticks);
    261            
    262            // Обновляем часы NODE_RTC и NODE_UPTIME
    263            if (c_TS == 0)
    264            {
    265              TIM_TimeStamp(&TimeStampTS0); // Первым делом обновим отметку точного времени
    266              clocks_update();
    267            }
    268            // Если что то пошло не так и мы промахнулись мимо слота
    269            // запускаем планировщик заново
    270            if (c_TS == NO_TIME_SLOT)
    271            {
    272              TIC_TDMAShelduler(c_TS);
    273              LOG(MSG_ON | MSG_INFO | MSG_TRACE, "TS = 255 \r\n");
    274              return;
    275            }
    276              
    277            // Вызываем один из указанных обработчиков.
    278            // Передача имеет приоритет над приемом.
    279            if (TSStateTable[c_TS] & TS_TX) 
    280              Callback_execution(TXCallback, c_TS);
    281            else if (TSStateTable[c_TS] & TS_RX)
    282              Callback_execution(RXCallback, c_TS);
    283              
    284            // Вызываем обработчик завершения слота
    285            Callback_execution(SECallback, c_TS);
    286            
    287            // Запускаем планировщик таймера
    288            TIC_TDMAShelduler(c_TS);
    289          }
    290          
    291          static void clocks_update(void)
    292          {
    293            NODE_UPTIME++;
    294            NODE_RTC++;
    295            NODE_NONCE++;
    296            if (NODE_RTC >= DAILY_SEC)
    297              NODE_RTC = 0;
    298          }
    299          
    300          void TIC_SetNonce(uint32_t nonce)
    301          {
    302            NODE_NONCE = nonce;
    303          }
    304          
    305          uint32_t TIC_GetNonce(void)
    306          {
    307            return NODE_NONCE;
    308          }
\\vmware-host\Shared Folders\Projects\WMNU\IAR\PRJ_UNITEST\src\utest.c
      1          #include "utest_suite.h"
      2          #include "nwdebuger.h"
      3          #include "assert.h"
      4          
      5          extern void suite_fbuf(void);
      6          extern void suite_TIC(void);
      7          extern void suite_TIC_HW(void);
      8          extern void suite_MAC(void);
      9          extern void suite_LLC(void);
     10          extern void suite_NT_HW(void);
     11          extern void suite_Frames(void);
     12          extern void suite_RADIO_HW(void);
     13          extern void suite_RADIO(void);
     14          extern void suite_delays_HW(void);
     15          extern void suite_delays(void);
     16          extern void suite_coder(void);
     17          extern void suite_frame(void);
     18          extern void suite_LLC_HW(void);
     19          extern void suite_printf_uart(void);
     20          extern void suite_malloc(void);
     21          
     22          int main()
     23          {
     24            nwDebugerInit();
     25            utestSigTraceInit();
     26            LOG(MSG_ON | MSG_INFO | MSG_TRACE, "Test log output\r\n");
     27            ASSERT(false, "Test assert output\r\n");
     28            
     29            // Вызов функций тестирования
     30            // Аппаратное тестирование
     31            {
     32              //suite_RADIO_HW();
     33              //suite_delays_HW();    //12.11 Работает
     34              //suite_TIC_HW();       //12.11 Работает
     35              //suite_NT_HW();        // 12.11 Работает
     36              suite_LLC_HW();
     37            };
     38            // Юнит тестирование
     39            {
     40              //suite_delays();
     41              //suite_coder();
     42              //suite_fbuf();
     43              //suite_frame();
     44              //suite_RADIO();
     45             // suite_MAC();
     46            // suite_printf_uart();
     47              //suite_malloc();
     48            }
     49          
     50          	//run_utest_framepart();
     51          
     52          // Добавляем результаты тестов
     53          	umsg_summary();
     54           //     while(1);
     55          	return 0;
     56          }
\\vmware-host\Shared Folders\Projects\WMNU\IAR\PRJ_UNITEST\src\utest_coder.c
      1          #include "utest_suite.h"
      2          #include "coder.h"
      3          #include "delays.h"
      4          #include "string.h"
      5          #include "stdio.h"
      6          #include "nwdebuger.h"
      7          
      8          static void aes_test(void)
      9          {
     10            AES_init();
     11            
     12            TimeStamp_s start,stop;
     13            uint32_t passed;
     14            #define max_len 10 
     15            uint8_t data[max_len] = "0123456789";
     16            uint8_t chiper[max_len];
     17            
     18            uint8_t key[16] = {18,11,12,13,14,15,16,17,10,11,12,13,14,15,16,17};
     19            uint8_t nonce[16] = {18,11,12,13,14,15,16,17,10,11,12,13,14,15,16,17};
     20            TIM_init();
     21            
     22            memset(chiper, 0 , max_len);
     23            
     24            TIM_TimeStamp(&start);
     25            AES_StreamCoder(true, data, chiper, key, nonce, max_len);
     26            TIM_TimeStamp(&stop);
     27            passed = TIM_passedTime(&start, &stop);
     28            printf("passed %lu \r\n", passed);
     29            
     30            memset(data, 0 , max_len);
     31            TIM_TimeStamp(&start);
     32            AES_StreamCoder(false, chiper, data, key, nonce, max_len);
     33            TIM_TimeStamp(&stop);
     34            passed = TIM_passedTime(&start, &stop);
     35          
     36            return;
     37          }
     38          
     39          static void CCM_test(void)
     40          {
     41            AES_init();
     42            TIM_init();
     43            
     44            #define DATA_LEN 10
     45            uint8_t data[DATA_LEN];
     46            uint8_t key[16] = {1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16};
     47            uint8_t nonce[16] = {1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16};
     48            uint8_t MIC[4];
     49            
     50            memset(MIC, 0, 4);
     51            for (uint8_t i = 0; i < DATA_LEN; i++)
     52              data[i] = i ;
     53            
     54            AES_CCMEncrypt( data, 7, 3, 1, key, nonce, MIC);
     55            
     56            bool res = AES_CCMDecrypt( data, 7, 3, 1, key, nonce, MIC);
     57          }
     58          
     59          static void single_speed_test(uint8_t *data, uint8_t f, uint8_t c, uint8_t m,
     60                                        uint8_t *key, uint8_t *nonce, uint8_t *MIC)
     61          {
     62            TimeStamp_s start,stop;
     63            TIM_TimeStamp(&start);
     64            AES_CCMEncrypt( data, f, c , m, key, nonce, MIC);
     65            TIM_TimeStamp(&stop);
     66            uint32_t time = TIM_passedTime(&start, &stop);
     67            LOG(MSG_ON | MSG_INFO | MSG_TRACE, "m=%d f=%d c=%d. Time = %lu\n",
     68                m, f, c, time);
     69          }
     70          
     71          static void CCM_speed_test(void)
     72          {
     73            #define SPEED_DATA_LEN 100
     74            uint8_t data[SPEED_DATA_LEN];
     75          
     76            uint8_t key[16] = {1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16};
     77            uint8_t nonce[16] = {1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16};
     78            uint8_t MIC[16];
     79          
     80            AES_init();
     81            TIM_init();
     82            
     83            for (uint8_t i = 10 ; i <= 50 ; i +=10)
     84              single_speed_test(data, i, 10, 1, key, nonce, MIC);
     85            
     86            for (uint8_t i = 10 ; i <= 50 ; i +=10)
     87              single_speed_test(data, 10, i, 1, key, nonce, MIC);
     88            
     89            for (uint8_t i = 10 ; i <= 50 ; i +=10)
     90              single_speed_test(data, i, 10, 2, key, nonce, MIC);
     91            
     92            for (uint8_t i = 10 ; i <= 50 ; i +=10)
     93              single_speed_test(data, 10, i, 2, key, nonce, MIC);
     94          }
     95          
     96          static bool single_enc_dec_test(uint8_t *data, uint8_t f, uint8_t c, uint8_t m,
     97                                        uint8_t *key, uint8_t *nonce, uint8_t *MIC)
     98          {
     99            AES_CCMEncrypt( data, f, c, m, key, nonce, MIC);  
    100            bool res = AES_CCMDecrypt( data, f, c, m, key, nonce, MIC); 
    101            return res;
    102          }
    103          
    104          static void CCM_code_decode_test(void)
    105          {
    106            #define CODE_DATA_LEN 128
    107            uint8_t data[CODE_DATA_LEN];
    108          
    109            uint8_t key[16] = {1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16};
    110            uint8_t nonce[16] = {1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16};
    111            uint8_t MIC[16];
    112          
    113            AES_init();
    114            TIM_init();  
    115            
    116            bool res;
    117           
    118            LOG(MSG_ON | MSG_INFO | MSG_TRACE, "CCM full size test 60 sec\n");
    119            
    120            res = true;
    121            for (uint8_t m = 0; m < 3; m++)
    122              for (uint8_t f = 0; f < 128 ; f++)
    123                for (uint8_t c = 0; c < (128 - f) ; c++) 
    124                {
    125                  res = res && single_enc_dec_test(data, f, c, m, key, nonce, MIC);
    126                  if (res)
    127                    continue;
    128                  
    129                  LOG(MSG_ON | MSG_INFO | MSG_TRACE, 
    130                      "Coder test stub on m=%d f=%d c=%d \n", m, f, c);
    131                  break;
    132                }
    133            umsg("coder", "CCM full coder test", res == true);
    134            
    135            res = single_enc_dec_test(data, 10, 10, 1, key, nonce, MIC);
    136          }
    137          
    138          static void mem_control(void)
    139          {
    140            #define MEM_CNTR_SIZE 10
    141            #define MAGIC_NUM 0x73
    142            
    143            uint8_t key[16] = {1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16};
    144            uint8_t nonce[16] = {1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16};
    145            
    146            struct 
    147            {
    148              uint8_t cnt_byte1;
    149              uint8_t data[MEM_CNTR_SIZE];
    150              uint8_t cnt_byte2;
    151            } __attribute__((packed)) data_struct;
    152           
    153              struct 
    154            {
    155              uint8_t cnt_byte1;
    156              uint8_t key[16];
    157              uint8_t cnt_byte2;
    158            } __attribute__((packed)) key_struct;
    159            
    160            struct 
    161            {
    162              uint8_t cnt_byte1;
    163              uint8_t nonce[16];
    164              uint8_t cnt_byte2;
    165            } __attribute__((packed)) nonce_struct;
    166            
    167            struct 
    168            {
    169              uint8_t cnt_byte1;
    170              uint8_t MIC[16];
    171              uint8_t cnt_byte2;
    172            } __attribute__((packed)) mic_struct;
    173            
    174            AES_init();
    175            TIM_init();
    176            
    177            data_struct.cnt_byte1 = MAGIC_NUM;
    178            data_struct.cnt_byte2 = MAGIC_NUM;
    179            key_struct.cnt_byte1 = MAGIC_NUM;  
    180            key_struct.cnt_byte2 = MAGIC_NUM;
    181            nonce_struct.cnt_byte1 = MAGIC_NUM;  
    182            nonce_struct.cnt_byte2 = MAGIC_NUM;
    183            mic_struct.cnt_byte1 = MAGIC_NUM;  
    184            mic_struct.cnt_byte2 = MAGIC_NUM;
    185            
    186            memcpy(key_struct.key , key, 16);
    187            memcpy(nonce_struct.nonce , nonce, 16);
    188            for (uint8_t i = 0; i < MEM_CNTR_SIZE; i++)
    189              data_struct.data[i] = i;
    190          
    191            for (uint8_t i = 0; i < 16; i++)
    192            {
    193              key_struct.key[i] = i + 100;
    194              nonce_struct.nonce[i] = i + 200;
    195            }
    196            
    197            AES_CCMEncrypt( data_struct.data, 5, MEM_CNTR_SIZE - 5, 1, key_struct.key,
    198                           nonce_struct.nonce, mic_struct.MIC);  
    199            
    200            bool data_mem_corrupt = false;
    201            bool key_mem_corrupt = false;
    202            bool nonce_mem_corrupt = false;
    203            bool mic_mem_corrupt = false;
    204            if ((data_struct.cnt_byte1 != MAGIC_NUM) || 
    205                (data_struct.cnt_byte2 != MAGIC_NUM))
    206            data_mem_corrupt = true;
    207            if ((key_struct.cnt_byte1 != MAGIC_NUM) || 
    208                (key_struct.cnt_byte2 != MAGIC_NUM))
    209            key_mem_corrupt = true;
    210            if ((nonce_struct.cnt_byte1 != MAGIC_NUM) || 
    211                (nonce_struct.cnt_byte2 != MAGIC_NUM))
    212            nonce_mem_corrupt = true;  
    213            if ((mic_struct.cnt_byte1 != MAGIC_NUM) || 
    214                (mic_struct.cnt_byte2 != MAGIC_NUM))
    215            mic_mem_corrupt = true;  
    216            
    217            umsg("coder", "CCM coder corrupt data memory", data_mem_corrupt == false);
    218            umsg("coder", "CCM coder corrupt key memory", key_mem_corrupt == false);
    219            umsg("coder", "CCM coder corrupt nonce memory", nonce_mem_corrupt == false);
    220            umsg("coder", "CCM coder corrupt mic memory", mic_mem_corrupt == false);
    221            
    222            
    223            data_struct.cnt_byte1 = MAGIC_NUM;
    224            data_struct.cnt_byte2 = MAGIC_NUM;
    225            key_struct.cnt_byte1 = MAGIC_NUM;  
    226            key_struct.cnt_byte2 = MAGIC_NUM;
    227            nonce_struct.cnt_byte1 = MAGIC_NUM;  
    228            nonce_struct.cnt_byte2 = MAGIC_NUM;
    229            mic_struct.cnt_byte1 = MAGIC_NUM;  
    230            mic_struct.cnt_byte2 = MAGIC_NUM;
    231            
    232            bool res = AES_CCMDecrypt( data_struct.data, 5, MEM_CNTR_SIZE - 5, 1, key_struct.key,
    233                           nonce_struct.nonce, mic_struct.MIC); 
    234            
    235            if ((data_struct.cnt_byte1 != MAGIC_NUM) || 
    236                (data_struct.cnt_byte2 != MAGIC_NUM))
    237            data_mem_corrupt = true;
    238            if ((key_struct.cnt_byte1 != MAGIC_NUM) || 
    239                (key_struct.cnt_byte2 != MAGIC_NUM))
    240            key_mem_corrupt = true;
    241            if ((nonce_struct.cnt_byte1 != MAGIC_NUM) || 
    242                (nonce_struct.cnt_byte2 != MAGIC_NUM))
    243            nonce_mem_corrupt = true;  
    244            if ((mic_struct.cnt_byte1 != MAGIC_NUM) || 
    245                (mic_struct.cnt_byte2 != MAGIC_NUM))
    246            mic_mem_corrupt = true;
    247          
    248            umsg("coder", "CCM decoder corrupt data memory", data_mem_corrupt == false);
    249            umsg("coder", "CCM decoder corrupt key memory", key_mem_corrupt == false);
    250            umsg("coder", "CCM decoder corrupt nonce memory", nonce_mem_corrupt == false);
    251            umsg("coder", "CCM decoder corrupt mic memory", mic_mem_corrupt == false);
    252            
    253            bool not_changed = true;
    254            for (uint8_t i = 0; i < MEM_CNTR_SIZE; i++)
    255              if (data_struct.data[i] != i)
    256                not_changed = true;
    257            umsg("coder", "CCM decoded data correct", not_changed == true);
    258              
    259            for (uint8_t i = 0; i < 16; i++)
    260              if (key_struct.key[i] != i + 100)
    261                not_changed = true;
    262            umsg("coder", "CCM key data correct", not_changed == true);  
    263           
    264            for (uint8_t i = 0; i < 16; i++)
    265              if (nonce_struct.nonce[i] != i + 200)
    266                not_changed = true;
    267            umsg("coder", "CCM nonce data correct", not_changed == true); 
    268          }
    269          
    270          //  umsg("FChain", "TODO memory malloc and free", false);
    271          void suite_coder(void)
    272          {
    273            umsg_line("coder module");
    274          //  CCM_speed_test();
    275            mem_control();
    276            CCM_code_decode_test();
    277            CCM_test();
    278            aes_test();
    279          }
\\vmware-host\Shared Folders\Projects\WMNU\IAR\PRJ_UNITEST\src\utest_delays.c
      1          #include "delays.h"
      2          #include "utest_suite.h"
      3          
      4          static void alg_test(void)
      5          {
      6            TIM_init();
      7            
      8            uint32_t passed;
      9            TimeStamp_s start, stop;
     10           
     11            TIM_TimeStamp(&start);
     12            TIM_TimeStamp(&stop);
     13            passed = TIM_passedTime(&start, &stop);
     14            umsg("delays", "TIM_passedTimeNs meas add op ", passed  < 10);
     15          }
     16          
     17          static void manual(void)
     18          {
     19            TIM_init();
     20            
     21            uint32_t passed;
     22            TimeStamp_s start, stop;
     23            
     24            //Это ручная проверка работы модуля
     25            TIM_TimeStamp(&start);
     26            TIM_delay(500);
     27            TIM_TimeStamp(&stop);
     28            passed = TIM_passedTime(&start, &stop);
     29            umsg("delays", "TIM_passedTimeNs meas add op ", passed  < 10);
     30            
     31            TIM_TimeStamp(&start);
     32            TIM_delay(60*Tsec);
     33            TIM_TimeStamp(&stop);
     34            passed = TIM_passedTime(&start, &stop);
     35            umsg("delays", "TIM_passedTimeNs meas add op ", passed  < 10);
     36          }
     37          
     38          void suite_delays_HW(void)
     39          {
     40            //umsg_line("delays module");
     41            manual();
     42          }
     43          
     44          
     45          void suite_delays(void)
     46          {
     47            umsg_line("delays module");
     48            alg_test();
     49          }
\\vmware-host\Shared Folders\Projects\WMNU\IAR\PRJ_UNITEST\src\utest_frame.c
      1          #include "utest_suite.h"
      2          #include "frame.h"
      3          #include "stdbool.h"
      4          #include "mem.h"
      5          
      6          static void test_1(void)
      7          {
      8            frame_s *fr = frame_create();
      9            umsg("frame", "Create", frame_getCount() == 1);
     10              
     11            frame_delete(fr);
     12            umsg("frame", "Delete", frame_getCount() == 0);
     13          }
     14          
     15          static void test_2(void)
     16          {
     17            uint8_t data[5];
     18            uint16_t heap_ptr_before = heap_ptr(1);
     19            
     20            frame_s *fr = frame_create();
     21            frame_addHeader(fr, data, sizeof(data));
     22            frame_delete(fr);
     23            
     24            umsg("frame", "Memmory free test 1", heap_ptr_before == heap_ptr(1));
     25          }
     26          
     27          static void test_3(void)
     28          {
     29            uint8_t data1[5] = {0,1,2,3,4};
     30            uint8_t data2[5] = {5,6,7,8,9};
     31            
     32            frame_s *fr = frame_create();
     33            frame_addHeader(fr, data2, sizeof(data2));
     34            frame_addHeader(fr, data1, sizeof(data1));
     35            
     36            bool ok = true;
     37            uint8_t *beg = (uint8_t*)fr->payload;
     38            for (int i = 0 ; i < 10; i++)
     39              if (beg[i] != i)
     40                ok = false;
     41            
     42            umsg("frame", "Header add", ok == true);
     43            
     44            frame_delete(fr); 
     45          }
     46          
     47          static void test_4(void)
     48          {
     49            uint8_t data1[] = {0,1,2,3,4,3,87,21,35,73};
     50            uint8_t data2[] = {5,6,7,8,9,36,85,98,23,98,42,12};
     51            uint8_t data3[] = {10,11,12,13,14,15,17,20};
     52            uint8_t data4[] = {5,6,7,8,9,23,56,23,6};
     53            
     54            uint16_t heap_ptr_before = heap_ptr(1);
     55            
     56            frame_s *fr = frame_create();
     57            frame_addHeader(fr, data1, sizeof(data1));
     58            frame_addHeader(fr, data2, sizeof(data2));
     59            frame_addHeader(fr, data3, sizeof(data3));
     60            frame_addHeader(fr, data4, sizeof(data4));
     61           
     62            frame_delete(fr);
     63            
     64            umsg("frame", "Memmory free test 2", heap_ptr_before == heap_ptr(1));
     65            
     66             
     67          }
     68          
     69          void suite_frame(void)
     70          {
     71            umsg_line("frame module");
     72            test_1();
     73            test_2();
     74            test_3();
     75            test_4();
     76          }
\\vmware-host\Shared Folders\Projects\WMNU\IAR\PRJ_UNITEST\src\utest_Frames.c
      1          #include "utest_suite.h"
      2          #include "string.h"
      3          #include "frame.h"
      4          #include "stdio.h"
      5          
      6          void suite_Frames(void)
      7          {
      8            umsg_line("Frames module");
      9          
     10          }
\\vmware-host\Shared Folders\Projects\WMNU\IAR\PRJ_UNITEST\src\utest_LLC.c
      1          #include "utest_suite.h"
      2          #include "LLC.h"
      3          #include "NTMR.h"
      4          #include "nwdebuger.h"
      5          #include "ioCC2530.h"
      6          #include "frame.h"
      7          #include "RADIO.h"
      8          #include "TIC.h"
      9          #include "mem.h"
     10          
     11          static void timealloc(void)
     12          {
     13            static bool led_stat = false;
     14              LED(D1, led_stat);
     15              led_stat = !led_stat;
     16          }
     17          
     18          static frame_s* getFrame(uint8_t *src, uint8_t len, uint8_t CH, uint8_t TS)
     19          {
     20            frame_s *fr;
     21            EA=0;
     22            fr = frame_create();
     23            frame_addHeader(fr, src, len);
     24            EA=1;
     25            fr->meta.SEND_TIME = 0;
     26            fr->meta.TS = TS;
     27            fr->meta.CH = CH;
     28            return fr;
     29          }
     30          
     31          static void show_heap_ptr(void)
     32          { 
     33            uint16_t *heap_ptr;
     34            heap_ptr = (uint16_t*)re_malloc(1);
     35            LOG(MSG_ON | MSG_INFO | MSG_TRACE, "HEAP_PTR = %d\r\n", (uint16_t)heap_ptr ); 
     36            re_free(heap_ptr);
     37          }
     38          
     39          static void test_create()
     40          {
     41            LLC_Init();
     42            LLC_TimeAlloc(timealloc);
     43            EA = 1;
     44            uint8_t DATA_SEND[10] = {0,1,2,3,4,5,6,7,8,9};  
     45            
     46            frame_s *fr;
     47            
     48            uint16_t TS = 0;
     49            uint8_t *ptr_stack = (uint8_t*)0x100;
     50            
     51            fr = getFrame(DATA_SEND, sizeof(DATA_SEND), CH11, TS);
     52            uint16_t fr_size = sizeof(frame_s);
     53            uint16_t bf_size = frame_len(fr);
     54            uint16_t HEAP_PTR_MAX = 0;
     55            uint16_t heap;
     56            uint8_t nbr_bufs, nbr_frames;
                           ^
Warning[Pe177]: variable "nbr_bufs" was declared but never referenced
          detected during compilation of secondary translation unit
                    "\\vmware-host\Shared
                    Folders\Projects\WMNU\IAR\PRJ_UNITEST\src\utest_LLC.c"

    uint8_t nbr_bufs, nbr_frames;
                      ^
"\\vmware-host\Shared Folders\Projects\WMNU\IAR\PRJ_UNITEST\src\utest_LLC.c",56  Warning[Pe550]: 
          variable "nbr_frames" was set but never used
          detected during compilation of secondary translation unit
                    "\\vmware-host\Shared
                    Folders\Projects\WMNU\IAR\PRJ_UNITEST\src\utest_LLC.c"
     57            
     58            LOG(MSG_ON | MSG_INFO | MSG_TRACE, 
     59                "Frame_s size = %d. Fbuf data = %d. Full =%d\r\n",
     60                fr_size, bf_size, bf_size+fr_size );
     61            frame_delete(fr);
     62            
     63            while(true)
     64            {  
     65              nbr_frames = frame_getCount();
     66             // LOG(MSG_ON | MSG_INFO | MSG_TRACE, "nbr_frames = %d \r\n" ,nbr_frames );
     67              
     68              if (LLC_GetTaskLen() < 5)
     69              {
     70                fr = getFrame(DATA_SEND, sizeof(DATA_SEND), CH11, TS);
     71                LOG(MSG_OFF | MSG_INFO | MSG_TRACE, "Create frame = %d.\r\n", (uint16_t)fr);    
     72                LLC_AddTask(fr);
     73                TS ++;
     74                if (TS == 5)
     75                TS = 0;
     76              }   
     77              if (*ptr_stack != 0xcd) // Контроль переполнения стека
     78                while(1);
     79             
     80              heap =  heap_ptr(10);
     81              if (heap > HEAP_PTR_MAX)
     82              {
     83                HEAP_PTR_MAX = heap;
     84                LOG(MSG_ON | MSG_INFO | MSG_TRACE, 
     85                "HEAP_PTR = %d\r\n", HEAP_PTR_MAX );
     86              }
     87            }
     88          }
     89          
     90          static void find_mem_problem(void)
     91          {
     92            LLC_Init();
     93            LLC_TimeAlloc(timealloc);
     94            EA = 1;
     95            uint8_t DATA_SEND[10] = {0,1,2,3,4,5,6,7,8,9};  
     96            
     97            frame_s *fr;
     98            
     99            uint16_t TS = 0;
    100            uint8_t *ptr_stack = (uint8_t*)0x100;
    101            
    102            uint16_t HEAP_PTR_MAX = 0;
                            ^
Warning[Pe177]: variable "HEAP_PTR_MAX" was declared but never referenced
          detected during compilation of secondary translation unit
                    "\\vmware-host\Shared
                    Folders\Projects\WMNU\IAR\PRJ_UNITEST\src\utest_LLC.c"
    103            uint16_t *heap_ptr;
                             ^
Warning[Pe177]: variable "heap_ptr" was declared but never referenced
          detected during compilation of secondary translation unit
                    "\\vmware-host\Shared
                    Folders\Projects\WMNU\IAR\PRJ_UNITEST\src\utest_LLC.c"
    104            
    105            while(true)
    106            {  
    107              if (frame_getCount() == 0)
    108              {
    109                show_heap_ptr();
    110                for (uint8_t i = 0; i < 20 ; i++)
    111                {
    112                    fr = getFrame(DATA_SEND, sizeof(DATA_SEND), CH11, TS);
    113                    TS++;
    114                    if (TS == 49)
    115                      TS = 0;
    116                    LLC_AddTask(fr);
    117                }
    118              }   
    119              
    120              if (*ptr_stack != 0xcd) // Контроль переполнения стека
    121                while(1);
    122            }
    123            
    124            
    125          }
    126          
    127          // Тест на максимальное количество фреймов 
    128          static void test_mem(void)
    129          {
    130            frame_s *FR[150];
                            ^
Warning[Pe550]: variable "FR" was set but never used
          detected during compilation of secondary translation unit
                    "\\vmware-host\Shared
                    Folders\Projects\WMNU\IAR\PRJ_UNITEST\src\utest_LLC.c"
    131            uint8_t DATA_SEND[10] = {0,1,2,3,4,5,6,7,8,9}; 
    132            
    133            for (uint8_t i = 0; i < 105; i++) 
    134              FR[i] = getFrame(DATA_SEND, sizeof(DATA_SEND), CH11, 5);
    135          }
    136          
    137          
    138          void suite_LLC_HW(void)
    139          {
    140           // umsg_line("LLC module");
    141            
    142            // Устанавливает и поддерживает в очереди 20 пакетов.
    143            // Для приема пакетов испольуеться второй модуль с прошивкой RadioRecvTest1
    144            test_create(); 
    145           // test_mem();
    146           // find_mem_problem();
    147             
    148          }
\\vmware-host\Shared Folders\Projects\WMNU\IAR\PRJ_UNITEST\src\utest_MAC.c
      1          #include "utest_suite.h"
      2          #include "MAC.h"
      3          #include "frame.h"
      4          #include "delays.h"
      5          #include "nwdebuger.h"
      6          #include "ioCC2530.h"
      7          
      8          static void test_ACK_SEND(void)
      9          {
     10            MAC_Init();
     11            
     12            bool res;
     13            uint8_t DATA_SEND[10] = {0,1,2,3,4,5,6,7,8,9};
     14            TimeStamp_s start, stop;
     15          while(1)
     16          {
     17            // Подготовим данные к отправке
     18            frame_s *fr = frame_create();
     19            frame_addHeader(fr, DATA_SEND, sizeof(DATA_SEND));
     20            fr->meta.SEND_TIME = 0;
     21            fr->meta.CH = CH11;
     22             
     23            // Нам не важно что структура не соотетсвует ACK. Важно чтоб пакет ушел
     24            TIM_TimeStamp(&start);
     25            res = MAC_ACK_Send(fr);
     26            TIM_TimeStamp(&stop);
     27            uint32_t passed = TIM_passedTime(&start, &stop);
     28            LOG(MSG_ON | MSG_INFO | MSG_TRACE, 
     29                "MAC_ACK_Send time = %lu. Success %d \n", passed, res);
     30          }
     31          }
     32          
     33          static void stub_se(uint8_t ts)
     34          {
     35          }
     36          
     37          static void test_TS_Send(void)
     38          {
     39            MAC_Init();
     40            TIC_SetSECallback(stub_se);
     41            EA = 1;
     42            uint8_t DATA_SEND[10] = {0,1,2,3,4,5,6,7,8,9};  
     43            uint8_t TS = 5, attempts = 3;
     44            
     45            frame_s *fr; 
     46            
     47            while (true)
     48            {
     49              if (!MAC_GetTXState(TS))
     50              {
     51                fr = frame_create();
     52                frame_addHeader(fr, DATA_SEND, sizeof(DATA_SEND));
     53                fr->meta.SEND_TIME = 0;
     54                fr->meta.TS = TS;
     55                fr->meta.CH = CH11;
     56                MAC_Send(fr, attempts);
     57                LOG(MSG_ON | MSG_INFO | MSG_TRACE, "Frame puted to MAC layer at %lu sec\n", TIC_GetRTC());
     58              }
     59            }
     60          }
     61          
     62          void suite_MAC(void)
     63          {
     64            // test_TS_Send отсылает пакеты по расписанию тайм слотов
     65            // Нужно запрограмировать второе устройство RadioRecvTest1
     66            // тогда будет гореть светодиод при приеме сигнала
     67            test_TS_Send(); 
     68            test_ACK_SEND();
     69          }
\\vmware-host\Shared Folders\Projects\WMNU\IAR\PRJ_UNITEST\src\utest_malloc.c
      1          #include "utest_suite.h"
      2          #include "stdlib.h"
      3          
      4          static  uint16_t getMallocSize(void *ptr)
      5          {
      6            uint16_t *size = (uint16_t*)ptr - 1;
      7            return *size-2;
      8          }
      9          
     10          
     11          static void test_1(void)
     12          {
     13            // Проверка как хранит размер памяти фун-я маллок
     14            // Перед указатель выделяется 2 байта и длинна на 2 байта увеличиается
     15            void *ptr_1 = malloc(0x32);
     16            void *ptr_2 = malloc(0x78);
     17            uint16_t size_1 = getMallocSize(ptr_1);
     18            uint16_t size_2 = getMallocSize(ptr_2);
     19          }
     20          
     21          void suite_malloc(void)
     22          {
     23           // umsg_line("LLC module");
     24            
     25            // Устанавливает и поддерживает в очереде 10 пакетов.
     26            // Мигает зеленым светодиодом. В TS0 включается, в TS5 выключаеться
     27            test_1();  
     28          }
\\vmware-host\Shared Folders\Projects\WMNU\IAR\PRJ_UNITEST\src\utest_NTMR.c
      1          #include "utest_suite.h"
      2          #include "NTMR.h"
      3          #include "ioCC2530.h"
      4          
      5          static bool finised;
      6          
      7          static inline bool isNear(uint16_t A, uint16_t B, uint16_t x)
      8          {
      9            if (A>B)
     10              A = A - B;
     11            else
     12              A = B - A;
     13            if (A<=x)
     14              return true;
     15            return false;
     16          }
     17          
     18          
     19          static void TimerHndl(uint16_t ticks)
     20          {    
     21            if (isNear(ticks, 0 , 3))
     22            {
     23              NT_SetCompare(1000);
     24              P0_0 = 1;
     25              P0_0 = 0;
     26            }
     27            else if (isNear(ticks, 1000 , 3))
     28            {
     29              NT_SetCompare(2000);
     30              P0_0 = 1;
     31              P0_0 = 0;
     32            }
     33            else if (isNear(ticks, 2000 , 3))
     34            {
     35              NT_SetCompare(25000);
     36              P0_0 = 1;
     37              P0_0 = 0;
     38            }  
     39            else if (isNear(ticks, 25000 , 3))
     40            {
     41              NT_SetCompare(26000);
     42              P0_0 = 1;
     43              P0_0 = 0;
     44            }
     45            else if (isNear(ticks, 26000 , 3))
     46            {
     47              NT_SetCompare(27000);
     48              P0_0 = 1;
     49              P0_0 = 0;
     50            }
     51            else if (isNear(ticks, 27000 , 3))
     52            {
     53              P0_0 = 1;
     54              P0_0 = 0;
     55              finised = true;
     56            }                    
     57          }
     58          
     59          /** 
     60          @brief Тестирование алгоритмов которые нельзя вынести из модуля 
     61          @deails Использует вывод P0_0 для индикации работы таймера
     62           Генерирует импульсы при каждом срабатывании. Нужно настроить логический
     63           анализатор на высокую частоту и работать с 1 каналом, иначе импульсы
     64           проглатывает.
     65          */
     66          static void alg_test(void)
     67          {
     68            EA = 1;
     69          
     70            P0DIR = 0x01;
     71            P0_0 = 0;
     72            
     73            NT_Init();
     74            NT_SetEventCallback(TimerHndl);
     75            
     76            // Тут поставить точку останова и запустить анализатор
     77            // Вы должны увидеть 6 импульсов. Измерения по переднему фронту
     78            // Работаем на внутреннем RC генераторе
     79            // И0-И1 30.508мс
     80            // И1-И2 30.521мс
     81            for (uint16_t i = 0 ; i < 1000; i++)
     82            {
     83              finised = false;
     84              NT_SetCompare(0);
     85              while (!finised);
     86            }
     87            // Тут поставить точку останова
     88          }
     89          
     90          void suite_NT_HW(void)
     91          {
     92            //umsg_line("NTMR module");
     93            alg_test();
     94          }
\\vmware-host\Shared Folders\Projects\WMNU\IAR\PRJ_UNITEST\src\utest_printf_uart.c
      1          #include "nwdebuger.h"
      2          #include "utest_suite.h"
      3          #include "delays.h"
      4          #include "stdio.h"
      5          
      6          void test_1(void)
      7          {
      8            const char test_string1[] = "Hello world\n";
      9            const char test_string2[] = "Hello worldHello worldHello worldHello world\n";
     10            TimeStamp_s start, stop;
     11            
     12            TIM_init();
     13            TIM_TimeStamp(&start);
     14            printf(test_string1);
     15            TIM_TimeStamp(&stop);
     16            
     17            uint32_t passed = TIM_passedTime(&start, &stop);
     18            
     19            LOG(MSG_ON | MSG_INFO | MSG_TRACE, 
     20                "String 1 len = %d. Print time = %lu us\n",
     21                sizeof(test_string1), passed);
     22            
     23            TIM_TimeStamp(&start);
     24            printf(test_string2);
     25            TIM_TimeStamp(&stop);
     26            
     27            passed = TIM_passedTime(&start, &stop);
     28            
     29            LOG(MSG_ON | MSG_INFO | MSG_TRACE, 
     30                "String 2 len = %d. Print time = %lu us.\n",
     31                sizeof(test_string2), passed);  
     32          }
     33          
     34          void suite_printf_uart(void)
     35          {
     36            umsg_line("printf speed uart");
     37            test_1();
     38            
     39          }
\\vmware-host\Shared Folders\Projects\WMNU\IAR\PRJ_UNITEST\src\utest_radio.c
      1          #include "utest_suite.h"
      2          #include "RADIO.h"
      3          #include "ioCC2530.h"
      4          #include "delays.h"
      5          #include "frame.h"
      6          #include "coder.h"
      7          #include "nwdebuger.h"
      8          #include "TIC.h"
      9          #include "NTMR.h"
     10          
     11          static void RadioSendTest1(void)
     12          {
     13            uint8_t DATA_SEND[10] = {0,1,2,3,4,5,6,7,8,9};
     14            uint8_t key[16] = {18,11,12,13,14,15,16,17,10,11,12,13,14,15,16,17};
     15            uint8_t nonce[16] = {18,11,12,13,14,15,16,17,10,11,12,13,14,15,16,17};
     16            
     17            TIM_init();
     18            RI_init();
     19            AES_init();
     20            
     21            RI_StreamCrypt(true);
     22            RI_SetChannel(CH11);
     23            RI_setKEY(key);
     24            RI_setIV(nonce);
     25            
     26            // Подготовим данные к отправке
     27            frame_s *fr = frame_create();
     28            frame_addHeader(fr, DATA_SEND, sizeof(DATA_SEND));
     29            fr->meta.SEND_TIME = 3000;
     30            
     31            // Передача данных
     32            bool res;
     33            while(true)
     34            {
     35              LED(D1, true);
     36              TIM_delay(100UL*Tmsec);
     37              LED(D1, false);
     38              res = RI_Send(fr);
     39              if (!res)
     40                LED(D2, true);
     41              else
     42                LED(D2, false);
     43              TIM_delay(900UL*Tmsec);
     44            };
     45            
     46            frame_delete(fr);
                   ^
Warning[Pe111]: statement is unreachable
          detected during compilation of secondary translation unit
                    "\\vmware-host\Shared
                    Folders\Projects\WMNU\IAR\PRJ_UNITEST\src\utest_radio.c"
     47          }
     48          
     49          static void RadioRecvTest1(void)
     50          {
     51            uint8_t DATA_RECV[10] = {0,1,2,3,4,5,6,7,8,9};
     52            uint8_t key[16] = {18,11,12,13,14,15,16,17,10,11,12,13,14,15,16,17};
     53            uint8_t nonce[16] = {18,11,12,13,14,15,16,17,10,11,12,13,14,15,16,17};
     54            
     55            NT_Init(); // Управление прериваниями таймера сна
     56            TIM_init();// Таймер MAC для измерения интервалов времени
     57            TIC_Init();// Контроллер интервалов времени (зависит от NT)
     58            RI_init(); // Иницилизация радио ( использует TIM и NT)
     59            AES_init();// Иницилизация шифровальщика
     60            
     61            RI_StreamCrypt(true);
     62            RI_SetChannel(CH11);
     63            RI_setKEY(key);
     64            RI_setIV(nonce);
     65            
     66            // Примем данных
     67            frame_s *fr;
     68            
     69            // Прием данных
     70            bool res;
     71            while(true)
     72            {
     73              fr = RI_Receive(2000);
     74              LED(D2, false);
     75              if (fr == NULL)
     76                continue;
     77              
     78              if (memory_compare((char*)DATA_RECV, fr->payload, 10))
     79                LED(D2, true);
     80              
     81              frame_delete(fr);
     82            };
     83            
     84            frame_delete(fr);
                   ^
Warning[Pe111]: statement is unreachable
          detected during compilation of secondary translation unit
                    "\\vmware-host\Shared
                    Folders\Projects\WMNU\IAR\PRJ_UNITEST\src\utest_radio.c"

    bool res;
         ^
"\\vmware-host\Shared Folders\Projects\WMNU\IAR\PRJ_UNITEST\src\utest_radio.c",70  Warning[Pe177]: 
          variable "res" was declared but never referenced
          detected during compilation of secondary translation unit
                    "\\vmware-host\Shared
                    Folders\Projects\WMNU\IAR\PRJ_UNITEST\src\utest_radio.c"
     85          }
     86          
     87          static void one_speed_test(frame_s *fr)
     88          {
     89            bool res;
     90            TimeStamp_s start, stop, *ts0;
                                             ^
Warning[Pe177]: variable "ts0" was declared but never referenced
          detected during compilation of secondary translation unit
                    "\\vmware-host\Shared
                    Folders\Projects\WMNU\IAR\PRJ_UNITEST\src\utest_radio.c"

  static void CCM_speed_test(void)
              ^
"\\vmware-host\Shared Folders\Projects\WMNU\IAR\PRJ_UNITEST\src\utest_coder.c",71  Warning[Pe177]: 
          function "CCM_speed_test" was declared but never referenced
          detected during compilation of secondary translation unit
                    "\\vmware-host\Shared
                    Folders\Projects\WMNU\IAR\PRJ_UNITEST\src\utest_coder.c"

  static void find_mem_problem(void)
              ^
"\\vmware-host\Shared Folders\Projects\WMNU\IAR\PRJ_UNITEST\src\utest_LLC.c",90  Warning[Pe177]: 
          function "find_mem_problem" was declared but never referenced
          detected during compilation of secondary translation unit
                    "\\vmware-host\Shared
                    Folders\Projects\WMNU\IAR\PRJ_UNITEST\src\utest_LLC.c"

  static void test_mem(void)
              ^
"\\vmware-host\Shared Folders\Projects\WMNU\IAR\PRJ_UNITEST\src\utest_LLC.c",128  Warning[Pe177]: 
          function "test_mem" was declared but never referenced
          detected during compilation of secondary translation unit
                    "\\vmware-host\Shared
                    Folders\Projects\WMNU\IAR\PRJ_UNITEST\src\utest_LLC.c"

  static void RadioSendTest1(void)
              ^
"\\vmware-host\Shared Folders\Projects\WMNU\IAR\PRJ_UNITEST\src\utest_radio.c",11  Warning[Pe177]: 
          function "RadioSendTest1" was declared but never referenced
          detected during compilation of secondary translation unit
                    "\\vmware-host\Shared
                    Folders\Projects\WMNU\IAR\PRJ_UNITEST\src\utest_radio.c"
     91            do
     92            {
     93              TIM_TimeStamp(&start);
     94              res = RI_Send(fr);
     95              TIM_TimeStamp(&stop);
     96            } while (!res);
     97            
     98            uint32_t passed = TIM_passedTime(&start, &stop);
     99            uint16_t passed_sfd = fr->meta.TIMESTAMP;
    100            LOG(MSG_ON | MSG_INFO | MSG_TRACE, 
    101                "Data size = %d. Full time = %lu us. SFD time = %d us\n"
    102                ,fr->len, passed, passed_sfd);
    103           
    104          }
    105          static void speed_test(void)
    106          {
    107            uint8_t DATA_SEND[100];
    108            uint8_t key[16] = {18,11,12,13,14,15,16,17,10,11,12,13,14,15,16,17};
    109            uint8_t nonce[16] = {18,11,12,13,14,15,16,17,10,11,12,13,14,15,16,17};
    110            uint8_t size_tests[] = {10, 50, 100, 125};
    111            
    112            TIM_init();
    113            RI_init();
    114            AES_init();
    115            
    116            RI_StreamCrypt(true);
    117            RI_SetChannel(CH11);
    118            RI_setKEY(key);
    119            RI_setIV(nonce);
    120            
    121            // Подготовим данные к отправке
    122            
    123            LOG(MSG_ON | MSG_INFO | MSG_TRACE, "SEND SPEED TEST WITH DATA ENCODE\n");  
    124            for (uint8_t s = 0; s < sizeof(size_tests) ; s++)
    125            {
    126              frame_s *fr = frame_create();
    127              frame_addHeader(fr, DATA_SEND, size_tests[s]);
    128              one_speed_test(fr);
    129              frame_delete(fr);
    130            }
    131            
    132            RI_StreamCrypt(false);
    133            LOG(MSG_ON | MSG_INFO | MSG_TRACE, "SEND SPEED TEST WITHOUT DATA ENCODE\n"); 
    134            for (uint8_t s = 0; s < sizeof(size_tests) ; s++)
    135            {
    136              frame_s *fr = frame_create();
    137              frame_addHeader(fr, DATA_SEND, size_tests[s]);
    138              one_speed_test(fr);
    139              frame_delete(fr);
    140            }
    141            
    142            RI_StreamCrypt(true);
    143            LOG(MSG_ON | MSG_INFO | MSG_TRACE, "SEND IN SEND_TIME 1000 ticks AFTER TS0\n"); 
    144            for (uint8_t s = 0; s < sizeof(size_tests) ; s++)
    145            {
    146              frame_s *fr = frame_create();
    147              frame_addHeader(fr, DATA_SEND, size_tests[s]);
    148              fr->meta.SEND_TIME = 1000;
    149              TIC_Init(); // При иницилизации TS0 отсчитываеться с этого момента
    150              one_speed_test(fr);
    151              frame_delete(fr);
    152            }  
    153            
    154          
    155            RI_StreamCrypt(true);
    156            LOG(MSG_ON | MSG_INFO | MSG_TRACE, "SEND IN SEND_TIME 1000 ticks AFTER TS0\n"); 
    157            for (uint8_t s = 0; s < sizeof(size_tests) ; s++)
    158            {
    159              frame_s *fr = frame_create();
    160              frame_addHeader(fr, DATA_SEND, size_tests[s]);
    161              fr->meta.SEND_TIME = 1000;
    162              TIC_Init(); // При иницилизации TS0 отсчитываеться с этого момента
    163              one_speed_test(fr);
    164              frame_delete(fr);
    165            } 
    166            
    167            RI_StreamCrypt(true);
    168            LOG(MSG_ON | MSG_INFO | MSG_TRACE, "SEND IN SEND_TIME 1000 ticks AFTER TS0\n"); 
    169            for (uint8_t s = 0; s < sizeof(size_tests) ; s++)
    170            {
    171              frame_s *fr = frame_create();
    172              frame_addHeader(fr, DATA_SEND, size_tests[s]);
    173              fr->meta.SEND_TIME = 1000;
    174              TIC_Init(); // При иницилизации TS0 отсчитываеться с этого момента
    175              one_speed_test(fr);
    176              frame_delete(fr);
    177            } 
    178            
    179          }
    180          
    181          // Тесты скорости
    182          void suite_RADIO(void)
    183          {
    184            umsg_line("RADIO module");
    185            speed_test();
    186          }
    187          // Для тестирования радио запрограмируй два узла. Первый узел RadioSendTest1();
    188          // Второй узел RadioRecvTest1(); Первый будет раз в секунду передавать
    189          // шифрованные данные. Второй при приеме и удачном декодировании включит
    190          // светодиод.
    191          void suite_RADIO_HW(void)
    192          {
    193            //umsg_line("NTMR module");
    194            //RadioSendTest1();
    195            //
    196            RadioRecvTest1();
    197          }
\\vmware-host\Shared Folders\Projects\WMNU\IAR\PRJ_UNITEST\src\utest_suite.c
      1          #include "stdio.h"
      2          #include "utest_suite.h"
      3          #include "ioCC2530.h"
      4          
      5          /**
      6          @brief Иницилизируем выводы светодидов
      7          */
      8          void utestSigTraceInit(void)
      9          {
     10            P1DIR = 0x13; // Включаем светодиоды
     11          }
     12          
     13          void LED(uint8_t led, bool state)
     14          {
     15            switch(led)
     16            {
     17              case D1:
     18                P1_0 = !state;
     19                break;
     20              case D2:
     21                P1_1 = !state;
     22                break;
     23              case D3:
     24                P1_4 = !state;
     25                break;
     26            }
     27          }
     28          
     29          
     30          static struct utest_summary_s
     31          {
     32          	uint16_t passed;
     33          	uint16_t failed;
     34          } utest_summary = {.passed =0, .failed = 0};;
     35          
     36          //utest_summary_s utest_summary = {.passed =0, .failed = 0};
     37          
     38          // Требует много програмной памяти
     39          size_t heap_size(void)
     40          { 
     41            return 0;
     42          }
     43          
     44          bool memory_compare(char* area1, char* area2, uint16_t size)
     45          {
     46          	while (size > 0)
     47          	{
     48          		if (*area1 != *area2)
     49          			return false;
     50          		area1++;
     51          		area2++;
     52                  size--;
     53          	} 
     54          	return true;
     55          }
     56          
     57          void umsg(char* module, char* name, bool status)
     58          {
     59          	if (status){
     60          		utest_summary.passed++;
     61          		printf("Module: %-15s Name: %-50s Status: %-10s\r\n", module, name, "PASSED");
     62          		}
     63          	else{
     64          		utest_summary.failed++;
     65          		printf("Module: %-15s Name: %-50s Status: %-10s\r\n", module, name, "FAILED <----");
     66          		}
     67          }
     68          
     69          void umsg_line(char* name)
     70          {
     71          	printf("**************************************\r\n");
     72          	printf("%s\r\n", name);
     73          	printf("**************************************\r\n");
     74          }
     75          
     76          void umsg_summary()
     77          {
     78          	umsg_line("Unit test symmary");
     79          	printf("PASSED: %d\r\n", utest_summary.passed);
     80          	printf("FAILD : %d\r\n", utest_summary.failed);
     81          	if (utest_summary.failed == 0)
     82                printf("Tests PASSED\r\n");
     83          	else
     84          		printf("Tests FAILED\r\n");
     85          }
\\vmware-host\Shared Folders\Projects\WMNU\IAR\PRJ_UNITEST\src\utest_TIC.c
      1          #include "utest_suite.h"
      2          #include "TIC.h"
      3          #include "NTMR.h"
      4          #include "ioCC2530.h"
      5          
      6          static void RXC(uint8_t TS)
      7          {
      8            P0_1 = 1;
      9            P0_1 = 0;
     10          }
     11          
     12          static void TXC(uint8_t TS)
     13          {
     14            P0_4 = 1;
     15            P0_4 = 0;
     16          }
     17          
     18          static void SEC(uint8_t TS)
     19          {
     20            if (TS == 0)
     21            {
     22              P0_0 = 1;
     23              P0_0 = 0;
     24            }
     25          }
     26          
     27          /**
     28          @details Аппаратный тест TIC. Выводит сигналы
     29          на выводы P0_0 завершение нулевого слота. P0_1 прием, P0_4 передача.
     30          Тайм слот 11 показывает приоритет передачи над приемом.
     31          */
     32          static void test_hw(void)
     33          {
     34            NT_Init();
     35            TIC_Init();
     36            EA = 1;
     37            P0DIR = 0xff;
     38            P0_0 = 0;
     39            P0_1 = 0;
     40            P0_2 = 0;
     41            
     42            TIC_SetRXCallback(RXC);
     43            TIC_SetTXCallback(TXC);
     44            TIC_SetSECallback(SEC);
     45            
     46            TIC_SetRXState(10, true);
     47            TIC_SetRXState(11, true);
     48            TIC_SetRXState(20, true);
     49            TIC_SetRXState(21, true);
     50            
     51            TIC_SetTXState(5, true);
     52            TIC_SetTXState(11, true);
     53           
     54            TIC_SetRTC(10000);
     55            TIC_SetNonce(5000);
     56            volatile uint32_t rtc, ut, nonce;
     57            while(true)
     58            {
     59              // тут можно остановить программу и посмотреть работу таймеров
     60              // rtc больше на 10000 чем uptime, nonce больше на 5000
     61              ut = TIC_GetUptime(); 
     62              rtc = TIC_GetRTC();
     63              nonce = TIC_GetNonce();
     64            }
     65          }
     66          
     67          void suite_TIC_HW(void)
     68          {
     69            test_hw();
     70          }

   Maximum stack usage in bytes:

   ISTACK XSTACK Function
   ------ ------ --------
      1    184   AES_CCMDecrypt
        0     66   -> CBCMAC_buf_encrypt
        0     70   -> CTR_enc_decrypt
        0     68   -> generateAuthData
        0     68   -> memcpy
        0     68   -> memset
      1    168   AES_CCMEncrypt
        0     50   -> CBCMAC_buf_encrypt
        0     54   -> CTR_enc_decrypt
        0     52   -> generateAuthData
        0     52   -> memcpy
        0     52   -> memset
      0    127   AES_StreamCoder
        0     39   -> memcpy
        0     39   -> memset
      2    188   AES_init
      0    116   CBCMAC_buf_encrypt
        0     50   -> memcpy
        0     50   -> memset
      0    194   CCM_code_decode_test
        0    188   -> AES_init
        0    188   -> TIM_init
        0    188   -> printf
        0    192   -> printf
        0    194   -> printf
        0    194   -> single_enc_dec_test
        0    188   -> umsg
      1     62   CCM_test
        0     62   -> AES_CCMDecrypt
        0     62   -> AES_CCMEncrypt
        0     56   -> AES_init
        0     56   -> TIM_init
        0     58   -> memset
      0    109   CTR_enc_decrypt
        0     39   -> memcpy
        0     39   -> memset
      0     28   Callback_execution
        0     12   -> STACK_FAILURE
        0     12   -> printf
        0     16   -> printf
      0     40   DelayCalibrate
        0     40   -> TIM_TimeStamp
        0     40   -> TIM_delay
        0     40   -> TIM_passedTime
      2      0   ETH_Init
        2      0   -> LLC_SetRXCallback
      0     18   ETH_RX_HNDL
        0     14   -> STACK_FAILURE
        0     14   -> extract_header
        0     14   -> frame_delete
        0     14   -> printf
        0     18   -> printf
        0     14   -> re_free
        0     14   -> send_ack
        0     14   -> strip_header
        0     14   -> validate
      0     14   ETH_Set_RXCallback
        0     10   -> STACK_FAILURE
        0     10   -> printf
        0     14   -> printf
      0     54   Interval
      0     52   LED
      1     49   LLC_AddTask
        0     12   -> STACK_FAILURE
        0     12   -> printf
        0     16   -> printf
        0     12   -> re_malloc
      2     33   LLC_GetTaskLen
      2     33   LLC_Init
        2      0   -> MAC_Init
        2      0   -> MAC_SetRXCallback
        2      0   -> TIC_SetSECallback
      0     14   LLC_RX_HNDL
        0     10   -> STACK_FAILURE
        0     10   -> printf
        0     14   -> printf
      0     18   LLC_RunTimeAlloc
      0      9   LLC_SE_HNDL
        0      9   -> LLC_RunTimeAlloc
        0      9   -> LLC_Shelduler
      0     14   LLC_SetRXCallback
        0     10   -> STACK_FAILURE
        0     10   -> printf
        0     14   -> printf
      0     22   LLC_Shelduler
        0     13   -> MAC_GetTXState
        0     13   -> MAC_Send
        0     13   -> re_free
      0     49   LLC_TimeAlloc
        0     12   -> STACK_FAILURE
        0     12   -> printf
        0     16   -> printf
        0     12   -> re_malloc
      2     16   LoadTXData
      0      0   MAC_ACK_Recv
      0     49   MAC_ACK_Send
        0      9   -> RI_Send
        0      9   -> RI_SetChannel
        0      9   -> frame_delete
      1     14   MAC_CloseRXSlot
        0     10   -> STACK_FAILURE
        0     10   -> TIC_SetRXState
        0     10   -> printf
        0     14   -> printf
      0     14   MAC_GetRXState
        0     10   -> STACK_FAILURE
        0     10   -> printf
        0     14   -> printf
      0     38   MAC_GetTXState
        0     10   -> STACK_FAILURE
        0     10   -> printf
        0     14   -> printf
      0     52   MAC_Init
        0     10   -> AES_init
        0     10   -> RI_StreamCrypt
        0     10   -> RI_init
        0     10   -> RI_setIV
        0     10   -> RI_setKEY
        0     10   -> TIC_Init
        0     10   -> TIC_SetRXCallback
        0     10   -> TIC_SetTXCallback
        0     10   -> TIM_init
        0     12   -> memset
      1     14   MAC_OpenRXSlot
        0     10   -> STACK_FAILURE
        0     10   -> TIC_SetRXState
        0     10   -> printf
        0     14   -> printf
      0     16   MAC_RX_HNDL
        0     12   -> RI_Receive
        0     12   -> RI_SetChannel
        0     12   -> STACK_FAILURE
        0     12   -> printf
        0     16   -> printf
      1     40   MAC_Send
        0     12   -> STACK_FAILURE
        0     12   -> TIC_SetTXState
        0     12   -> printf
        0     16   -> printf
      2      0   MAC_SetRXCallback
      2      0   MAC_Set_isACK_OK_Callback
      1     16   MAC_TX_HNDL
        0     12   -> RI_Receive
        0     12   -> RI_Send
        0     12   -> RI_SetChannel
        0     12   -> STACK_FAILURE
        0     12   -> TIC_SetTXState
        0     12   -> TIM_delay
        0     12   -> frame_delete
        0     12   -> printf
        0     16   -> printf
      0     16   MyLowLevelPutchar
      0     48   NT_GetTime
        0     16   -> ReadTimer
      0     15   NT_IRQEnable
      2     52   NT_Init
        2      0   -> NT_IRQEnable
      0     30   NT_SetCompare
        0     12   -> NT_IRQEnable
        0     12   -> STACK_FAILURE
        0     12   -> calcCompareTime
        0     12   -> loadTimerCompare
        0     12   -> printf
        0     16   -> printf
      2      9   NT_SetEventCallback
      0     28   NT_SetTime
        0     14   -> NT_SetCompare
        0     14   -> ReadTimer
        0     14   -> STACK_FAILURE
        0     14   -> isIRQEnable
        0     14   -> printf
        0     18   -> printf
      0     28   NT_WaitTime
      0     32   RI_BitRawCrypt
        0     16   -> AES_StreamCoder
      0     62   RI_BitRawDecrypt
        0     16   -> AES_StreamCoder
      2      0   RI_GetCCAReject
      2      0   RI_GetCRCError
      2      0   RI_GetUptime
      1    100   RI_Receive
        0     46   -> RI_BitRawDecrypt
        0     46   -> RI_cfg
        0     48   -> RecvData
        0     46   -> TIM_TimeStamp
        0     46   -> TIM_passedTime
        0     46   -> UnLoadRXData
        0     46   -> frame_addHeader
        0     46   -> frame_create
        0     46   -> re_free
        0     46   -> re_malloc
      0     72   RI_Send
        0     36   -> RI_cfg
        0     36   -> STACK_FAILURE
        0     36   -> SendData
        0     36   -> TIM_TimeStamp
        0     36   -> TIM_passedTime
        0     36   -> printf
        0     40   -> printf
      2    148   RI_SetChannel
      2    148   RI_StreamCrypt
      3     47   RI_cfg
        2      1   -> setFreq
      2    148   RI_init
        2      0   -> random_core_init
      0    160   RI_setIV
        0     12   -> memcpy
      0    160   RI_setKEY
        0     12   -> memcpy
      0      0   RXC
      0     54   RadioRecvTest1
        0     52   -> AES_init
        0     52   -> LED
        0     52   -> NT_Init
        0     52   -> RI_Receive
        0     52   -> RI_SetChannel
        0     52   -> RI_StreamCrypt
        0     52   -> RI_init
        0     52   -> RI_setIV
        0     52   -> RI_setKEY
        0     52   -> TIC_Init
        0     52   -> TIM_init
        0     52   -> frame_delete
        0     54   -> memory_compare
      2     22   ReadTimer
      0     80   RecvData
        0     32   -> NT_GetTime
        0     32   -> TIM_TimeStamp
        0     32   -> TIM_passedTime
      0      0   SEC
      0     36   STACK_FAILURE
      0     52   SendData
        0     16   -> LoadTXData
        0     16   -> NT_GetTime
        0     16   -> NT_WaitTime
        0     16   -> RI_BitRawCrypt
        0     16   -> re_free
      0      0   SetCPU32M
      2     12   TIC_GetNonce
      2     24   TIC_GetRTC
      0     14   TIC_GetRXState
        0     10   -> STACK_FAILURE
        0     10   -> printf
        0     14   -> printf
      0     14   TIC_GetTXState
        0     10   -> STACK_FAILURE
        0     10   -> printf
        0     14   -> printf
      0      0   TIC_GetTimeStampTS0
      2      0   TIC_GetTimer
        2      0   -> NT_GetTime
      2     12   TIC_GetUptime
      0     16   TIC_HW_Timer_IRQ
        0     12   -> Callback_execution
        0     12   -> TIC_TDMAShelduler
        0     12   -> TIC_getCurrentTS
        0     12   -> TIM_TimeStamp
        0     12   -> clocks_update
        0     12   -> printf
        0     16   -> printf
      2    148   TIC_Init
        2      0   -> NT_SetCompare
        2      0   -> NT_SetEventCallback
        2      0   -> TIC_SetTimer
        2      0   -> TIM_TimeStamp
      0     24   TIC_SetNonce
      0     24   TIC_SetRTC
      0     26   TIC_SetRXCallback
        0     10   -> STACK_FAILURE
        0     10   -> printf
        0     14   -> printf
      0     26   TIC_SetRXState
        0     10   -> STACK_FAILURE
        0     10   -> printf
        0     14   -> printf
      0     38   TIC_SetSECallback
        0     10   -> STACK_FAILURE
        0     10   -> printf
        0     14   -> printf
      0     26   TIC_SetTXCallback
        0     10   -> STACK_FAILURE
        0     10   -> printf
        0     14   -> printf
      0     26   TIC_SetTXState
        0     10   -> STACK_FAILURE
        0     10   -> printf
        0     14   -> printf
      0     14   TIC_SetTimer
        0     10   -> NT_SetTime
        0     10   -> STACK_FAILURE
        0     10   -> printf
        0     14   -> printf
      3     13   TIC_TDMAShelduler
        2      1   -> incrementTS
        2      1   -> set_capture_time
      0     24   TIC_TimeUsFromTS0
        0     24   -> TIM_TimeStamp
        0     24   -> TIM_passedTime
      0     22   TIC_getCurrentTS
      3     91   TIM_TimeStamp
      0     14   TIM_copy
        0     14   -> memcpy
      0     76   TIM_delay
        0     36   -> Interval
        0     36   -> TIM_TimeStamp
      2    188   TIM_init
        2      0   -> DelayCalibrate
      0    109   TIM_passedTime
        0     18   -> Interval
      0      0   TXC
      0     15   TimerCompareInterrupt
        0     15   -> NT_GetTime
        0     15   -> NT_IRQEnable
      0     12   TimerHndl
        0     10   -> NT_SetCompare
        0     12   -> isNear
      3     46   UnLoadRXData
      0     18   __write
        0     16   -> MyLowLevelPutchar
      0     88   aes_test
        0     88   -> AES_StreamCoder
        0     84   -> AES_init
        0     84   -> TIM_TimeStamp
        0     84   -> TIM_init
        0     84   -> TIM_passedTime
        0     86   -> memset
        0     88   -> printf
      0      9   alg_test
        0      9   -> NT_Init
        0      9   -> NT_SetCompare
        0      9   -> NT_SetEventCallback
      0     32   alg_test
        0     32   -> TIM_TimeStamp
        0     32   -> TIM_init
        0     32   -> TIM_passedTime
        0     32   -> umsg
      0      9   bits_count
      2     34   calcCompareTime
        0     22   -> ReadTimer
      0     24   clocks_update
      0     32   extract_header
        0     14   -> STACK_FAILURE
        0     14   -> frame_len
        0     14   -> printf
        0     18   -> printf
        0     14   -> re_malloc
      1    170   frame_addHeader
        0     18   -> STACK_FAILURE
        0     18   -> printf
        0     22   -> printf
        0     18   -> re_free
        0     18   -> re_malloc
        0     20   -> re_memcpy
      0    164   frame_create
        0     12   -> STACK_FAILURE
        0     14   -> memset
        0     12   -> printf
        0     16   -> printf
        0     12   -> re_malloc
      1     18   frame_delHeader
        0     14   -> STACK_FAILURE
        0     14   -> printf
        0     18   -> printf
        0     14   -> re_free
        0     14   -> re_malloc
        0     16   -> re_memcpy
      0    158   frame_delete
        0     10   -> re_free
      2     33   frame_getCount
      2     33   frame_len
      0     19   free
        0      9   -> __xdata_free
      0     86   generateAuthData
        0     18   -> memcpy
      1     49   getFrame
        0     16   -> frame_addHeader
        0     16   -> frame_create
      2     14   getMallocSize
      2      9   getRNDByte
      0     63   heap_ptr
        0     12   -> re_free
        0     12   -> re_malloc
      0      0   heap_size
      2      1   incrementTS
      0     14   isIRQEnable
      2     12   isNear
      0     28   loadTimerCompare
      0      4   main
        0      0   -> nwDebugerInit
        0      0   -> printf
        0      4   -> printf
        0      0   -> suite_LLC_HW
        0      0   -> umsg_summary
        0      0   -> utestSigTraceInit
      0     23   malloc
        0      9   -> __xdata_malloc
      0     32   manual
        0     32   -> TIM_TimeStamp
        0     32   -> TIM_delay
        0     32   -> TIM_init
        0     32   -> TIM_passedTime
        0     32   -> umsg
      1    114   mem_control
        0    114   -> AES_CCMDecrypt
        0    114   -> AES_CCMEncrypt
        0    108   -> AES_init
        0    108   -> TIM_init
        0    110   -> memcpy
        0    108   -> umsg
      0     63   memory_compare
      2      0   nwDebugerInit
        2      0   -> SetCPU32M
        2      0   -> uart_init
      0    188   one_speed_test
        0     32   -> RI_Send
        0     32   -> TIM_TimeStamp
        0     32   -> TIM_passedTime
        0     36   -> printf
        0     40   -> printf
      0      9   random_core_init
        0      9   -> RI_cfg
        0      9   -> rand
        0      9   -> readRandom
        0      9   -> srand
      0     56   re_free
        0     10   -> free
      0     60   re_malloc
        0     14   -> malloc
      0     36   re_memcpy
        0     16   -> memcpy
      0     18   readRandom
        0      9   -> bits_count
        0      9   -> getRNDByte
      0     14   send_ack
      1     16   setFreq
        0     11   -> STACK_FAILURE
        0     11   -> printf
        0     15   -> printf
      0     10   set_capture_time
        0      9   -> NT_SetCompare
      0    214   single_enc_dec_test
        0     20   -> AES_CCMDecrypt
        0     20   -> AES_CCMEncrypt
      0    152   speed_test
        0    148   -> AES_init
        0    148   -> RI_SetChannel
        0    148   -> RI_StreamCrypt
        0    148   -> RI_init
        0    148   -> RI_setIV
        0    148   -> RI_setKEY
        0    148   -> TIC_Init
        0    148   -> TIM_init
        0    148   -> frame_addHeader
        0    148   -> frame_create
        0    148   -> frame_delete
        0    148   -> one_speed_test
        0    148   -> printf
        0    152   -> printf
      0     14   strip_header
      0      0   stub_se
      2      0   suite_Frames
        2      0   -> umsg_line
      2      0   suite_LLC_HW
        2      0   -> test_create
      2      0   suite_MAC
        2      0   -> test_ACK_SEND
        2      0   -> test_TS_Send
      2      0   suite_NT_HW
        2      0   -> alg_test
      2      0   suite_RADIO
        2      0   -> speed_test
        2      0   -> umsg_line
      2      0   suite_RADIO_HW
        2      0   -> RadioRecvTest1
      2      0   suite_TIC_HW
        2      0   -> test_hw
      2      0   suite_coder
        2      0   -> CCM_code_decode_test
        2      0   -> CCM_test
        2      0   -> aes_test
        2      0   -> mem_control
        2      0   -> umsg_line
      2      0   suite_delays
        2      0   -> alg_test
        2      0   -> umsg_line
      2      0   suite_delays_HW
        2      0   -> manual
      2      0   suite_frame
        2      0   -> test_1
        2      0   -> test_2
        2      0   -> test_3
        2      0   -> test_4
        2      0   -> umsg_line
      2      0   suite_malloc
        2      0   -> test_1
      2      0   suite_printf_uart
        2      0   -> test_1
        2      0   -> umsg_line
      0     14   test_1
        0     14   -> getMallocSize
        0     14   -> malloc
      0     10   test_1
        0     10   -> frame_create
        0     10   -> frame_delete
        0     10   -> frame_getCount
        0     10   -> umsg
      0     97   test_1
        0     91   -> TIM_TimeStamp
        0     91   -> TIM_init
        0     91   -> TIM_passedTime
        0     91   -> printf
        0     95   -> printf
        0     97   -> printf
      0     17   test_2
        0     17   -> frame_addHeader
        0     17   -> frame_create
        0     17   -> frame_delete
        0     17   -> heap_ptr
        0     17   -> umsg
      0     20   test_3
        0     20   -> frame_addHeader
        0     20   -> frame_create
        0     20   -> frame_delete
        0     20   -> umsg
      0     51   test_4
        0     51   -> frame_addHeader
        0     51   -> frame_create
        0     51   -> frame_delete
        0     51   -> heap_ptr
        0     51   -> umsg
      0     46   test_ACK_SEND
        0     40   -> MAC_ACK_Send
        0     40   -> MAC_Init
        0     40   -> TIM_TimeStamp
        0     40   -> TIM_passedTime
        0     40   -> frame_addHeader
        0     40   -> frame_create
        0     44   -> printf
        0     46   -> printf
      1     28   test_TS_Send
        0     24   -> MAC_GetTXState
        0     24   -> MAC_Init
        0     24   -> MAC_Send
        0     24   -> TIC_GetRTC
        0     24   -> TIC_SetSECallback
        0     24   -> frame_addHeader
        0     24   -> frame_create
        0     28   -> printf
      1     39   test_create
        0     33   -> LLC_AddTask
        0     33   -> LLC_GetTaskLen
        0     33   -> LLC_Init
        0     33   -> LLC_TimeAlloc
        0     33   -> frame_delete
        0     33   -> frame_getCount
        0     33   -> frame_len
        0     33   -> getFrame
        0     33   -> heap_ptr
        0     35   -> printf
        0     37   -> printf
        0     39   -> printf
      2     12   test_hw
        2     12   -> NT_Init
        2     12   -> TIC_GetNonce
        2     12   -> TIC_GetRTC
        2     12   -> TIC_GetUptime
        2     12   -> TIC_Init
        2     12   -> TIC_SetNonce
        2     12   -> TIC_SetRTC
        2     12   -> TIC_SetRXCallback
        2     12   -> TIC_SetRXState
        2     12   -> TIC_SetSECallback
        2     12   -> TIC_SetTXCallback
        2     12   -> TIC_SetTXState
      2      0   timealloc
        2      0   -> LED
      0      0   uart_init
      0    208   umsg
        0     20   -> printf
      0     12   umsg_line
        0     10   -> printf
        0     12   -> printf
      2      2   umsg_summary
        2      0   -> printf
        2      2   -> printf
        2      0   -> umsg_line
      0      0   utestSigTraceInit
      0     14   validate


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
       5  ?<Constant "%s\r\n">
      41  ?<Constant "*********************...">
      19  ?<Constant "*ASSERT* %s:%d -> ">
      17  ?<Constant "*ASSERT* %s:%d->">
      17  ?<Constant "*ASSERT* %s:%d->">_1
      17  ?<Constant "*ASSERT* %s:%d->">_2
      17  ?<Constant "*ASSERT* %s:%d->">_3
      17  ?<Constant "*ASSERT* %s:%d->">_4
      17  ?<Constant "*ASSERT* %s:%d->">_5
      17  ?<Constant "*ASSERT* %s:%d->">_6
      19  ?<Constant "*LOGGER* %s:%d -> ">
      19  ?<Constant "*LOGGER* %s:%d -> ">_1
      19  ?<Constant "*LOGGER* %s:%d -> ">_2
      19  ?<Constant "*LOGGER* %s:%d -> ">_3
      19  ?<Constant "*LOGGER* %s:%d -> ">_4
      19  ?<Constant "*LOGGER* %s:%d -> ">_5
      19  ?<Constant "*LOGGER* %s:%d -> ">_6
       9  ?<Constant "*fr null">
      27  ?<Constant ".Program execution ha...">
      27  ?<Constant ".Program execution ha...">_1
      27  ?<Constant ".Program execution ha...">_2
      27  ?<Constant ".Program execution ha...">_3
      27  ?<Constant ".Program execution ha...">_4
      27  ?<Constant ".Program execution ha...">_5
      27  ?<Constant ".Program execution ha...">_6
      10  ?<Constant "0123456789">
      13  ?<Constant "Assert fails">
      13  ?<Constant "Assert fails">_1
      13  ?<Constant "Assert fails">_2
      13  ?<Constant "Assert fails">_3
      13  ?<Constant "Assert fails">_4
      13  ?<Constant "Assert fails">_5
      13  ?<Constant "Assert fails">_6
      30  ?<Constant "CCM coder corrupt dat...">
      29  ?<Constant "CCM coder corrupt key...">
      29  ?<Constant "CCM coder corrupt mic...">
      31  ?<Constant "CCM coder corrupt non...">
      25  ?<Constant "CCM decoded data correct">
      32  ?<Constant "CCM decoder corrupt d...">
      31  ?<Constant "CCM decoder corrupt k...">
      31  ?<Constant "CCM decoder corrupt m...">
      33  ?<Constant "CCM decoder corrupt n...">
      20  ?<Constant "CCM full coder test">
      27  ?<Constant "CCM full size test 60...">
      21  ?<Constant "CCM key data correct">
      23  ?<Constant "CCM nonce data correct">
      17  ?<Constant "Callback is NULL">
      36  ?<Constant "Coder test stub on m=...">
       7  ?<Constant "Create">
      54  ?<Constant "Data size = %d. Full ...">
       7  ?<Constant "Delete">
      13  ?<Constant "FAILD : %d\r\n">
      13  ?<Constant "FAILED <----">
      11  ?<Constant "Fn is NULL">
      37  ?<Constant "Frame puted to MAC la...">
      46  ?<Constant "Frame_s size = %d. Fb...">
      14  ?<Constant "Frames module">
      16  ?<Constant "HEAP_PTR = %d\r\n">
      11  ?<Constant "Header add">
      46  ?<Constant "Hello worldHello worl...">
      13  ?<Constant "Hello world\n">
      13  ?<Constant "Incorrect TS">
      19  ?<Constant "Incorrect eth size">
      24  ?<Constant "Incorrect radio channel">
      16  ?<Constant "Incorrect ticks">
      27  ?<Constant "LLC re_malloc for new...">
       6  ?<Constant "LLC.c">
       6  ?<Constant "MAC.c">
      38  ?<Constant "MAC_ACK_Send time = %...">
      20  ?<Constant "Memmory free test 1">
      20  ?<Constant "Memmory free test 2">
      24  ?<Constant "Memory allocation fails">
      42  ?<Constant "Module: %-15s Name: %...">
       7  ?<Constant "NTMR.c">
      23  ?<Constant "NULL pointer not allow">
      23  ?<Constant "NULL pointer not allow">_1
      10  ?<Constant "No memory">
      10  ?<Constant "No memory">_1
       7  ?<Constant "PASSED">
      13  ?<Constant "PASSED: %d\r\n">
      13  ?<Constant "RADIO module">
       8  ?<Constant "RADIO.c">
      21  ?<Constant "RXCallback func NULL">
      19  ?<Constant "RXCallback is NULL">
      40  ?<Constant "SEND IN SEND_TIME 100...">
      34  ?<Constant "SEND SPEED TEST WITH ...">
      37  ?<Constant "SEND SPEED TEST WITHO...">
      40  ?<Constant "String 1 len = %d. Pr...">
      41  ?<Constant "String 2 len = %d. Pr...">
      22  ?<Constant "Striped_frame is NULL">
       6  ?<Constant "TIC.c">
      30  ?<Constant "TIM_passedTimeNs meas...">
      12  ?<Constant "TS = 255 \r\n">
      16  ?<Constant "TS not in range">
      21  ?<Constant "Test assert output\r\n">
      18  ?<Constant "Test log output\r\n">
      15  ?<Constant "Tests FAILED\r\n">
      15  ?<Constant "Tests PASSED\r\n">
      19  ?<Constant "Ticks not in range">
      18  ?<Constant "Unit test symmary">
       3  ?<Constant "\r\n">
      13  ?<Constant "attempts = 0">
      13  ?<Constant "coder module">
       6  ?<Constant "coder">
      14  ?<Constant "delays module">
       7  ?<Constant "delays">
      11  ?<Constant "ethernet.c">
       8  ?<Constant "fr NULL">
       8  ?<Constant "fr NULL">_1
      11  ?<Constant "fr is NULL">
      13  ?<Constant "frame module">
       6  ?<Constant "frame">
       8  ?<Constant "frame.c">
      19  ?<Constant "isACK_OK func NULL">
      14  ?<Constant "passed %lu \r\n">
      18  ?<Constant "printf speed uart">
       8  ?<Constant "utest.c">
      12  ?<Constant "utest_LLC.c">
      12  ?<Constant "utest_MAC.c">
      14  ?<Constant "utest_coder.c">
      20  ?<Constant "utest_printf_uart.c">
      14  ?<Constant "utest_radio.c">
      10  ?<Constant {0, 1, 2, 3, 4, 3, 87, 21, 35, 73}>
      10  ?<Constant {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}>
      10  ?<Constant {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}>_1
      10  ?<Constant {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}>_2
      10  ?<Constant {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}>_3
       5  ?<Constant {0, 1, 2, 3, 4}>
      16  ?<Constant {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11,
      16  ?<Constant {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11,_1
      16  ?<Constant {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11,_2
      16  ?<Constant {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11,_3
      16  ?<Constant {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11,_4
      16  ?<Constant {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11,_5
       8  ?<Constant {10, 11, 12, 13, 14, 15, 17, 20}>
       4  ?<Constant {10, 50, 100, 125}>
      16  ?<Constant {18, 11, 12, 13, 14, 15, 16, 17, 10
      16  ?<Constant {18, 11, 12, 13, 14, 15, 16, 17, 10_1
      16  ?<Constant {18, 11, 12, 13, 14, 15, 16, 17, 10_2
      16  ?<Constant {18, 11, 12, 13, 14, 15, 16, 17, 10_3
      16  ?<Constant {18, 11, 12, 13, 14, 15, 16, 17, 10_4
      16  ?<Constant {18, 11, 12, 13, 14, 15, 16, 17, 10_5
       9  ?<Constant {5, 6, 7, 8, 9, 23, 56, 23, 6}>
      12  ?<Constant {5, 6, 7, 8, 9, 36, 85, 98, 23, 98,
       5  ?<Constant {5, 6, 7, 8, 9}>
       5  ?<Initializer for <Constant "%s\r\n">>
      41  ?<Initializer for <Constant "*****************
      19  ?<Initializer for <Constant "*ASSERT* %s:%d ->
      17  ?<Initializer for <Constant "*ASSERT* %s:%d->"
      17  ?<Initializer for <Constant "*ASSERT* %s:%d->"_1
      17  ?<Initializer for <Constant "*ASSERT* %s:%d->"_2
      17  ?<Initializer for <Constant "*ASSERT* %s:%d->"_3
      17  ?<Initializer for <Constant "*ASSERT* %s:%d->"_4
      17  ?<Initializer for <Constant "*ASSERT* %s:%d->"_5
      17  ?<Initializer for <Constant "*ASSERT* %s:%d->"_6
      19  ?<Initializer for <Constant "*LOGGER* %s:%d ->
      19  ?<Initializer for <Constant "*LOGGER* %s:%d ->_1
      19  ?<Initializer for <Constant "*LOGGER* %s:%d ->_2
      19  ?<Initializer for <Constant "*LOGGER* %s:%d ->_3
      19  ?<Initializer for <Constant "*LOGGER* %s:%d ->_4
      19  ?<Initializer for <Constant "*LOGGER* %s:%d ->_5
      19  ?<Initializer for <Constant "*LOGGER* %s:%d ->_6
       9  ?<Initializer for <Constant "*fr null">>
      27  ?<Initializer for <Constant ".Program executio
      27  ?<Initializer for <Constant ".Program executio_1
      27  ?<Initializer for <Constant ".Program executio_2
      27  ?<Initializer for <Constant ".Program executio_3
      27  ?<Initializer for <Constant ".Program executio_4
      27  ?<Initializer for <Constant ".Program executio_5
      27  ?<Initializer for <Constant ".Program executio_6
      10  ?<Initializer for <Constant "0123456789">>
      13  ?<Initializer for <Constant "Assert fails">>
      13  ?<Initializer for <Constant "Assert fails">>_1
      13  ?<Initializer for <Constant "Assert fails">>_2
      13  ?<Initializer for <Constant "Assert fails">>_3
      13  ?<Initializer for <Constant "Assert fails">>_4
      13  ?<Initializer for <Constant "Assert fails">>_5
      13  ?<Initializer for <Constant "Assert fails">>_6
      30  ?<Initializer for <Constant "CCM coder corrupt
      29  ?<Initializer for <Constant "CCM coder corrupt_1
      31  ?<Initializer for <Constant "CCM coder corrupt_2
      29  ?<Initializer for <Constant "CCM coder corrupt_3
      25  ?<Initializer for <Constant "CCM decoded data
      32  ?<Initializer for <Constant "CCM decoder corru
      31  ?<Initializer for <Constant "CCM decoder corru_1
      33  ?<Initializer for <Constant "CCM decoder corru_2
      31  ?<Initializer for <Constant "CCM decoder corru_3
      20  ?<Initializer for <Constant "CCM full coder te
      27  ?<Initializer for <Constant "CCM full size tes
      21  ?<Initializer for <Constant "CCM key data corr
      23  ?<Initializer for <Constant "CCM nonce data co
      17  ?<Initializer for <Constant "Callback is NULL"
      36  ?<Initializer for <Constant "Coder test stub o
       7  ?<Initializer for <Constant "Create">>
      54  ?<Initializer for <Constant "Data size = %d. F
       7  ?<Initializer for <Constant "Delete">>
      13  ?<Initializer for <Constant "FAILD : %d\r\n">>
      13  ?<Initializer for <Constant "FAILED <----">>
      11  ?<Initializer for <Constant "Fn is NULL">>
      37  ?<Initializer for <Constant "Frame puted to MA
      46  ?<Initializer for <Constant "Frame_s size = %d
      14  ?<Initializer for <Constant "Frames module">>
      16  ?<Initializer for <Constant "HEAP_PTR = %d\r\n
      11  ?<Initializer for <Constant "Header add">>
      46  ?<Initializer for <Constant "Hello worldHello
      13  ?<Initializer for <Constant "Hello world\n">>
      13  ?<Initializer for <Constant "Incorrect TS">>
      19  ?<Initializer for <Constant "Incorrect eth siz
      24  ?<Initializer for <Constant "Incorrect radio c
      16  ?<Initializer for <Constant "Incorrect ticks">
      27  ?<Initializer for <Constant "LLC re_malloc for
       6  ?<Initializer for <Constant "LLC.c">>
       6  ?<Initializer for <Constant "MAC.c">>
      38  ?<Initializer for <Constant "MAC_ACK_Send time
      20  ?<Initializer for <Constant "Memmory free test
      20  ?<Initializer for <Constant "Memmory free test_1
      24  ?<Initializer for <Constant "Memory allocation
      42  ?<Initializer for <Constant "Module: %-15s Nam
       7  ?<Initializer for <Constant "NTMR.c">>
      23  ?<Initializer for <Constant "NULL pointer not
      23  ?<Initializer for <Constant "NULL pointer not _1
      10  ?<Initializer for <Constant "No memory">>
      10  ?<Initializer for <Constant "No memory">>_1
       7  ?<Initializer for <Constant "PASSED">>
      13  ?<Initializer for <Constant "PASSED: %d\r\n">>
      13  ?<Initializer for <Constant "RADIO module">>
       8  ?<Initializer for <Constant "RADIO.c">>
      21  ?<Initializer for <Constant "RXCallback func N
      19  ?<Initializer for <Constant "RXCallback is NUL
      40  ?<Initializer for <Constant "SEND IN SEND_TIME
      34  ?<Initializer for <Constant "SEND SPEED TEST W
      37  ?<Initializer for <Constant "SEND SPEED TEST W_1
      40  ?<Initializer for <Constant "String 1 len = %d
      41  ?<Initializer for <Constant "String 2 len = %d
      22  ?<Initializer for <Constant "Striped_frame is
       6  ?<Initializer for <Constant "TIC.c">>
      30  ?<Initializer for <Constant "TIM_passedTimeNs
      12  ?<Initializer for <Constant "TS = 255 \r\n">>
      16  ?<Initializer for <Constant "TS not in range">
      21  ?<Initializer for <Constant "Test assert outpu
      18  ?<Initializer for <Constant "Test log output\r
      15  ?<Initializer for <Constant "Tests FAILED\r\n"
      15  ?<Initializer for <Constant "Tests PASSED\r\n"
      19  ?<Initializer for <Constant "Ticks not in rang
      18  ?<Initializer for <Constant "Unit test symmary
       3  ?<Initializer for <Constant "\r\n">>
      13  ?<Initializer for <Constant "attempts = 0">>
      13  ?<Initializer for <Constant "coder module">>
       6  ?<Initializer for <Constant "coder">>
      14  ?<Initializer for <Constant "delays module">>
       7  ?<Initializer for <Constant "delays">>
      11  ?<Initializer for <Constant "ethernet.c">>
       8  ?<Initializer for <Constant "fr NULL">>
       8  ?<Initializer for <Constant "fr NULL">>_1
      11  ?<Initializer for <Constant "fr is NULL">>
      13  ?<Initializer for <Constant "frame module">>
       6  ?<Initializer for <Constant "frame">>
       8  ?<Initializer for <Constant "frame.c">>
      19  ?<Initializer for <Constant "isACK_OK func NUL
      14  ?<Initializer for <Constant "passed %lu \r\n">
      18  ?<Initializer for <Constant "printf speed uart
       8  ?<Initializer for <Constant "utest.c">>
      12  ?<Initializer for <Constant "utest_LLC.c">>
      12  ?<Initializer for <Constant "utest_MAC.c">>
      14  ?<Initializer for <Constant "utest_coder.c">>
      20  ?<Initializer for <Constant "utest_printf_uart
      14  ?<Initializer for <Constant "utest_radio.c">>
      10  ?<Initializer for <Constant {0, 1, 2, 3, 4, 3,
      10  ?<Initializer for <Constant {0, 1, 2, 3, 4, 5,
      10  ?<Initializer for <Constant {0, 1, 2, 3, 4, 5,_1
      10  ?<Initializer for <Constant {0, 1, 2, 3, 4, 5,_2
      10  ?<Initializer for <Constant {0, 1, 2, 3, 4, 5,_3
       5  ?<Initializer for <Constant {0, 1, 2, 3, 4}>>
      16  ?<Initializer for <Constant {1, 2, 3, 4, 5, 6,
      16  ?<Initializer for <Constant {1, 2, 3, 4, 5, 6,_1
      16  ?<Initializer for <Constant {1, 2, 3, 4, 5, 6,_2
      16  ?<Initializer for <Constant {1, 2, 3, 4, 5, 6,_3
      16  ?<Initializer for <Constant {1, 2, 3, 4, 5, 6,_4
      16  ?<Initializer for <Constant {1, 2, 3, 4, 5, 6,_5
       8  ?<Initializer for <Constant {10, 11, 12, 13, 1
       4  ?<Initializer for <Constant {10, 50, 100, 125}
      16  ?<Initializer for <Constant {18, 11, 12, 13, 1
      16  ?<Initializer for <Constant {18, 11, 12, 13, 1_1
      16  ?<Initializer for <Constant {18, 11, 12, 13, 1_2
      16  ?<Initializer for <Constant {18, 11, 12, 13, 1_3
      16  ?<Initializer for <Constant {18, 11, 12, 13, 1_4
      16  ?<Initializer for <Constant {18, 11, 12, 13, 1_5
       9  ?<Initializer for <Constant {5, 6, 7, 8, 9, 23
      12  ?<Initializer for <Constant {5, 6, 7, 8, 9, 36
       5  ?<Initializer for <Constant {5, 6, 7, 8, 9}>>
      16  ?<Initializer for IV>
      16  ?<Initializer for KEY>
       4  ?<Initializer for MAC_TIMER_MAX>
       4  ?<Initializer for __Constant_1388>
       4  ?<Initializer for __Constant_15180>
       4  ?<Initializer for __Constant_1>
       4  ?<Initializer for __Constant_1f4>
       4  ?<Initializer for __Constant_20>
       4  ?<Initializer for __Constant_2710>
       4  ?<Initializer for __Constant_3938700>
       4  ?<Initializer for __Constant_3d000000>
       4  ?<Initializer for __Constant_3e8>
       4  ?<Initializer for __Constant_447a0000>
       4  ?<Initializer for __Constant_7d0>
       4  ?<Initializer for __Constant_7fff>
       4  ?<Initializer for __Constant_8000>
       4  ?<Initializer for __Constant_a>
       4  ?<Initializer for __Constant_ffff8000>
       4  ?<Initializer for __Constant_fffffe0c>
       4  ?<Initializer for __Constant_ffffff>
     476  AES_CCMDecrypt
       6  AES_CCMDecrypt::?relay
     446  AES_CCMEncrypt
       6  AES_CCMEncrypt::?relay
     600  AES_StreamCoder
       6  AES_StreamCoder::?relay
     239  AES_init
       6  AES_init::?relay
     461  CBCMAC_buf_encrypt
       6  CBCMAC_buf_encrypt::?relay
     397  CCM_code_decode_test
       6  CCM_code_decode_test::?relay
     238  CCM_test
       6  CCM_test::?relay
       1  CLKCONCMD
       1  CLKCONSTA
       4  COMPARE_TIME
     600  CTR_enc_decrypt
       6  CTR_enc_decrypt::?relay
      88  Callback_execution
       6  Callback_execution::?relay
       4  DELAY_CALIBRATE_TICS
       1  DMA0CFGH
       1  DMA0CFGL
       1  DMA1CFGH
       1  DMA1CFGL
       1  DMAARM
       1  DMAREQ
       8  DMA_AES_DW
       8  DMA_AES_UP
     147  DelayCalibrate
       6  DelayCalibrate::?relay
       1  ENCCS
      28  ETH_Init
       6  ETH_Init::?relay
     322  ETH_RX_HNDL
       6  ETH_RX_HNDL::?relay
      81  ETH_Set_RXCallback
       6  ETH_Set_RXCallback::?relay
       2  EventCallback
       2  FirstTask
       4  HeadAllocFunc
      16  IV
      16  IV
     163  Interval
       6  Interval::?relay
      16  KEY
      16  KEY
      37  LED
       6  LED::?relay
     312  LLC_AddTask
       6  LLC_AddTask::?relay
      16  LLC_GetTaskLen
       6  LLC_GetTaskLen::?relay
      50  LLC_Init
       6  LLC_Init::?relay
      99  LLC_RX_HNDL
       6  LLC_RX_HNDL::?relay
      67  LLC_RunTimeAlloc
       6  LLC_RunTimeAlloc::?relay
      20  LLC_SE_HNDL
       6  LLC_SE_HNDL::?relay
      81  LLC_SetRXCallback
       6  LLC_SetRXCallback::?relay
     201  LLC_Shelduler
       6  LLC_Shelduler::?relay
     149  LLC_TimeAlloc
       6  LLC_TimeAlloc::?relay
      50  LoadTXData
       6  LoadTXData::?relay
     350  MACSlotTable
       7  MAC_ACK_Recv
       6  MAC_ACK_Recv::?relay
      49  MAC_ACK_Send
       6  MAC_ACK_Send::?relay
     122  MAC_CloseRXSlot
       6  MAC_CloseRXSlot::?relay
     111  MAC_GetRXState
       6  MAC_GetRXState::?relay
     111  MAC_GetTXState
       6  MAC_GetTXState::?relay
      82  MAC_Init
       6  MAC_Init::?relay
     165  MAC_OpenRXSlot
       6  MAC_OpenRXSlot::?relay
     152  MAC_RX_HNDL
       6  MAC_RX_HNDL::?relay
     336  MAC_Send
       6  MAC_Send::?relay
      19  MAC_SetRXCallback
       6  MAC_SetRXCallback::?relay
      19  MAC_Set_isACK_OK_Callback
       6  MAC_Set_isACK_OK_Callback::?relay
       4  MAC_TIMER_MAX
     808  MAC_TX_HNDL
       6  MAC_TX_HNDL::?relay
      12  MyLowLevelPutchar
       6  MyLowLevelPutchar::?relay
       1  NBR_FRAME
       4  NODE_NONCE
       4  NODE_RTC
       4  NODE_UPTIME
      55  NT_GetTime
       6  NT_GetTime::?relay
      19  NT_IRQEnable
       6  NT_IRQEnable::?relay
      54  NT_Init
       6  NT_Init::?relay
     130  NT_SetCompare
       6  NT_SetCompare::?relay
      19  NT_SetEventCallback
       6  NT_SetEventCallback::?relay
     157  NT_SetTime
       6  NT_SetTime::?relay
     126  NT_WaitTime
       6  NT_WaitTime::?relay
       1  P0DIR
       1  P0SEL
       1  P1DIR
       1  PERCFG
       4  RADIO_CFG
       1  RFD
       1  RFIRQF0
       1  RFIRQF1
       1  RFST
      64  RI_BitRawCrypt
       6  RI_BitRawCrypt::?relay
      64  RI_BitRawDecrypt
       6  RI_BitRawDecrypt::?relay
       4  RI_CCA_REJECT
       4  RI_CRC_ERROR
      17  RI_GetCCAReject
       6  RI_GetCCAReject::?relay
      17  RI_GetCRCError
       6  RI_GetCRCError::?relay
      17  RI_GetUptime
       6  RI_GetUptime::?relay
     581  RI_Receive
       6  RI_Receive::?relay
     217  RI_Send
       6  RI_Send::?relay
      32  RI_SetChannel
       6  RI_SetChannel::?relay
      23  RI_StreamCrypt
       6  RI_StreamCrypt::?relay
       4  RI_UPTIME
     109  RI_cfg
       6  RI_cfg::?relay
      38  RI_init
       6  RI_init::?relay
      41  RI_setIV
       6  RI_setIV::?relay
      41  RI_setKEY
       6  RI_setKEY::?relay
       7  RXC
       6  RXC::?relay
       2  RXCallback
       2  RXCallback
       2  RXCallback
       2  RXCallback
     166  RadioRecvTest1
       6  RadioRecvTest1::?relay
      59  ReadTimer
       6  ReadTimer::?relay
     152  RecvData
       6  RecvData::?relay
      10  SEC
       6  SEC::?relay
       2  SECallback
       1  SLEEPSTA
       1  ST0
       1  ST1
       1  ST2
       2  STACK_FAILURE
       6  STACK_FAILURE::?relay
       1  STLOAD
     180  SendData
       6  SendData::?relay
      12  SetCPU32M
       6  SetCPU32M::?relay
       1  T2CTRL
       1  T2M0
       1  T2M1
       1  T2MOVF0
       1  T2MOVF1
      17  TIC_GetNonce
       6  TIC_GetNonce::?relay
      17  TIC_GetRTC
       6  TIC_GetRTC::?relay
      99  TIC_GetRXState
       6  TIC_GetRXState::?relay
      99  TIC_GetTXState
       6  TIC_GetTXState::?relay
       7  TIC_GetTimeStampTS0
       6  TIC_GetTimeStampTS0::?relay
      14  TIC_GetTimer
       6  TIC_GetTimer::?relay
      17  TIC_GetUptime
       6  TIC_GetUptime::?relay
     178  TIC_HW_Timer_IRQ
       6  TIC_HW_Timer_IRQ::?relay
      39  TIC_Init
       6  TIC_Init::?relay
      26  TIC_SetNonce
       6  TIC_SetNonce::?relay
      40  TIC_SetRTC
       6  TIC_SetRTC::?relay
      81  TIC_SetRXCallback
       6  TIC_SetRXCallback::?relay
     129  TIC_SetRXState
       6  TIC_SetRXState::?relay
      81  TIC_SetSECallback
       6  TIC_SetSECallback::?relay
      81  TIC_SetTXCallback
       6  TIC_SetTXCallback::?relay
     129  TIC_SetTXState
       6  TIC_SetTXState::?relay
      94  TIC_SetTimer
       6  TIC_SetTimer::?relay
      92  TIC_TDMAShelduler
       6  TIC_TDMAShelduler::?relay
      66  TIC_TimeUsFromTS0
       6  TIC_TimeUsFromTS0::?relay
      61  TIC_getCurrentTS
       6  TIC_getCurrentTS::?relay
      61  TIM_TimeStamp
       6  TIM_TimeStamp::?relay
      45  TIM_copy
       6  TIM_copy::?relay
     133  TIM_delay
       6  TIM_delay::?relay
      17  TIM_init
       6  TIM_init::?relay
      94  TIM_passedTime
       6  TIM_passedTime::?relay
       2  TOFFSET
      50  TSStateTable
       7  TXC
       6  TXC::?relay
       2  TXCallback
       8  TimeStampTS0
      60  TimerCompareInterrupt
       3  TimerCompareInterrupt::??INTVEC 43
     265  TimerHndl
       6  TimerHndl::?relay
       1  U0BAUD
       1  U0CSR
       1  U0DBUF
       1  U0GCR
      40  UnLoadRXData
       6  UnLoadRXData::?relay
       1  _A_IEN0
       1  _A_IRCON
       1  _A_P0
       1  _A_P1
       4  __Constant_1
       4  __Constant_1388
       4  __Constant_15180
       4  __Constant_1f4
       4  __Constant_20
       4  __Constant_2710
       4  __Constant_3938700
       4  __Constant_3d000000
       4  __Constant_3e8
       4  __Constant_447a0000
       4  __Constant_7d0
       4  __Constant_7fff
       4  __Constant_8000
       4  __Constant_a
       4  __Constant_ffff8000
       4  __Constant_fffffe0c
       4  __Constant_ffffff
     156  __write
       6  __write::?relay
     332  aes_test
       6  aes_test::?relay
      66  alg_test
      97  alg_test
       6  alg_test::?relay
       6  alg_test::?relay
      34  bits_count
       6  bits_count::?relay
     162  buf
     189  calcCompareTime
       6  calcCompareTime::?relay
      94  clocks_update
       6  clocks_update::?relay
     164  extract_header
       6  extract_header::?relay
       1  finised
     368  frame_addHeader
       6  frame_addHeader::?relay
     169  frame_create
       6  frame_create::?relay
     216  frame_delHeader
       6  frame_delHeader::?relay
      71  frame_delete
       6  frame_delete::?relay
      16  frame_getCount
       6  frame_getCount::?relay
      19  frame_len
       6  frame_len::?relay
      21  free
       6  free::?relay
     241  generateAuthData
       6  generateAuthData::?relay
     105  getFrame
       6  getFrame::?relay
      34  getMallocSize
       6  getMallocSize::?relay
      53  getRNDByte
       6  getRNDByte::?relay
      40  heap_ptr
       6  heap_ptr::?relay
       7  heap_size
       6  heap_size::?relay
      36  incrementTS
       6  incrementTS::?relay
       2  isACK_OK
      11  isIRQEnable
       6  isIRQEnable::?relay
      56  isNear
       6  isNear::?relay
       1  led_stat
      70  loadTimerCompare
       6  loadTimerCompare::?relay
     108  main
       6  main::?relay
      21  malloc
       6  malloc::?relay
     189  manual
       6  manual::?relay
    1008  mem_control
       6  mem_control::?relay
      70  memory_compare
       6  memory_compare::?relay
       1  nbrTasks
      17  nwDebugerInit
       6  nwDebugerInit::?relay
     165  one_speed_test
       6  one_speed_test::?relay
      78  random_core_init
       6  random_core_init::?relay
      35  re_free
       6  re_free::?relay
      49  re_malloc
       6  re_malloc::?relay
      65  re_memcpy
       6  re_memcpy::?relay
      54  readRandom
       6  readRandom::?relay
       4  ret_val
       3  send_ack
       6  send_ack::?relay
     121  setFreq
       6  setFreq::?relay
      67  set_capture_time
       6  set_capture_time::?relay
     114  single_enc_dec_test
       6  single_enc_dec_test::?relay
     745  speed_test
       6  speed_test::?relay
       3  strip_header
       6  strip_header::?relay
       3  stub_se
       6  stub_se::?relay
      18  suite_Frames
       6  suite_Frames::?relay
      14  suite_LLC_HW
       6  suite_LLC_HW::?relay
      17  suite_MAC
       6  suite_MAC::?relay
      14  suite_NT_HW
       6  suite_NT_HW::?relay
      21  suite_RADIO
       6  suite_RADIO::?relay
      14  suite_RADIO_HW
       6  suite_RADIO_HW::?relay
      14  suite_TIC_HW
       6  suite_TIC_HW::?relay
      30  suite_coder
       6  suite_coder::?relay
      21  suite_delays
       6  suite_delays::?relay
      14  suite_delays_HW
       6  suite_delays_HW::?relay
      30  suite_frame
       6  suite_frame::?relay
      14  suite_malloc
       6  suite_malloc::?relay
      21  suite_printf_uart
       6  suite_printf_uart::?relay
       1  tasksBLOCK
      74  test_1
      76  test_1
     271  test_1
       6  test_1::?relay
       6  test_1::?relay
       6  test_1::?relay
     108  test_2
       6  test_2::?relay
     167  test_3
       6  test_3::?relay
     201  test_4
       6  test_4::?relay
     194  test_ACK_SEND
       6  test_ACK_SEND::?relay
     194  test_TS_Send
       6  test_TS_Send::?relay
     410  test_create
       6  test_create::?relay
     143  test_hw
       6  test_hw::?relay
      37  timealloc
       6  timealloc::?relay
      19  uart_init
       6  uart_init::?relay
     118  umsg
       6  umsg::?relay
      45  umsg_line
       6  umsg_line::?relay
      82  umsg_summary
       6  umsg_summary::?relay
       6  utestSigTraceInit
       6  utestSigTraceInit::?relay
       4  utest_summary
       4  val
       4  validate
       6  validate::?relay

 
 19 770 bytes in segment BANKED_CODE
  1 008 bytes in segment BANK_RELAYS
      3 bytes in segment INTVEC
     60 bytes in segment NEAR_CODE
     35 bytes in segment SFR_AN
  2 753 bytes in segment XDATA_I
  2 753 bytes in segment XDATA_ID
    695 bytes in segment XDATA_Z
 
  3 735 bytes of CODE     memory (+ 89 bytes shared)
      0 bytes of DATA     memory (+ 35 bytes shared)
 19 726 bytes of HUGECODE memory (+ 44 bytes shared)
  3 380 bytes of XDATA    memory (+ 68 bytes shared)

Errors: none
Warnings: 15
