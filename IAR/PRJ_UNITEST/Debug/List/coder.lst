###############################################################################
#
# IAR C/C++ Compiler V10.10.1.4655 for 8051               28/Nov/2019  01:52:55
# Copyright 2004-2017 IAR Systems AB.
# PC-locked license - IAR Embedded Workbench for 8051
#
#    Core               =  plain
#    Code model         =  banked
#    Data model         =  large
#    Calling convention =  xdata reentrant
#    Constant location  =  data
#    Dptr setup         =  1,16
#                          
#    Source file        =  
#        \\vmware-host\Shared Folders\Projects\WMNU\IAR\SHARE_PRJ_SRC\coder.c
#    Command line       =  
#        -f C:\Users\08A4~1\AppData\Local\Temp\EW7F8B.tmp
#        ("\\vmware-host\Shared
#        Folders\Projects\WMNU\IAR\SHARE_PRJ_SRC\coder.c" -lc
#        "\\vmware-host\Shared
#        Folders\Projects\WMNU\IAR\PRJ_UNITEST\Debug\List" -o
#        "\\vmware-host\Shared Folders\Projects\WMNU\IAR\PRJ_UNITEST\Debug\Obj"
#        -e --debug --core=plain --dptr=16,1 --data_model=large
#        --code_model=banked --calling_convention=xdata_reentrant
#        --place_constants=data --nr_virtual_regs 8 --dlib_config "C:\Program
#        Files (x86)\IAR Systems\Embedded Workbench
#        8.0\8051\LIB\DLIB\dl8051Normal.h" --no_path_in_file_macros -I
#        "\\vmware-host\Shared Folders\Projects\WMNU\IAR\SHARE_PRJ_SRC\" -On
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_cross_call --mfc "\\vmware-host\Shared
#        Folders\Projects\WMNU\IAR\SHARE_PRJ_SRC\delays.c"
#        "\\vmware-host\Shared Folders\Projects\WMNU\IAR\SHARE_PRJ_SRC\fbuf.c"
#        "\\vmware-host\Shared Folders\Projects\WMNU\IAR\SHARE_PRJ_SRC\frame.c"
#        "\\vmware-host\Shared Folders\Projects\WMNU\IAR\SHARE_PRJ_SRC\LLC.c"
#        "\\vmware-host\Shared Folders\Projects\WMNU\IAR\SHARE_PRJ_SRC\MAC.c"
#        "\\vmware-host\Shared Folders\Projects\WMNU\IAR\SHARE_PRJ_SRC\NTMR.c"
#        "\\vmware-host\Shared
#        Folders\Projects\WMNU\IAR\SHARE_PRJ_SRC\nwdebuger.c"
#        "\\vmware-host\Shared Folders\Projects\WMNU\IAR\SHARE_PRJ_SRC\RADIO.c"
#        "\\vmware-host\Shared Folders\Projects\WMNU\IAR\SHARE_PRJ_SRC\TIC.c"
#        "\\vmware-host\Shared
#        Folders\Projects\WMNU\IAR\PRJ_UNITEST\src\utest.c"
#        "\\vmware-host\Shared
#        Folders\Projects\WMNU\IAR\PRJ_UNITEST\src\utest_coder.c"
#        "\\vmware-host\Shared
#        Folders\Projects\WMNU\IAR\PRJ_UNITEST\src\utest_delays.c"
#        "\\vmware-host\Shared
#        Folders\Projects\WMNU\IAR\PRJ_UNITEST\src\utest_fbuf.c"
#        "\\vmware-host\Shared
#        Folders\Projects\WMNU\IAR\PRJ_UNITEST\src\utest_frame.c"
#        "\\vmware-host\Shared
#        Folders\Projects\WMNU\IAR\PRJ_UNITEST\src\utest_Frames.c"
#        "\\vmware-host\Shared
#        Folders\Projects\WMNU\IAR\PRJ_UNITEST\src\utest_LLC.c"
#        "\\vmware-host\Shared
#        Folders\Projects\WMNU\IAR\PRJ_UNITEST\src\utest_MAC.c"
#        "\\vmware-host\Shared
#        Folders\Projects\WMNU\IAR\PRJ_UNITEST\src\utest_malloc.c"
#        "\\vmware-host\Shared
#        Folders\Projects\WMNU\IAR\PRJ_UNITEST\src\utest_NTMR.c"
#        "\\vmware-host\Shared
#        Folders\Projects\WMNU\IAR\PRJ_UNITEST\src\utest_printf_uart.c"
#        "\\vmware-host\Shared
#        Folders\Projects\WMNU\IAR\PRJ_UNITEST\src\utest_radio.c"
#        "\\vmware-host\Shared
#        Folders\Projects\WMNU\IAR\PRJ_UNITEST\src\utest_suite.c"
#        "\\vmware-host\Shared
#        Folders\Projects\WMNU\IAR\PRJ_UNITEST\src\utest_TIC.c")
#    Locale             =  Russian_Russia.1251
#    List file          =  
#        \\vmware-host\Shared
#        Folders\Projects\WMNU\IAR\PRJ_UNITEST\Debug\List\coder.lst
#    Object file        =  
#        \\vmware-host\Shared
#        Folders\Projects\WMNU\IAR\PRJ_UNITEST\Debug\Obj\coder.r51
#
###############################################################################

\\vmware-host\Shared Folders\Projects\WMNU\IAR\SHARE_PRJ_SRC\coder.c
      1          /*!
      2          \file Модуль шифрования данных
      3          \brief Функции кодирования данных
      4          */
      5          
      6          #include "coder.h"
      7          #include "ioCC2530.h"
      8          #include "string.h"
      9          #include "delays.h" // Для профилирования, Отладка
     10          
     11          #define AES_START()  {ENCCS |= 0x01;} //!< Запуск выполнения команды  
     12          #define AES_SET_MODE(mode) {ENCCS &= ~0x70; ENCCS |= mode;} //!< Установка режима
     13          #define AES_SET_OPERATION(op) {ENCCS = (ENCCS & ~0x07) | op;} 
     14          #define AES_RDY() (ENCCS & 8) //!< Состояние модуля
     15          
     16          #define ST_DEF(STRUCT, FILD, VAL)  STRUCT.FILD = VAL
     17          #define HADDR(ADDR) ((uint16_t)ADDR >> 8)
     18          #define LADDR(ADDR) ((uint16_t)ADDR)
     19          #define BV(n)                   (1 << (n))
     20          #define MIC_2_MICLEN(m)         (BV((m&3)+1) & ~3)
     21          
     22          // Режимы шифрования
     23          #define AES_MODE_CBC            0x00
     24          #define AES_MODE_CFB            0x10
     25          #define AES_MODE_OFB            0x20
     26          #define AES_MODE_CTR            0x30
     27          #define AES_MODE_ECB            0x40
     28          #define AES_MODE_CBCMAC         0x50
     29          
     30          // Операции 
     31          #define AES_ENCRYPT             0x00
     32          #define AES_DECRYPT             0x02
     33          #define AES_LOAD_KEY            0x04
     34          #define AES_LOAD_IV             0x06
     35          
     36          #define ENC_DW 29 // DMA AES тригер запрос загрузки
     37          #define ENC_UP 30 // DMA AES тригер запрос выгрузки
     38          
     39          #define STREAM_ENC_MODE     AES_MODE_OFB //!< Метод шифрования потока данных
     40          
     41          // Доступные методы
     42          void AES_StreamCoder(bool enc_mode, uint8_t *src, uint8_t *dst, 
     43                               uint8_t *key, uint8_t *nonce, uint8_t len);
     44          
     45          // Приватные функции
     46          static inline uint8_t generateAuthData(uint8_t *src, uint8_t *nonce, uint8_t c,
     47                                                 uint8_t f, uint8_t lm);
     48          static void CBCMAC_buf_encrypt(uint8_t len, uint8_t *key, uint8_t *mac);
     49          
     50          /**
     51          @brief Локальный буфер для работы режима CCM
     52          @detail 128 длина сообщения. 18 длинна блока B0 и строки состояния.
     53           16 длина дополнения нулями
     54          */
     55          static uint8_t buf[128+18+16]; 
     56          
     57          
     58          typedef struct //!< Структура блока B0 для режима CCM
     59          {
     60            struct 
     61            {
     62              uint8_t L:3;
     63              uint8_t M:3;
     64              uint8_t A_Data:1;
     65            } flag;
     66            uint16_t nonce[9];
     67            uint8_t L_M[6];
     68          } __attribute__((packed)) B0_s;
     69          
     70          typedef struct //!< Структура блока A0 для режима CCM
     71          {
     72            struct 
     73            {
     74              uint8_t L:3;
     75            } flag;
     76            uint8_t nonce[11];
     77            uint8_t ctr;
     78          } __attribute__((packed)) A0_s;
     79          
     80          typedef struct //!< Структура с настройками DMA 
     81          {
     82            uint8_t  SRCADDRH;
     83            uint8_t  SRCADDRL;
     84            uint8_t  DSTADDRH;
     85            uint8_t  DSTADDRL;
     86            struct  {
     87            uint8_t   LENH        :5;
     88            uint8_t   VLEN        :3;
     89            };
     90            struct  {
     91            uint8_t   LENL        :8;
     92            };
     93            struct  {
     94            uint8_t   TRIG        :5;
     95            uint8_t   TMODE       :2;
     96            uint8_t   WORDSIZE    :1;
     97            };
     98            struct {
     99            uint8_t   PRIORITY    :2;
    100            uint8_t   M8          :1;
    101            uint8_t   IRQMASK     :1;
    102            uint8_t   DESTINC     :2;
    103            uint8_t   SRCINC      :2;
    104            };
    105          } __attribute__((packed)) DMA_AES_s ;
    106          
    107          DMA_AES_s DMA_AES_DW; //!< DMA на запись
    108          DMA_AES_s DMA_AES_UP; //!< DMA на чтение
    109          
    110          
    111          /**
    112          @brief Иницилизация модуля
    113          @detail Модуль использует DMA каналы 0 и 1
    114          */
    115          void AES_init(void)
    116          {
    117            // Настроим канал 0 DMA для загрузки данных в AES
    118            uint16_t CONF_ADDR = (uint16_t)&DMA_AES_DW;
    119            DMA0CFGH = CONF_ADDR >> 8;
    120            DMA0CFGL = CONF_ADDR & 0xFF;
    121            
    122            // Настроим канал 1 DMA для выгрузки данных из AES
    123            CONF_ADDR = (uint16_t)&DMA_AES_UP;
    124            DMA1CFGH = CONF_ADDR >> 8;
    125            DMA1CFGL = CONF_ADDR & 0xFF;
    126            
    127            ST_DEF(DMA_AES_DW, DSTADDRH, 0x70); // Пишем данные XENCDI = 0xB1 
    128            ST_DEF(DMA_AES_DW, DSTADDRL, 0xB1); //  
    129            ST_DEF(DMA_AES_DW, PRIORITY, 0x00); // Низкий приоритет
    130            ST_DEF(DMA_AES_DW, M8, 0x00); // Используем 8 бит для счетика длинны
    131            ST_DEF(DMA_AES_DW, IRQMASK, 0x00); // Запрещаем генерировать перывания
    132            ST_DEF(DMA_AES_DW, DESTINC, 0x00); // Не увеличиваем адресс назначения
    133            ST_DEF(DMA_AES_DW, SRCINC, 0x01); // Увеличиваем адресс источника
    134            ST_DEF(DMA_AES_DW, TRIG, ENC_DW); // Тригер по загрузке
    135            ST_DEF(DMA_AES_DW, WORDSIZE, 0x00); // Копируем по 1 байту
    136            ST_DEF(DMA_AES_DW, TMODE, 0x01); //  Блочное копирование по тригеру
    137            ST_DEF(DMA_AES_DW, VLEN, 0x00); //  Количество байт определяет поле LEN  
    138            ST_DEF(DMA_AES_DW, LENH, 0x00); 
    139            
    140            ST_DEF(DMA_AES_UP, SRCADDRH, 0x70); // Читаем данные из X_ENCDO  
    141            ST_DEF(DMA_AES_UP, SRCADDRL, 0xB2);  
    142            ST_DEF(DMA_AES_UP, PRIORITY, 0x00); // Низкий приоритет
    143            ST_DEF(DMA_AES_UP, M8, 0x00); // Используем 8 бит для счетика длинны
    144            ST_DEF(DMA_AES_UP, IRQMASK, 0x00); // Запрещаем генерировать перывания
    145            ST_DEF(DMA_AES_UP, DESTINC, 0x01); // Увеличиваем адресс назначения
    146            ST_DEF(DMA_AES_UP, SRCINC, 0x00); // Не увеличиваем адресс источника
    147            ST_DEF(DMA_AES_UP, TRIG, ENC_UP); // Тригер по выгрузке
    148            ST_DEF(DMA_AES_UP, WORDSIZE, 0x00); // Копируем по 1 байту
    149            ST_DEF(DMA_AES_UP, TMODE, 0x01); //  Блочное копирование по тригеру
    150            ST_DEF(DMA_AES_UP, VLEN, 0x00); //  Количество байт определяет поле LEN  
    151            ST_DEF(DMA_AES_UP, LENH, 0x00); 
    152          }
    153          
    154          /**
    155          @brief Шифрует/дешифрует поток данных во время радиопередачи. Без проверки MIC
    156          @param[in] enc_mode Режим работы процедуры. true - шифрование.
    157          @param[in] src Указатель на данные подлежащии шифрованию
    158          @param[in] dst Указтель куда будут помещены зашифрованные данные
    159          @param[in] key Указатье на ключ. 16 байт
    160          @param[in] iv  Указатель на вектор иницилизации. 16 байт 
    161          @param[in] len Длинна данных
    162          */
    163          void AES_StreamCoder(bool enc_mode, uint8_t *src, uint8_t *dst, uint8_t *key,
    164                                   uint8_t *iv, uint8_t len)
    165          {
    166            // Установим метод кодироваения
    167            AES_SET_MODE(STREAM_ENC_MODE);
    168              
    169            // Загружаем ключ
    170            AES_SET_OPERATION(AES_LOAD_KEY);
    171            ST_DEF(DMA_AES_DW, SRCADDRL, LADDR(key));
    172            ST_DEF(DMA_AES_DW, SRCADDRH, HADDR(key));
    173            ST_DEF(DMA_AES_DW, LENL, 16);
    174            DMAARM |= 0x01;
    175            AES_START();
    176            while (DMAARM);
    177          
    178            // Загружаем IV
    179            AES_SET_OPERATION(AES_LOAD_IV);
    180            ST_DEF(DMA_AES_DW, SRCADDRL, LADDR(iv));
    181            ST_DEF(DMA_AES_DW, SRCADDRH, HADDR(iv));
    182            ST_DEF(DMA_AES_DW, LENL, 16);
    183            DMAARM |= 0x01;
    184            AES_START();
    185            while (DMAARM);
    186          
    187            // Установим необходимую операцию AES
    188            if (enc_mode) 
    189              AES_SET_OPERATION(AES_ENCRYPT)
    190            else 
    191              AES_SET_OPERATION(AES_DECRYPT)
    192            
    193            switch(STREAM_ENC_MODE) 
    194            {
    195            case AES_MODE_ECB: // ECB, CBC не реализованы
    196            case AES_MODE_CBC:
    197              break;
    198            case AES_MODE_CFB:
    199            case AES_MODE_OFB:
    200            case AES_MODE_CTR:
    201              {
    202                // Загрузка блоками по 128 бит с разделением на под-блоки по 32 бита
    203                uint8_t nbrBlocks = len / 16; // Количество целых блоков по 128 бит
    204                uint8_t ptr, sub_ptr; // Смещение
    205                uint8_t *download, *upload;
    206                
    207                // Для этих типов шифрования длина блоков по 4 байта
    208                ST_DEF(DMA_AES_DW, LENL, 4);
    209                ST_DEF(DMA_AES_UP, LENL, 4);
    210                
    211                // Шифруем все целые блоки
    212                for (uint8_t block = 0; block < nbrBlocks; block ++)
    213                {
    214                  ptr = 16 * block;
    215                  AES_START();
    216                  for (uint8_t j = 0; j < 4; j++)
    217                  {
    218                    sub_ptr = ptr + 4*j;
    219                    download = &src[sub_ptr];
    220                    upload = &dst[sub_ptr];
    221                    // Указываем адресс DMA откуда читать данные
    222                    ST_DEF(DMA_AES_DW, SRCADDRL, LADDR(download));
    223                    ST_DEF(DMA_AES_DW, SRCADDRH, HADDR(download));
    224                    // Указываем адрес DMA куда записывать данные          
    225                    ST_DEF(DMA_AES_UP, DSTADDRL, LADDR(upload));
    226                    ST_DEF(DMA_AES_UP, DSTADDRH, HADDR(upload));
    227                    // Активируем DMA
    228                    DMAARM |= 0x03;  
    229                    DMAREQ |= 0x01;
    230                    while (DMAARM);          
    231                  }
    232                }     
    233                // Шифруем последний блок
    234                uint8_t block_len = len % 16; // Размер последнего блока
    235                
    236                // Завершаем работу если блок пустой
    237                if (!block_len)
    238                  return;
    239                
    240                uint8_t padding_block[16]; // Блок заполненый нулями
    241                ptr = 16*nbrBlocks; // Смещение на первый байт последнего блока в src
    242                memset(padding_block, 0x00, sizeof(padding_block)); // Заполняем нулями
    243                memcpy(padding_block, &src[ptr], block_len); // Копируем данные
    244                
    245                AES_START();
    246                for (uint8_t j = 0; j < 4; j++)
    247                  {
    248                    sub_ptr = 4*j;
    249                    download = &padding_block[sub_ptr];
    250                    // Указываем адресс DMA откуда читать данные
    251                    ST_DEF(DMA_AES_DW, SRCADDRL, LADDR(download));
    252                    ST_DEF(DMA_AES_DW, SRCADDRH, HADDR(download));
    253                    // Указываем аддрес DMA куда записывать данные          
    254                    ST_DEF(DMA_AES_UP, DSTADDRL, LADDR(download));
    255                    ST_DEF(DMA_AES_UP, DSTADDRH, HADDR(download));
    256                    // Активируем DMA
    257                    DMAARM |= 0x03;  
    258                    DMAREQ |= 0x01;
    259                    while (DMAARM);
    260                  }
    261                memcpy(&dst[ptr], padding_block, block_len); // Копируем в src
    262                
    263              } //CASE
    264              
    265              break;
    266            } 
    267          }
    268          
    269          /**
    270          @brief Шифрует/дешифрует поток данных во время радиопередачи. Без проверки MIC
    271          @param[in] enc_mode Режим работы процедуры. true - шифрование.
    272          @param[in] src Указатель на данные подлежащии шифрованию
    273          @param[in] dst Указтель куда будут помещены зашифрованные данные
    274          @param[in] key Указатье на ключ. 16 байт
    275          @param[in] iv  Указатель на вектор иницилизации. 16 байт 
    276          @param[in] len Длинна данных
    277          */
    278          static void CTR_enc_decrypt(bool enc_mode, uint8_t *src, uint8_t *dst, uint8_t *key,
    279                                   uint8_t *iv, uint8_t len)
    280          {
    281            // Установим метод кодироваения
    282            AES_SET_MODE(AES_MODE_CTR);
    283            
    284            // Загружаем ключ
    285            AES_SET_OPERATION(AES_LOAD_KEY);
    286            ST_DEF(DMA_AES_DW, SRCADDRL, LADDR(key));
    287            ST_DEF(DMA_AES_DW, SRCADDRH, HADDR(key));
    288            ST_DEF(DMA_AES_DW, LENL, 16);
    289            DMAARM |= 0x01;
    290            AES_START();
    291            while (DMAARM);
    292          
    293            // Загружаем IV
    294            AES_SET_OPERATION(AES_LOAD_IV);
    295            ST_DEF(DMA_AES_DW, SRCADDRL, LADDR(iv));
    296            ST_DEF(DMA_AES_DW, SRCADDRH, HADDR(iv));
    297            ST_DEF(DMA_AES_DW, LENL, 16);
    298            DMAARM |= 0x01;
    299            AES_START();
    300            while (DMAARM);
    301          
    302            // Установим необходимую операцию AES
    303            if (enc_mode) 
    304              AES_SET_OPERATION(AES_ENCRYPT)
    305            else 
    306              AES_SET_OPERATION(AES_DECRYPT)
    307            
    308            // Загрузка блоками по 128 бит с разделением на под-блоки по 32 бита
    309            uint8_t nbrBlocks = len / 16; // Количество целых блоков по 128 бит
    310            uint8_t ptr, sub_ptr; // Смещение
    311            uint8_t *download, *upload;
    312                
    313            // Для этих типов шифрования длина блоков по 4 байта
    314            ST_DEF(DMA_AES_DW, LENL, 4);
    315            ST_DEF(DMA_AES_UP, LENL, 4);
    316                
    317            // Шифруем все целые блоки
    318            for (uint8_t block = 0; block < nbrBlocks; block ++)
    319              {
    320                ptr = 16 * block;
    321                AES_START();
    322                for (uint8_t j = 0; j < 4; j++)
    323                  {
    324                    sub_ptr = ptr + 4*j;
    325                    download = &src[sub_ptr];
    326                    upload = &dst[sub_ptr];
    327                    // Указываем адресс DMA откуда читать данные
    328                    ST_DEF(DMA_AES_DW, SRCADDRL, LADDR(download));
    329                    ST_DEF(DMA_AES_DW, SRCADDRH, HADDR(download));
    330                    // Указываем адрес DMA куда записывать данные          
    331                    ST_DEF(DMA_AES_UP, DSTADDRL, LADDR(upload));
    332                    ST_DEF(DMA_AES_UP, DSTADDRH, HADDR(upload));
    333                    // Активируем DMA
    334                    DMAARM |= 0x03;  
    335                    DMAREQ |= 0x01;
    336                    while (DMAARM);          
    337                  }
    338              }     
    339              // Шифруем последний блок
    340              uint8_t block_len = len % 16; // Размер последнего блока
    341                
    342              // Завершаем работу если блок пустой
    343              if (!block_len)
    344                return;
    345                
    346              uint8_t padding_block[16]; // Блок заполненый нулями
    347              ptr = 16*nbrBlocks; // Смещение на первый байт последнего блока в src
    348              memset(padding_block, 0x00, sizeof(padding_block)); // Заполняем нулями
    349              memcpy(padding_block, &src[ptr], block_len); // Копируем данные
    350                
    351              AES_START();
    352              for (uint8_t j = 0; j < 4; j++)
    353                {
    354                  sub_ptr = 4*j;
    355                  download = &padding_block[sub_ptr];
    356                  // Указываем адресс DMA откуда читать данные
    357                  ST_DEF(DMA_AES_DW, SRCADDRL, LADDR(download));
    358                  ST_DEF(DMA_AES_DW, SRCADDRH, HADDR(download));
    359                  // Указываем аддрес DMA куда записывать данные          
    360                  ST_DEF(DMA_AES_UP, DSTADDRL, LADDR(download));
    361                  ST_DEF(DMA_AES_UP, DSTADDRH, HADDR(download));
    362                  // Активируем DMA
    363                  DMAARM |= 0x03;  
    364                  DMAREQ |= 0x01;
    365                  while (DMAARM);
    366                }
    367              memcpy(&dst[ptr], padding_block, block_len); // Копируем в src
    368          }
    369          
    370          /**
    371          @brief Зашифровывает buf в режиме CBC-MAC с IV = 0
    372          @param[in] len улинна последовательности для вычисления MAC
    373          @param[out] mac указатель на память куда будет записан mac (до 16 байт)
    374          */
    375          static void CBCMAC_buf_encrypt(uint8_t len, uint8_t *key, uint8_t *mac)
    376          {
    377            uint8_t IV[16];
    378            
    379            // Заполняем вектор нулями
    380            memset(IV, 0x00, sizeof(IV));
    381            
    382            // Установим метод кодироваения
    383            AES_SET_MODE(AES_MODE_CBCMAC);  
    384            
    385            { // Сворачиваем код для улучшения чтения
    386            // Загружаем ключ
    387            AES_SET_OPERATION(AES_LOAD_KEY);
    388            ST_DEF(DMA_AES_DW, SRCADDRL, LADDR(key));
    389            ST_DEF(DMA_AES_DW, SRCADDRH, HADDR(key));
    390            ST_DEF(DMA_AES_DW, LENL, 16);
    391            DMAARM |= 0x01;
    392            AES_START();
    393            while (DMAARM);
    394          
    395            // Загружаем IV
    396            AES_SET_OPERATION(AES_LOAD_IV);
    397            ST_DEF(DMA_AES_DW, SRCADDRL, LADDR(IV));
    398            ST_DEF(DMA_AES_DW, SRCADDRH, HADDR(IV));
    399            ST_DEF(DMA_AES_DW, LENL, 16);
    400            DMAARM |= 0x01;
    401            AES_START();
    402            while (DMAARM);
    403            };
    404            
    405            // Устанавливаем операцию шифрования
    406            AES_SET_OPERATION(AES_ENCRYPT);
    407            
    408            // Загрузка блоками по 128 бит
    409            uint8_t nbrBlocks = len / 16; // Количество целых блоков по 128 бит
    410            uint8_t block_len = len % 16; // Размер последнего блока
    411            uint8_t ptr; // Смещение
    412                
    413            // Для этого типа шифрования длина блоков по 16 байт
    414            ST_DEF(DMA_AES_DW, LENL, 16);
    415            // Устанавливаем куда будем выгружать вычисленный MAC
    416            ST_DEF(DMA_AES_UP, DSTADDRL, LADDR(mac));
    417            ST_DEF(DMA_AES_UP, DSTADDRH, HADDR(mac));
    418            ST_DEF(DMA_AES_UP, LENL, 16);
    419            
    420            // Шифруем все целые блоки
    421            for (uint8_t block = 0; block < nbrBlocks; block ++)
    422              {
    423                // Последний блок шифруем в режиме CBC при условии что нет блок не 
    424                // кратного 16 байтам.
    425                if (!block_len && (block == nbrBlocks - 1))
    426                  AES_SET_MODE(AES_MODE_CBC);
    427                    
    428                ptr = 16 * block;
    429                while(!AES_RDY());
    430                AES_START();
    431                // Указываем адресс DMA откуда читать данные
    432                ST_DEF(DMA_AES_DW, SRCADDRL, LADDR(buf[ptr]));
    433                ST_DEF(DMA_AES_DW, SRCADDRH, HADDR(buf[ptr]));
    434                // Активируем DMA
    435                DMAARM |= 0x01;  
    436                // Активируем выгрузку только последнего блока
    437                if (!block_len && (block == nbrBlocks - 1))
    438                  DMAARM = 0x03;
    439                
    440                DMAREQ |= 0x01;
    441                while (DMAARM);          
    442               }
    443                 
    444            // Шифруем последний блок в режиме CBC
    445            AES_SET_MODE(AES_MODE_CBC);
    446                    
    447            // Завершаем работу если блок пустой
    448            if (!block_len)
    449              return;
    450                
    451            uint8_t padding_block[16]; // Блок заполненый нулями
    452            ptr = 16*nbrBlocks; // Смещение на первый байт последнего блока в src
    453            memset(padding_block, 0x00, sizeof(padding_block)); // Заполняем нулями
    454            memcpy(padding_block, &buf[ptr], block_len); // Копируем данные
    455                
    456            while(!AES_RDY());
    457            AES_START();
    458            // Указываем адресс DMA откуда читать данные
    459            ST_DEF(DMA_AES_DW, SRCADDRL, LADDR(padding_block));
    460            ST_DEF(DMA_AES_DW, SRCADDRH, HADDR(padding_block));
    461            // Активируем DMA и выгрузку MAC
    462            DMAARM |= 0x03;  
    463            DMAREQ |= 0x01;
    464            while (DMAARM);
    465          }
    466          
    467          static inline uint8_t generateAuthData(uint8_t *src, uint8_t *nonce, uint8_t c,
    468                                                 uint8_t f, uint8_t lm)
    469          {
    470            memcpy(buf, nonce,16);
    471            
    472            // Буфер от 0 до 15 байта специальный блок B0
    473            // Настраиваем флаг. У нас длинна 2 байта. nonce 13 байт => L_M = L-1=0x01
    474            buf[0]=  0x01;  
    475            // Если есть данные для авторизации установим A_Data 
    476            if (f > 0)
    477              buf[0] |= 0x40;
    478            
    479            buf[0] |= ((lm - 2) / 2 ) << 3;   // см. документацию M'= (lm-2) / 2;
    480            
    481            // Устанавливаем длинну сообщения
    482            buf[14] = 0x00;
    483            buf[15] = c;
    484            
    485            // Добавляем строку авторизации L(a). если данных нет, то она пустая. f=0
    486            buf[16]= 0;
    487            buf[17]= f;
    488            
    489            // Копируем данные авторизации в буфер
    490            memcpy(&buf[18], src, f);
    491            
    492            // Смещение на следующий байт после данных авторизации.
    493            // Данные авторизации занимают положение в буфере [18, 18+f]
    494            uint8_t ptr_end= 18 + f;
    495            // Заполняем нулями до границы 16 байт  
    496            while (ptr_end & 0x0f)
    497              buf[ptr_end++] = 0x00;
    498            
    499            // Копируем данные для шифрования в буфер после нулей
    500            memcpy(&buf[ptr_end], &src[f], c);
    501            
    502            // Возвращаем размер данных в буфере
    503            return ptr_end+c;
    504          };
    505          
    506          /**
    507          @brief Шифрует/дешифрует данные с проверкой MIC
    508          @param[in] src Указатель на данные подлежащии шифрованию
    509          @param[in] len Размер данных
    510          @param[in] с Количество байт для шифрования
    511          @param[in] f Количество байт для авторизации
    512          @param[in] m Размер MIC (m=1,2,3 l(m) = 4,8,16 байт)
    513          @param[in] iv  Указатель на вектор иницилизации. 16 байт 
    514          @param[in] len Длинна данных
    515          @param[in,out] MIC Указатель на массив соответсвующий длинне (4,8,16 байт)
    516          */
    517          void AES_CCMEncrypt( uint8_t *src, uint8_t c, uint8_t f, uint8_t m,
    518                              uint8_t *key, uint8_t *nonce, uint8_t *MIC)
    519          {
    520            uint8_t lm = MIC_2_MICLEN(m);
    521            
    522            // Генерируем данные для авторизации
    523            uint8_t dlen = generateAuthData(src, nonce, c, f, lm);
    524            
    525            uint8_t mac[16]; // Сюда пишем мак
    526            CBCMAC_buf_encrypt(dlen, key, mac);
    527            
    528            // Шифруем MAC
    529            uint8_t CTR_IV[16];
    530            memcpy(CTR_IV, nonce, 16);
    531            CTR_IV[0] = 0x01; // Флаг режима CTR
    532            CTR_IV[15] = 0;   // Значение счетчика
    533            CTR_enc_decrypt(true, mac, mac, key, CTR_IV, 16);
    534            
    535            // Шифруем текст. он имеет размер 'c' и находится в буфере начиная с
    536            // dlen-c, dlen
    537            uint8_t ds = dlen - c; // Начало данных для шифрования
    538            
    539            // 0x0F & (16 - (dlen & 0x0f)) оставляет числа от 0 до 15  
    540            memset(buf+dlen, 0x00, 0x0F & (16 - (dlen & 0x0f)) ); // Дополняем нулями
    541            CTR_IV[15] = 1; // Счетчик CTR
    542            CTR_enc_decrypt(true, &buf[ds], &buf[ds], key, CTR_IV, c); // Шифруем
    543            
    544            // Заполняем буфер буфер src. src[0,f] это данные авторизации. 
    545            // src[f, f+c] это шифрованные данные.
    546            memcpy(&src[f], &buf[ds], c); 
    547            memcpy(MIC, mac, lm);
    548            
    549            //https://github.com/zhaohengyi/CC2530Example/blob/
    550            //master/source/components/radios/cc2530/hal_rf_security.c
    551          }
    552          
    553          /**
    554          @brief Дешифрует данные с проверкой MIC
    555          @param[in] src Указатель на данные подлежащии шифрованию
    556          @param[in] len Размер данных
    557          @param[in] с Количество байт для шифрования
    558          @param[in] f Количество байт для авторизации
    559          @param[in] m Размер MIC (m=1,2,3 l(m) = 4,8,16 байт)
    560          @param[in] iv  Указатель на вектор иницилизации. 16 байт 
    561          @param[in] len Длинна данных
    562          @param[in,out] MIC Указатель на массив соответсвующий длинне (4,8,16 байт)
    563          */
    564          bool AES_CCMDecrypt( uint8_t *src, uint8_t c, uint8_t f, uint8_t m,
    565                              uint8_t *key, uint8_t *nonce, uint8_t *MIC)
    566          {
    567            uint8_t lm = MIC_2_MICLEN(m);
    568            
    569            // Расшифровываем MAC
    570            uint8_t mac[16]; // Расшифрованый мак
    571            uint8_t CTR_IV[16];
    572            memcpy(CTR_IV, nonce, 16);
    573            CTR_IV[0] = 0x01; // Флаг режима CTR
    574            CTR_IV[15] = 0;   // Значение счетчика
    575            CTR_enc_decrypt(false, MIC, mac, key, CTR_IV, lm);  
    576            
    577            // Генерируем данные для авторизации
    578            uint8_t dlen = generateAuthData(src, nonce, c, f, lm);
    579            
    580            // Дешифруем текст. он имеет размер 'c' и находится в буфере начиная с
    581            // dlen-c, dlen
    582            uint8_t ds = dlen - c; // Начало данных для дешифрования
    583            
    584            // 0x0F & (16 - (dlen & 0x0f)) оставляет числа от 0 до 15  
    585            memset(buf+dlen, 0x00, 0x0F & (16 - (dlen & 0x0f)) ); // Дополняем нулями
    586            CTR_IV[15] = 1; // Счетчик CTR
    587            CTR_enc_decrypt(false, &buf[ds], &buf[ds], key, CTR_IV, c); // Дешифруем
    588            
    589            uint8_t new_mac[16]; // мак полученный в ходе рашифровки сообщения
    590            CBCMAC_buf_encrypt(dlen, key, new_mac);
    591            
    592            // Проверяем что маки совпадают, значит дешифровано верно
    593            bool mac_equal = true;
    594            for (uint8_t i = 0 ; i < lm ; i++)
    595            {
    596              if (mac[i] != new_mac[i])
    597              mac_equal = false;
    598              break;
    599            }
    600            
    601            // Выходим если MACи не совпали  
    602            if (!mac_equal)
    603              return false;
    604            
    605            // Копируем  расшифрованные данные
    606            memcpy(&src[f], &buf[ds], c); 
    607            return true;
    608          }
\\vmware-host\Shared Folders\Projects\WMNU\IAR\SHARE_PRJ_SRC\delays.c
      1          /*!
      2          \file  Модуль измерения интервалов времени и функция задержки времени
      3          \brief Функции измерения времени и задержки
      4          */
      5          
      6          #include "ioCC2530.h"
      7          #include "delays.h"
      8          #include "string.h"
      9          
     10          #define TICK_NS  31.25 // Количество нс в одном такте TIM2
     11          #define TICK_US  0.03125 // Количество мкс в одном такте TIM2
     12          #define TICK_PER_US 32 // Количество тактов в одной микросекунде
     13          
     14          // Максимальное кол-во тактов таймера. Константа 40 бит, 5 байт
     15          static const uint32_t MAC_TIMER_MAX = 0xFFFFFFFFUL; 
     16          static uint32_t DELAY_CALIBRATE_TICS; // Колибровка функции задержки
     17          
     18          // Публичные методы
     19          void TIM_init(void);
     20          void TIM_TimeStamp(TimeStamp_s* timestamp);
     21          void TIM_delay(uint32_t delay);
     22          uint32_t TIM_passedTime(TimeStamp_s* start, TimeStamp_s* stop);
     23          void TIM_copy(TimeStamp_s *src, TimeStamp_s *dst);
     24          
     25          // Приватные
     26          static inline uint32_t Interval(TimeStamp_s* start, TimeStamp_s* stop);
     27          static void DelayCalibrate(void);
     28          
     29          /**
     30          @brief Иницилизация таймера
     31          @brief Используется таймер 2. MAC таймер
     32          */
     33          void TIM_init(void)
     34          {
     35            // Запускаем таймер, LATCH MODE = 1
     36            // Latch mode фиксирует значение таймера переполнения при чтении T2M0
     37            // ЗАпускаем MAC таймер без синхронизации с кварцем 32.768к
     38            T2CTRL = (1<<0) | (1<<3); 
     39            // Калибровка функции задержки
     40            DelayCalibrate();
     41          }
     42          
     43          /**
     44          @brief Возвращает временую метку.
     45          @params[out] timestamp указатель на временную метку 
     46          */
     47          void TIM_TimeStamp(TimeStamp_s* timestamp)
     48          {
     49            timestamp->byte[0] = T2M0;
     50            timestamp->byte[1] = T2M1;
     51            timestamp->byte[2] = T2MOVF0;
     52            timestamp->byte[3] = T2MOVF1;
     53          }
     54          
     55          /**
     56          @brief Калибровка функции задержки TIM_delay
     57          */
     58          static void DelayCalibrate(void)
     59          {
     60            #define ACCURATE_VAL_US 500 
     61            DELAY_CALIBRATE_TICS = 0;
     62            TimeStamp_s start, stop;
     63            uint32_t passed, cal;
     64            
     65            TIM_TimeStamp(&start);
     66            TIM_delay(ACCURATE_VAL_US);
     67            TIM_TimeStamp(&stop);
     68            passed = TIM_passedTime(&start, &stop);
     69            
     70            cal = passed - ACCURATE_VAL_US;
     71            DELAY_CALIBRATE_TICS = cal * TICK_PER_US; 
     72          };
     73          
     74          /**
     75          @brief Вычисляет количество тактов между двумя времеными метками
     76          @return Количество тактов
     77          */
     78          static inline uint32_t Interval(TimeStamp_s* start, TimeStamp_s* stop)
     79          {
     80            uint32_t ret;
     81          
     82            if (stop->timer >= start->timer)
     83              ret = stop->timer - start->timer;
     84            else
     85            { 
     86              ret = (MAC_TIMER_MAX - start->timer) + stop->timer;
     87            }
     88            return ret;
     89          }
     90          
     91          /**
     92          @brief Вычисляет прошедшее время между двумя времеными метками
     93          @return Время в мкс.
     94          */
     95          uint32_t TIM_passedTime(TimeStamp_s* start, TimeStamp_s* stop)
     96          {
     97            uint32_t ret = Interval(start, stop);
     98            
     99            ret = (uint32_t)((float)ret * TICK_US);
    100            return ret;
    101          }
    102          
    103          /**
    104          @brief Задержка на заданное количество мкс. 
    105          @details Погрешность около 20 мкс при значениях выше 150 мкс.
    106           Рекомендуется использовать для организации задержек не менее 200 мкс.
    107          @params[in] delay количество микросекунд. Не более 134217727 мкс (134.2 сек)
    108          */
    109          void TIM_delay(uint32_t delay)
    110          {
    111            uint32_t passed = 0;
    112            TimeStamp_s start, now;
    113            TIM_TimeStamp(&start);
    114            
    115            // Конвертируем мкс в такты и вносим поправку
    116            delay = delay * TICK_PER_US; 
    117            if (delay > DELAY_CALIBRATE_TICS)
    118              delay -= DELAY_CALIBRATE_TICS;
    119            
    120            do
    121            {
    122              TIM_TimeStamp(&now);
    123              passed = Interval(&start, &now);
    124            } while (passed < delay);
    125          }
    126          
    127          /**
    128          @brief Копирование временной метки
    129          @param[in] src указатель на исходную метку для копирование
    130          @param[out] dst указатель на метку назначения
    131          */
    132          void TIM_copy(TimeStamp_s *src, TimeStamp_s *dst)
    133          {
    134            memcpy(src, dst, sizeof(TimeStamp_s));
    135          }
\\vmware-host\Shared Folders\Projects\WMNU\IAR\SHARE_PRJ_SRC\fbuf.c
      1          /*!
      2          \file Модуль реализует связанные буфера данных
      3          \brief 
      4          */
      5          
      6          #include "fbuf.h"
      7          #include "string.h"
      8          #include "stdlib.h"
      9          #include "Net_frames.h"
     10          #include "nwdebuger.h"
     11          
     12          // Макросы для выравнивания памяти
     13          // На текущий момент выравниевание не используется, так как были ошибки
     14          // в работе макросов.
     15          typedef uint16_t mem_ptr_t;
     16          #define MEM_ALIGNMENT 2 //!< Кратность в байтах для выравнивания памяти
     17          #define MEM_ALIGN_SIZE(size) (((size) + MEM_ALIGNMENT - 1) & ~(MEM_ALIGNMENT-1))
     18          #define MEM_ALIGN(addr) ((void *)(((mem_ptr_t)(addr) + MEM_ALIGNMENT - 1) & ~(mem_ptr_t)(MEM_ALIGNMENT-1)))
     19          
     20          // Доступные методы
     21          fbuf_s* fbuf_create(uint8_t type, void* payload, uint8_t len);
     22          void fbuf_delete(fbuf_s *fb);
     23          void fbuf_chain(fbuf_s *h, fbuf_s *t);
     24          fbuf_s* fbuf_next(fbuf_s *fb);
     25          uint8_t fbuf_getCount(void);
     26          
     27          // Локальные переменные модуля
     28          static uint8_t NBR_BUF = 0; //!< Количество буферов в памяти
     29          
     30          
     31          /**
     32          @brief Создает fbuf указанного типа
     33          @details 
     34          @param type
     35          @param payload
     36          @param len
     37          */
     38          fbuf_s* fbuf_create(uint8_t type, void* payload, uint8_t len)
     39          {
     40            uint8_t req_len;
     41            // Определим длинну данных fbuf
     42            switch (type)
     43            {
     44              case FB_ETH_LAY:
     45                req_len = ETH_LAY_SIZE;
     46                break;
     47              case FB_IP_LAY:
     48                req_len = IP_LAY_SIZE;
     49                break;
     50              case FB_SYNC_LAY:
     51                req_len = SYNC_LAY_SIZE;
     52                break;
     53              case FB_TRANSPORT_LAY:
     54              case FB_RAW_LAY:
     55                req_len = len;
     56                break;
     57            default:
     58              ASSERT_HALT(false, "Incorrect fbuf type");
     59            } 
     60            
     61            // Выделяем память под структуру и данные и выравниваем в памяти
     62            // Выравнивание с помощью макросов приводило к пиздецу.
     63            fbuf_s* fb = (fbuf_s*)malloc(FBUF_S_SIZE + req_len);
     64            ASSERT_HALT(fb != NULL, "No memory");
     65            
     66            memset(fb, 0x77 , FBUF_S_SIZE + req_len);
     67            fb->payload = (uint8_t*)fb + FBUF_S_SIZE;
     68            
     69            // Заполним структуру
     70            fb->type = type;
     71            fb->next = NULL;
     72            fb->len = req_len;
     73            
     74            // Если пользователю нужно разместить сырые данные или транспортный
     75            // уровень, то скопируем данные
     76            if ((type == FB_TRANSPORT_LAY) || (type == FB_RAW_LAY))
     77              memcpy(fb->payload, payload, req_len);
     78            
     79            NBR_BUF++;
     80            return fb;
     81          }
     82          
     83          /**
     84          @brief Получить количество буферов в памяти
     85          @return Возвращает количество буферов
     86          */
     87          uint8_t fbuf_getCount(void)
     88          {
     89            return NBR_BUF;
     90          }
     91          
     92          /**
     93          @brief Удаляем буфер
     94          */
     95          void fbuf_delete(fbuf_s *fb)
     96          {
     97            free(fb);
     98            NBR_BUF--;
     99          }
    100          
    101          /**
    102          @brief Переход к следующему буферу
    103          @return Указатель на следующий буфер или NULL
    104          */
    105          fbuf_s* fbuf_next(fbuf_s *fb)
    106          {
    107            if (fb->next == NULL)
    108              return NULL;
    109            return  fb->next;
    110          }
    111          
    112          /**
    113          @brief Связывает два буфера. Head->Tail
    114          @param[in,out] h head
    115          @param[in] t tail
    116          */
    117          void fbuf_chain(fbuf_s *h, fbuf_s *t)
    118          {
    119            h->next = t;
    120          }
\\vmware-host\Shared Folders\Projects\WMNU\IAR\SHARE_PRJ_SRC\frame.c
      1          /**
      2          @file Модуль описывает сетевой кадр и связанные с ним буферы данных
      3          @brief Типы frame
      4          */
      5          
      6          #include "frame.h"
      7          #include "string.h"
      8          #include "stdlib.h"
      9          #include "Net_frames.h"
     10          #include "nwdebuger.h"
     11          
     12          frame_s* frame_create(void);
     13          void frame_delete(frame_s *fr);
     14          void frame_insert_head(frame_s *fr , fbuf_s *fb);
     15          void frame_insert_tail(frame_s *fr , fbuf_s *fb);
     16          fbuf_s* frame_get_fbuf_head(frame_s *fr);
     17          fbuf_s* frame_get_fbuf_tail(frame_s *fr);
     18          void* frame_merge(frame_s *fr, uint8_t *len);
     19          uint8_t frame_len(frame_s *fr);
     20          uint8_t frame_getCount(void);
     21          
     22          static uint8_t NBR_FRAME = 0; //!< Количество фреймов в памяти
     23          
     24          /**
     25          @brief Получить количество буферов в памяти
     26          @return Возвращает количество буферов
     27          */
     28          uint8_t frame_getCount(void)
     29          {
     30            return NBR_FRAME;
     31          }
     32          
     33          /**
     34          @brief Создание структуры frame
     35          @return Указатель на структуру frame
     36          */
     37          frame_s* frame_create(void)
     38          {
     39              frame_s* fr= (frame_s*)malloc(FRAME_S_SIZE);
     40              ASSERT_HALT(fr != NULL, "No memory");
     41              
     42              fr->head = NULL;
     43              fr->tail = NULL;
     44              memset(&fr->meta, 0x00, META_S_SIZE);
     45              NBR_FRAME++;
     46              return fr;
     47          };
     48          
     49          /**
     50          @brief Удаление frame
     51          @detail Проуедура так же удаляет все связанные с ней буфера fbuf
     52          @param[in] fr указатель на структуру frame
     53          */
     54          void frame_delete(frame_s *fr)
     55          {
     56            fbuf_s *fb = fr->head;
     57            fbuf_s *next = fb;
     58            
     59            // Удаляем все связанные буфера
     60            while (fb != NULL)
     61            {
     62                next = fb->next;
     63                fbuf_delete(fb);
     64                fb = next;
     65            };
     66            
     67            NBR_FRAME--;
     68            free(fr);
     69          }
     70          
     71          /**
     72          @brief Вставить буфер в начало цепочки
     73          @param[in,out] fr указатель на структуру frame
     74          @param[in] fb указатель на буфер для вставки
     75          */
     76          void frame_insert_head(frame_s *fr , fbuf_s *fb)
     77          {
     78            if (fr->head == NULL)
     79            {
     80              fr->head = fb;
     81              fr->tail = fb;
     82              return;
     83            }
     84            
     85            fb->next = fr->head; 
     86            fr->head = fb;
     87          }
     88          
     89          /**
     90          @brief Вставить буфер в конец цепочки
     91          @param[in,out] fr указатель на структуру frame
     92          @param[in] fb указатель на буфер для вставки
     93          */
     94          void frame_insert_tail(frame_s *fr , fbuf_s *fb)
     95          {
     96            ASSERT_HALT(fr != NULL, "No fr");
     97            ASSERT_HALT(fb != NULL, "No fb");
     98            
     99            if (fr->tail == NULL)
    100            {
    101              fr->head = fb;
    102              fr->tail = fb;
    103              return;
    104            }
    105            
    106            fr->tail->next = fb;
    107            fr->tail = fb;
    108          }
    109          
    110          /**
    111          @brief Получить указатель на первый элемент в цепочке
    112          @param[in] fr указатель на структуру frame
    113          @return указатель на первый буфер или NULL
    114          */
    115          fbuf_s* frame_get_fbuf_head(frame_s *fr)
    116          {
    117            return fr->head;
    118          }
    119          
    120          /**
    121          @brief Получить указатель на последний элемент в цепочке
    122          @param[in] fr указатель на структуру frame
    123          @return указатель на последний буфер или NULL
    124          */
    125          fbuf_s* frame_get_fbuf_tail(frame_s *fr)
    126          {
    127            return fr->tail;
    128          }
    129          
    130          /**
    131          @brief Производит слияние всех данных в один массив
    132          @details Данные требуют удаления после использования free(..)
    133          @param[in] fr указатель на frame
    134          @param[out] len длинна результирующего массива данных
    135          @return Указатель на начало данных
    136          */
    137          void* frame_merge(frame_s *fr, uint8_t *len)
    138          {
    139            ASSERT_HALT(fr != NULL, "No fr");
    140            
    141            uint8_t tot_len = frame_len(fr); // Общая длинна данных
    142            *len = tot_len;
    143            
    144            // Выходим если данных нет
    145            if (!tot_len) 
    146              return NULL;
    147            
    148            // Выделяем память
    149            void* mem = malloc(tot_len);
    150            ASSERT_HALT(mem != NULL, "No memory");
    151            
    152            uint8_t *ptr = (uint8_t*)mem;
    153            
    154            // Копируем данные
    155            fbuf_s *fb = fr->head;
    156            while (fb!= NULL)
    157            {
    158              memcpy(ptr, fb->payload, fb->len);
    159              ptr += fb->len;
    160              fb = fb->next;
    161            }
    162            return mem;
    163          }
    164          
    165          /**
    166          @brief Вычисляет размер цепочки fbuf
    167          @param[in] fr указатель на frame_s
    168          @return Количество байт в цепочке буферов
    169          */
    170          uint8_t frame_len(frame_s *fr)
    171          {
    172            uint8_t tot_len = 0;
    173            fbuf_s *fb = fr->head;
    174           
    175            while (fb != NULL)
    176            {
    177              tot_len += fb->len;
    178              fb = fb->next;
    179            }
    180            return tot_len;
    181          }
\\vmware-host\Shared Folders\Projects\WMNU\IAR\SHARE_PRJ_SRC\LLC.c
      1          /**
      2          @file 
      3          @brief Модуль содержит реализацию интерфейса радио для приема/передачи данных.
      4          */
      5          
      6          #include "LLC.h"
      7          #include "MAC.h"
      8          #include "TIC.h"
      9          #include "stdlib.h"
     10          #include "nwdebuger.h"
     11          #include "ioCC2530.h"
     12          
     13          // Публичные методы
     14          void LLC_Init(void);
     15          
     16          // Методы модуля
     17          void LLC_SetRXCallback(void (*fn)(frame_s *fr));
     18          void LLC_TimeAlloc(void (*fn)(void)); 
     19          bool LLC_AddTask(frame_s* fr);
     20          uint8_t LLC_GetTaskLen(void);
     21          
     22          // Закрытые методы
     23          static void LLC_SE_HNDL(uint8_t TS); //!< Обработчик завешения слота TIC
     24          static void LLC_Shelduler(uint8_t TS);
     25          static void LLC_RX_HNDL(frame_s *fr); //!< Обработчик примема пакета
     26          static void LLC_RunTimeAlloc(void);
     27          
     28          // Переменные модуля
     29          #define UNICAST_SEND_ATEMPTS 5 //!< Количество попыток передачи пакета 
     30          #define MAX_nbrTASKS 20 //!< Максимальное количество задач в очередях
     31          
     32          typedef struct LLCTask LLCTask;
     33          typedef struct TimeAllocFunc TimeAllocFunc;
     34          static bool tasksBLOCK; //!< блокировка доступа к LLCTask
     35          
     36          /**
     37          @brief Описание задачи модуля LLC
     38          */
     39          struct LLCTask
     40          {
     41            LLCTask *next; //!< Указатель на следующую задачу. NULL - конец очереди
     42            uint8_t TS; //!< Номер временого канала для передачи сообщения
     43            uint8_t CH; //!< Номера радиоканала для передачи сообщения
     44            frame_s *fr; //!< Указатель на данные для передачи
     45          };
     46          
     47          /**
     48          @brief Список функций вызываемых по завешению временного слота
     49          */
     50          struct TimeAllocFunc
     51          {
     52            TimeAllocFunc *next; //!< Указатель на следующую функцию. NULL - конец списка
     53            void (*fn)(void); //!< Указатель на функцию. NULL - нет обработчика
     54          };
     55          
     56          static LLCTask *FirstTask; //!< Указатель на первый элемент очереди задач
     57          static uint8_t nbrTasks; // Количество задач в очереди
     58          
     59          /**
     60          @brief Обратный вызов при приеме пакета данных
     61          */
     62          static void (*RXCallback)(frame_s *fr);
     63          
     64          /**
     65          @brief Первый элемент обработчика конца временного слота
     66          @details Элемент создается статически, все остальные задачи создаются malloc
     67          и добавляются к HeadAllocFunc.
     68          */
     69          static TimeAllocFunc HeadAllocFunc;
     70          
     71          /**
     72          @brief Инициализация модуля
     73          @detail Иницилизирует MAC
     74          */
     75          void LLC_Init(void)
     76          {  
     77            MAC_Init();
     78            nbrTasks = 0; 
     79            tasksBLOCK = false;
     80            FirstTask = NULL;
     81            // TODO Очистить очередь HeadTask
     82            // Регистрируем обработчики
     83            TIC_SetSECallback(LLC_SE_HNDL); // Завершение временного слота
     84            MAC_SetRXCallback(LLC_RX_HNDL); // Принято сообщение
     85          }
     86          
     87          /**
     88          @brief Количество задач в очереди
     89          @return количество задач в очереди
     90          */
     91          uint8_t LLC_GetTaskLen(void)
     92          {
     93            return nbrTasks;
     94          }
     95          
     96          void LLC_SetRXCallback(void (*fn)(frame_s *fr))
     97          {
     98            ASSERT_HALT(fn != NULL, "NULL pointer not allow");
     99            RXCallback = fn;
    100          }
    101          
    102          /**
    103          @brief Добавляет обработчик заверешения временого слота в список
    104          */
    105          void LLC_TimeAlloc(void (*fn)(void))
    106          {
    107            TimeAllocFunc *ta = malloc(sizeof(TimeAllocFunc));
    108            ASSERT_HALT(ta != NULL, "Memory allocation fails");
    109            ta->next = NULL;
    110            ta->fn = fn;
    111          
    112            // Перебираемся в конец списка
    113            TimeAllocFunc *next = &HeadAllocFunc;
    114            while (next->next != NULL)
    115              next = next->next;
    116            
    117            // Добавляем новый элемент
    118            next->next = ta;
    119          };
    120          
    121          /**
    122          @brief Добавляем задачу в очередь
    123          @brief Взовращает true если задача добавлена в очередь. false, если размер 
    124           очереди достиг максимального размера.
    125          */
    126          bool LLC_AddTask(frame_s* fr)
    127          {
    128             ASSERT_HALT(fr != NULL, "fr NULL");
    129           
    130              if (nbrTasks == MAX_nbrTASKS)
    131                return false;
    132              
    133             // Ждем пока разбокируется доступ.
    134             while (tasksBLOCK);
    135             tasksBLOCK = true;
    136             
    137             // Создаем новую задачу
    138             EA=0;
    139             LLCTask *new_task = (LLCTask*)malloc(sizeof(LLCTask));
    140             EA=1;
    141             ASSERT_HALT(new_task !=NULL, "LLC malloc for new_task"); 
    142                
    143             new_task->TS = fr->meta.TS;
    144             new_task->CH = fr->meta.CH;
    145             new_task->fr = fr;
    146             
    147            LOG(MSG_ON | MSG_INFO | MSG_TRACE, "Add task = %u, CH = %d, TS = %d, OTS = %d. fr = %d\r\n",
    148                (uint16_t)new_task,new_task->CH, new_task->TS, fr->meta.TS, (uint16_t)fr);
    149            
    150             // Если в очереди нет задач, добавим первую
    151             if (FirstTask == NULL) 
    152             {
    153               new_task->next = NULL;
    154               FirstTask = new_task;
    155             }
    156             // Если в очереди были задачи то вставим новую в голову списка
    157             else 
    158             {
    159               new_task->next = FirstTask;
    160               FirstTask = new_task;  
    161             }
    162             
    163             nbrTasks ++;
    164             tasksBLOCK = false;
    165             return true;
    166          }
    167          
    168          /**
    169          @brief Планировщик задач
    170          @details Соотносит задачи в очереди и свободные временные слоты MAC уровня.
    171          При освобождении временных слотов, планировщик устанавливает данные для 
    172          передачи в MAC.
    173          @param[in] TS номер текущего временого слота
    174          */
    175          static void LLC_Shelduler(uint8_t TS)
    176          {
    177            // Если работает функция добавления задачи, то обслуживание очереди не
    178            // производится. Это может привести к необычным последствиям
    179            if (tasksBLOCK)
    180              return;
    181            
    182            tasksBLOCK = true;
    183            // Перебираем попорядку весь список на отправку
    184            // HeadTask только указатель на первый элемент, сам он не подлежит отправке
    185            LLCTask *task = FirstTask;
    186            LLCTask *last = FirstTask;
    187            LLCTask *next = FirstTask;
    188            
    189            while (task != NULL)
    190            {    
    191              
    192              if (MAC_GetTXState(task->TS)) // Занят ли временой слот
    193              {
    194                // Если слот занят переходим к следующей задаче
    195                last = task;
    196                task = task->next;
    197                continue; 
    198              }
    199              
    200              MAC_Send(task->fr, UNICAST_SEND_ATEMPTS);
    201              
    202              next = task->next; // Запомним следующую задачу
    203              
    204              // Удаляем текущую задачу из списка
    205              if (task == FirstTask)
    206              {
    207              // Удаляемым элементом является указателем на голову
    208                 FirstTask = next;
    209                 last = FirstTask;
    210              }
    211              else
    212              {
    213                // Удаляемым элементом является промежуточный элемент
    214                last->next = next;
    215              }
    216              
    217              nbrTasks--;
    218              LOG(MSG_OFF | MSG_INFO | MSG_TRACE, "Free task = %u, nbrTasks = %d\r\n",
    219                  (uint16_t)task, nbrTasks); 
    220              free(task);
    221              task = next;
    222            }
    223            
    224            tasksBLOCK = false;
    225          }
    226          
    227          /**
    228          @brief Обработчик заверешния временого слота
    229          @details Обратный вызов из TIC. Обработчик вызывает планировщик задач очереди
    230          и передает управление зарегистрированым функциям с помощью LLC_TimeAlloc.
    231          @param[in] TS номер завершенного временого слота
    232          */
    233          static void LLC_SE_HNDL(uint8_t TS)
    234          {
    235            LLC_Shelduler(TS);
    236            LLC_RunTimeAlloc();
    237          }
    238          
    239          static void LLC_RX_HNDL(frame_s *fr)
    240          {
    241            ASSERT_HALT(RXCallback !=NULL, "RXCallback func NULL");
    242            RXCallback(fr);
    243          }
    244          
    245          /**
    246          @brief Передаем управление зарегистрированным функциям
    247          */
    248          static void LLC_RunTimeAlloc(void)
    249          {
    250              TimeAllocFunc *next = &HeadAllocFunc;
    251            // HeadAllocFunc служит только для указания на первый элемент в очереди
    252            // так что его нужно пропустить и переходить сразу к next
    253            while (next->next != NULL)
    254            {
    255              next->next->fn();
    256              next = next->next;
    257            }
    258          }
\\vmware-host\Shared Folders\Projects\WMNU\IAR\SHARE_PRJ_SRC\MAC.c
      1          #include "MAC.h"
      2          #include "frame.h"
      3          #include "string.h"
      4          #include "nwdebuger.h"
      5          #include "coder.h"
      6          #include "TIC.h"
      7          
      8          // Обработчики прерываний
      9          static void MAC_RX_HNDL(uint8_t TS);
     10          static void MAC_TX_HNDL(uint8_t TS);
     11          static void (*RXCallback)(frame_s *fr);
     12          bool (*isACK_OK)(frame_s *fr, frame_s *fr_ack);
     13          
     14          // Публичные методы
     15          void MAC_Init(void);
     16          void MAC_OpenRXSlot(uint8_t TS, uint8_t CH);
     17          void MAC_CloseRXSlot(uint8_t TS);
     18          void MAC_Send(frame_s *fr, uint8_t attempts);
     19          bool MAC_ACK_Send(frame_s *fr);
     20          void MAC_SetRXCallback(void (*fn)(frame_s *fr));
     21          void MAC_Set_isACK_OK_Callback(bool(*fn)(frame_s *fr, frame_s *fr_ack));
     22          bool MAC_GetTXState(uint8_t TS);
     23          bool MAC_GetRXState(uint8_t TS);
     24          
     25          // Ключ потокового шифрования и вектор иницилизации
     26          uint8_t KEY[16] = {18,11,12,13,14,15,16,17,10,11,12,13,14,15,16,17};
     27          uint8_t IV[16] = {18,11,12,13,14,15,16,17,10,11,12,13,14,15,16,17};
     28            
     29          #define RECV_TIMEOUT 3000UL // Время ожидания приема пакета в мкс
     30          #define ACK_RECV_TIMEOUT 1000UL // Время ожидания приема подтверждения в мкс
     31          // Задержка перед приемом ACK в мкс если данные шифруются
     32          #define DELAY_BEFORE_ACK_RECV_CRYPT 2000UL 
     33          // Задержка перед приемом ACK в мкс если данные не шифруются
     34          #define DELAY_BEFORE_ACK_RECV_NOCRYPT 1000UL
     35          
     36          #define RARIO_STREAM_ENCRYPT false // Шифрование данных включенно 
     37          
     38          typedef struct
     39          {
     40           struct 
     41           {
     42             bool enable;
     43             uint8_t attempts;
     44             uint8_t CH;
     45             frame_s *fr;
     46           } __attribute__((packed)) TX;
     47           
     48           struct
     49           {
     50            bool enable; 
     51            uint8_t CH;
     52           } __attribute__((packed)) RX;
     53          } __attribute__((packed)) MACSState_s; 
     54          
     55          
     56          // Таблица состояний слотов приема/передачи
     57          MACSState_s MACSlotTable[50];
     58          
     59          
     60          /**
     61          @brief Установка обработчика функции  isACK_OK
     62          @param[in] fn(frame_s *fr, frame_s *fr_ack) указатель на функцию
     63          */
     64          void MAC_Set_isACK_OK_Callback(bool(*fn)(frame_s *fr, frame_s *fr_ack))
     65          {
     66            isACK_OK = fn;
     67          }
     68          
     69          /**
     70          @brief Иницилизация MAC
     71          @detail Инизилизирует TIM, TIC, RI, AES
     72          */
     73          void MAC_Init(void)
     74          {
     75            TIM_init();
     76            TIC_Init();
     77            RI_init();
     78            AES_init();
     79            
     80            TIC_SetRXCallback(MAC_RX_HNDL);
     81            TIC_SetTXCallback(MAC_TX_HNDL);
     82            RI_StreamCrypt(RARIO_STREAM_ENCRYPT);
     83            RI_setKEY(KEY);
     84            RI_setIV(IV);  
     85            memset(MACSlotTable, 0x00, 50*sizeof(MACSState_s));
     86          }
     87          
     88          /**
     89          @brief Открыть временой слот приема данных
     90          @param[in] TS номер слота от 0 до 49
     91          @param[in] CH номер радиоканала
     92          */
     93          void MAC_OpenRXSlot(uint8_t TS, uint8_t CH)
     94          {
     95              ASSERT_HALT(TS < 50, "Incorrect TS");
     96              MACSlotTable[TS].RX.enable = true;
     97              MACSlotTable[TS].RX.CH = CH;
     98              TIC_SetRXState(TS, true);
     99          }
    100          
    101          /**
    102          @brief Закрыть временой слот приема данных
    103          @param[in] TS номер слота от 0 до 49
    104          */
    105          void MAC_CloseRXSlot(uint8_t TS)
    106          {
    107            ASSERT_HALT(TS < 50, "Incorrect TS");
    108            MACSlotTable[TS].RX.enable = false;
    109            TIC_SetRXState(TS, false);
    110          }
    111          
    112          /**
    113          @brief Поставить пакет в таблицу отправки сообщений
    114          @param[in] fr указатель на пакет
    115          @param[in] attempts количество попыток
    116          */
    117          void MAC_Send(frame_s *fr, uint8_t attempts)
    118          {
    119              ASSERT_HALT(fr != NULL, "*fr null");
    120              ASSERT_HALT(attempts != 0, "attempts = 0");
    121              
    122              uint8_t TS = fr->meta.TS; 
    123              MACSlotTable[TS].TX.attempts = attempts;
    124              MACSlotTable[TS].TX.CH = fr->meta.CH;
    125              MACSlotTable[TS].TX.enable = true;
    126              MACSlotTable[TS].TX.fr = fr;
    127              TIC_SetTXState(TS, true);
    128          }
    129          
    130          /**
    131          @brief Посылает подтверждение приема пакета
    132          @param[in] fr указатель на кадр подтверждения
    133          */
    134          bool MAC_ACK_Send(frame_s *fr)
    135          {
    136            RI_SetChannel(fr->meta.CH);
    137            bool res = RI_Send(fr);
    138            frame_delete(fr);
    139            return res;
    140          }
    141          
    142          /**          *********** TODO ************ прием из Ethernet протокола
    143          @brief Посылает подтверждение приема пакета
    144          @param[in] fr указатель на кадр подтверждения
    145          */
    146          frame_s* MAC_ACK_Recv(void)
    147          {
    148            // ACK RECV TIMEOUT
    149            //RI_SetChannel(fr->meta.CH);
    150            //RI_Send(fr);
    151            //frame_delete(fr);
    152            return NULL;
    153          }
    154          
    155          /**
    156          @brief Устанавливает функцию обратного вызова при приеме пакета
    157          @param[in] fn указатель на функцию обработчик
    158          */
    159          void MAC_SetRXCallback(void (*fn)(frame_s *fr))
    160          {
    161            RXCallback = fn;
    162          }
    163          
    164          /**
    165          @brief Состояние слота TS передача
    166          @return возвращает true, если слот содержит пакет для передачи
    167          */
    168          bool MAC_GetTXState(uint8_t TS)
    169          {
    170            ASSERT_HALT(TS < 50, "Incorrect TS");
    171            return MACSlotTable[TS].TX.enable;
    172          }
    173          
    174          /**
    175          @brief Состояние слота TS приема
    176          @return возвращает true, если слот принимает пакет
    177          */
    178          bool MAC_GetRXState(uint8_t TS)
    179          {
    180            ASSERT_HALT(TS < 50, "Incorrect TS");
    181            return MACSlotTable[TS].RX.enable;
    182          }
    183          
    184          /**
    185          @brief Обработчик слота приема пакета
    186          @detail Отправкой подтвеждения приема пакета занимается ethernet протокол
    187          @param[in] TS номер временного слота
    188          */
    189          static void MAC_RX_HNDL(uint8_t TS)
    190          {
    191            ASSERT_HALT(TS < 50, "Incorrect TS");
    192            
    193            RI_SetChannel(MACSlotTable[TS].RX.CH);
    194            frame_s *fr = RI_Receive(RECV_TIMEOUT);
    195            
    196            // Если пакета нет, выходим из обработчика
    197            if (fr == NULL)
    198              return;
    199            
    200            RXCallback(fr);   // Передаем пакет на дальнейшую обработку
    201            frame_delete(fr); // Удаляем пакет
    202          }
    203          
    204          /**
    205          @brief Обработчик слота пердачи пакета
    206          @detail После отправки пакета требуется подтверждение приема если meta.ACK = 1.
    207           После отправки ждем приема ACK. Проверка подлинности ACK происходит с помощью
    208           обратного вызова isACK_OK(*fr, *fr_ACK). Результат true или false.
    209          @param[in] TS номер временного слота
    210          */
    211          static void MAC_TX_HNDL(uint8_t TS)
    212          {
    213            ASSERT_HALT(TS < 50, "Incorrect TS");
    214            
    215            // По ошибки вызвали. Такого быть не должно, но подстрахуемся.
    216            if ((!MACSlotTable[TS].TX.enable) || (MACSlotTable[TS].TX.attempts == 0)) 
    217              TIC_SetTXState(TS, false);
    218             
    219            RI_SetChannel(MACSlotTable[TS].TX.CH); // Устанавливаем канал передачи
    220          
    221            // Пробуем передать данные
    222            bool tx_success = RI_Send(MACSlotTable[TS].TX.fr); 
    223            bool send_success = false;  
    224            
    225            LOG(MSG_OFF | MSG_INFO | MSG_TRACE, "RI_Send = %d, CH = %d, TS = %d\r\n",
    226                tx_success, MACSlotTable[TS].TX.CH, TS);
    227              
    228            // Если отправка была успешна и требуется прием подтверждения ACK
    229            if (tx_success && MACSlotTable[TS].TX.fr->meta.ACK)
    230            {
    231              // TODO ждем пакета ACK
    232              // Задержка отправки подтверждения пока что не известна.
    233              // Если есть шифрование это на 1 мс дольше чем без него
    234              // Можно подумать над тем , что бы пакет ACK был не ETH формата.
    235              // К примеру ACK = LEN, FRAME_LEN, FCS1, FCS2 и он существовал
    236              // на уровне MAC и не использовал ETH. Отправка ACK без шифрования.
    237              // Это увеличит время работы узла. Или вместо FRAME_LEN отправлять
    238              // FCS1, FCS2 отправленного пакета что бы его подтвердить или использовать
    239              // свой алгоритм расчета CRC
    240              
    241              // Если включено шифрование, то можно выключать радиоприемник для экономии
    242              // Шифрование данных занимает некоторое время (минимум 1 мс)
    243              if (RARIO_STREAM_ENCRYPT)
    244                TIM_delay(DELAY_BEFORE_ACK_RECV_CRYPT);
    245              else
    246                TIM_delay(DELAY_BEFORE_ACK_RECV_NOCRYPT);
    247              
    248              frame_s *fr_ACK = RI_Receive(ACK_RECV_TIMEOUT);
    249            
    250              if (fr_ACK == NULL) // Не приняли ACK
    251                goto LABEL_MAC_TX_HNDL_END;
    252              
    253              else // Приняли ACK
    254              {
    255                ASSERT_HALT(isACK_OK !=NULL, "isACK_OK func NULL");
    256               
    257                // Проверим является ли принятый пакет ACK подтверждением 
    258                // переданного пакета 
    259                bool isACK = isACK_OK(MACSlotTable[TS].TX.fr, fr_ACK); 
    260               
    261                if (isACK) // Пакет подтвержден
    262                  send_success = true;
    263                
    264                frame_delete(fr_ACK); // Удаляем принятый пакет ACK
    265                goto LABEL_MAC_TX_HNDL_END;
    266              }
    267            }
    268           
    269            // Если отправка была успешна и НЕ требуется подтверждение ACK
    270            if (tx_success && !MACSlotTable[TS].TX.fr->meta.ACK) 
    271              send_success = true;
    272            
    273            
    274          LABEL_MAC_TX_HNDL_END:  
    275            if (send_success) // В случаи успеха удаляем данные и закрываем слоты 
    276            { 
    277              frame_delete(MACSlotTable[TS].TX.fr);
    278              MACSlotTable[TS].TX.enable = false;
    279              TIC_SetTXState(TS, false);      
    280            }
    281            else // Уменьшаем счетчик попыток передачи и удаляем пакет при достижении 0.
    282            {
    283              MACSlotTable[TS].TX.attempts --;
    284              if (MACSlotTable[TS].TX.attempts == 0)
    285                {
    286                  frame_delete(MACSlotTable[TS].TX.fr);
    287                  MACSlotTable[TS].TX.enable = false;
    288                  TIC_SetTXState(TS, false);  
    289                }
    290            }
    291          }
\\vmware-host\Shared Folders\Projects\WMNU\IAR\SHARE_PRJ_SRC\NTMR.c
      1          #include "NTMR.h"
      2          #include "stdlib.h"
      3          #include "ioCC2530.h"
      4          #include "nwdebuger.h"
      5          
      6          /**
      7          @file 
      8          @brief Модуль управления таймером сна
      9          @details При создании обьекта с помощью NT_Create, производится иницилизация
     10           аппаратного таймера сна и он переходит в активное состояние. Если установлено 
     11           определение #define USE_OSC32K будет использван внешний кварц.
     12           За установку глобального прерывания IE отвечает пользователь.
     13           Для использования модуля необходимо установить обработчик прерывания
     14           NT_SetEventCallback(..). Далее с помощью NT_SetCompare(..) установить
     15           время срабатывания прерывания, она же включит прерывание таймера. 
     16           Перед вызовом пользовательского обработчика, запрещается прерывание таймера,
     17           пользователь должен установить его повторно на необходимое время.
     18           Модуль сна пробуждает МК из режимов PM1,PM2, но не переводит их обратно.
     19           После завершения обработки прерывание, продолжится выполнение основного 
     20           потока программы. Пользователь самостоятельно должен перевести МК в режим сна.
     21           Функция NT_SetTime(..) производит подстройку времени сети и корректирует время
     22           срабатывания прерывания. Что бы было понятнее приведу пример: 
     23           Время сети 400 и установленно прерывание на 700.
     24           Пользователь корректирует время на 300, но из-за разной разрядности счетчиков
     25           прерывание произойдет по "старым часам", так как NT_SetTime только изменит
     26           переменную относительного смещения, а не непосредственно значение счетчика.
     27           Поэтому необходимо пересчитать время прерывания 700 к новому смещению.
     28           Из найденных особенностей: когда вызывается обработчик прерывания, значение
     29           времени всегда больше на 2 тика. Предполагаю из за ожидания синхронизации при
     30           чтении значения таймера. 
     31          */
     32          
     33          
     34          // После вызова EventCallback аппаратное прерывание завершается
     35          // и управление передается в главный цикл main.
     36          // Пользователь сам должен положить систему в сон
     37          // Для работы используется sleep timer.
     38          // Значение таймера изменить нельзя, он автоматически стартует после
     39          // Включения микроконтроллера. Нам нужно выбрать XOSC вместо RCOSC,
     40          // Но на отладочной плате нет резонатора
     41          // Чтение значения ST2:ST1:ST0 первым из ST0
     42          // Таймер работает во всех режимах кроме PM3
     43          // После пробуждения нужно убеиться что SLEEPSTA.CLK32K бит установлен прежде 
     44          // чем считывать ST0-3
     45          
     46          
     47          //#define USE_OSC32K // Использовать внешний квац 32.768 кГц
     48          
     49          // Методы модуля
     50          bool NT_SetTime(uint16_t ticks);
     51          void NT_SetCompare(uint16_t ticks);
     52          void NT_SetEventCallback(void (*fn)(uint16_t ticks));
     53          uint16_t NT_GetTime(void);
     54          uint16_t NT_WaitTime(uint16_t ticks);
     55          
     56          // Приватные методы
     57          static uint32_t ReadTimer(void);
     58          static void loadTimerCompare(uint32_t ticks);
     59          static inline bool isIRQEnable(void);
     60          static inline void NT_IRQEnable(bool state);
     61          
     62          // Переменные модуля
     63          static void (*EventCallback)(uint16_t ticks);
     64          static uint32_t COMPARE_TIME; //!< Значение загруженное в регистр compare
     65          
     66          /**
     67          @details Смещение времени сети относительно времени таймера.
     68           NETWORK TIME = TIMER + TOFFSET
     69          */
     70          uint16_t TOFFSET; 
     71          
     72          /**
     73          @brief Инизиализация таймера
     74          */
     75          void NT_Init(void)
     76          {
     77            TOFFSET = 0;
     78            COMPARE_TIME = 0;
     79            EventCallback = NULL;
     80          
     81            #ifdef USE_OSC32K
     82            CLKCONCMD &= ~(1<<7); // Сбрасываем бит OSC32K, будет выбран 32.768 кварц
     83            while (CLKCONSTA & (1<<7)); // Ждем пока бит не станет 0
     84            #endif
     85          
     86            NT_IRQEnable(false);
     87          }
     88          
     89          /**
     90          @brief Устанавливаем текущее время сети и переустанавливает capture time
     91          @param[in] ticks время от 0-32767. Один tick 1/32768
     92          @return true если аргумент в диапазоне
     93          */
     94          bool NT_SetTime(uint16_t ticks)
     95          {
     96            ASSERT_HALT(ticks < 32768, "Incorrect ticks");
     97            if (ticks > 32767)
     98              return false;
     99           
    100            uint16_t timer = ReadTimer();
    101            TOFFSET = ticks - timer;
    102            TOFFSET &= 0x7FFF;
    103          
    104            // После установки времени нужно изменить compare time в таймере
    105            // Но только в случаи если прерывание активно
    106            if (isIRQEnable())
    107            {
    108              NT_SetCompare(COMPARE_TIME);
    109            }
    110          
    111            return true;
    112          }
    113          
    114          /**
    115          @brief Вычисляет значение, которое нужно установить в регистр compare таймера.
    116          @params[in] ticks время сети в тикак
    117          */
    118          static inline uint32_t calcCompareTime(uint16_t ticks)
    119          {   
    120              uint32_t timer = ReadTimer(); // Текущее значение счетчика
    121              
    122              //NETWORK TIME = TIMER + TOFFSET  
    123              // Приводим такты к тактам таймера
    124              uint16_t ticks_offset = (ticks - TOFFSET) & 0x7FFF;
    125              
    126              uint32_t cmp_time = timer & ~0x7FFF; // Убираем младшие 15 бит
    127              cmp_time |= ticks_offset; // Вычисляем новое время
    128              
    129              if (cmp_time <= timer)
    130              {
    131                cmp_time += 0x8000;
    132                cmp_time &=0xFFFFFF;
    133              }
    134                
    135               LOG(MSG_OFF | MSG_INFO | MSG_TRACE, 
    136                   "Timer = %lu, Ticks = %d,CMP = %lu \r\n",
    137                    timer, ticks, cmp_time );
    138              return cmp_time;
    139          }
    140          
    141          /**
    142          @brief Устанавливает время прерывания
    143          @details Время прерывания устанавливается относительно времени сети
    144          ,к примеру, что бы проснуться в таймслот номер 0, нужно установить ticks = 0.
    145          Процедура учитывает текущее значение таймера и перерасчитывает значение ticks. 
    146          @params[in] ticks время сети в тиках когда нужно проснуться
    147          */
    148          void NT_SetCompare(uint16_t ticks)
    149          {
    150            ASSERT_HALT(ticks < 32768, "Incorrect ticks");
    151            
    152            COMPARE_TIME = ticks; // Сохраняем установленное значение
    153           
    154            uint32_t compare_time = calcCompareTime(ticks);
    155           
    156            loadTimerCompare(compare_time);
    157            NT_IRQEnable(true);
    158          }
    159          
    160          /**
    161          @brief Разрешение прерываний таймера сна
    162          @params[in] state = true - разрешить обработку прерываний
    163          */
    164          static inline void NT_IRQEnable(bool state)
    165          {
    166            STIF = 0;
    167            if (state)
    168            {
    169              STIE = 1;
    170            }
    171            else
    172            {
    173              STIE = 0;
    174            }
    175          }
    176          
    177          /**
    178          @brief Проверка активности прерывания таймера
    179          @return true если прерывание установленно
    180          */
    181          static inline bool isIRQEnable(void)
    182          {
    183            if (STIE)
    184              return true;
    185            else 
    186              return false;
    187          }
    188          
    189          /**
    190          @brief Устанавливает обработчик прерывания таймера
    191          @param[in] fn(uint16_t ticks) указатель на функцию-обработчик
    192          */
    193          void NT_SetEventCallback(void (*fn)(uint16_t ticks))
    194          {
    195            EventCallback = fn;
    196          }
    197          
    198          /**
    199          @brief Возвращает время сети 
    200          @return Время сети в тиках
    201          */
    202          uint16_t NT_GetTime(void)
    203          {
    204            uint32_t val = ReadTimer();
    205            // TOFFSET = NETWORK TIME - TIMER
    206            // NETWORK TIME = TIMER + TOFFSET
    207            val +=TOFFSET;
    208            val &= 0x7FFF; // Приводим значения таймера к 0-32767
    209            return val;
    210          }
    211          
    212          /**
    213          @brief Обработчик прерывания таймера сна
    214          */
    215          #pragma vector=ST_VECTOR
    216          __interrupt void TimerCompareInterrupt(void)
    217          {  
    218            uint16_t ticks = NT_GetTime();
    219            if (EventCallback == NULL)
    220              return;
    221            // Отключаем прерывание таймера. Забота пользователя его включить
    222            NT_IRQEnable(false); 
    223            EventCallback(ticks); // Вызываем пользовательский обработчик
    224            STIF = 0; // Очищаем флаг прерывания
    225          }
    226          
    227          /**
    228          @breif Ожидание наступления времени сети
    229          @param[in] ticks время в тактах
    230          @return фактическое время сети
    231          */
    232          uint16_t NT_WaitTime(uint16_t ticks)
    233          {
    234            static union 
    235            {
    236              uint32_t val;
    237              uint8_t fild[4];
    238            } val;
    239            
    240            val.val = 0;
    241            // TOFFSET = NETWORK TIME - TIMER
    242            // NETWORK TIME = TIMER + TOFFSET
    243            
    244            // Ждем синхронизацию таймера после пробуждения
    245            while (!(SLEEPSTA & 0x01));
    246            
    247            do
    248            {
    249              // Соблюдаем порядок чтения регисторов ST  
    250              val.fild[0] = ST0;
    251              val.fild[1] = ST1;
    252              val.fild[2] = ST2;
    253              val.val +=TOFFSET;
    254              val.val &= 0x7FFF; // Приводим значения таймера к 0-32767    
    255            } while (val.val < ticks);
    256            return val.val;
    257          }
    258          
    259          /**
    260          @brief Возвращает текущее значение таймера
    261          @return Текущие ticks
    262          */
    263          static uint32_t ReadTimer(void)
    264          {
    265            static union 
    266            {
    267              uint32_t val;
    268              uint8_t fild[4];
    269            } ret_val;
    270            
    271            ret_val.val = 0;
    272            
    273            // Ждем синхронизацию таймера после пробуждения
    274            while (!(SLEEPSTA & 0x01));
    275            
    276            // Соблюдаем порядок чтения регисторов ST  
    277            ret_val.fild[0] = ST0;
    278            ret_val.fild[1] = ST1;
    279            ret_val.fild[2] = ST2;
    280            return ret_val.val;
    281          }
    282          
    283          /**
    284          @brief Устанавливает время пробуждения микроконтролера
    285          @params[in] ticks 24 битное значение времени пробуждения в ticks
    286          */
    287          static void loadTimerCompare(uint32_t ticks)
    288          {
    289            union 
    290            {
    291              uint32_t val;
    292              uint8_t fild[4];
    293            } value;
    294            
    295            value.val = ticks;
    296            
    297            // Ждем разрешения на запись нового значения
    298            while (!(STLOAD & 0x01));
    299            
    300            // Регистр ST0 должен быть записан в последнию очередь
    301            ST2 = value.fild[2];
    302            ST1 = value.fild[1];
    303            ST0 = value.fild[0];
    304          }
\\vmware-host\Shared Folders\Projects\WMNU\IAR\SHARE_PRJ_SRC\nwdebuger.c
      1          #include "nwdebuger.h"
      2          #include "ioCC2530.h"
      3          #include "stdint.h"
      4          #include "stdio.h"
      5          
      6          
      7          #define UART_DEBUG // Если определено, то вывод в uart
      8          
      9          // Настройка выводов SIG и порта uart для отладки
     10          
     11          static void uart_init(void)
     12          {
     13            // Выбор расположения UART на выводах
     14            uint8_t U0CFG = 0; // 0={TX=P0_3, RX=P0_2
     15            PERCFG |= (U0CFG<<0); 
     16            
     17            // U0UCR регистр настройки режима uart. меня устраивает по умолчанию
     18            U0CSR = (1<<7); // Выбираем режим uart 
     19            
     20            // Настройка скорости передачи данных на 2М  
     21            U0BAUD = 0;  // табличные значения из pdf
     22            U0GCR =  16;
     23            
     24            // Включаем альтернативные функции выводов
     25            P0SEL = (1<<2)|(1<<3);
     26          }
     27          
     28          static void SetCPU32M(void)
     29          {
     30            CLKCONCMD = 0x88;
     31            while (CLKCONSTA&(1<<6));
     32          }
     33          
     34          void nwDebugerInit(void)
     35          {
     36            SetCPU32M();
     37          #ifdef UART_DEBUG
     38            uart_init();
     39          #endif
     40          }
     41          
     42          __attribute__((weak)) void STACK_FAILURE(char* msg)
     43          {
     44            LOG(MSG_ON | MSG_ALARM | MSG_ALL, "STACK FAILURE. HALT\n");
     45            while(1);
     46          }
     47          
     48          // Переопределяем функцию записи в порт
     49          #ifdef UART_DEBUG
     50          #include <yfuns.h>
     51          
     52          _STD_BEGIN
     53          
     54          #pragma module_name = "?__write"
     55          
     56          int MyLowLevelPutchar(int x);
     57          
     58          int MyLowLevelPutchar(int x){
     59            while( U0CSR&(1<<0));
     60            U0DBUF = x;
     61            return x;
     62          }
     63          /*
     64           * If the __write implementation uses internal buffering, uncomment
     65           * the following line to ensure that we are called with "buffer" as 0
     66           * (i.e. flush) when the application terminates.
     67           */
     68          
     69          size_t __write(int handle, const unsigned char * buffer, size_t size)
     70          {
     71            /* Remove the #if #endif pair to enable the implementation */
     72             
     73          
     74            size_t nChars = 0;
     75          
     76            if (buffer == 0)
     77            {
     78              /*
     79               * This means that we should flush internal buffers.  Since we
     80               * don't we just return.  (Remember, "handle" == -1 means that all
     81               * handles should be flushed.)
     82               */
     83              return 0;
     84            }
     85          
     86            /* This template only writes to "standard out" and "standard err",
     87             * for all other file handles it returns failure. */
     88            if (handle != _LLIO_STDOUT && handle != _LLIO_STDERR)
     89            {
     90              return _LLIO_ERROR;
     91            }
     92          
     93            for (/* Empty */; size != 0; --size)
     94            {
     95              if (MyLowLevelPutchar(*buffer++) < 0)
     96              {
     97                return _LLIO_ERROR;
     98              }
     99          
    100              ++nChars;
    101            }
    102          
    103            return nChars;
    104          
    105          }
    106          
    107          _STD_END
    108          #endif
\\vmware-host\Shared Folders\Projects\WMNU\IAR\SHARE_PRJ_SRC\RADIO.c
      1          /*!
      2          \file 
      3          \brief Модуль содержит реализацию интерфейса радио для приема/передачи данных.
      4          */
      5          
      6          #include "RADIO.h"
      7          #include "stdlib.h"
      8          #include "nwdebuger.h"
      9          #include "Radio_defs.h"
     10          #include "TIC.h"
     11          #include "delays.h"
     12          #include "frame.h"
     13          #include "string.h"
     14          #include "coder.h"
     15          #include "NTMR.h"
     16          
     17          // Открытые методы модуля
     18          void RI_init(void);
     19          bool RI_SetChannel(uint8_t CH);
     20          bool RI_Send(frame_s *fr);
     21          frame_s* RI_Receive(uint16_t timeout);
     22          uint32_t RI_GetCRCError(void);
     23          uint32_t RI_GetCCAReject(void);
     24          float RI_GetUptime(void);
     25          void RI_StreamCrypt(bool state);
     26          void RI_setKEY(void* ptr_KEY);
     27          void RI_setIV(void* ptr_IV);
     28          
     29          // Приватные методы
     30          static void random_core_init(void);
     31          static void RI_cfg(void);
     32          
     33          // TODO можно добавть простой алгоритм перестановки для сокрытия данных 
     34          // при передаче RAW формата. Алгоритм должен быть достаточно простой и 
     35          // перестанавливать биты, смешивать их с ключом. Алгорим не производит 
     36          // контроль дешифровки с помощью цифровых подписей.
     37          // Шифрование можно включаеть/отключаеть
     38          // Возможно попробовать аппаратный модуль, так как к уже зашифрованому пакету
     39          // IP добавятся данные и зашифруются еще одним ключем, надежность возрастет.
     40          // Думаю это не будет являтся двойным шифрованием и будет устойчиво к взлому
     41          static void RI_BitRawCrypt(uint8_t *src, uint8_t size); // Шифрование передачи
     42          static void RI_BitRawDecrypt(uint8_t *src, uint8_t size); // Дешифрока приема
     43          static inline void setFreq(uint8_t CH); // Установка частоты передатчика
     44          static void LoadTXData(uint8_t *src, uint8_t len); // Загрузка данных в tx buf
     45          static void UnLoadRXData(uint8_t *src, uint8_t len);
     46          static bool SendData(frame_s *fc);
     47          static bool RecvData(uint32_t timeout_us, uint16_t *SFD_TimeStamp);
     48          
     49          // Переменные модуля
     50          static float RI_UPTIME = 0; // Время работы радио в мс. 49 дней максимум
     51          static uint32_t RI_CRC_ERROR = 0; // Количество ошибок CRC
     52          static uint32_t RI_CCA_REJECT = 0; // Количество отказов передач из-за CCA
     53          static uint8_t IV[16];  // Вектор иницилизации для кодирования
     54          static uint8_t KEY[16]; // Ключ для кодирования
     55          
     56          /*!
     57          \brief Константы для установки выходной мощности радиопередатчика.
     58          Пример: p4x5 = +4,5 дБ. m0x5 = -0.5 дБ
     59          */
     60          enum TX_POWER_e 
     61          {
     62            // +4.5дБ = p4x5, -1.5дБ = m1x5.
     63            // +4.5 = 34мА, +1 = 29мА, -4 = 26мА, -10 = 25 мА, -22 = 23 мА
     64            p4x5 = 0xF5, p2x5 = 0xE5, p1x0 = 0xD5, m0x5 = 0xC5, m1x5 = 0xB5, m3x0 = 0xA5,
     65            m4x0 = 0x95, m6x0 = 0x85, m8x0 = 0x75, m10x0 = 0x65, m12x0 = 0x55, 
     66            m14x0 = 0x45, m16x0 = 0x35, m20x0 = 0x15, m22x0 = 0x05
     67          };
     68          
     69          
     70          #define IEEE_MODE 0     //!< Режимы фазы сигнала
     71          #define NOT_IEEE_MODE 1 //!< Режимы фазы сигнала
     72          #define RSSI_OFFSET -76 //!< Константа для вычисления реальной мощности
     73          
     74          /*!
     75          \details 
     76           Расчет качества связи. Коэффициенты получаются эксперементально.
     77           Есть предположение, что количество ошибок будет пропорционально квадрату
     78           коеффициента корреляции сигнала.
     79           LIQ = 255 передача 1000 пакетов без ошибок CRC
     80           LIQ = 127 передача 1000 пакетов с 50% ошибок CRC
     81           LIQ = 0   передача 1000 пакетов с 100% ошибок CRC
     82          */ 
     83          #define CONST_A (int8_t)0 //!< Коэффициент A
     84          #define CONST_B (int8_t)1 //!< Коэффициент B
     85          #define LIQ_CALC(corr) ((corr-CONST_A)*CONST_B) //!< Формула вычисление LIQ 
     86          #define FRQ_CALC(x) (11+5*(x-11)) //!< Формул вычисления частоты сигнала
     87          
     88          /// Глобальные параметры модуля
     89          struct
     90          {
     91            uint8_t CH;       //!< Номер канала с 11 до 26 включительно
     92            uint8_t TX_POWER; //!< Мощность радиопередатчика по умолчанию. 7 бит
     93            bool MODULATION_MODE; //!< false - совместимость с IEEE 802.15.4
     94            bool STREAM_CRYPT_ENABLE; //!< Шифрование выходного потока данных
     95          } RADIO_CFG;
     96          
     97          /**
     98          @brief Установить вектор иницилизации для шифрования
     99          @param[in] ptr_IV указатель на 16 байтный вектор иницилизации
    100          */
    101          void RI_setIV(void* ptr_IV)
    102          {
    103            memcpy(IV, ptr_IV, 16);
    104          }
    105          
    106          /**
    107          @brief Установить ключ шифрования
    108          @param[in] ptr_KEY указатель на 16 байтный ключ
    109          */
    110          void RI_setKEY(void* ptr_KEY)
    111          {
    112            memcpy(KEY, ptr_KEY, 16);
    113          }
    114          
    115          /*!
    116          \brief Иницилизация радио интерфейса
    117          */
    118          void RI_init(void)
    119          {
    120            // Настройки поумолчанию
    121            RADIO_CFG.CH = CH11;
    122            RADIO_CFG.TX_POWER = m0x5;
    123            RADIO_CFG.MODULATION_MODE = IEEE_MODE;
    124            RADIO_CFG.STREAM_CRYPT_ENABLE = true;
    125            // Пост действия с радио
    126            random_core_init();
    127          }
    128          
    129          /*!
    130          \brief Переводит радио в активный режим и устанавливает параметры.
    131          */
    132          static void RI_cfg(void)
    133          {
    134          /*
    135          APPEND_DATA_MODE = 0. FCS1 = signed rssi, FCS2.7 CRC OK, FCS2.6-0 Correlation
    136          A correlation value of ~110 indicates a maximum quality frame while a value 
    137          of ~50 is typically the lowest quality frames detectable by CC2520. 
    138          */
    139          /* После включения радио находится в активном режиме но приемник выключен */
    140            
    141            // Устанавливаем частоту радиопередатчика
    142            setFreq(RADIO_CFG.CH);
    143            
    144            // Устанавливаем мощность выходного сигнала
    145            TXPOWER = RADIO_CFG.TX_POWER;
    146           
    147            FRMFILT0 = 0x00; // Отключаем фильтрацию пакетов
    148            
    149            // Устанавливаем режим модуляции
    150            MDMTEST1_u MDM1;
    151            MDM1.value = MDMTEST1;
    152            MDM1.bits.MODULATION_MODE = RADIO_CFG.MODULATION_MODE;
    153            MDMTEST1 = MDM1.value; 
    154          }
    155          
    156          /*!
    157          \brief Устанавливает канал радиопередатчика.
    158          \param[in] CH Номера каналов [11..26]
    159          \return Возвращает true если аргументы верны
    160          */
    161          bool RI_SetChannel(uint8_t CH)
    162          {
    163            if ((CH >=11) && (CH<=26))
    164            {
    165              RADIO_CFG.CH = CH;
    166              return true;
    167            }
    168            return false;
    169          }
    170          
    171          /*!
    172          \brief Передает данные в эфир
    173          \details Функция может самостоятельно шифровать поток данных, увеличивает 
    174           RI_CCA_REJECT при невозможности отправки сообщения, расчитывает время работы 
    175           радио передатчика. Отправка сообщения в заданное сетевое время 
    176           fr->meta.SEND_TIME. Если равно 0, то отправка через случайноу время в мкс.
    177           Данные автоматически оборачиваются в LEN, CRC1,CRC2
    178          \param[in] *fr Указатель на структуру frame_s RAW_LAY
    179          \return Возвращает true в случаи успешной передачи
    180          */
    181          bool RI_Send(frame_s *fr)
    182          {
    183            ASSERT_HALT(fr != NULL, "fr NULL");
    184            
    185            // Устанавливаем частоту передачи пакета
    186            RI_cfg();
    187            
    188            bool send_res; // Результат передачи данных
    189            TimeStamp_s start,stop; // Измерение времени
    190            
    191            TIM_TimeStamp(&start); // Начало измерения времени
    192            send_res = SendData(fr);
    193            TIM_TimeStamp(&stop); // Конец измерения времени
    194            
    195            uint32_t passed = TIM_passedTime(&start, &stop);
    196            RI_UPTIME += (float)passed/1000; // Микросекунды в милисекунды
    197            
    198            // В случаи ошибки передачи увеличиваем счетчик RI_CCA_REJECT
    199            if (!send_res)
    200              RI_CCA_REJECT++;
    201            
    202            return send_res;
    203          }
    204          
    205          /**
    206          @brief Отправка сообщения
    207          @detail Время отправки с шифрованием 10 байт в мкс. Merge = 155, Crypt = 239,
    208           Load TX = 30, RSSI_OK = 328, ISTXON = 11, SFD(192us+5*8*4us) = 400, TX = 370, Full = 1535.
    209          Время работы радио RSSI_OK+ISTXON+SFD+TX = 1109 us
    210          @return true в случаи успеха
    211          */
    212          static bool SendData(frame_s *fr)
    213          {
    214          ////TimeStamp_s ts_start, ts_frame_merge, ts_crypt, ts_load_tx, 
    215          ////ts_rssistat, ts_istxon, ts_sfd, ts_stop;
    216            
    217          ////TIM_TimeStamp(&ts_start);  
    218            uint8_t data_size;
    219            uint8_t *data = (uint8_t*)frame_merge(fr, &data_size); 
    220          ////TIM_TimeStamp(&ts_frame_merge);  
    221            bool result = true;
    222            switch(true)
    223            {
    224              case true:
    225                // Шифруем данные при необходимости
    226                RI_BitRawCrypt(data, data_size);
    227          ////TIM_TimeStamp(&ts_crypt); 
    228                // Копируем данные в буфер. Очистка буфера автоматическая
    229                LoadTXData(data, data_size);
    230          ////TIM_TimeStamp(&ts_load_tx); 
    231                // Для начала передачи по команде STXONCCA нужно включить приемник
    232                ISRXON();
    233                // Ждем пока статус RSSI_VALID станет true
    234                while(!RSSISTAT);
    235          ////TIM_TimeStamp(&ts_rssistat); 
    236                // Очищаем флаг завершения передачи сообщения
    237                RFIRQF1 &= ~RFIRQF1_TXDONE;
    238                RFIRQF0 &= ~RFIRQF0_SFD;
    239                
    240                // Время отправки сообщения измеряется в тактах сетевого времени NTMR
    241                // Он работатаеи намного лучше чем MAC таймер(меньше погрешность)
    242                // Отправка в обозначенное время или по факту готовности
    243                uint16_t timer = 0; // Для отлалки. 
                                ^
Warning[Pe550]: variable "timer" was set but never used
          detected during compilation of secondary translation unit
                    "\\vmware-host\Shared
                    Folders\Projects\WMNU\IAR\SHARE_PRJ_SRC\RADIO.c"
    244                if (fr->meta.SEND_TIME != 0)
    245                  timer = NT_WaitTime(fr->meta.SEND_TIME);
    246          
    247                // Начинаем передачу данных
    248                // Transmission of preamble begins 192 μs after the STXON or STXONCCA 
    249                // command strobe
    250                // 192+(4(pream)+1(sfd))*8bit*4us = 352 мкс. Измерил 360мкс
    251                // Измерил в тактах NT_GetTimer() получилось 13 тиков. 396 мкс 
    252                ISTXONCCA();
    253          ////TIM_TimeStamp(&ts_istxon); 
    254                // Произошла ошибка передачи если SAMPLED_CCA false
    255                if (!(FSMSTAT1 & 1<<3)) //SAMPLED_CCA == 0
    256                {
    257                  result = false;
    258                  break;
    259                }
    260          
    261                // Ждем завершения отправки SFD
    262                while (!(RFIRQF0 & RFIRQF0_SFD));
    263                fr->meta.TIMESTAMP = NT_GetTime(); 
    264          ////TIM_TimeStamp(&ts_sfd); 
    265                // Проверим переданно ли сообщение TX_FRM_DONE
    266                while (!(RFIRQF1 & RFIRQF1_TXDONE));
    267                break;
    268            }
    269          ////TIM_TimeStamp(&ts_stop);
    270          
    271            free(data);
    272            ISRFOFF();
    273          ////  LOG(MSG_ON | MSG_INFO | MSG_TRACE, 
    274          ////"Merge = %lu. Crypt = %lu. Load TX = %lu. RSSI_OK = %lu. ISTXON = %lu. SFD = %lu. TX = %lu. FULL = %lu \n", 
    275          ////      TIM_passedTime(&ts_start, &ts_frame_merge),
    276          ////      TIM_passedTime(&ts_frame_merge, &ts_crypt),
    277          ////      TIM_passedTime(&ts_crypt, &ts_load_tx),
    278          ////      TIM_passedTime(&ts_load_tx, &ts_rssistat),
    279          ////      TIM_passedTime(&ts_rssistat, &ts_istxon),
    280          ////      TIM_passedTime(&ts_istxon, &ts_sfd),
    281          ////      TIM_passedTime(&ts_sfd, &ts_stop),
    282          ////      TIM_passedTime(&ts_start, &ts_stop)
    283          ////      );
    284            
    285            if (result)
    286              return true;
    287            return false; 
    288          }
    289          
    290          /**
    291          @brief Загрузка данных для передачи в буфер. 
    292          @detail Поля LEN, FCS1, FCS2 добавляются автоматически
    293          @param[in] src указатель на данные
    294          @param[in] len размер данных
    295          */
    296          static void LoadTXData(uint8_t *src, uint8_t len)
    297          {
    298            // Очищаем буфер передатчика
    299            ISFLUSHTX(); 
    300            // Поле LEN на два байта больше
    301            RFD = len + 2;
    302            
    303            for (uint8_t i = 0 ; i < len; i++)
    304              RFD = src[i];
    305            
    306            // Добавляем CRC1,2
    307            RFD = 0x00;
    308            RFD = 0x00;
    309          };
    310          
    311          /**
    312          @brief Выгружаем принятый пакет из радио
    313          @param[out] src указатель на буфер приемника
    314          @param[in] len размер выгружаемых данных
    315          */
    316          static void UnLoadRXData(uint8_t *src, uint8_t len)
    317          {
    318            for (uint8_t i = 0 ; i < len; i++)
    319              src[i] = RFD;
    320          };
    321          
    322          static inline void setFreq(uint8_t CH)
    323          {
    324            ASSERT_HALT( (CH >= 11) && (CH <= 26), "Incorrect radio channel");
    325            // Устанавливаем частоту радиопередатчика
    326            FREQCTRL_u FRQ;
    327            FRQ.value = FRQ_CALC(RADIO_CFG.CH);
    328            FREQCTRL = FRQ.value;  
    329          }
    330          
    331          /*!
    332          \brief Принимает данные из эфира
    333          \details Функция принимает данные из эфира. Проводит проверку CRC, увеличивает
    334          RI_CRC_ERROR. Дешифрует данные при необходимости. Отмечает время прихода SFD 
    335           в тактах сетевого времени .
    336          \param[in] timeout Время ожидания данных в милисекундах
    337          \return Возвращает NULL если данных нет
    338          */
    339          frame_s* RI_Receive(uint16_t timeout)
    340          {
    341            // Устанавливаем частоту передачи пакета
    342            RI_cfg();
    343            uint16_t SFD_TimeStamp;
    344            
    345            // Принимаем пакет 
    346            uint32_t timeout_us = timeout*1000UL; // Переводим мс->мкс
    347            TimeStamp_s start,stop; // Измерение времени
    348            TIM_TimeStamp(&start); // Начало измерения времени работы радио
    349            bool recv_res = RecvData(timeout_us, &SFD_TimeStamp);
    350            TIM_TimeStamp(&stop); // Конец измерения времени радио
    351            uint32_t passed = TIM_passedTime(&start, &stop);
    352            RI_UPTIME += (float)passed/(float)1000; // Микросекунды в милисекунды
    353            
    354            // Если ничего не приняли возвращаем NULL
    355            if (!recv_res)
    356              return NULL;
    357            
    358            uint8_t frame_size = RXFIFOCNT; // Количество принятых данных
    359            
    360            // Минимальный размер FCS1,FCS2 - 2 байта. LEN не включен в подсчет 
    361            if (frame_size <= 2)
    362              return NULL;
    363            
    364            // Выгружаем данные из приемника
    365            uint8_t *frame_raw = malloc(frame_size); 
    366            UnLoadRXData(frame_raw, frame_size);
    367            
    368            int8_t  FCS1 = frame_raw[frame_size - 2]; // RSSI
    369            uint8_t FCS2 = frame_raw[frame_size - 1]; // bit7 = CRCOK, bit[6..0] Corr_val
    370            uint8_t LEN_F = frame_raw[0]; // Поле LEN
    371            
    372            // Проверим поле LEN. Размер данных в заголовке должен совпадать
    373            // с фактической длинной принятых данных
    374            if (LEN_F != frame_size - 1)
    375            {
    376              free(frame_raw);
    377              RI_CRC_ERROR ++;
    378              return NULL;
    379            }
    380            
    381            // Проверим поле CRCOK
    382            if (!(FCS2 && 1<<7))
    383            {
    384              free(frame_raw);
    385              RI_CRC_ERROR ++;
    386              return NULL;
    387            }
    388            
    389            // Создаем буфер, последнии два байта FCS1,2 и поле LEN не копируем
    390            fbuf_s* fb = fbuf_create(FB_RAW_LAY, &frame_raw[1], frame_size - 2);
    391            RI_BitRawDecrypt(fb->payload, fb->len); // Декодируем поток если нужно
    392            
    393            // Создаем фрейм
    394            frame_s *fr = frame_create();
    395            frame_insert_head(fr ,fb); // Добавляем буферы
    396           
    397            // Копируем метку времени SFD
    398            fr->meta.TIMESTAMP = SFD_TimeStamp;
    399            
    400            // Расчитываем мощность принятого сигнала
    401            fr->meta.RSSI_SIG =  FCS1 + RSSI_OFFSET;
    402            // Расчитываем качество сигнала
    403            uint8_t corr = FCS2 & 0x7F;
    404            fr->meta.LIQ = LIQ_CALC(corr); // Значение коэфф. корреляции
    405          
    406            fr->meta.CH = RADIO_CFG.CH;
    407          
    408            free(frame_raw);
    409            return fr;
    410          }
    411          
    412          /**
    413          @brief Прием данных из эфира
    414          @param[in] timeout_us время ожидания в микросекундах
    415          @param[out] SFD_TimeStamp отметка времени завершения приема SFD
    416          */
    417          static bool RecvData(uint32_t timeout_us, uint16_t *SFD_TimeStamp)
    418          {
    419            TimeStamp_s start,stop; // Измерение времени  
    420            ISFLUSHRX(); // Очищаем буфер приема
    421            
    422            TIM_TimeStamp(&start);
    423            
    424            // Очищаем флаг завершения передачи сообщения и приема SFD
    425            RFIRQF0 &= ~RFIRQF0_RXPKTDONE;  
    426            RFIRQF0 &= ~RFIRQF0_SFD; 
    427            ISRXON(); // Включаем радиопередатчик
    428          
    429            bool time_out = false; // Истекло время ожидания пакета
    430            bool packet_received = false; // Приняли пакет
    431            bool sfd_received = false; // Приняли sfd
    432            
    433            // Цикл приема пакета
    434            while (true)
    435            {
    436              TIM_TimeStamp(&stop);
    437              if (TIM_passedTime(&start, &stop) >= timeout_us)
    438              {
    439                time_out = true;
    440                break;
    441              }
    442             
    443              // Принят сигнал SFD
    444              if ((RFIRQF0 & RFIRQF0_SFD))
    445              {
    446                *SFD_TimeStamp = NT_GetTime(); 
    447                sfd_received = true;
    448              }
    449              
    450              //  Завершен ли прием сообщения RX_FRM_DONE (RXPKTDONE)
    451              if ((RFIRQF0 & RFIRQF0_RXPKTDONE))
    452              {
    453                packet_received = true;
    454                break;
    455              }
    456            } // while 
    457            
    458            ISRFOFF();
    459            if (packet_received && sfd_received && !time_out)
    460              return true;
    461            else
    462              return false;
    463          }
    464          
    465          /*!
    466          \brief Возвращает количество ошибок возникших с момента иницилизации
    467          \return Количество CRC ошибок
    468          */
    469          uint32_t RI_GetCRCError(void)
    470          {
    471            return RI_CRC_ERROR;
    472          }
    473          
    474          /*!
    475          \brief Возвращает количестов отказов передачи пакета из-за занятости канала.
    476          \return Количество отказов CCA
    477          */
    478          uint32_t RI_GetCCAReject(void)
    479          {
    480            return RI_CCA_REJECT;
    481          }
    482          
    483          /*!
    484          \brief Возвращает суммарное время работы радио в режиме прием/передача
    485          \return Вермя в милисекундах
    486          */
    487          float RI_GetUptime(void)
    488          {
    489            return RI_UPTIME;
    490          }
    491          
    492          /**
    493          @breif Подссчет количества бит в байте
    494          @return Возвращает количество бит
    495          */
    496          static uint8_t bits_count(uint8_t value) {
    497            int ret = 0;
    498            for ( ; value; value = value >> 1 )
    499              ret += value & 1;
    500            return ret;
    501          }
    502          
    503          /**
    504          @brief Возращает 1 байт случайного числа
    505          @details Радио выдает всего лишь дви бита, нам нужно 8 
    506          */
    507          static inline uint8_t getRNDByte(void)
    508          {
    509            uint8_t val = 0;
    510            val |= RFRND << 0;
    511            val |= RFRND << 2;
    512            val |= RFRND << 4;
    513            val |= RFRND << 6;
    514            return val;
    515          }
    516          
    517          /**
    518          @brief Возвращает случайное число с числом включеных бит от 2 до 6 включительно
    519          @details Случайные числа появляются в регистре с частотой 170нс. Функция 
    520          возвращает гарантированно новое значение. 
    521          @return возвращает случайное число.
    522          */
    523          static inline uint8_t readRandom(void)
    524          {
    525            uint8_t rnd_val = 0;
    526            uint8_t bit_cnt = 0;
    527            while ( bit_cnt <= 2 || bit_cnt >= 6 )
    528            {
    529              rnd_val = getRNDByte();
    530              while (rnd_val == getRNDByte());
    531              rnd_val = getRNDByte();
    532              bit_cnt = bits_count(rnd_val);
    533            }
    534            return rnd_val;
    535          }
    536          
    537          /*!
    538          \brief Иницилизирует ядро генератора случайных чисел данными из эфира
    539          */
    540          static void random_core_init(void)  
    541          {
    542            unsigned int rnd_core = 0;;
    543               
    544            RI_cfg();
    545            FREQCTRL = 0x00; // Выбираем не используемую частоту
    546          
    547            // TODO По какой то причине OP_EXE не выполняет команду.
    548            // регистра RFST читается как 0xD0. это его состояние при reset
    549            // Включаем демодулятор
    550            ISRXON();
    551            
    552            // Ждем пока статус RSSI_VALID станет true
    553            while(!RSSISTAT);
    554            
    555            // Ждем случайных чисел
    556            while (RFRND == 0);
    557            
    558            // Настраиваем ядро случайного генератора
    559            rnd_core = readRandom();
    560            rnd_core |= (unsigned int)readRandom()<<8;
    561            srand(rnd_core);
    562            
    563            // Включаем демодулятор
    564            ISRFOFF();
    565            // Первая генерация случайного числа занимает много времени.
    566            // Влияло на работу радио, так как использовались случайные посылки
    567            rand(); 
    568          }
    569          
    570          /*!
    571          \brief Установка разрешения шифрования потока данных
    572          \param[in] true - включить шифрование
    573          */
    574          void RI_StreamCrypt(bool state)
    575          {
    576            RADIO_CFG.STREAM_CRYPT_ENABLE = state;
    577          }
    578          
    579          /*!
    580          \brief Шифрует область памяти если шифрование разрешено
    581          \param[in,out] *src Указатель на начало области шифрования
    582          \param[in] size Размер шифруемых данных
    583          */
    584          static void RI_BitRawCrypt(uint8_t *src, uint8_t size)
    585          {
    586            if (!RADIO_CFG.STREAM_CRYPT_ENABLE)
    587              return;
    588            
    589            AES_StreamCoder(true, src, src, KEY, IV, size);
    590          }
    591          
    592          /*!
    593          \brief Расшифровка область памяти если шифрование разрешено
    594          \param[in,out] *src Указатель на начало области дешифрования
    595          \param[in] size Размер расшифруемых данных
    596          */
    597          static void RI_BitRawDecrypt(uint8_t *src, uint8_t size)
    598          {
    599             if (!RADIO_CFG.STREAM_CRYPT_ENABLE)
    600              return;
    601             
    602            AES_StreamCoder(false, src, src, KEY, IV, size);
    603          }
\\vmware-host\Shared Folders\Projects\WMNU\IAR\SHARE_PRJ_SRC\TIC.c
      1          #include "TIC.h"
      2          #include "NTMR.h"
      3          #include "stdlib.h"
      4          #include "nwdebuger.h"
      5          #include "delays.h"
      6          
      7          /**
      8          @file 
      9          @brief 
     10          @details
     11          */
     12          
     13          // Публичные методы
     14          void TIC_Init(void);
     15          
     16          // Методы класса
     17          void TIC_SetTimer(uint16_t ticks);
     18          uint16_t TIC_GetTimer(void);
     19          bool TIC_SetTXState(uint8_t TS, bool state);
     20          bool TIC_SetRXState(uint8_t TS, bool state);
     21          bool TIC_GetTXState(uint8_t TS);
     22          bool TIC_GetRXState(uint8_t TS);
     23          void TIC_SetRXCallback(void (*fn)(uint8_t TS));
     24          void TIC_SetTXCallback(void (*fn)(uint8_t TS));
     25          void TIC_SetSECallback(void (*fn)(uint8_t TS));
     26          uint32_t TIC_GetUptime(void);
     27          uint32_t TIC_GetRTC(void);
     28          bool TIC_SetRTC(uint32_t RTC);
     29          void TIC_SetNonce(uint32_t nonce);
     30          uint32_t TIC_GetNonce(void);
     31          uint32_t TIC_TimeUsFromTS0();
     32          TimeStamp_s* TIC_GetTimeStampTS0(void);
     33           
     34          // Приватные методы
     35          static uint8_t TIC_getCurrentTS(uint16_t ticks);
     36          static void TIC_TDMAShelduler(uint8_t TS);
     37          static void TIC_HW_Timer_IRQ(uint16_t ticks);
     38          static inline void set_capture_time(uint8_t TS);
     39          static inline void Callback_execution(void (*fn)(uint8_t TS), uint8_t TS);
     40          static inline void incrementTS(uint8_t *TS);
     41          static void clocks_update(void);
     42          
     43          // Переменные модуля
     44          
     45          // Всего 50 слотов. (50 активных и 50 слотов сна)
     46          // Кварц имеет 32768 тактов в секунду. После 100 слотов
     47          // Остается 68 неучтеных тактов. Их нужно учитывать.
     48          #define MAX_TS (uint8_t)50
     49          #define TS_ACTIVE (uint16_t)327 // 9.979 мс
     50          #define TS_SLEEP (uint16_t)327  // 2.075 мс
     51          #define TS_UNACCOUNTED 68
     52          // Целый цикл-это сумма времени активного периода и сна
     53          #define FULL_SLOT  (TS_ACTIVE+TS_SLEEP)
     54          #define NO_TIME_SLOT 0xFF
     55          
     56          #define TS_RX (uint8_t)(1<<0)
     57          #define TS_TX (uint8_t)(1<<1)
     58          #define DAILY_SEC (uint32_t)86400
     59          #define MAX_TICKS (uint16_t)32768
     60          
     61          static uint32_t NODE_UPTIME = 0;
     62          static uint32_t NODE_RTC = 0;
     63          static uint32_t NODE_NONCE = 0;
     64          static void (*RXCallback)(uint8_t TS);
     65          static void (*TXCallback)(uint8_t TS);
     66          static void (*SECallback)(uint8_t TS);
     67          static uint8_t TSStateTable[MAX_TS];
     68          static TimeStamp_s TimeStampTS0;
     69          
     70          
     71          TimeStamp_s* TIC_GetTimeStampTS0(void)
     72          {
     73            return &TimeStampTS0;
     74          }
     75          void TIC_Init(void)
     76          {    
     77            // Устанавливаем обработчик прерываний таймера
     78            NT_SetEventCallback(TIC_HW_Timer_IRQ);
     79            // Запускаем процесс планировщика
     80            NT_SetCompare(0); 
     81            TIC_SetTimer(0);
     82            TIM_TimeStamp(&TimeStampTS0);
     83          }
     84          
     85          uint32_t TIC_TimeUsFromTS0()
     86          {
     87            uint32_t passed;
     88            TimeStamp_s now;
     89            TIM_TimeStamp(&now);
     90            passed = TIM_passedTime(&TimeStampTS0, &now);
     91            return passed;
     92          }
     93          
     94          void TIC_SetTimer(uint16_t ticks)
     95          {
     96            ASSERT_HALT(ticks < MAX_TICKS, "Ticks not in range");
     97            if (ticks >= MAX_TICKS)
     98              return ;
     99            
    100            NT_SetTime(ticks);
    101          }
    102          
    103          uint16_t TIC_GetTimer(void)
    104          {
    105            return NT_GetTime();
    106          }
    107          
    108          bool TIC_SetTXState(uint8_t TS, bool state)
    109          {
    110            if (TS>=MAX_TS)
    111            {
    112              return false;
    113            }
    114            ASSERT_HALT(TS<MAX_TS, "TS not in range");
    115            
    116            if (state)
    117              TSStateTable[TS] |= TS_TX;
    118            else
    119              TSStateTable[TS] &= ~TS_TX;
    120            
    121            return true;
    122          }
    123          
    124          bool TIC_SetRXState(uint8_t TS, bool state)
    125          {
    126            if (TS>=MAX_TS)
    127            {
    128              return false;
    129            }
    130            ASSERT_HALT(TS<MAX_TS, "TS not in range");
    131            
    132            if (state)
    133              TSStateTable[TS] |= TS_RX;
    134            else
    135              TSStateTable[TS] &= ~TS_RX;
    136            
    137            return true;
    138          }
    139          
    140          bool TIC_GetTXState(uint8_t TS)
    141          {
    142              if (TS>=MAX_TS)
    143            {
    144              return false;
    145            }
    146            ASSERT_HALT(TS<MAX_TS, "TS not in range");
    147            
    148            return (TSStateTable[TS] & TS_TX) ;
    149          }
    150          
    151          bool TIC_GetRXState(uint8_t TS)
    152          {
    153              if (TS>=MAX_TS)
    154            {
    155              return false;
    156            }
    157            ASSERT_HALT(TS<MAX_TS, "TS not in range");
    158            
    159            return (TSStateTable[TS] & TS_RX) ;
    160          }
    161          
    162          void TIC_SetRXCallback(void (*fn)(uint8_t TS))
    163          {
    164            ASSERT_HALT(fn != NULL, "Fn is NULL");
    165            RXCallback = fn;
    166          }
    167          
    168          void TIC_SetTXCallback(void (*fn)(uint8_t TS))
    169          {
    170            ASSERT_HALT(fn != NULL, "Fn is NULL");
    171            TXCallback = fn;
    172          }
    173          
    174          void TIC_SetSECallback(void (*fn)(uint8_t TS))
    175          {
    176            ASSERT_HALT(fn != NULL, "Fn is NULL");
    177            SECallback = fn;
    178          }
    179          
    180          uint32_t TIC_GetUptime(void)
    181          {
    182            return NODE_UPTIME;
    183          }
    184          
    185          uint32_t TIC_GetRTC(void)
    186          {
    187            return NODE_RTC;
    188          }
    189          
    190          bool TIC_SetRTC(uint32_t RTC)
    191          {
    192            if (RTC >= DAILY_SEC)
    193              return false;
    194            
    195            NODE_RTC = RTC;
    196            return true;
    197          }
    198          
    199          static uint8_t TIC_getCurrentTS(uint16_t ticks)
    200          {
    201            //uint16_t ticks = nt->NT_GetTime();
    202            // Вычисляем количество целых циклов
    203            uint8_t full_slot_num = ticks/FULL_SLOT;
    204            
    205            // Вычисляем остаток от деления. Остаток - смещение внутри
    206            // временного слота.
    207            uint16_t time_remainder = ticks % FULL_SLOT; 
    208            // Если значение внутри интервала 0..TS_ACTIVE. 
    209            if (time_remainder < TS_ACTIVE)
    210              return full_slot_num;
    211            
    212            return NO_TIME_SLOT;
    213          }
    214          
    215          static inline void incrementTS(uint8_t *TS)
    216          {
    217            // Выбираем следующий тайм слот
    218            (*TS)++;
    219            if (*TS >= MAX_TS)
    220              *TS = 0;
    221          }
    222          
    223          static inline void set_capture_time(uint8_t TS)
    224          {
    225            uint16_t ct = FULL_SLOT*(uint16_t)TS;
    226            
    227            LOG(MSG_OFF | MSG_INFO | MSG_TRACE, "Set compare = %d, TS = %d \r\n", ct, TS);
    228            // Установка прерывания на нужный слот
    229            NT_SetCompare(FULL_SLOT*(uint16_t)TS);
    230          }
    231          
    232          static void TIC_TDMAShelduler(uint8_t TS)
    233          {
    234            // Устанавливает прерывание на ближайший активный слот
    235            // Если слот 0 ближе, то на него. 
    236            // Cлот - обработка секундных таймеров 
    237            
    238            // Ищем следующий активный слот или слот 0
    239            incrementTS(&TS);
    240            while ((TS != 0) && !TSStateTable[TS])  
    241              incrementTS(&TS); 
    242            
    243            set_capture_time(TS);
    244          }
    245          
    246          static inline void Callback_execution(void (*fn)(uint8_t TS), uint8_t TS)
    247          {
    248            // Помошник вызова функций. Упрощает проверки
    249            ASSERT_HALT(fn != NULL, "Callback is NULL");
    250            if (fn == NULL)
    251              return;
    252            fn(TS);
    253          }
    254          
    255          static void TIC_HW_Timer_IRQ(uint16_t ticks)
    256          {
    257            // TODO Обработка TS=0xFF
    258            // Номер текущего слота 
    259            uint8_t c_TS = TIC_getCurrentTS(ticks);
    260            
    261            // Обновляем часы NODE_RTC и NODE_UPTIME
    262            if (c_TS == 0)
    263            {
    264              TIM_TimeStamp(&TimeStampTS0); // Первым делом обновим отметку точного времени
    265              clocks_update();
    266            }
    267            // Если что то пошло не так и мы промахнулись мимо слота
    268            // запускаем планировщик заново
    269            if (c_TS == NO_TIME_SLOT)
    270            {
    271              TIC_TDMAShelduler(c_TS);
    272              LOG(MSG_ON | MSG_INFO | MSG_TRACE, "TS = 255 \r\n");
    273              return;
    274            }
    275              
    276            // Вызываем один из указанных обработчиков.
    277            // Передача имеет приоритет над приемом.
    278            if (TSStateTable[c_TS] & TS_TX) 
    279              Callback_execution(TXCallback, c_TS);
    280            else if (TSStateTable[c_TS] & TS_RX)
    281              Callback_execution(RXCallback, c_TS);
    282              
    283            // Вызываем обработчик завершения слота
    284            Callback_execution(SECallback, c_TS);
    285            
    286            // Запускаем планировщик таймера
    287            TIC_TDMAShelduler(c_TS);
    288          }
    289          
    290          static void clocks_update(void)
    291          {
    292            NODE_UPTIME++;
    293            NODE_RTC++;
    294            NODE_NONCE++;
    295            if (NODE_RTC >= DAILY_SEC)
    296              NODE_RTC = 0;
    297          }
    298          
    299          void TIC_SetNonce(uint32_t nonce)
    300          {
    301            NODE_NONCE = nonce;
    302          }
    303          
    304          uint32_t TIC_GetNonce(void)
    305          {
    306            return NODE_NONCE;
    307          }
\\vmware-host\Shared Folders\Projects\WMNU\IAR\PRJ_UNITEST\src\utest.c
      1          #include "utest_suite.h"
      2          #include "nwdebuger.h"
      3          #include "assert.h"
      4          
      5          extern void suite_fbuf(void);
      6          extern void suite_TIC(void);
      7          extern void suite_TIC_HW(void);
      8          extern void suite_MAC(void);
      9          extern void suite_LLC(void);
     10          extern void suite_NT_HW(void);
     11          extern void suite_Frames(void);
     12          extern void suite_RADIO_HW(void);
     13          extern void suite_RADIO(void);
     14          extern void suite_delays_HW(void);
     15          extern void suite_delays(void);
     16          extern void suite_coder(void);
     17          extern void suite_frame(void);
     18          extern void suite_LLC_HW(void);
     19          extern void suite_printf_uart(void);
     20          extern void suite_malloc(void);
     21          
     22          int main()
     23          {
     24            nwDebugerInit();
     25            utestSigTraceInit();
     26            LOG(MSG_ON | MSG_INFO | MSG_TRACE, "Test log output\r\n");
     27            ASSERT(false, "Test assert output\r\n");
     28            
     29            // Вызов функций тестирования
     30            // Аппаратное тестирование
     31            {
     32              //suite_RADIO_HW();
     33              //suite_delays_HW();    //12.11 Работает
     34              //suite_TIC_HW();       //12.11 Работает
     35              //suite_NT_HW();        // 12.11 Работает
     36              suite_LLC_HW();
     37            };
     38            // Юнит тестирование
     39            {
     40              //suite_delays();
     41              //suite_coder();
     42              //suite_fbuf();
     43             // suite_frame();
     44              //suite_RADIO();
     45             // suite_MAC();
     46            // suite_printf_uart();
     47              //suite_malloc();
     48            }
     49          
     50          	//run_utest_framepart();
     51          
     52          // Добавляем результаты тестов
     53          	umsg_summary();
     54           //     while(1);
     55          	return 0;
     56          }
\\vmware-host\Shared Folders\Projects\WMNU\IAR\PRJ_UNITEST\src\utest_coder.c
      1          #include "utest_suite.h"
      2          #include "coder.h"
      3          #include "delays.h"
      4          #include "string.h"
      5          #include "stdio.h"
      6          #include "nwdebuger.h"
      7          
      8          static void aes_test(void)
      9          {
     10            AES_init();
     11            
     12            TimeStamp_s start,stop;
     13            uint32_t passed;
     14            #define max_len 10 
     15            uint8_t data[max_len] = "0123456789";
     16            uint8_t chiper[max_len];
     17            
     18            uint8_t key[16] = {18,11,12,13,14,15,16,17,10,11,12,13,14,15,16,17};
     19            uint8_t nonce[16] = {18,11,12,13,14,15,16,17,10,11,12,13,14,15,16,17};
     20            TIM_init();
     21            
     22            memset(chiper, 0 , max_len);
     23            
     24            TIM_TimeStamp(&start);
     25            AES_StreamCoder(true, data, chiper, key, nonce, max_len);
     26            TIM_TimeStamp(&stop);
     27            passed = TIM_passedTime(&start, &stop);
     28            printf("passed %lu \r\n", passed);
     29            
     30            memset(data, 0 , max_len);
     31            TIM_TimeStamp(&start);
     32            AES_StreamCoder(false, chiper, data, key, nonce, max_len);
     33            TIM_TimeStamp(&stop);
     34            passed = TIM_passedTime(&start, &stop);
     35          
     36            return;
     37          }
     38          
     39          static void CCM_test(void)
     40          {
     41            AES_init();
     42            TIM_init();
     43            
     44            #define DATA_LEN 10
     45            uint8_t data[DATA_LEN];
     46            uint8_t key[16] = {1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16};
     47            uint8_t nonce[16] = {1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16};
     48            uint8_t MIC[4];
     49            
     50            memset(MIC, 0, 4);
     51            for (uint8_t i = 0; i < DATA_LEN; i++)
     52              data[i] = i ;
     53            
     54            AES_CCMEncrypt( data, 7, 3, 1, key, nonce, MIC);
     55            
     56            bool res = AES_CCMDecrypt( data, 7, 3, 1, key, nonce, MIC);
     57          }
     58          
     59          static void single_speed_test(uint8_t *data, uint8_t f, uint8_t c, uint8_t m,
     60                                        uint8_t *key, uint8_t *nonce, uint8_t *MIC)
     61          {
     62            TimeStamp_s start,stop;
     63            TIM_TimeStamp(&start);
     64            AES_CCMEncrypt( data, f, c , m, key, nonce, MIC);
     65            TIM_TimeStamp(&stop);
     66            uint32_t time = TIM_passedTime(&start, &stop);
     67            LOG(MSG_ON | MSG_INFO | MSG_TRACE, "m=%d f=%d c=%d. Time = %lu\n",
     68                m, f, c, time);
     69          }
     70          
     71          static void CCM_speed_test(void)
     72          {
     73            #define SPEED_DATA_LEN 100
     74            uint8_t data[SPEED_DATA_LEN];
     75          
     76            uint8_t key[16] = {1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16};
     77            uint8_t nonce[16] = {1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16};
     78            uint8_t MIC[16];
     79          
     80            AES_init();
     81            TIM_init();
     82            
     83            for (uint8_t i = 10 ; i <= 50 ; i +=10)
     84              single_speed_test(data, i, 10, 1, key, nonce, MIC);
     85            
     86            for (uint8_t i = 10 ; i <= 50 ; i +=10)
     87              single_speed_test(data, 10, i, 1, key, nonce, MIC);
     88            
     89            for (uint8_t i = 10 ; i <= 50 ; i +=10)
     90              single_speed_test(data, i, 10, 2, key, nonce, MIC);
     91            
     92            for (uint8_t i = 10 ; i <= 50 ; i +=10)
     93              single_speed_test(data, 10, i, 2, key, nonce, MIC);
     94          }
     95          
     96          static bool single_enc_dec_test(uint8_t *data, uint8_t f, uint8_t c, uint8_t m,
     97                                        uint8_t *key, uint8_t *nonce, uint8_t *MIC)
     98          {
     99            AES_CCMEncrypt( data, f, c, m, key, nonce, MIC);  
    100            bool res = AES_CCMDecrypt( data, f, c, m, key, nonce, MIC); 
    101            return res;
    102          }
    103          
    104          static void CCM_code_decode_test(void)
    105          {
    106            #define CODE_DATA_LEN 128
    107            uint8_t data[CODE_DATA_LEN];
    108          
    109            uint8_t key[16] = {1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16};
    110            uint8_t nonce[16] = {1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16};
    111            uint8_t MIC[16];
    112          
    113            AES_init();
    114            TIM_init();  
    115            
    116            bool res;
    117           
    118            LOG(MSG_ON | MSG_INFO | MSG_TRACE, "CCM full size test 60 sec\n");
    119            
    120            res = true;
    121            for (uint8_t m = 0; m < 3; m++)
    122              for (uint8_t f = 0; f < 128 ; f++)
    123                for (uint8_t c = 0; c < (128 - f) ; c++) 
    124                {
    125                  res = res && single_enc_dec_test(data, f, c, m, key, nonce, MIC);
    126                  if (res)
    127                    continue;
    128                  
    129                  LOG(MSG_ON | MSG_INFO | MSG_TRACE, 
    130                      "Coder test stub on m=%d f=%d c=%d \n", m, f, c);
    131                  break;
    132                }
    133            umsg("coder", "CCM full coder test", res == true);
    134            
    135            res = single_enc_dec_test(data, 10, 10, 1, key, nonce, MIC);
    136          }
    137          
    138          static void mem_control(void)
    139          {
    140            #define MEM_CNTR_SIZE 10
    141            #define MAGIC_NUM 0x73
    142            
    143            uint8_t key[16] = {1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16};
    144            uint8_t nonce[16] = {1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16};
    145            
    146            struct 
    147            {
    148              uint8_t cnt_byte1;
    149              uint8_t data[MEM_CNTR_SIZE];
    150              uint8_t cnt_byte2;
    151            } __attribute__((packed)) data_struct;
    152           
    153              struct 
    154            {
    155              uint8_t cnt_byte1;
    156              uint8_t key[16];
    157              uint8_t cnt_byte2;
    158            } __attribute__((packed)) key_struct;
    159            
    160            struct 
    161            {
    162              uint8_t cnt_byte1;
    163              uint8_t nonce[16];
    164              uint8_t cnt_byte2;
    165            } __attribute__((packed)) nonce_struct;
    166            
    167            struct 
    168            {
    169              uint8_t cnt_byte1;
    170              uint8_t MIC[16];
    171              uint8_t cnt_byte2;
    172            } __attribute__((packed)) mic_struct;
    173            
    174            AES_init();
    175            TIM_init();
    176            
    177            data_struct.cnt_byte1 = MAGIC_NUM;
    178            data_struct.cnt_byte2 = MAGIC_NUM;
    179            key_struct.cnt_byte1 = MAGIC_NUM;  
    180            key_struct.cnt_byte2 = MAGIC_NUM;
    181            nonce_struct.cnt_byte1 = MAGIC_NUM;  
    182            nonce_struct.cnt_byte2 = MAGIC_NUM;
    183            mic_struct.cnt_byte1 = MAGIC_NUM;  
    184            mic_struct.cnt_byte2 = MAGIC_NUM;
    185            
    186            memcpy(key_struct.key , key, 16);
    187            memcpy(nonce_struct.nonce , nonce, 16);
    188            for (uint8_t i = 0; i < MEM_CNTR_SIZE; i++)
    189              data_struct.data[i] = i;
    190          
    191            for (uint8_t i = 0; i < 16; i++)
    192            {
    193              key_struct.key[i] = i + 100;
    194              nonce_struct.nonce[i] = i + 200;
    195            }
    196            
    197            AES_CCMEncrypt( data_struct.data, 5, MEM_CNTR_SIZE - 5, 1, key_struct.key,
    198                           nonce_struct.nonce, mic_struct.MIC);  
    199            
    200            bool data_mem_corrupt = false;
    201            bool key_mem_corrupt = false;
    202            bool nonce_mem_corrupt = false;
    203            bool mic_mem_corrupt = false;
    204            if ((data_struct.cnt_byte1 != MAGIC_NUM) || 
    205                (data_struct.cnt_byte2 != MAGIC_NUM))
    206            data_mem_corrupt = true;
    207            if ((key_struct.cnt_byte1 != MAGIC_NUM) || 
    208                (key_struct.cnt_byte2 != MAGIC_NUM))
    209            key_mem_corrupt = true;
    210            if ((nonce_struct.cnt_byte1 != MAGIC_NUM) || 
    211                (nonce_struct.cnt_byte2 != MAGIC_NUM))
    212            nonce_mem_corrupt = true;  
    213            if ((mic_struct.cnt_byte1 != MAGIC_NUM) || 
    214                (mic_struct.cnt_byte2 != MAGIC_NUM))
    215            mic_mem_corrupt = true;  
    216            
    217            umsg("coder", "CCM coder corrupt data memory", data_mem_corrupt == false);
    218            umsg("coder", "CCM coder corrupt key memory", key_mem_corrupt == false);
    219            umsg("coder", "CCM coder corrupt nonce memory", nonce_mem_corrupt == false);
    220            umsg("coder", "CCM coder corrupt mic memory", mic_mem_corrupt == false);
    221            
    222            
    223            data_struct.cnt_byte1 = MAGIC_NUM;
    224            data_struct.cnt_byte2 = MAGIC_NUM;
    225            key_struct.cnt_byte1 = MAGIC_NUM;  
    226            key_struct.cnt_byte2 = MAGIC_NUM;
    227            nonce_struct.cnt_byte1 = MAGIC_NUM;  
    228            nonce_struct.cnt_byte2 = MAGIC_NUM;
    229            mic_struct.cnt_byte1 = MAGIC_NUM;  
    230            mic_struct.cnt_byte2 = MAGIC_NUM;
    231            
    232            bool res = AES_CCMDecrypt( data_struct.data, 5, MEM_CNTR_SIZE - 5, 1, key_struct.key,
    233                           nonce_struct.nonce, mic_struct.MIC); 
    234            
    235            if ((data_struct.cnt_byte1 != MAGIC_NUM) || 
    236                (data_struct.cnt_byte2 != MAGIC_NUM))
    237            data_mem_corrupt = true;
    238            if ((key_struct.cnt_byte1 != MAGIC_NUM) || 
    239                (key_struct.cnt_byte2 != MAGIC_NUM))
    240            key_mem_corrupt = true;
    241            if ((nonce_struct.cnt_byte1 != MAGIC_NUM) || 
    242                (nonce_struct.cnt_byte2 != MAGIC_NUM))
    243            nonce_mem_corrupt = true;  
    244            if ((mic_struct.cnt_byte1 != MAGIC_NUM) || 
    245                (mic_struct.cnt_byte2 != MAGIC_NUM))
    246            mic_mem_corrupt = true;
    247          
    248            umsg("coder", "CCM decoder corrupt data memory", data_mem_corrupt == false);
    249            umsg("coder", "CCM decoder corrupt key memory", key_mem_corrupt == false);
    250            umsg("coder", "CCM decoder corrupt nonce memory", nonce_mem_corrupt == false);
    251            umsg("coder", "CCM decoder corrupt mic memory", mic_mem_corrupt == false);
    252            
    253            bool not_changed = true;
    254            for (uint8_t i = 0; i < MEM_CNTR_SIZE; i++)
    255              if (data_struct.data[i] != i)
    256                not_changed = true;
    257            umsg("coder", "CCM decoded data correct", not_changed == true);
    258              
    259            for (uint8_t i = 0; i < 16; i++)
    260              if (key_struct.key[i] != i + 100)
    261                not_changed = true;
    262            umsg("coder", "CCM key data correct", not_changed == true);  
    263           
    264            for (uint8_t i = 0; i < 16; i++)
    265              if (nonce_struct.nonce[i] != i + 200)
    266                not_changed = true;
    267            umsg("coder", "CCM nonce data correct", not_changed == true); 
    268          }
    269          
    270          //  umsg("FChain", "TODO memory malloc and free", false);
    271          void suite_coder(void)
    272          {
    273            umsg_line("coder module");
    274          //  CCM_speed_test();
    275            mem_control();
    276            CCM_code_decode_test();
    277            CCM_test();
    278            aes_test();
    279          }
\\vmware-host\Shared Folders\Projects\WMNU\IAR\PRJ_UNITEST\src\utest_delays.c
      1          #include "delays.h"
      2          #include "utest_suite.h"
      3          
      4          static void alg_test(void)
      5          {
      6            TIM_init();
      7            
      8            uint32_t passed;
      9            TimeStamp_s start, stop;
     10           
     11            TIM_TimeStamp(&start);
     12            TIM_TimeStamp(&stop);
     13            passed = TIM_passedTime(&start, &stop);
     14            umsg("delays", "TIM_passedTimeNs meas add op ", passed  < 10);
     15          }
     16          
     17          static void manual(void)
     18          {
     19            TIM_init();
     20            
     21            uint32_t passed;
     22            TimeStamp_s start, stop;
     23            
     24            //Это ручная проверка работы модуля
     25            TIM_TimeStamp(&start);
     26            TIM_delay(500);
     27            TIM_TimeStamp(&stop);
     28            passed = TIM_passedTime(&start, &stop);
     29            umsg("delays", "TIM_passedTimeNs meas add op ", passed  < 10);
     30            
     31            TIM_TimeStamp(&start);
     32            TIM_delay(60*Tsec);
     33            TIM_TimeStamp(&stop);
     34            passed = TIM_passedTime(&start, &stop);
     35            umsg("delays", "TIM_passedTimeNs meas add op ", passed  < 10);
     36          }
     37          
     38          void suite_delays_HW(void)
     39          {
     40            //umsg_line("delays module");
     41            manual();
     42          }
     43          
     44          
     45          void suite_delays(void)
     46          {
     47            umsg_line("delays module");
     48            alg_test();
     49          }
\\vmware-host\Shared Folders\Projects\WMNU\IAR\PRJ_UNITEST\src\utest_fbuf.c
      1          #include "utest_suite.h"
      2          #include "fbuf.h"
      3          #include "Net_frames.h"
      4          
      5          static void test_create(void)
      6          { 
      7            fbuf_s *fb = fbuf_create(FB_ETH_LAY, NULL, NULL);
      8            umsg("fbuf", "fbuf FB_ETH_LAY created", fb != NULL);
      9            umsg("fbuf", "fbuf FB_ETH_LAY lenght", fb->len == ETH_LAY_SIZE);
     10            fbuf_delete(fb);
     11           
     12            fb = fbuf_create(FB_IP_LAY, NULL, NULL);
     13            umsg("fbuf", "fbuf FB_IP_LAY created", fb != NULL);
     14            umsg("fbuf", "fbuf FB_IP_LAY lenght", fb->len == IP_LAY_SIZE);
     15            fbuf_delete(fb);
     16            
     17            fb = fbuf_create(FB_SYNC_LAY, NULL, NULL);
     18            umsg("fbuf", "fbuf FB_SYNC_LAY created", fb != NULL);
     19            umsg("fbuf", "fbuf FB_SYNC_LAY lenght", fb->len == SYNC_LAY_SIZE);
     20            fbuf_delete(fb);
     21          }
     22          
     23          static void test_logic(void)
     24          {
     25            fbuf_s *fb1 = fbuf_create(FB_ETH_LAY, NULL, NULL);
     26            fbuf_s *fb2 = fbuf_create(FB_IP_LAY, NULL, NULL);
     27            fbuf_s *fb3 = fbuf_create(FB_SYNC_LAY, NULL, NULL);
     28            
     29            fbuf_chain(fb1, fb2);
     30            fbuf_chain(fb2, fb3);
     31            
     32            umsg("fbuf", "chain fb1 -> fb2", fb1->next == fb2);
     33            umsg("fbuf", "chain fb2 -> fb3", fb2->next == fb3);
     34            umsg("fbuf", "chain fb3 next NULL", fb3->next == NULL);
     35            
     36            fbuf_s *iterator = fb1;
     37            umsg("fbuf", "iterator = fb1", iterator == fb1);
     38            
     39            iterator = fbuf_next(iterator);
     40            umsg("fbuf", "iterator = fb2", iterator == fb2);
     41            
     42            iterator = fbuf_next(iterator);
     43            umsg("fbuf", "iterator = fb3", iterator == fb3);
     44            
     45            iterator = fbuf_next(iterator);
     46            umsg("fbuf", "iterator = NULL", iterator == NULL);
     47            
     48            fbuf_delete(fb1);
     49            fbuf_delete(fb2);
     50            fbuf_delete(fb3);
     51          }
     52          
     53          static void raw_data_test(void)
     54          {
     55            #define RAW_LEN 100 
     56            uint8_t data[RAW_LEN];
     57            
     58            for (uint8_t i = 0; i < RAW_LEN; i++)
     59              data[i] = i;
     60            
     61            fbuf_s *fb = fbuf_create(FB_RAW_LAY, data, RAW_LEN);
     62            bool flag = memory_compare((char*)data, fb->payload, RAW_LEN);
     63            umsg("fbuf", "FB_RAW_LAY mem is equal", flag == true);
     64            
     65            ((uint8_t*)fb->payload)[6] = 10;
     66            flag = memory_compare((char*)data, fb->payload, RAW_LEN);
     67            umsg("fbuf", "FB_RAW_LAY mem is not qual", flag == false);
     68            
     69            umsg("fbuf", "FB_RAW_LAY len is equal", fb->len == RAW_LEN);
     70            fbuf_delete(fb);
     71          }
     72          
     73          static void delete_test(void)
     74          {
     75            fbuf_s *fb = fbuf_create(FB_SYNC_LAY, NULL, NULL);
     76            fbuf_delete(fb);
     77            fbuf_s *fb1 = fbuf_create(FB_SYNC_LAY, NULL, NULL);
     78            umsg("fbuf", "fbuf_delete", fb == fb1);
     79          }
     80          
     81          void suite_fbuf(void)
     82          {
     83            umsg_line("fbuf module");
     84            test_create();
     85            delete_test();
     86            raw_data_test();
     87            test_logic();
     88          }
\\vmware-host\Shared Folders\Projects\WMNU\IAR\PRJ_UNITEST\src\utest_frame.c
      1          #include "utest_suite.h"
      2          #include "frame.h"
      3          #include "Net_frames.h"
      4          #include "stdbool.h"
      5          
      6          static void insert1_test(void)
      7          {
      8            fbuf_s *fb1 = fbuf_create(FB_ETH_LAY, NULL, NULL);
      9            
     10            frame_s* fr = frame_create();
     11            frame_insert_head(fr, fb1);
     12            umsg("frame", "Insert head. head = fb1", fr->head == fb1);
     13            umsg("frame", "Insert head. tail = fb1", fr->tail == fb1);
     14            frame_delete(fr);
     15          }
     16          
     17          static void insert2_test(void)
     18          {
     19            fbuf_s *fb1 = fbuf_create(FB_ETH_LAY, NULL, NULL);
     20            
     21            frame_s *fr = frame_create();
     22            frame_insert_tail(fr, fb1);
     23            umsg("frame", "Insert tail. head = fb1", fr->head == fb1);
     24            umsg("frame", "Insert tail. tail = fb1", fr->tail == fb1);
     25            frame_delete(fr);
     26          }
     27          
     28          static void insert3_test(void)
     29          {
     30            fbuf_s *fb1 = fbuf_create(FB_ETH_LAY, NULL, NULL);
     31            fbuf_s *fb2 = fbuf_create(FB_IP_LAY, NULL, NULL);
     32            fbuf_s *fb3 = fbuf_create(FB_SYNC_LAY, NULL, NULL);
     33          
     34            frame_s *fr = frame_create();
     35            frame_insert_head(fr, fb1);
     36            frame_insert_head(fr, fb2);
     37            frame_insert_head(fr, fb3);
     38            
     39            fbuf_s *iterator = frame_get_fbuf_head(fr);
     40            umsg("frame", "iterator = fb3", iterator == fb3);
     41            
     42            iterator = fbuf_next(iterator);
     43            umsg("frame", "iterator = fb2", iterator == fb2);
     44            
     45            iterator = fbuf_next(iterator);
     46            umsg("frame", "iterator = fb1", iterator == fb1); 
     47            
     48            iterator = fbuf_next(iterator);
     49            umsg("frame", "iterator = NULL", iterator == NULL);
     50            
     51            fbuf_s *tail = frame_get_fbuf_tail(fr);
     52            umsg("frame", "iterator = fb1", tail == fb1);
     53            
     54            frame_delete(fr);
     55          
     56          }
     57          
     58          static void delete_test(void)
     59          {
     60            // Тест основан на том что malloc выделит ранее освобожденные
     61            // участки памяти после освобождения памяти. 
     62            fbuf_s *fb01 = fbuf_create(FB_ETH_LAY, NULL, NULL);
     63            fbuf_s *fb02 = fbuf_create(FB_ETH_LAY, NULL, NULL);
     64            fbuf_s *fb03 = fbuf_create(FB_ETH_LAY, NULL, NULL);
     65            fbuf_s *fb04 = fbuf_create(FB_ETH_LAY, NULL, NULL);
     66            
     67            frame_s *fr = frame_create();
     68            frame_insert_head(fr, fb01);
     69            frame_insert_head(fr, fb02);
     70            frame_insert_head(fr, fb03);
     71            frame_insert_head(fr, fb04);
     72            frame_delete(fr);
     73            
     74            fbuf_s *fb11 = fbuf_create(FB_ETH_LAY, NULL, NULL);
     75            fbuf_s *fb12 = fbuf_create(FB_ETH_LAY, NULL, NULL);
     76            fbuf_s *fb13 = fbuf_create(FB_ETH_LAY, NULL, NULL);
     77            fbuf_s *fb14 = fbuf_create(FB_ETH_LAY, NULL, NULL);
     78            
     79            umsg("frame", "delete test. fb1", fb01 == fb11);
     80            umsg("frame", "delete test. fb2", fb02 == fb12);
     81            umsg("frame", "delete test. fb3", fb03 == fb13);
     82            umsg("frame", "delete test. fb4", fb04 == fb14);
     83            
     84            fbuf_delete(fb11);
     85            fbuf_delete(fb12);
     86            fbuf_delete(fb13);
     87            fbuf_delete(fb14);
     88            fbuf_delete(fb01);
     89            fbuf_delete(fb02);
     90            fbuf_delete(fb03);
     91            fbuf_delete(fb04);
     92          }
     93          
     94          static void insert4_test(void)
     95          {
     96            fbuf_s *fb1 = fbuf_create(FB_ETH_LAY, NULL, NULL);
     97            fbuf_s *fb2 = fbuf_create(FB_IP_LAY, NULL, NULL);
     98            fbuf_s *fb3 = fbuf_create(FB_SYNC_LAY, NULL, NULL);
     99          
    100            frame_s *fr = frame_create();
    101            frame_insert_tail(fr, fb1);
    102            frame_insert_tail(fr, fb2);
    103            frame_insert_tail(fr, fb3);
    104            
    105            fbuf_s *iterator = frame_get_fbuf_head(fr);
    106            umsg("frame", "iterator = fb1", iterator == fb1);
    107            
    108            iterator = fbuf_next(iterator);
    109            umsg("frame", "iterator = fb2", iterator == fb2);
    110            
    111            iterator = fbuf_next(iterator);
    112            umsg("frame", "iterator = fb3", iterator == fb3); 
    113            
    114            iterator = fbuf_next(iterator);
    115            umsg("frame", "iterator = NULL", iterator == NULL);
    116            
    117            fbuf_s *tail = frame_get_fbuf_head(fr);
    118            umsg("frame", "iterator = fb1", tail == fb1);
    119            
    120            frame_delete(fr);
    121          }
    122          
    123          static void tot_len_test(void)
    124          {
    125            uint8_t tmp[10];
    126            fbuf_s *fb1 = fbuf_create(FB_ETH_LAY, NULL, NULL);
    127            fbuf_s *fb2 = fbuf_create(FB_IP_LAY, NULL, NULL);
    128            fbuf_s *fb3 = fbuf_create(FB_SYNC_LAY, NULL, NULL);
    129            fbuf_s *fb4 = fbuf_create(FB_RAW_LAY, tmp, sizeof(tmp));
    130            
    131            frame_s *fr = frame_create();
    132            frame_insert_tail(fr, fb1);
    133            frame_insert_tail(fr, fb2);
    134            frame_insert_tail(fr, fb3);
    135            frame_insert_tail(fr, fb4);
    136            
    137            uint8_t data_len = ETH_LAY_SIZE + IP_LAY_SIZE + SYNC_LAY_SIZE + sizeof(tmp);
    138            uint8_t tot_len = frame_len(fr);
    139            umsg("frame", "frame_len calc", tot_len == data_len);
    140            frame_delete(fr);
    141          }
    142          
    143          static void test_frame_merge(void)
    144          {
    145            uint8_t data[10] = {0,1,2,3,4,5,6,7,8,9};
    146            uint8_t len;
    147            
    148            fbuf_s *fb = fbuf_create(FB_RAW_LAY, data, sizeof(data));
    149            frame_s *fr = frame_create();
    150            frame_insert_tail(fr, fb);
    151            uint8_t *raw_data = frame_merge(fr, &len);
    152            
    153            bool test_res;
    154            test_res = memory_compare((char*)raw_data, (char*)data, sizeof(data));
    155            umsg("frame", "Memory corr", test_res == true);
    156          }
    157          
    158          void suite_frame(void)
    159          {
    160            umsg_line("fbuf module");
    161            test_frame_merge();
    162            tot_len_test();
    163            delete_test();
    164            insert1_test();
    165            insert2_test();
    166            insert3_test();
    167            insert4_test();  
    168          }
\\vmware-host\Shared Folders\Projects\WMNU\IAR\PRJ_UNITEST\src\utest_Frames.c
      1          #include "utest_suite.h"
      2          #include "string.h"
      3          #include "frame.h"
      4          #include "stdio.h"
      5          
      6          void suite_Frames(void)
      7          {
      8            umsg_line("Frames module");
      9          
     10          }
\\vmware-host\Shared Folders\Projects\WMNU\IAR\PRJ_UNITEST\src\utest_LLC.c
      1          #include "utest_suite.h"
      2          #include "LLC.h"
      3          #include "NTMR.h"
      4          #include "nwdebuger.h"
      5          #include "ioCC2530.h"
      6          #include "frame.h"
      7          #include "RADIO.h"
      8          #include "TIC.h"
      9          #include "stdlib.h"
     10          
     11          static void timealloc(void)
     12          {
     13            static bool led_stat = false;
     14              LED(D1, led_stat);
     15              led_stat = !led_stat;
     16          }
     17          
     18          static frame_s* getFrame(uint8_t *src, uint8_t len, uint8_t CH, uint8_t TS)
     19          {
     20            frame_s *fr;
     21            EA=0;
     22            fr = frame_create();
     23            
     24            fbuf_s *fb = fbuf_create(FB_RAW_LAY, src, len);
     25            EA=1;
     26            fr->meta.SEND_TIME = 0;
     27            fr->meta.TS = TS;
     28            fr->meta.CH = CH;
     29            frame_insert_head(fr, fb);
     30            return fr;
     31          }
     32          
     33          static void show_heap_ptr(void)
     34          { 
     35            uint16_t *heap_ptr;
     36            heap_ptr = (uint16_t*)malloc(1);
     37            LOG(MSG_ON | MSG_INFO | MSG_TRACE, "HEAP_PTR = %d\r\n", (uint16_t)heap_ptr ); 
     38            free(heap_ptr);
     39          }
     40          
     41          static void test_create()
     42          {
     43            LLC_Init();
     44            LLC_TimeAlloc(timealloc);
     45            EA = 1;
     46            uint8_t DATA_SEND[10] = {0,1,2,3,4,5,6,7,8,9};  
     47            
     48            frame_s *fr;
     49            
     50            uint16_t TS = 0;
     51            uint8_t *ptr_stack = (uint8_t*)0x100;
     52            
     53            fr = getFrame(DATA_SEND, sizeof(DATA_SEND), CH11, TS);
     54            uint16_t fr_size = sizeof(frame_s);
     55            uint16_t bf_size = frame_len(fr);
     56            uint16_t HEAP_PTR_MAX = 0;
     57            uint16_t *heap_ptr;
     58            uint8_t nbr_bufs, nbr_frames;
                           ^
Warning[Pe550]: variable "nbr_bufs" was set but never used
          detected during compilation of secondary translation unit
                    "\\vmware-host\Shared
                    Folders\Projects\WMNU\IAR\PRJ_UNITEST\src\utest_LLC.c"

    uint8_t nbr_bufs, nbr_frames;
                      ^
"\\vmware-host\Shared Folders\Projects\WMNU\IAR\PRJ_UNITEST\src\utest_LLC.c",58  Warning[Pe550]: 
          variable "nbr_frames" was set but never used
          detected during compilation of secondary translation unit
                    "\\vmware-host\Shared
                    Folders\Projects\WMNU\IAR\PRJ_UNITEST\src\utest_LLC.c"
     59            
     60            LOG(MSG_ON | MSG_INFO | MSG_TRACE, 
     61                "Frame_s size = %d. Fbuf data = %d. Full =%d\r\n",
     62                fr_size, bf_size, bf_size+fr_size );
     63            frame_delete(fr);
     64            
     65            while(true)
     66            {  
     67              nbr_bufs = fbuf_getCount();
     68              nbr_frames = frame_getCount();
     69              if (LLC_GetTaskLen() < 20)
     70              {
     71                    fr = getFrame(DATA_SEND, sizeof(DATA_SEND), CH11, TS);
     72                  LOG(MSG_OFF | MSG_INFO | MSG_TRACE, "Create frame = %d.\r\n", (uint16_t)fr);    
     73                    LLC_AddTask(fr);
     74                    TS ++;
     75                    if (TS == 49)
     76                      TS = 0;
     77              }   
     78              if (*ptr_stack != 0xcd) // Контроль переполнения стека
     79                while(1);
     80              EA=0;
     81              heap_ptr = (uint16_t*)malloc(1);
     82              EA=1;
     83              if ((uint16_t)heap_ptr > HEAP_PTR_MAX)
     84              {
     85                HEAP_PTR_MAX = (uint16_t)heap_ptr;
     86                LOG(MSG_ON | MSG_INFO | MSG_TRACE, 
     87                "HEAP_PTR = %d\r\n", HEAP_PTR_MAX );
     88              }
     89              EA=0;
     90              free(heap_ptr);
     91              EA=1;
     92            }
     93            
     94          }
     95          
     96          static void find_mem_problem(void)
     97          {
     98            LLC_Init();
     99            LLC_TimeAlloc(timealloc);
    100            EA = 1;
    101            uint8_t DATA_SEND[10] = {0,1,2,3,4,5,6,7,8,9};  
    102            
    103            frame_s *fr;
    104            
    105            uint16_t TS = 0;
    106            uint8_t *ptr_stack = (uint8_t*)0x100;
    107            
    108            uint16_t HEAP_PTR_MAX = 0;
                            ^
Warning[Pe177]: variable "HEAP_PTR_MAX" was declared but never referenced
          detected during compilation of secondary translation unit
                    "\\vmware-host\Shared
                    Folders\Projects\WMNU\IAR\PRJ_UNITEST\src\utest_LLC.c"
    109            uint16_t *heap_ptr;
                             ^
Warning[Pe177]: variable "heap_ptr" was declared but never referenced
          detected during compilation of secondary translation unit
                    "\\vmware-host\Shared
                    Folders\Projects\WMNU\IAR\PRJ_UNITEST\src\utest_LLC.c"
    110            
    111            while(true)
    112            {  
    113              if (fbuf_getCount() == 0)
    114              {
    115                show_heap_ptr();
    116                for (uint8_t i = 0; i < 20 ; i++)
    117                {
    118                    fr = getFrame(DATA_SEND, sizeof(DATA_SEND), CH11, TS);
    119                    TS++;
    120                    if (TS == 49)
    121                      TS = 0;
    122                    LLC_AddTask(fr);
    123                }
    124              }   
    125              
    126              if (*ptr_stack != 0xcd) // Контроль переполнения стека
    127                while(1);
    128            }
    129            
    130            
    131          }
    132          
    133          // Тест на максимальное количество фреймов 
    134          static void test_mem(void)
    135          {
    136            frame_s *FR[150];
                            ^
Warning[Pe550]: variable "FR" was set but never used
          detected during compilation of secondary translation unit
                    "\\vmware-host\Shared
                    Folders\Projects\WMNU\IAR\PRJ_UNITEST\src\utest_LLC.c"
    137            uint8_t DATA_SEND[10] = {0,1,2,3,4,5,6,7,8,9}; 
    138            
    139            for (uint8_t i = 0; i < 105; i++) 
    140              FR[i] = getFrame(DATA_SEND, sizeof(DATA_SEND), CH11, 5);
    141          }
    142          
    143          
    144          void suite_LLC_HW(void)
    145          {
    146           // umsg_line("LLC module");
    147            
    148            // Устанавливает и поддерживает в очереде 10 пакетов.
    149            // Мигает зеленым светодиодом. В TS0 включается, в TS5 выключаеться
    150           // test_mem();
    151           // find_mem_problem();
    152            test_create();  
    153          }
\\vmware-host\Shared Folders\Projects\WMNU\IAR\PRJ_UNITEST\src\utest_MAC.c
      1          #include "utest_suite.h"
      2          #include "MAC.h"
      3          #include "frame.h"
      4          #include "delays.h"
      5          #include "nwdebuger.h"
      6          #include "ioCC2530.h"
      7          
      8          static void test_ACK_SEND(void)
      9          {
     10            MAC_Init();
     11            
     12            bool res;
     13            uint8_t DATA_SEND[10] = {0,1,2,3,4,5,6,7,8,9};
     14            TimeStamp_s start, stop;
     15          while(1)
     16          {
     17            // Подготовим данные к отправке
     18            frame_s *fr = frame_create();
     19            fbuf_s *fb = fbuf_create(FB_RAW_LAY, DATA_SEND, sizeof(DATA_SEND));
     20            fr->meta.SEND_TIME = 0;
     21            fr->meta.CH = CH11;
     22            frame_insert_head(fr, fb);
     23             
     24            // Нам не важно что структура не соотетсвует ACK. Важно чтоб пакет ушел
     25            TIM_TimeStamp(&start);
     26            res = MAC_ACK_Send(fr);
     27            TIM_TimeStamp(&stop);
     28            uint32_t passed = TIM_passedTime(&start, &stop);
     29            LOG(MSG_ON | MSG_INFO | MSG_TRACE, 
     30                "MAC_ACK_Send time = %lu. Success %d \n", passed, res);
     31          }
     32          }
     33          
     34          static void stub_se(uint8_t ts)
     35          {
     36          }
     37          
     38          static void test_TS_Send(void)
     39          {
     40            MAC_Init();
     41            TIC_SetSECallback(stub_se);
     42            EA = 1;
     43            uint8_t DATA_SEND[10] = {0,1,2,3,4,5,6,7,8,9};  
     44            uint8_t TS = 5, attempts = 3;
     45            
     46            frame_s *fr; 
     47            
     48            while (true)
     49            {
     50              if (!MAC_GetTXState(TS))
     51              {
     52                fr = frame_create();
     53                fbuf_s *fb = fbuf_create(FB_RAW_LAY, DATA_SEND, sizeof(DATA_SEND));
     54                fr->meta.SEND_TIME = 0;
     55                fr->meta.TS = TS;
     56                fr->meta.CH = CH11;
     57                frame_insert_head(fr, fb);
     58                MAC_Send(fr, attempts);
     59                LOG(MSG_ON | MSG_INFO | MSG_TRACE, "Frame puted to MAC layer at %lu sec\n", TIC_GetRTC());
     60              }
     61            }
     62          }
     63          
     64          void suite_MAC(void)
     65          {
     66            // test_TS_Send отсылает пакеты по расписанию тайм слотов
     67            // Нужно запрограмировать второе устройство RadioRecvTest1
     68            // тогда будет гореть светодиод при приеме сигнала
     69            test_TS_Send(); 
     70            test_ACK_SEND();
     71          }
\\vmware-host\Shared Folders\Projects\WMNU\IAR\PRJ_UNITEST\src\utest_malloc.c
      1          #include "utest_suite.h"
      2          #include "stdlib.h"
      3          
      4          static  uint16_t getMallocSize(void *ptr)
      5          {
      6            uint16_t *size = (uint16_t*)ptr - 1;
      7            return *size-2;
      8          }
      9          
     10          
     11          static void test_1(void)
     12          {
     13            // Проверка как хранит размер памяти фун-я маллок
     14            // Перед указатель выделяется 2 байта и длинна на 2 байта увеличиается
     15            void *ptr_1 = malloc(0x32);
     16            void *ptr_2 = malloc(0x78);
     17            uint16_t size_1 = getMallocSize(ptr_1);
     18            uint16_t size_2 = getMallocSize(ptr_2);
     19          }
     20          
     21          void suite_malloc(void)
     22          {
     23           // umsg_line("LLC module");
     24            
     25            // Устанавливает и поддерживает в очереде 10 пакетов.
     26            // Мигает зеленым светодиодом. В TS0 включается, в TS5 выключаеться
     27            test_1();  
     28          }
\\vmware-host\Shared Folders\Projects\WMNU\IAR\PRJ_UNITEST\src\utest_NTMR.c
      1          #include "utest_suite.h"
      2          #include "NTMR.h"
      3          #include "ioCC2530.h"
      4          
      5          static bool finised;
      6          
      7          static inline bool isNear(uint16_t A, uint16_t B, uint16_t x)
      8          {
      9            if (A>B)
     10              A = A - B;
     11            else
     12              A = B - A;
     13            if (A<=x)
     14              return true;
     15            return false;
     16          }
     17          
     18          
     19          static void TimerHndl(uint16_t ticks)
     20          {    
     21            if (isNear(ticks, 0 , 3))
     22            {
     23              NT_SetCompare(1000);
     24              P0_0 = 1;
     25              P0_0 = 0;
     26            }
     27            else if (isNear(ticks, 1000 , 3))
     28            {
     29              NT_SetCompare(2000);
     30              P0_0 = 1;
     31              P0_0 = 0;
     32            }
     33            else if (isNear(ticks, 2000 , 3))
     34            {
     35              NT_SetCompare(25000);
     36              P0_0 = 1;
     37              P0_0 = 0;
     38            }  
     39            else if (isNear(ticks, 25000 , 3))
     40            {
     41              NT_SetCompare(26000);
     42              P0_0 = 1;
     43              P0_0 = 0;
     44            }
     45            else if (isNear(ticks, 26000 , 3))
     46            {
     47              NT_SetCompare(27000);
     48              P0_0 = 1;
     49              P0_0 = 0;
     50            }
     51            else if (isNear(ticks, 27000 , 3))
     52            {
     53              P0_0 = 1;
     54              P0_0 = 0;
     55              finised = true;
     56            }                    
     57          }
     58          
     59          /** 
     60          @brief Тестирование алгоритмов которые нельзя вынести из модуля 
     61          @deails Использует вывод P0_0 для индикации работы таймера
     62           Генерирует импульсы при каждом срабатывании. Нужно настроить логический
     63           анализатор на высокую частоту и работать с 1 каналом, иначе импульсы
     64           проглатывает.
     65          */
     66          static void alg_test(void)
     67          {
     68            EA = 1;
     69          
     70            P0DIR = 0x01;
     71            P0_0 = 0;
     72            
     73            NT_Init();
     74            NT_SetEventCallback(TimerHndl);
     75            
     76            // Тут поставить точку останова и запустить анализатор
     77            // Вы должны увидеть 6 импульсов. Измерения по переднему фронту
     78            // Работаем на внутреннем RC генераторе
     79            // И0-И1 30.508мс
     80            // И1-И2 30.521мс
     81            for (uint16_t i = 0 ; i < 1000; i++)
     82            {
     83              finised = false;
     84              NT_SetCompare(0);
     85              while (!finised);
     86            }
     87            // Тут поставить точку останова
     88          }
     89          
     90          void suite_NT_HW(void)
     91          {
     92            //umsg_line("NTMR module");
     93            alg_test();
     94          }
\\vmware-host\Shared Folders\Projects\WMNU\IAR\PRJ_UNITEST\src\utest_printf_uart.c
      1          #include "nwdebuger.h"
      2          #include "utest_suite.h"
      3          #include "delays.h"
      4          #include "stdio.h"
      5          
      6          void test_1(void)
      7          {
      8            const char test_string1[] = "Hello world\n";
      9            const char test_string2[] = "Hello worldHello worldHello worldHello world\n";
     10            TimeStamp_s start, stop;
     11            
     12            TIM_init();
     13            TIM_TimeStamp(&start);
     14            printf(test_string1);
     15            TIM_TimeStamp(&stop);
     16            
     17            uint32_t passed = TIM_passedTime(&start, &stop);
     18            
     19            LOG(MSG_ON | MSG_INFO | MSG_TRACE, 
     20                "String 1 len = %d. Print time = %lu us\n",
     21                sizeof(test_string1), passed);
     22            
     23            TIM_TimeStamp(&start);
     24            printf(test_string2);
     25            TIM_TimeStamp(&stop);
     26            
     27            passed = TIM_passedTime(&start, &stop);
     28            
     29            LOG(MSG_ON | MSG_INFO | MSG_TRACE, 
     30                "String 2 len = %d. Print time = %lu us.\n",
     31                sizeof(test_string2), passed);  
     32          }
     33          
     34          void suite_printf_uart(void)
     35          {
     36            umsg_line("printf speed uart");
     37            test_1();
     38            
     39          }
\\vmware-host\Shared Folders\Projects\WMNU\IAR\PRJ_UNITEST\src\utest_radio.c
      1          #include "utest_suite.h"
      2          #include "RADIO.h"
      3          #include "ioCC2530.h"
      4          #include "delays.h"
      5          #include "frame.h"
      6          #include "coder.h"
      7          #include "nwdebuger.h"
      8          #include "TIC.h"
      9          #include "NTMR.h"
     10          
     11          static void RadioSendTest1(void)
     12          {
     13            uint8_t DATA_SEND[10] = {0,1,2,3,4,5,6,7,8,9};
     14            uint8_t key[16] = {18,11,12,13,14,15,16,17,10,11,12,13,14,15,16,17};
     15            uint8_t nonce[16] = {18,11,12,13,14,15,16,17,10,11,12,13,14,15,16,17};
     16            
     17            TIM_init();
     18            RI_init();
     19            AES_init();
     20            
     21            RI_StreamCrypt(true);
     22            RI_SetChannel(CH11);
     23            RI_setKEY(key);
     24            RI_setIV(nonce);
     25            
     26            // Подготовим данные к отправке
     27            frame_s *fr = frame_create();
     28            fbuf_s *fb = fbuf_create(FB_RAW_LAY, DATA_SEND, sizeof(DATA_SEND));
     29            fr->meta.SEND_TIME = 3000;
     30            frame_insert_head(fr, fb);
     31            
     32            // Передача данных
     33            bool res;
     34            while(true)
     35            {
     36              LED(D1, true);
     37              TIM_delay(100UL*Tmsec);
     38              LED(D1, false);
     39              res = RI_Send(fr);
     40              if (!res)
     41                LED(D2, true);
     42              else
     43                LED(D2, false);
     44              TIM_delay(900UL*Tmsec);
     45            };
     46            
     47            frame_delete(fr);
                   ^
Warning[Pe111]: statement is unreachable
          detected during compilation of secondary translation unit
                    "\\vmware-host\Shared
                    Folders\Projects\WMNU\IAR\PRJ_UNITEST\src\utest_radio.c"
     48          }
     49          
     50          static void RadioRecvTest1(void)
     51          {
     52            uint8_t DATA_RECV[10] = {0,1,2,3,4,5,6,7,8,9};
     53            uint8_t key[16] = {18,11,12,13,14,15,16,17,10,11,12,13,14,15,16,17};
     54            uint8_t nonce[16] = {18,11,12,13,14,15,16,17,10,11,12,13,14,15,16,17};
     55            
     56            NT_Init(); // Управление прериваниями таймера сна
     57            TIM_init();// Таймер MAC для измерения интервалов времени
     58            TIC_Init();// Контроллер интервалов времени (зависит от NT)
     59            RI_init(); // Иницилизация радио ( использует TIM и NT)
     60            AES_init();// Иницилизация шифровальщика
     61            
     62            RI_StreamCrypt(true);
     63            RI_SetChannel(CH11);
     64            RI_setKEY(key);
     65            RI_setIV(nonce);
     66            
     67            // Примем данных
     68            frame_s *fr;
     69            
     70            // Прием данных
     71            bool res;
     72            while(true)
     73            {
     74              fr = RI_Receive(2000);
     75              LED(D2, false);
     76              if (fr == NULL)
     77                continue;
     78              
     79              if (memory_compare((char*)DATA_RECV, fr->head->payload, 10))
     80                LED(D2, true);
     81              
     82              frame_delete(fr);
     83            };
     84            
     85            frame_delete(fr);
                   ^
Warning[Pe111]: statement is unreachable
          detected during compilation of secondary translation unit
                    "\\vmware-host\Shared
                    Folders\Projects\WMNU\IAR\PRJ_UNITEST\src\utest_radio.c"

    bool res;
         ^
"\\vmware-host\Shared Folders\Projects\WMNU\IAR\PRJ_UNITEST\src\utest_radio.c",71  Warning[Pe177]: 
          variable "res" was declared but never referenced
          detected during compilation of secondary translation unit
                    "\\vmware-host\Shared
                    Folders\Projects\WMNU\IAR\PRJ_UNITEST\src\utest_radio.c"
     86          }
     87          
     88          static void one_speed_test(frame_s *fr)
     89          {
     90            bool res;
     91            TimeStamp_s start, stop, *ts0;
                                             ^
Warning[Pe177]: variable "ts0" was declared but never referenced
          detected during compilation of secondary translation unit
                    "\\vmware-host\Shared
                    Folders\Projects\WMNU\IAR\PRJ_UNITEST\src\utest_radio.c"

  static void CCM_speed_test(void)
              ^
"\\vmware-host\Shared Folders\Projects\WMNU\IAR\PRJ_UNITEST\src\utest_coder.c",71  Warning[Pe177]: 
          function "CCM_speed_test" was declared but never referenced
          detected during compilation of secondary translation unit
                    "\\vmware-host\Shared
                    Folders\Projects\WMNU\IAR\PRJ_UNITEST\src\utest_coder.c"

  static void find_mem_problem(void)
              ^
"\\vmware-host\Shared Folders\Projects\WMNU\IAR\PRJ_UNITEST\src\utest_LLC.c",96  Warning[Pe177]: 
          function "find_mem_problem" was declared but never referenced
          detected during compilation of secondary translation unit
                    "\\vmware-host\Shared
                    Folders\Projects\WMNU\IAR\PRJ_UNITEST\src\utest_LLC.c"

  static void test_mem(void)
              ^
"\\vmware-host\Shared Folders\Projects\WMNU\IAR\PRJ_UNITEST\src\utest_LLC.c",134  Warning[Pe177]: 
          function "test_mem" was declared but never referenced
          detected during compilation of secondary translation unit
                    "\\vmware-host\Shared
                    Folders\Projects\WMNU\IAR\PRJ_UNITEST\src\utest_LLC.c"

  static void RadioSendTest1(void)
              ^
"\\vmware-host\Shared Folders\Projects\WMNU\IAR\PRJ_UNITEST\src\utest_radio.c",11  Warning[Pe177]: 
          function "RadioSendTest1" was declared but never referenced
          detected during compilation of secondary translation unit
                    "\\vmware-host\Shared
                    Folders\Projects\WMNU\IAR\PRJ_UNITEST\src\utest_radio.c"
     92            do
     93            {
     94              TIM_TimeStamp(&start);
     95              res = RI_Send(fr);
     96              TIM_TimeStamp(&stop);
     97            } while (!res);
     98            
     99            uint32_t passed = TIM_passedTime(&start, &stop);
    100            uint16_t passed_sfd = fr->meta.TIMESTAMP;
    101            LOG(MSG_ON | MSG_INFO | MSG_TRACE, 
    102                "Data size = %d. Full time = %lu us. SFD time = %d us\n"
    103                ,fr->head->len, passed, passed_sfd);
    104           
    105          }
    106          static void speed_test(void)
    107          {
    108            uint8_t DATA_SEND[100];
    109            uint8_t key[16] = {18,11,12,13,14,15,16,17,10,11,12,13,14,15,16,17};
    110            uint8_t nonce[16] = {18,11,12,13,14,15,16,17,10,11,12,13,14,15,16,17};
    111            uint8_t size_tests[] = {10, 50, 100, 125};
    112            
    113            TIM_init();
    114            RI_init();
    115            AES_init();
    116            
    117            RI_StreamCrypt(true);
    118            RI_SetChannel(CH11);
    119            RI_setKEY(key);
    120            RI_setIV(nonce);
    121            
    122            // Подготовим данные к отправке
    123            
    124            LOG(MSG_ON | MSG_INFO | MSG_TRACE, "SEND SPEED TEST WITH DATA ENCODE\n");  
    125            for (uint8_t s = 0; s < sizeof(size_tests) ; s++)
    126            {
    127              frame_s *fr = frame_create();
    128              fbuf_s *fb = fbuf_create(FB_RAW_LAY, DATA_SEND, size_tests[s]);
    129              frame_insert_head(fr, fb);
    130              one_speed_test(fr);
    131              frame_delete(fr);
    132            }
    133            
    134            RI_StreamCrypt(false);
    135            LOG(MSG_ON | MSG_INFO | MSG_TRACE, "SEND SPEED TEST WITHOUT DATA ENCODE\n"); 
    136            for (uint8_t s = 0; s < sizeof(size_tests) ; s++)
    137            {
    138              frame_s *fr = frame_create();
    139              fbuf_s *fb = fbuf_create(FB_RAW_LAY, DATA_SEND, size_tests[s]);
    140              frame_insert_head(fr, fb);
    141              one_speed_test(fr);
    142              frame_delete(fr);
    143            }
    144            
    145            RI_StreamCrypt(true);
    146            LOG(MSG_ON | MSG_INFO | MSG_TRACE, "SEND IN SEND_TIME 1000 ticks AFTER TS0\n"); 
    147            for (uint8_t s = 0; s < sizeof(size_tests) ; s++)
    148            {
    149              frame_s *fr = frame_create();
    150              fbuf_s *fb = fbuf_create(FB_RAW_LAY, DATA_SEND, size_tests[s]);
    151              frame_insert_head(fr, fb);
    152              fr->meta.SEND_TIME = 1000;
    153              TIC_Init(); // При иницилизации TS0 отсчитываеться с этого момента
    154              one_speed_test(fr);
    155              frame_delete(fr);
    156            }  
    157            
    158          
    159            RI_StreamCrypt(true);
    160            LOG(MSG_ON | MSG_INFO | MSG_TRACE, "SEND IN SEND_TIME 1000 ticks AFTER TS0\n"); 
    161            for (uint8_t s = 0; s < sizeof(size_tests) ; s++)
    162            {
    163              frame_s *fr = frame_create();
    164              fbuf_s *fb = fbuf_create(FB_RAW_LAY, DATA_SEND, size_tests[s]);
    165              frame_insert_head(fr, fb);
    166              fr->meta.SEND_TIME = 1000;
    167              TIC_Init(); // При иницилизации TS0 отсчитываеться с этого момента
    168              one_speed_test(fr);
    169              frame_delete(fr);
    170            } 
    171            
    172            RI_StreamCrypt(true);
    173            LOG(MSG_ON | MSG_INFO | MSG_TRACE, "SEND IN SEND_TIME 1000 ticks AFTER TS0\n"); 
    174            for (uint8_t s = 0; s < sizeof(size_tests) ; s++)
    175            {
    176              frame_s *fr = frame_create();
    177              fbuf_s *fb = fbuf_create(FB_RAW_LAY, DATA_SEND, size_tests[s]);
    178              frame_insert_head(fr, fb);
    179              fr->meta.SEND_TIME = 1000;
    180              TIC_Init(); // При иницилизации TS0 отсчитываеться с этого момента
    181              one_speed_test(fr);
    182              frame_delete(fr);
    183            } 
    184            
    185          }
    186          
    187          // Тесты скорости
    188          void suite_RADIO(void)
    189          {
    190            umsg_line("RADIO module");
    191            speed_test();
    192          }
    193          // Для тестирования радио запрограмируй два узла. Первый узел RadioSendTest1();
    194          // Второй узел RadioRecvTest1(); Первый будет раз в секунду передавать
    195          // шифрованные данные. Второй при приеме и удачном декодировании включит
    196          // светодиод.
    197          void suite_RADIO_HW(void)
    198          {
    199            //umsg_line("NTMR module");
    200            //RadioSendTest1();
    201            //
    202            RadioRecvTest1();
    203          }
\\vmware-host\Shared Folders\Projects\WMNU\IAR\PRJ_UNITEST\src\utest_suite.c
      1          #include "stdio.h"
      2          #include "utest_suite.h"
      3          #include "ioCC2530.h"
      4          
      5          /**
      6          @brief Иницилизируем выводы светодидов
      7          */
      8          void utestSigTraceInit(void)
      9          {
     10            P1DIR = 0x13; // Включаем светодиоды
     11          }
     12          
     13          void LED(uint8_t led, bool state)
     14          {
     15            switch(led)
     16            {
     17              case D1:
     18                P1_0 = !state;
     19                break;
     20              case D2:
     21                P1_1 = !state;
     22                break;
     23              case D3:
     24                P1_4 = !state;
     25                break;
     26            }
     27          }
     28          
     29          
     30          static struct utest_summary_s
     31          {
     32          	uint16_t passed;
     33          	uint16_t failed;
     34          } utest_summary = {.passed =0, .failed = 0};;
     35          
     36          //utest_summary_s utest_summary = {.passed =0, .failed = 0};
     37          
     38          // Требует много програмной памяти
     39          size_t heap_size(void)
     40          { 
     41            return 0;
     42          }
     43          
     44          bool memory_compare(char* area1, char* area2, uint16_t size)
     45          {
     46          	while (size > 0)
     47          	{
     48          		if (*area1 != *area2)
     49          			return false;
     50          		area1++;
     51          		area2++;
     52                  size--;
     53          	} 
     54          	return true;
     55          }
     56          
     57          void umsg(char* module, char* name, bool status)
     58          {
     59          	if (status){
     60          		utest_summary.passed++;
     61          		printf("Module: %-15s Name: %-50s Status: %-10s\r\n", module, name, "PASSED");
     62          		}
     63          	else{
     64          		utest_summary.failed++;
     65          		printf("Module: %-15s Name: %-50s Status: %-10s\r\n", module, name, "FAILED <----");
     66          		}
     67          }
     68          
     69          void umsg_line(char* name)
     70          {
     71          	printf("**************************************\r\n");
     72          	printf("%s\r\n", name);
     73          	printf("**************************************\r\n");
     74          }
     75          
     76          void umsg_summary()
     77          {
     78          	umsg_line("Unit test symmary");
     79          	printf("PASSED: %d\r\n", utest_summary.passed);
     80          	printf("FAILD : %d\r\n", utest_summary.failed);
     81          	if (utest_summary.failed == 0)
     82                printf("Tests PASSED\r\n");
     83          	else
     84          		printf("Tests FAILED\r\n");
     85          }
\\vmware-host\Shared Folders\Projects\WMNU\IAR\PRJ_UNITEST\src\utest_TIC.c
      1          #include "utest_suite.h"
      2          #include "TIC.h"
      3          #include "NTMR.h"
      4          #include "ioCC2530.h"
      5          
      6          static void RXC(uint8_t TS)
      7          {
      8            P0_1 = 1;
      9            P0_1 = 0;
     10          }
     11          
     12          static void TXC(uint8_t TS)
     13          {
     14            P0_4 = 1;
     15            P0_4 = 0;
     16          }
     17          
     18          static void SEC(uint8_t TS)
     19          {
     20            if (TS == 0)
     21            {
     22              P0_0 = 1;
     23              P0_0 = 0;
     24            }
     25          }
     26          
     27          /**
     28          @details Аппаратный тест TIC. Выводит сигналы
     29          на выводы P0_0 завершение нулевого слота. P0_1 прием, P0_4 передача.
     30          Тайм слот 11 показывает приоритет передачи над приемом.
     31          */
     32          static void test_hw(void)
     33          {
     34            NT_Init();
     35            TIC_Init();
     36            EA = 1;
     37            P0DIR = 0xff;
     38            P0_0 = 0;
     39            P0_1 = 0;
     40            P0_2 = 0;
     41            
     42            TIC_SetRXCallback(RXC);
     43            TIC_SetTXCallback(TXC);
     44            TIC_SetSECallback(SEC);
     45            
     46            TIC_SetRXState(10, true);
     47            TIC_SetRXState(11, true);
     48            TIC_SetRXState(20, true);
     49            TIC_SetRXState(21, true);
     50            
     51            TIC_SetTXState(5, true);
     52            TIC_SetTXState(11, true);
     53           
     54            TIC_SetRTC(10000);
     55            TIC_SetNonce(5000);
     56            volatile uint32_t rtc, ut, nonce;
     57            while(true)
     58            {
     59              // тут можно остановить программу и посмотреть работу таймеров
     60              // rtc больше на 10000 чем uptime, nonce больше на 5000
     61              ut = TIC_GetUptime(); 
     62              rtc = TIC_GetRTC();
     63              nonce = TIC_GetNonce();
     64            }
     65          }
     66          
     67          void suite_TIC_HW(void)
     68          {
     69            test_hw();
     70          }

   Maximum stack usage in bytes:

   ISTACK XSTACK Function
   ------ ------ --------
      1    184   AES_CCMDecrypt
        0     66   -> CBCMAC_buf_encrypt
        0     70   -> CTR_enc_decrypt
        0     68   -> generateAuthData
        0     68   -> memcpy
        0     68   -> memset
      1    168   AES_CCMEncrypt
        0     50   -> CBCMAC_buf_encrypt
        0     54   -> CTR_enc_decrypt
        0     52   -> generateAuthData
        0     52   -> memcpy
        0     52   -> memset
      0    127   AES_StreamCoder
        0     39   -> memcpy
        0     39   -> memset
      2    188   AES_init
      0    116   CBCMAC_buf_encrypt
        0     50   -> memcpy
        0     50   -> memset
      0    194   CCM_code_decode_test
        0    188   -> AES_init
        0    188   -> TIM_init
        0    188   -> printf
        0    192   -> printf
        0    194   -> printf
        0    194   -> single_enc_dec_test
        0    188   -> umsg
      1     62   CCM_test
        0     62   -> AES_CCMDecrypt
        0     62   -> AES_CCMEncrypt
        0     56   -> AES_init
        0     56   -> TIM_init
        0     58   -> memset
      0    109   CTR_enc_decrypt
        0     39   -> memcpy
        0     39   -> memset
      0     28   Callback_execution
        0     12   -> STACK_FAILURE
        0     12   -> printf
        0     16   -> printf
      0     40   DelayCalibrate
        0     40   -> TIM_TimeStamp
        0     40   -> TIM_delay
        0     40   -> TIM_passedTime
      0     54   Interval
      0     52   LED
      1     58   LLC_AddTask
        0     14   -> STACK_FAILURE
        0     14   -> malloc
        0     14   -> printf
        0     18   -> printf
        0     24   -> printf
      2     34   LLC_GetTaskLen
      2     34   LLC_Init
        2      0   -> MAC_Init
        2      0   -> MAC_SetRXCallback
        2      0   -> TIC_SetSECallback
      0     14   LLC_RX_HNDL
        0     10   -> STACK_FAILURE
        0     10   -> printf
        0     14   -> printf
      0     18   LLC_RunTimeAlloc
      0      9   LLC_SE_HNDL
        0      9   -> LLC_RunTimeAlloc
        0      9   -> LLC_Shelduler
      0     14   LLC_SetRXCallback
        0     10   -> STACK_FAILURE
        0     10   -> printf
        0     14   -> printf
      0     22   LLC_Shelduler
        0     13   -> MAC_GetTXState
        0     13   -> MAC_Send
        0     13   -> free
      0     50   LLC_TimeAlloc
        0     12   -> STACK_FAILURE
        0     12   -> malloc
        0     12   -> printf
        0     16   -> printf
      2     15   LoadTXData
      0      0   MAC_ACK_Recv
      0     51   MAC_ACK_Send
        0      9   -> RI_Send
        0      9   -> RI_SetChannel
        0      9   -> frame_delete
      1     14   MAC_CloseRXSlot
        0     10   -> STACK_FAILURE
        0     10   -> TIC_SetRXState
        0     10   -> printf
        0     14   -> printf
      0     14   MAC_GetRXState
        0     10   -> STACK_FAILURE
        0     10   -> printf
        0     14   -> printf
      0     40   MAC_GetTXState
        0     10   -> STACK_FAILURE
        0     10   -> printf
        0     14   -> printf
      0     54   MAC_Init
        0     10   -> AES_init
        0     10   -> RI_StreamCrypt
        0     10   -> RI_init
        0     10   -> RI_setIV
        0     10   -> RI_setKEY
        0     10   -> TIC_Init
        0     10   -> TIC_SetRXCallback
        0     10   -> TIC_SetTXCallback
        0     10   -> TIM_init
        0     12   -> memset
      1     14   MAC_OpenRXSlot
        0     10   -> STACK_FAILURE
        0     10   -> TIC_SetRXState
        0     10   -> printf
        0     14   -> printf
      0     16   MAC_RX_HNDL
        0     12   -> RI_Receive
        0     12   -> RI_SetChannel
        0     12   -> STACK_FAILURE
        0     12   -> frame_delete
        0     12   -> printf
        0     16   -> printf
      1     42   MAC_Send
        0     12   -> STACK_FAILURE
        0     12   -> TIC_SetTXState
        0     12   -> printf
        0     16   -> printf
      2      0   MAC_SetRXCallback
      2      0   MAC_Set_isACK_OK_Callback
      1     16   MAC_TX_HNDL
        0     12   -> RI_Receive
        0     12   -> RI_Send
        0     12   -> RI_SetChannel
        0     12   -> STACK_FAILURE
        0     12   -> TIC_SetTXState
        0     12   -> TIM_delay
        0     12   -> frame_delete
        0     12   -> printf
        0     16   -> printf
      0     16   MyLowLevelPutchar
      0     48   NT_GetTime
        0     16   -> ReadTimer
      0     15   NT_IRQEnable
      2     52   NT_Init
        2      0   -> NT_IRQEnable
      0     30   NT_SetCompare
        0     12   -> NT_IRQEnable
        0     12   -> STACK_FAILURE
        0     12   -> calcCompareTime
        0     12   -> loadTimerCompare
        0     12   -> printf
        0     16   -> printf
      2      9   NT_SetEventCallback
      0     28   NT_SetTime
        0     14   -> NT_SetCompare
        0     14   -> ReadTimer
        0     14   -> STACK_FAILURE
        0     14   -> isIRQEnable
        0     14   -> printf
        0     18   -> printf
      0     27   NT_WaitTime
      0     31   RI_BitRawCrypt
        0     16   -> AES_StreamCoder
      0     62   RI_BitRawDecrypt
        0     16   -> AES_StreamCoder
      2      0   RI_GetCCAReject
      2      0   RI_GetCRCError
      2      0   RI_GetUptime
      1    100   RI_Receive
        0     46   -> RI_BitRawDecrypt
        0     46   -> RI_cfg
        0     48   -> RecvData
        0     46   -> TIM_TimeStamp
        0     46   -> TIM_passedTime
        0     46   -> UnLoadRXData
        0     46   -> fbuf_create
        0     46   -> frame_create
        0     46   -> frame_insert_head
        0     46   -> free
        0     46   -> malloc
      0     72   RI_Send
        0     36   -> RI_cfg
        0     36   -> STACK_FAILURE
        0     36   -> SendData
        0     36   -> TIM_TimeStamp
        0     36   -> TIM_passedTime
        0     36   -> printf
        0     40   -> printf
      2    150   RI_SetChannel
      2    150   RI_StreamCrypt
      3     47   RI_cfg
        2      1   -> setFreq
      2    150   RI_init
        2      0   -> random_core_init
      0    162   RI_setIV
        0     12   -> memcpy
      0    162   RI_setKEY
        0     12   -> memcpy
      0      0   RXC
      0     54   RadioRecvTest1
        0     52   -> AES_init
        0     52   -> LED
        0     52   -> NT_Init
        0     52   -> RI_Receive
        0     52   -> RI_SetChannel
        0     52   -> RI_StreamCrypt
        0     52   -> RI_init
        0     52   -> RI_setIV
        0     52   -> RI_setKEY
        0     52   -> TIC_Init
        0     52   -> TIM_init
        0     52   -> frame_delete
        0     54   -> memory_compare
      2     22   ReadTimer
      0     80   RecvData
        0     32   -> NT_GetTime
        0     32   -> TIM_TimeStamp
        0     32   -> TIM_passedTime
      0      0   SEC
      0     36   STACK_FAILURE
      0     51   SendData
        0     15   -> LoadTXData
        0     15   -> NT_GetTime
        0     15   -> NT_WaitTime
        0     15   -> RI_BitRawCrypt
        0     15   -> frame_merge
        0     15   -> free
      0      0   SetCPU32M
      2     12   TIC_GetNonce
      2     26   TIC_GetRTC
      0     14   TIC_GetRXState
        0     10   -> STACK_FAILURE
        0     10   -> printf
        0     14   -> printf
      0     14   TIC_GetTXState
        0     10   -> STACK_FAILURE
        0     10   -> printf
        0     14   -> printf
      0      0   TIC_GetTimeStampTS0
      2      0   TIC_GetTimer
        2      0   -> NT_GetTime
      2     12   TIC_GetUptime
      0     16   TIC_HW_Timer_IRQ
        0     12   -> Callback_execution
        0     12   -> TIC_TDMAShelduler
        0     12   -> TIC_getCurrentTS
        0     12   -> TIM_TimeStamp
        0     12   -> clocks_update
        0     12   -> printf
        0     16   -> printf
      2    150   TIC_Init
        2      0   -> NT_SetCompare
        2      0   -> NT_SetEventCallback
        2      0   -> TIC_SetTimer
        2      0   -> TIM_TimeStamp
      0     24   TIC_SetNonce
      0     24   TIC_SetRTC
      0     26   TIC_SetRXCallback
        0     10   -> STACK_FAILURE
        0     10   -> printf
        0     14   -> printf
      0     26   TIC_SetRXState
        0     10   -> STACK_FAILURE
        0     10   -> printf
        0     14   -> printf
      0     40   TIC_SetSECallback
        0     10   -> STACK_FAILURE
        0     10   -> printf
        0     14   -> printf
      0     26   TIC_SetTXCallback
        0     10   -> STACK_FAILURE
        0     10   -> printf
        0     14   -> printf
      0     26   TIC_SetTXState
        0     10   -> STACK_FAILURE
        0     10   -> printf
        0     14   -> printf
      0     14   TIC_SetTimer
        0     10   -> NT_SetTime
        0     10   -> STACK_FAILURE
        0     10   -> printf
        0     14   -> printf
      3     13   TIC_TDMAShelduler
        2      1   -> incrementTS
        2      1   -> set_capture_time
      0     24   TIC_TimeUsFromTS0
        0     24   -> TIM_TimeStamp
        0     24   -> TIM_passedTime
      0     22   TIC_getCurrentTS
      3     91   TIM_TimeStamp
      0     14   TIM_copy
        0     14   -> memcpy
      0     76   TIM_delay
        0     36   -> Interval
        0     36   -> TIM_TimeStamp
      2    188   TIM_init
        2      0   -> DelayCalibrate
      0    109   TIM_passedTime
        0     18   -> Interval
      0      0   TXC
      0     15   TimerCompareInterrupt
        0     15   -> NT_GetTime
        0     15   -> NT_IRQEnable
      0     12   TimerHndl
        0     10   -> NT_SetCompare
        0     12   -> isNear
      3     46   UnLoadRXData
      0     18   __write
        0     16   -> MyLowLevelPutchar
      0     88   aes_test
        0     88   -> AES_StreamCoder
        0     84   -> AES_init
        0     84   -> TIM_TimeStamp
        0     84   -> TIM_init
        0     84   -> TIM_passedTime
        0     86   -> memset
        0     88   -> printf
      0     32   alg_test
        0     32   -> TIM_TimeStamp
        0     32   -> TIM_init
        0     32   -> TIM_passedTime
        0     32   -> umsg
      0      9   alg_test
        0      9   -> NT_Init
        0      9   -> NT_SetCompare
        0      9   -> NT_SetEventCallback
      0      9   bits_count
      2     34   calcCompareTime
        0     22   -> ReadTimer
      0     24   clocks_update
      0     12   delete_test
        0     12   -> fbuf_create
        0     12   -> fbuf_delete
        0     12   -> umsg
      0     26   delete_test
        0     26   -> fbuf_create
        0     26   -> fbuf_delete
        0     26   -> frame_create
        0     26   -> frame_delete
        0     26   -> frame_insert_head
        0     26   -> umsg
      2     16   fbuf_chain
      1    170   fbuf_create
        0     16   -> STACK_FAILURE
        0     16   -> malloc
        0     18   -> memcpy
        0     18   -> memset
        0     16   -> printf
        0     20   -> printf
      0    119   fbuf_delete
        0      9   -> free
      2     34   fbuf_getCount
      2     20   fbuf_next
      0    164   frame_create
        0     10   -> STACK_FAILURE
        0     10   -> malloc
        0     12   -> memset
        0     10   -> printf
        0     14   -> printf
      0    162   frame_delete
        0     12   -> fbuf_delete
        0     12   -> free
      2     34   frame_getCount
      2     20   frame_get_fbuf_head
      2     20   frame_get_fbuf_tail
      0    159   frame_insert_head
      0     44   frame_insert_tail
        0     12   -> STACK_FAILURE
        0     12   -> printf
        0     16   -> printf
      2     34   frame_len
      1     49   frame_merge
        0     20   -> STACK_FAILURE
        0     20   -> frame_len
        0     20   -> malloc
        0     22   -> memcpy
        0     20   -> printf
        0     24   -> printf
      0     55   free
        0      9   -> __xdata_free
      0     86   generateAuthData
        0     18   -> memcpy
      1     52   getFrame
        0     18   -> fbuf_create
        0     18   -> frame_create
        0     18   -> frame_insert_head
      2     14   getMallocSize
      2      9   getRNDByte
      0      0   heap_size
      2      1   incrementTS
      0     12   insert1_test
        0     12   -> fbuf_create
        0     12   -> frame_create
        0     12   -> frame_delete
        0     12   -> frame_insert_head
        0     12   -> umsg
      0     12   insert2_test
        0     12   -> fbuf_create
        0     12   -> frame_create
        0     12   -> frame_delete
        0     12   -> frame_insert_tail
        0     12   -> umsg
      0     20   insert3_test
        0     20   -> fbuf_create
        0     20   -> fbuf_next
        0     20   -> frame_create
        0     20   -> frame_delete
        0     20   -> frame_get_fbuf_head
        0     20   -> frame_get_fbuf_tail
        0     20   -> frame_insert_head
        0     20   -> umsg
      0     20   insert4_test
        0     20   -> fbuf_create
        0     20   -> fbuf_next
        0     20   -> frame_create
        0     20   -> frame_delete
        0     20   -> frame_get_fbuf_head
        0     20   -> frame_insert_tail
        0     20   -> umsg
      0     14   isIRQEnable
      2     12   isNear
      0     28   loadTimerCompare
      0      4   main
        0      0   -> nwDebugerInit
        0      0   -> printf
        0      4   -> printf
        0      0   -> suite_LLC_HW
        0      0   -> umsg_summary
        0      0   -> utestSigTraceInit
      0     55   malloc
        0      9   -> __xdata_malloc
      0     32   manual
        0     32   -> TIM_TimeStamp
        0     32   -> TIM_delay
        0     32   -> TIM_init
        0     32   -> TIM_passedTime
        0     32   -> umsg
      1    114   mem_control
        0    114   -> AES_CCMDecrypt
        0    114   -> AES_CCMEncrypt
        0    108   -> AES_init
        0    108   -> TIM_init
        0    110   -> memcpy
        0    108   -> umsg
      0    121   memory_compare
      2      0   nwDebugerInit
        2      0   -> SetCPU32M
        2      0   -> uart_init
      0    190   one_speed_test
        0     32   -> RI_Send
        0     32   -> TIM_TimeStamp
        0     32   -> TIM_passedTime
        0     36   -> printf
        0     40   -> printf
      0      9   random_core_init
        0      9   -> RI_cfg
        0      9   -> rand
        0      9   -> readRandom
        0      9   -> srand
      1    112   raw_data_test
        0    110   -> fbuf_create
        0    110   -> fbuf_delete
        0    112   -> memory_compare
        0    110   -> umsg
      0     18   readRandom
        0      9   -> bits_count
        0      9   -> getRNDByte
      1     16   setFreq
        0     11   -> STACK_FAILURE
        0     11   -> printf
        0     15   -> printf
      0     10   set_capture_time
        0      9   -> NT_SetCompare
      0    214   single_enc_dec_test
        0     20   -> AES_CCMDecrypt
        0     20   -> AES_CCMEncrypt
      0    154   speed_test
        0    150   -> AES_init
        0    150   -> RI_SetChannel
        0    150   -> RI_StreamCrypt
        0    150   -> RI_init
        0    150   -> RI_setIV
        0    150   -> RI_setKEY
        0    150   -> TIC_Init
        0    150   -> TIM_init
        0    150   -> fbuf_create
        0    150   -> frame_create
        0    150   -> frame_delete
        0    150   -> frame_insert_head
        0    150   -> one_speed_test
        0    150   -> printf
        0    154   -> printf
      0      0   stub_se
      2      0   suite_Frames
        2      0   -> umsg_line
      2      0   suite_LLC_HW
        2      0   -> test_create
      2      0   suite_MAC
        2      0   -> test_ACK_SEND
        2      0   -> test_TS_Send
      2      0   suite_NT_HW
        2      0   -> alg_test
      2      0   suite_RADIO
        2      0   -> speed_test
        2      0   -> umsg_line
      2      0   suite_RADIO_HW
        2      0   -> RadioRecvTest1
      2      0   suite_TIC_HW
        2      0   -> test_hw
      2      0   suite_coder
        2      0   -> CCM_code_decode_test
        2      0   -> CCM_test
        2      0   -> aes_test
        2      0   -> mem_control
        2      0   -> umsg_line
      2      0   suite_delays
        2      0   -> alg_test
        2      0   -> umsg_line
      2      0   suite_delays_HW
        2      0   -> manual
      2      0   suite_fbuf
        2      0   -> delete_test
        2      0   -> raw_data_test
        2      0   -> test_create
        2      0   -> test_logic
        2      0   -> umsg_line
      2      0   suite_frame
        2      0   -> delete_test
        2      0   -> insert1_test
        2      0   -> insert2_test
        2      0   -> insert3_test
        2      0   -> insert4_test
        2      0   -> test_frame_merge
        2      0   -> tot_len_test
        2      0   -> umsg_line
      2      0   suite_malloc
        2      0   -> test_1
      2      0   suite_printf_uart
        2      0   -> test_1
        2      0   -> umsg_line
      0     14   test_1
        0     14   -> getMallocSize
        0     14   -> malloc
      0     97   test_1
        0     91   -> TIM_TimeStamp
        0     91   -> TIM_init
        0     91   -> TIM_passedTime
        0     91   -> printf
        0     95   -> printf
        0     97   -> printf
      0     48   test_ACK_SEND
        0     42   -> MAC_ACK_Send
        0     42   -> MAC_Init
        0     42   -> TIM_TimeStamp
        0     42   -> TIM_passedTime
        0     42   -> fbuf_create
        0     42   -> frame_create
        0     42   -> frame_insert_head
        0     46   -> printf
        0     48   -> printf
      1     30   test_TS_Send
        0     26   -> MAC_GetTXState
        0     26   -> MAC_Init
        0     26   -> MAC_Send
        0     26   -> TIC_GetRTC
        0     26   -> TIC_SetSECallback
        0     26   -> fbuf_create
        0     26   -> frame_create
        0     26   -> frame_insert_head
        0     30   -> printf
      0     10   test_create
        0     10   -> fbuf_create
        0     10   -> fbuf_delete
        0     10   -> umsg
      1     40   test_create
        0     34   -> LLC_AddTask
        0     34   -> LLC_GetTaskLen
        0     34   -> LLC_Init
        0     34   -> LLC_TimeAlloc
        0     34   -> fbuf_getCount
        0     34   -> frame_delete
        0     34   -> frame_getCount
        0     34   -> frame_len
        0     34   -> free
        0     34   -> getFrame
        0     34   -> malloc
        0     36   -> printf
        0     38   -> printf
        0     40   -> printf
      0     27   test_frame_merge
        0     25   -> fbuf_create
        0     25   -> frame_create
        0     25   -> frame_insert_tail
        0     25   -> frame_merge
        0     27   -> memory_compare
        0     25   -> umsg
      2     12   test_hw
        2     12   -> NT_Init
        2     12   -> TIC_GetNonce
        2     12   -> TIC_GetRTC
        2     12   -> TIC_GetUptime
        2     12   -> TIC_Init
        2     12   -> TIC_SetNonce
        2     12   -> TIC_SetRTC
        2     12   -> TIC_SetRXCallback
        2     12   -> TIC_SetRXState
        2     12   -> TIC_SetSECallback
        2     12   -> TIC_SetTXCallback
        2     12   -> TIC_SetTXState
      0     16   test_logic
        0     16   -> fbuf_chain
        0     16   -> fbuf_create
        0     16   -> fbuf_delete
        0     16   -> fbuf_next
        0     16   -> umsg
      2      0   timealloc
        2      0   -> LED
      0     28   tot_len_test
        0     28   -> fbuf_create
        0     28   -> frame_create
        0     28   -> frame_delete
        0     28   -> frame_insert_tail
        0     28   -> frame_len
        0     28   -> umsg
      0      0   uart_init
      0    208   umsg
        0     20   -> printf
      0     12   umsg_line
        0     10   -> printf
        0     12   -> printf
      2      2   umsg_summary
        2      0   -> printf
        2      2   -> printf
        2      0   -> umsg_line
      0      0   utestSigTraceInit


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
       5  ?<Constant "%s\r\n">
      41  ?<Constant "*********************...">
      19  ?<Constant "*ASSERT* %s:%d -> ">
      17  ?<Constant "*ASSERT* %s:%d->">
      17  ?<Constant "*ASSERT* %s:%d->">_1
      17  ?<Constant "*ASSERT* %s:%d->">_2
      17  ?<Constant "*ASSERT* %s:%d->">_3
      17  ?<Constant "*ASSERT* %s:%d->">_4
      17  ?<Constant "*ASSERT* %s:%d->">_5
      17  ?<Constant "*ASSERT* %s:%d->">_6
      19  ?<Constant "*LOGGER* %s:%d -> ">
      19  ?<Constant "*LOGGER* %s:%d -> ">_1
      19  ?<Constant "*LOGGER* %s:%d -> ">_2
      19  ?<Constant "*LOGGER* %s:%d -> ">_3
      19  ?<Constant "*LOGGER* %s:%d -> ">_4
      19  ?<Constant "*LOGGER* %s:%d -> ">_5
      19  ?<Constant "*LOGGER* %s:%d -> ">_6
      19  ?<Constant "*LOGGER* %s:%d -> ">_7
       9  ?<Constant "*fr null">
      27  ?<Constant ".Program execution ha...">
      27  ?<Constant ".Program execution ha...">_1
      27  ?<Constant ".Program execution ha...">_2
      27  ?<Constant ".Program execution ha...">_3
      27  ?<Constant ".Program execution ha...">_4
      27  ?<Constant ".Program execution ha...">_5
      27  ?<Constant ".Program execution ha...">_6
      10  ?<Constant "0123456789">
      53  ?<Constant "Add task = %u, CH = %...">
      13  ?<Constant "Assert fails">
      13  ?<Constant "Assert fails">_1
      13  ?<Constant "Assert fails">_2
      13  ?<Constant "Assert fails">_3
      13  ?<Constant "Assert fails">_4
      13  ?<Constant "Assert fails">_5
      13  ?<Constant "Assert fails">_6
      30  ?<Constant "CCM coder corrupt dat...">
      29  ?<Constant "CCM coder corrupt key...">
      29  ?<Constant "CCM coder corrupt mic...">
      31  ?<Constant "CCM coder corrupt non...">
      25  ?<Constant "CCM decoded data correct">
      32  ?<Constant "CCM decoder corrupt d...">
      31  ?<Constant "CCM decoder corrupt k...">
      31  ?<Constant "CCM decoder corrupt m...">
      33  ?<Constant "CCM decoder corrupt n...">
      20  ?<Constant "CCM full coder test">
      27  ?<Constant "CCM full size test 60...">
      21  ?<Constant "CCM key data correct">
      23  ?<Constant "CCM nonce data correct">
      17  ?<Constant "Callback is NULL">
      36  ?<Constant "Coder test stub on m=...">
      54  ?<Constant "Data size = %d. Full ...">
      13  ?<Constant "FAILD : %d\r\n">
      13  ?<Constant "FAILED <----">
      24  ?<Constant "FB_RAW_LAY len is equal">
      24  ?<Constant "FB_RAW_LAY mem is equal">
      27  ?<Constant "FB_RAW_LAY mem is not...">
      11  ?<Constant "Fn is NULL">
      37  ?<Constant "Frame puted to MAC la...">
      46  ?<Constant "Frame_s size = %d. Fb...">
      14  ?<Constant "Frames module">
      16  ?<Constant "HEAP_PTR = %d\r\n">
      46  ?<Constant "Hello worldHello worl...">
      13  ?<Constant "Hello world\n">
      13  ?<Constant "Incorrect TS">
      20  ?<Constant "Incorrect fbuf type">
      24  ?<Constant "Incorrect radio channel">
      16  ?<Constant "Incorrect ticks">
      24  ?<Constant "Insert head. head = fb1">
      24  ?<Constant "Insert head. tail = fb1">
      24  ?<Constant "Insert tail. head = fb1">
      24  ?<Constant "Insert tail. tail = fb1">
      24  ?<Constant "LLC malloc for new_task">
       6  ?<Constant "LLC.c">
       6  ?<Constant "MAC.c">
      38  ?<Constant "MAC_ACK_Send time = %...">
      24  ?<Constant "Memory allocation fails">
      12  ?<Constant "Memory corr">
      42  ?<Constant "Module: %-15s Name: %...">
       7  ?<Constant "NTMR.c">
      23  ?<Constant "NULL pointer not allow">
       6  ?<Constant "No fb">
       6  ?<Constant "No fr">
      10  ?<Constant "No memory">
      10  ?<Constant "No memory">_1
       7  ?<Constant "PASSED">
      13  ?<Constant "PASSED: %d\r\n">
      13  ?<Constant "RADIO module">
       8  ?<Constant "RADIO.c">
      21  ?<Constant "RXCallback func NULL">
      40  ?<Constant "SEND IN SEND_TIME 100...">
      34  ?<Constant "SEND SPEED TEST WITH ...">
      37  ?<Constant "SEND SPEED TEST WITHO...">
      40  ?<Constant "String 1 len = %d. Pr...">
      41  ?<Constant "String 2 len = %d. Pr...">
       6  ?<Constant "TIC.c">
      30  ?<Constant "TIM_passedTimeNs meas...">
      12  ?<Constant "TS = 255 \r\n">
      16  ?<Constant "TS not in range">
      21  ?<Constant "Test assert output\r\n">
      18  ?<Constant "Test log output\r\n">
      15  ?<Constant "Tests FAILED\r\n">
      15  ?<Constant "Tests PASSED\r\n">
      19  ?<Constant "Ticks not in range">
      18  ?<Constant "Unit test symmary">
       3  ?<Constant "\r\n">
      13  ?<Constant "attempts = 0">
      17  ?<Constant "chain fb1 -> fb2">
      17  ?<Constant "chain fb2 -> fb3">
      20  ?<Constant "chain fb3 next NULL">
      13  ?<Constant "coder module">
       6  ?<Constant "coder">
      14  ?<Constant "delays module">
       7  ?<Constant "delays">
      17  ?<Constant "delete test. fb1">
      17  ?<Constant "delete test. fb2">
      17  ?<Constant "delete test. fb3">
      17  ?<Constant "delete test. fb4">
      24  ?<Constant "fbuf FB_ETH_LAY created">
      23  ?<Constant "fbuf FB_ETH_LAY lenght">
      23  ?<Constant "fbuf FB_IP_LAY created">
      22  ?<Constant "fbuf FB_IP_LAY lenght">
      25  ?<Constant "fbuf FB_SYNC_LAY created">
      24  ?<Constant "fbuf FB_SYNC_LAY lenght">
      12  ?<Constant "fbuf module">
      12  ?<Constant "fbuf module">_1
       5  ?<Constant "fbuf">
       7  ?<Constant "fbuf.c">
      12  ?<Constant "fbuf_delete">
       8  ?<Constant "fr NULL">
       8  ?<Constant "fr NULL">_1
       6  ?<Constant "frame">
       8  ?<Constant "frame.c">
      15  ?<Constant "frame_len calc">
      19  ?<Constant "isACK_OK func NULL">
      16  ?<Constant "iterator = NULL">
      16  ?<Constant "iterator = NULL">_1
      15  ?<Constant "iterator = fb1">
      15  ?<Constant "iterator = fb1">_1
      15  ?<Constant "iterator = fb2">
      15  ?<Constant "iterator = fb2">_1
      15  ?<Constant "iterator = fb3">
      15  ?<Constant "iterator = fb3">_1
      14  ?<Constant "passed %lu \r\n">
      18  ?<Constant "printf speed uart">
       8  ?<Constant "utest.c">
      12  ?<Constant "utest_LLC.c">
      12  ?<Constant "utest_MAC.c">
      14  ?<Constant "utest_coder.c">
      20  ?<Constant "utest_printf_uart.c">
      14  ?<Constant "utest_radio.c">
      10  ?<Constant {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}>
      10  ?<Constant {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}>_1
      10  ?<Constant {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}>_2
      10  ?<Constant {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}>_3
      10  ?<Constant {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}>_4
      16  ?<Constant {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11,
      16  ?<Constant {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11,_1
      16  ?<Constant {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11,_2
      16  ?<Constant {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11,_3
      16  ?<Constant {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11,_4
      16  ?<Constant {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11,_5
       4  ?<Constant {10, 50, 100, 125}>
      16  ?<Constant {18, 11, 12, 13, 14, 15, 16, 17, 10
      16  ?<Constant {18, 11, 12, 13, 14, 15, 16, 17, 10_1
      16  ?<Constant {18, 11, 12, 13, 14, 15, 16, 17, 10_2
      16  ?<Constant {18, 11, 12, 13, 14, 15, 16, 17, 10_3
      16  ?<Constant {18, 11, 12, 13, 14, 15, 16, 17, 10_4
      16  ?<Constant {18, 11, 12, 13, 14, 15, 16, 17, 10_5
       5  ?<Initializer for <Constant "%s\r\n">>
      41  ?<Initializer for <Constant "*****************
      19  ?<Initializer for <Constant "*ASSERT* %s:%d ->
      17  ?<Initializer for <Constant "*ASSERT* %s:%d->"
      17  ?<Initializer for <Constant "*ASSERT* %s:%d->"_1
      17  ?<Initializer for <Constant "*ASSERT* %s:%d->"_2
      17  ?<Initializer for <Constant "*ASSERT* %s:%d->"_3
      17  ?<Initializer for <Constant "*ASSERT* %s:%d->"_4
      17  ?<Initializer for <Constant "*ASSERT* %s:%d->"_5
      17  ?<Initializer for <Constant "*ASSERT* %s:%d->"_6
      19  ?<Initializer for <Constant "*LOGGER* %s:%d ->
      19  ?<Initializer for <Constant "*LOGGER* %s:%d ->_1
      19  ?<Initializer for <Constant "*LOGGER* %s:%d ->_2
      19  ?<Initializer for <Constant "*LOGGER* %s:%d ->_3
      19  ?<Initializer for <Constant "*LOGGER* %s:%d ->_4
      19  ?<Initializer for <Constant "*LOGGER* %s:%d ->_5
      19  ?<Initializer for <Constant "*LOGGER* %s:%d ->_6
      19  ?<Initializer for <Constant "*LOGGER* %s:%d ->_7
       9  ?<Initializer for <Constant "*fr null">>
      27  ?<Initializer for <Constant ".Program executio
      27  ?<Initializer for <Constant ".Program executio_1
      27  ?<Initializer for <Constant ".Program executio_2
      27  ?<Initializer for <Constant ".Program executio_3
      27  ?<Initializer for <Constant ".Program executio_4
      27  ?<Initializer for <Constant ".Program executio_5
      27  ?<Initializer for <Constant ".Program executio_6
      10  ?<Initializer for <Constant "0123456789">>
      53  ?<Initializer for <Constant "Add task = %u, CH
      13  ?<Initializer for <Constant "Assert fails">>
      13  ?<Initializer for <Constant "Assert fails">>_1
      13  ?<Initializer for <Constant "Assert fails">>_2
      13  ?<Initializer for <Constant "Assert fails">>_3
      13  ?<Initializer for <Constant "Assert fails">>_4
      13  ?<Initializer for <Constant "Assert fails">>_5
      13  ?<Initializer for <Constant "Assert fails">>_6
      30  ?<Initializer for <Constant "CCM coder corrupt
      29  ?<Initializer for <Constant "CCM coder corrupt_1
      31  ?<Initializer for <Constant "CCM coder corrupt_2
      29  ?<Initializer for <Constant "CCM coder corrupt_3
      25  ?<Initializer for <Constant "CCM decoded data
      32  ?<Initializer for <Constant "CCM decoder corru
      31  ?<Initializer for <Constant "CCM decoder corru_1
      33  ?<Initializer for <Constant "CCM decoder corru_2
      31  ?<Initializer for <Constant "CCM decoder corru_3
      20  ?<Initializer for <Constant "CCM full coder te
      27  ?<Initializer for <Constant "CCM full size tes
      21  ?<Initializer for <Constant "CCM key data corr
      23  ?<Initializer for <Constant "CCM nonce data co
      17  ?<Initializer for <Constant "Callback is NULL"
      36  ?<Initializer for <Constant "Coder test stub o
      54  ?<Initializer for <Constant "Data size = %d. F
      13  ?<Initializer for <Constant "FAILD : %d\r\n">>
      13  ?<Initializer for <Constant "FAILED <----">>
      24  ?<Initializer for <Constant "FB_RAW_LAY len is
      24  ?<Initializer for <Constant "FB_RAW_LAY mem is
      27  ?<Initializer for <Constant "FB_RAW_LAY mem is_1
      11  ?<Initializer for <Constant "Fn is NULL">>
      37  ?<Initializer for <Constant "Frame puted to MA
      46  ?<Initializer for <Constant "Frame_s size = %d
      14  ?<Initializer for <Constant "Frames module">>
      16  ?<Initializer for <Constant "HEAP_PTR = %d\r\n
      46  ?<Initializer for <Constant "Hello worldHello
      13  ?<Initializer for <Constant "Hello world\n">>
      13  ?<Initializer for <Constant "Incorrect TS">>
      20  ?<Initializer for <Constant "Incorrect fbuf ty
      24  ?<Initializer for <Constant "Incorrect radio c
      16  ?<Initializer for <Constant "Incorrect ticks">
      24  ?<Initializer for <Constant "Insert head. head
      24  ?<Initializer for <Constant "Insert head. tail
      24  ?<Initializer for <Constant "Insert tail. head
      24  ?<Initializer for <Constant "Insert tail. tail
      24  ?<Initializer for <Constant "LLC malloc for ne
       6  ?<Initializer for <Constant "LLC.c">>
       6  ?<Initializer for <Constant "MAC.c">>
      38  ?<Initializer for <Constant "MAC_ACK_Send time
      24  ?<Initializer for <Constant "Memory allocation
      12  ?<Initializer for <Constant "Memory corr">>
      42  ?<Initializer for <Constant "Module: %-15s Nam
       7  ?<Initializer for <Constant "NTMR.c">>
      23  ?<Initializer for <Constant "NULL pointer not
       6  ?<Initializer for <Constant "No fb">>
       6  ?<Initializer for <Constant "No fr">>
      10  ?<Initializer for <Constant "No memory">>
      10  ?<Initializer for <Constant "No memory">>_1
       7  ?<Initializer for <Constant "PASSED">>
      13  ?<Initializer for <Constant "PASSED: %d\r\n">>
      13  ?<Initializer for <Constant "RADIO module">>
       8  ?<Initializer for <Constant "RADIO.c">>
      21  ?<Initializer for <Constant "RXCallback func N
      40  ?<Initializer for <Constant "SEND IN SEND_TIME
      34  ?<Initializer for <Constant "SEND SPEED TEST W
      37  ?<Initializer for <Constant "SEND SPEED TEST W_1
      40  ?<Initializer for <Constant "String 1 len = %d
      41  ?<Initializer for <Constant "String 2 len = %d
       6  ?<Initializer for <Constant "TIC.c">>
      30  ?<Initializer for <Constant "TIM_passedTimeNs
      12  ?<Initializer for <Constant "TS = 255 \r\n">>
      16  ?<Initializer for <Constant "TS not in range">
      21  ?<Initializer for <Constant "Test assert outpu
      18  ?<Initializer for <Constant "Test log output\r
      15  ?<Initializer for <Constant "Tests FAILED\r\n"
      15  ?<Initializer for <Constant "Tests PASSED\r\n"
      19  ?<Initializer for <Constant "Ticks not in rang
      18  ?<Initializer for <Constant "Unit test symmary
       3  ?<Initializer for <Constant "\r\n">>
      13  ?<Initializer for <Constant "attempts = 0">>
      17  ?<Initializer for <Constant "chain fb1 -> fb2"
      17  ?<Initializer for <Constant "chain fb2 -> fb3"
      20  ?<Initializer for <Constant "chain fb3 next NU
      13  ?<Initializer for <Constant "coder module">>
       6  ?<Initializer for <Constant "coder">>
      14  ?<Initializer for <Constant "delays module">>
       7  ?<Initializer for <Constant "delays">>
      17  ?<Initializer for <Constant "delete test. fb1"
      17  ?<Initializer for <Constant "delete test. fb2"
      17  ?<Initializer for <Constant "delete test. fb3"
      17  ?<Initializer for <Constant "delete test. fb4"
      24  ?<Initializer for <Constant "fbuf FB_ETH_LAY c
      23  ?<Initializer for <Constant "fbuf FB_ETH_LAY l
      23  ?<Initializer for <Constant "fbuf FB_IP_LAY cr
      22  ?<Initializer for <Constant "fbuf FB_IP_LAY le
      25  ?<Initializer for <Constant "fbuf FB_SYNC_LAY
      24  ?<Initializer for <Constant "fbuf FB_SYNC_LAY _1
      12  ?<Initializer for <Constant "fbuf module">>
      12  ?<Initializer for <Constant "fbuf module">>_1
       5  ?<Initializer for <Constant "fbuf">>
       7  ?<Initializer for <Constant "fbuf.c">>
      12  ?<Initializer for <Constant "fbuf_delete">>
       8  ?<Initializer for <Constant "fr NULL">>
       8  ?<Initializer for <Constant "fr NULL">>_1
       6  ?<Initializer for <Constant "frame">>
       8  ?<Initializer for <Constant "frame.c">>
      15  ?<Initializer for <Constant "frame_len calc">>
      19  ?<Initializer for <Constant "isACK_OK func NUL
      16  ?<Initializer for <Constant "iterator = NULL">
      16  ?<Initializer for <Constant "iterator = NULL">_1
      15  ?<Initializer for <Constant "iterator = fb1">>
      15  ?<Initializer for <Constant "iterator = fb1">>_1
      15  ?<Initializer for <Constant "iterator = fb2">>
      15  ?<Initializer for <Constant "iterator = fb2">>_1
      15  ?<Initializer for <Constant "iterator = fb3">>
      15  ?<Initializer for <Constant "iterator = fb3">>_1
      14  ?<Initializer for <Constant "passed %lu \r\n">
      18  ?<Initializer for <Constant "printf speed uart
       8  ?<Initializer for <Constant "utest.c">>
      12  ?<Initializer for <Constant "utest_LLC.c">>
      12  ?<Initializer for <Constant "utest_MAC.c">>
      14  ?<Initializer for <Constant "utest_coder.c">>
      20  ?<Initializer for <Constant "utest_printf_uart
      14  ?<Initializer for <Constant "utest_radio.c">>
      10  ?<Initializer for <Constant {0, 1, 2, 3, 4, 5,
      10  ?<Initializer for <Constant {0, 1, 2, 3, 4, 5,_1
      10  ?<Initializer for <Constant {0, 1, 2, 3, 4, 5,_2
      10  ?<Initializer for <Constant {0, 1, 2, 3, 4, 5,_3
      10  ?<Initializer for <Constant {0, 1, 2, 3, 4, 5,_4
      16  ?<Initializer for <Constant {1, 2, 3, 4, 5, 6,
      16  ?<Initializer for <Constant {1, 2, 3, 4, 5, 6,_1
      16  ?<Initializer for <Constant {1, 2, 3, 4, 5, 6,_2
      16  ?<Initializer for <Constant {1, 2, 3, 4, 5, 6,_3
      16  ?<Initializer for <Constant {1, 2, 3, 4, 5, 6,_4
      16  ?<Initializer for <Constant {1, 2, 3, 4, 5, 6,_5
       4  ?<Initializer for <Constant {10, 50, 100, 125}
      16  ?<Initializer for <Constant {18, 11, 12, 13, 1
      16  ?<Initializer for <Constant {18, 11, 12, 13, 1_1
      16  ?<Initializer for <Constant {18, 11, 12, 13, 1_2
      16  ?<Initializer for <Constant {18, 11, 12, 13, 1_3
      16  ?<Initializer for <Constant {18, 11, 12, 13, 1_4
      16  ?<Initializer for <Constant {18, 11, 12, 13, 1_5
      16  ?<Initializer for IV>
      16  ?<Initializer for KEY>
       4  ?<Initializer for MAC_TIMER_MAX>
       4  ?<Initializer for __Constant_1388>
       4  ?<Initializer for __Constant_15180>
       4  ?<Initializer for __Constant_1>
       4  ?<Initializer for __Constant_1f4>
       4  ?<Initializer for __Constant_20>
       4  ?<Initializer for __Constant_2710>
       4  ?<Initializer for __Constant_3938700>
       4  ?<Initializer for __Constant_3d000000>
       4  ?<Initializer for __Constant_3e8>
       4  ?<Initializer for __Constant_447a0000>
       4  ?<Initializer for __Constant_7fff>
       4  ?<Initializer for __Constant_8000>
       4  ?<Initializer for __Constant_a>
       4  ?<Initializer for __Constant_ffff8000>
       4  ?<Initializer for __Constant_fffffe0c>
       4  ?<Initializer for __Constant_ffffff>
     476  AES_CCMDecrypt
       6  AES_CCMDecrypt::?relay
     446  AES_CCMEncrypt
       6  AES_CCMEncrypt::?relay
     576  AES_StreamCoder
       6  AES_StreamCoder::?relay
     239  AES_init
       6  AES_init::?relay
     449  CBCMAC_buf_encrypt
       6  CBCMAC_buf_encrypt::?relay
     397  CCM_code_decode_test
       6  CCM_code_decode_test::?relay
     238  CCM_test
       6  CCM_test::?relay
       1  CLKCONCMD
       1  CLKCONSTA
       4  COMPARE_TIME
     576  CTR_enc_decrypt
       6  CTR_enc_decrypt::?relay
      88  Callback_execution
       6  Callback_execution::?relay
       4  DELAY_CALIBRATE_TICS
       1  DMA0CFGH
       1  DMA0CFGL
       1  DMA1CFGH
       1  DMA1CFGL
       1  DMAARM
       1  DMAREQ
       8  DMA_AES_DW
       8  DMA_AES_UP
     147  DelayCalibrate
       6  DelayCalibrate::?relay
       1  ENCCS
       2  EventCallback
       2  FirstTask
       4  HeadAllocFunc
      16  IV
      16  IV
     163  Interval
       6  Interval::?relay
      16  KEY
      16  KEY
      37  LED
       6  LED::?relay
     456  LLC_AddTask
       6  LLC_AddTask::?relay
      16  LLC_GetTaskLen
       6  LLC_GetTaskLen::?relay
      50  LLC_Init
       6  LLC_Init::?relay
      99  LLC_RX_HNDL
       6  LLC_RX_HNDL::?relay
      67  LLC_RunTimeAlloc
       6  LLC_RunTimeAlloc::?relay
      20  LLC_SE_HNDL
       6  LLC_SE_HNDL::?relay
      81  LLC_SetRXCallback
       6  LLC_SetRXCallback::?relay
     201  LLC_Shelduler
       6  LLC_Shelduler::?relay
     149  LLC_TimeAlloc
       6  LLC_TimeAlloc::?relay
      50  LoadTXData
       6  LoadTXData::?relay
     350  MACSlotTable
       7  MAC_ACK_Recv
       6  MAC_ACK_Recv::?relay
      50  MAC_ACK_Send
       6  MAC_ACK_Send::?relay
     122  MAC_CloseRXSlot
       6  MAC_CloseRXSlot::?relay
     111  MAC_GetRXState
       6  MAC_GetRXState::?relay
     111  MAC_GetTXState
       6  MAC_GetTXState::?relay
      82  MAC_Init
       6  MAC_Init::?relay
     165  MAC_OpenRXSlot
       6  MAC_OpenRXSlot::?relay
     159  MAC_RX_HNDL
       6  MAC_RX_HNDL::?relay
     338  MAC_Send
       6  MAC_Send::?relay
      19  MAC_SetRXCallback
       6  MAC_SetRXCallback::?relay
      19  MAC_Set_isACK_OK_Callback
       6  MAC_Set_isACK_OK_Callback::?relay
       4  MAC_TIMER_MAX
     808  MAC_TX_HNDL
       6  MAC_TX_HNDL::?relay
      12  MyLowLevelPutchar
       6  MyLowLevelPutchar::?relay
       1  NBR_BUF
       1  NBR_FRAME
       4  NODE_NONCE
       4  NODE_RTC
       4  NODE_UPTIME
      55  NT_GetTime
       6  NT_GetTime::?relay
      19  NT_IRQEnable
       6  NT_IRQEnable::?relay
      54  NT_Init
       6  NT_Init::?relay
     130  NT_SetCompare
       6  NT_SetCompare::?relay
      19  NT_SetEventCallback
       6  NT_SetEventCallback::?relay
     157  NT_SetTime
       6  NT_SetTime::?relay
     126  NT_WaitTime
       6  NT_WaitTime::?relay
       1  P0DIR
       1  P0SEL
       1  P1DIR
       1  PERCFG
       4  RADIO_CFG
       1  RFD
       1  RFIRQF0
       1  RFIRQF1
       1  RFST
      64  RI_BitRawCrypt
       6  RI_BitRawCrypt::?relay
      64  RI_BitRawDecrypt
       6  RI_BitRawDecrypt::?relay
       4  RI_CCA_REJECT
       4  RI_CRC_ERROR
      17  RI_GetCCAReject
       6  RI_GetCCAReject::?relay
      17  RI_GetCRCError
       6  RI_GetCRCError::?relay
      17  RI_GetUptime
       6  RI_GetUptime::?relay
     613  RI_Receive
       6  RI_Receive::?relay
     217  RI_Send
       6  RI_Send::?relay
      32  RI_SetChannel
       6  RI_SetChannel::?relay
      23  RI_StreamCrypt
       6  RI_StreamCrypt::?relay
       4  RI_UPTIME
     109  RI_cfg
       6  RI_cfg::?relay
      38  RI_init
       6  RI_init::?relay
      41  RI_setIV
       6  RI_setIV::?relay
      41  RI_setKEY
       6  RI_setKEY::?relay
       7  RXC
       6  RXC::?relay
       2  RXCallback
       2  RXCallback
       2  RXCallback
     176  RadioRecvTest1
       6  RadioRecvTest1::?relay
      59  ReadTimer
       6  ReadTimer::?relay
     152  RecvData
       6  RecvData::?relay
      10  SEC
       6  SEC::?relay
       2  SECallback
       1  SLEEPSTA
       1  ST0
       1  ST1
       1  ST2
       2  STACK_FAILURE
       6  STACK_FAILURE::?relay
       1  STLOAD
     204  SendData
       6  SendData::?relay
      12  SetCPU32M
       6  SetCPU32M::?relay
       1  T2CTRL
       1  T2M0
       1  T2M1
       1  T2MOVF0
       1  T2MOVF1
      17  TIC_GetNonce
       6  TIC_GetNonce::?relay
      17  TIC_GetRTC
       6  TIC_GetRTC::?relay
      99  TIC_GetRXState
       6  TIC_GetRXState::?relay
      99  TIC_GetTXState
       6  TIC_GetTXState::?relay
       7  TIC_GetTimeStampTS0
       6  TIC_GetTimeStampTS0::?relay
      14  TIC_GetTimer
       6  TIC_GetTimer::?relay
      17  TIC_GetUptime
       6  TIC_GetUptime::?relay
     178  TIC_HW_Timer_IRQ
       6  TIC_HW_Timer_IRQ::?relay
      39  TIC_Init
       6  TIC_Init::?relay
      26  TIC_SetNonce
       6  TIC_SetNonce::?relay
      40  TIC_SetRTC
       6  TIC_SetRTC::?relay
      81  TIC_SetRXCallback
       6  TIC_SetRXCallback::?relay
     129  TIC_SetRXState
       6  TIC_SetRXState::?relay
      81  TIC_SetSECallback
       6  TIC_SetSECallback::?relay
      81  TIC_SetTXCallback
       6  TIC_SetTXCallback::?relay
     129  TIC_SetTXState
       6  TIC_SetTXState::?relay
      94  TIC_SetTimer
       6  TIC_SetTimer::?relay
      92  TIC_TDMAShelduler
       6  TIC_TDMAShelduler::?relay
      66  TIC_TimeUsFromTS0
       6  TIC_TimeUsFromTS0::?relay
      61  TIC_getCurrentTS
       6  TIC_getCurrentTS::?relay
      61  TIM_TimeStamp
       6  TIM_TimeStamp::?relay
      45  TIM_copy
       6  TIM_copy::?relay
     133  TIM_delay
       6  TIM_delay::?relay
      17  TIM_init
       6  TIM_init::?relay
      94  TIM_passedTime
       6  TIM_passedTime::?relay
       2  TOFFSET
      50  TSStateTable
       7  TXC
       6  TXC::?relay
       2  TXCallback
       8  TimeStampTS0
      60  TimerCompareInterrupt
       3  TimerCompareInterrupt::??INTVEC 43
     265  TimerHndl
       6  TimerHndl::?relay
       1  U0BAUD
       1  U0CSR
       1  U0DBUF
       1  U0GCR
      40  UnLoadRXData
       6  UnLoadRXData::?relay
       1  _A_IEN0
       1  _A_IRCON
       1  _A_P0
       1  _A_P1
       4  __Constant_1
       4  __Constant_1388
       4  __Constant_15180
       4  __Constant_1f4
       4  __Constant_20
       4  __Constant_2710
       4  __Constant_3938700
       4  __Constant_3d000000
       4  __Constant_3e8
       4  __Constant_447a0000
       4  __Constant_7fff
       4  __Constant_8000
       4  __Constant_a
       4  __Constant_ffff8000
       4  __Constant_fffffe0c
       4  __Constant_ffffff
     156  __write
       6  __write::?relay
     332  aes_test
       6  aes_test::?relay
      66  alg_test
      97  alg_test
       6  alg_test::?relay
       6  alg_test::?relay
      34  bits_count
       6  bits_count::?relay
     162  buf
     189  calcCompareTime
       6  calcCompareTime::?relay
      94  clocks_update
       6  clocks_update::?relay
      84  delete_test
     506  delete_test
       6  delete_test::?relay
       6  delete_test::?relay
      20  fbuf_chain
       6  fbuf_chain::?relay
     346  fbuf_create
       6  fbuf_create::?relay
      28  fbuf_delete
       6  fbuf_delete::?relay
      16  fbuf_getCount
       6  fbuf_getCount::?relay
      43  fbuf_next
       6  fbuf_next::?relay
       1  finised
     149  frame_create
       6  frame_create::?relay
      73  frame_delete
       6  frame_delete::?relay
      16  frame_getCount
       6  frame_getCount::?relay
      20  frame_get_fbuf_head
       6  frame_get_fbuf_head::?relay
      22  frame_get_fbuf_tail
       6  frame_get_fbuf_tail::?relay
      72  frame_insert_head
       6  frame_insert_head::?relay
     213  frame_insert_tail
       6  frame_insert_tail::?relay
      49  frame_len
       6  frame_len::?relay
     348  frame_merge
       6  frame_merge::?relay
      21  free
       6  free::?relay
     241  generateAuthData
       6  generateAuthData::?relay
     150  getFrame
       6  getFrame::?relay
      34  getMallocSize
       6  getMallocSize::?relay
      53  getRNDByte
       6  getRNDByte::?relay
       7  heap_size
       6  heap_size::?relay
      36  incrementTS
       6  incrementTS::?relay
     134  insert1_test
       6  insert1_test::?relay
     134  insert2_test
       6  insert2_test::?relay
     375  insert3_test
       6  insert3_test::?relay
     375  insert4_test
       6  insert4_test::?relay
       2  isACK_OK
      11  isIRQEnable
       6  isIRQEnable::?relay
      56  isNear
       6  isNear::?relay
       1  led_stat
      70  loadTimerCompare
       6  loadTimerCompare::?relay
     108  main
       6  main::?relay
      21  malloc
       6  malloc::?relay
     189  manual
       6  manual::?relay
    1008  mem_control
       6  mem_control::?relay
      70  memory_compare
       6  memory_compare::?relay
       1  nbrTasks
      17  nwDebugerInit
       6  nwDebugerInit::?relay
     177  one_speed_test
       6  one_speed_test::?relay
      78  random_core_init
       6  random_core_init::?relay
     242  raw_data_test
       6  raw_data_test::?relay
      54  readRandom
       6  readRandom::?relay
       4  ret_val
     121  setFreq
       6  setFreq::?relay
      67  set_capture_time
       6  set_capture_time::?relay
     114  single_enc_dec_test
       6  single_enc_dec_test::?relay
     840  speed_test
       6  speed_test::?relay
       3  stub_se
       6  stub_se::?relay
      18  suite_Frames
       6  suite_Frames::?relay
      14  suite_LLC_HW
       6  suite_LLC_HW::?relay
      17  suite_MAC
       6  suite_MAC::?relay
      14  suite_NT_HW
       6  suite_NT_HW::?relay
      21  suite_RADIO
       6  suite_RADIO::?relay
      14  suite_RADIO_HW
       6  suite_RADIO_HW::?relay
      14  suite_TIC_HW
       6  suite_TIC_HW::?relay
      30  suite_coder
       6  suite_coder::?relay
      21  suite_delays
       6  suite_delays::?relay
      14  suite_delays_HW
       6  suite_delays_HW::?relay
      30  suite_fbuf
       6  suite_fbuf::?relay
      39  suite_frame
       6  suite_frame::?relay
      14  suite_malloc
       6  suite_malloc::?relay
      21  suite_printf_uart
       6  suite_printf_uart::?relay
       1  tasksBLOCK
      74  test_1
     271  test_1
       6  test_1::?relay
       6  test_1::?relay
     214  test_ACK_SEND
       6  test_ACK_SEND::?relay
     215  test_TS_Send
       6  test_TS_Send::?relay
     244  test_create
     442  test_create
       6  test_create::?relay
       6  test_create::?relay
     143  test_frame_merge
       6  test_frame_merge::?relay
     143  test_hw
       6  test_hw::?relay
     375  test_logic
       6  test_logic::?relay
      37  timealloc
       6  timealloc::?relay
     211  tot_len_test
       6  tot_len_test::?relay
      19  uart_init
       6  uart_init::?relay
     118  umsg
       6  umsg::?relay
      45  umsg_line
       6  umsg_line::?relay
      82  umsg_summary
       6  umsg_summary::?relay
       6  utestSigTraceInit
       6  utestSigTraceInit::?relay
       4  utest_summary
       4  val

 
 22 227 bytes in segment BANKED_CODE
  1 038 bytes in segment BANK_RELAYS
      3 bytes in segment INTVEC
     60 bytes in segment NEAR_CODE
     35 bytes in segment SFR_AN
  3 259 bytes in segment XDATA_I
  3 259 bytes in segment XDATA_ID
    694 bytes in segment XDATA_Z
 
  4 275 bytes of CODE     memory (+ 85 bytes shared)
      0 bytes of DATA     memory (+ 35 bytes shared)
 22 183 bytes of HUGECODE memory (+ 44 bytes shared)
  3 889 bytes of XDATA    memory (+ 64 bytes shared)

Errors: none
Warnings: 14
