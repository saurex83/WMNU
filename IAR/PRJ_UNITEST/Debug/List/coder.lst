###############################################################################
#
# IAR C/C++ Compiler V10.10.1.4655 for 8051               01/Dec/2019  21:26:08
# Copyright 2004-2017 IAR Systems AB.
# PC-locked license - IAR Embedded Workbench for 8051
#
#    Core               =  plain
#    Code model         =  banked
#    Data model         =  large
#    Calling convention =  xdata reentrant
#    Constant location  =  data
#    Dptr setup         =  1,16
#                          
#    Source file        =  
#        \\vmware-host\Shared Folders\Projects\WMNU\IAR\SHARE_PRJ_SRC\coder.c
#    Command line       =  
#        -f C:\Users\08A4~1\AppData\Local\Temp\EW888.tmp ("\\vmware-host\Shared
#        Folders\Projects\WMNU\IAR\SHARE_PRJ_SRC\coder.c" -lc
#        "\\vmware-host\Shared
#        Folders\Projects\WMNU\IAR\PRJ_UNITEST\Debug\List" -o
#        "\\vmware-host\Shared Folders\Projects\WMNU\IAR\PRJ_UNITEST\Debug\Obj"
#        -e --debug --core=plain --dptr=16,1 --data_model=large
#        --code_model=banked --calling_convention=xdata_reentrant
#        --place_constants=data --nr_virtual_regs 8 --dlib_config "C:\Program
#        Files (x86)\IAR Systems\Embedded Workbench
#        8.0\8051\LIB\DLIB\dl8051Normal.h" --no_path_in_file_macros -I
#        "\\vmware-host\Shared Folders\Projects\WMNU\IAR\SHARE_PRJ_SRC\" -On
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_cross_call --mfc "\\vmware-host\Shared
#        Folders\Projects\WMNU\IAR\SHARE_PRJ_SRC\delays.c"
#        "\\vmware-host\Shared
#        Folders\Projects\WMNU\IAR\SHARE_PRJ_SRC\ethernet.c"
#        "\\vmware-host\Shared Folders\Projects\WMNU\IAR\SHARE_PRJ_SRC\fbuf.c"
#        "\\vmware-host\Shared Folders\Projects\WMNU\IAR\SHARE_PRJ_SRC\frame.c"
#        "\\vmware-host\Shared Folders\Projects\WMNU\IAR\SHARE_PRJ_SRC\LLC.c"
#        "\\vmware-host\Shared Folders\Projects\WMNU\IAR\SHARE_PRJ_SRC\MAC.c"
#        "\\vmware-host\Shared Folders\Projects\WMNU\IAR\SHARE_PRJ_SRC\mem.c"
#        "\\vmware-host\Shared Folders\Projects\WMNU\IAR\SHARE_PRJ_SRC\NTMR.c"
#        "\\vmware-host\Shared
#        Folders\Projects\WMNU\IAR\SHARE_PRJ_SRC\nwdebuger.c"
#        "\\vmware-host\Shared Folders\Projects\WMNU\IAR\SHARE_PRJ_SRC\RADIO.c"
#        "\\vmware-host\Shared Folders\Projects\WMNU\IAR\SHARE_PRJ_SRC\TIC.c"
#        "\\vmware-host\Shared
#        Folders\Projects\WMNU\IAR\PRJ_UNITEST\src\utest.c"
#        "\\vmware-host\Shared
#        Folders\Projects\WMNU\IAR\PRJ_UNITEST\src\utest_coder.c"
#        "\\vmware-host\Shared
#        Folders\Projects\WMNU\IAR\PRJ_UNITEST\src\utest_delays.c"
#        "\\vmware-host\Shared
#        Folders\Projects\WMNU\IAR\PRJ_UNITEST\src\utest_fbuf.c"
#        "\\vmware-host\Shared
#        Folders\Projects\WMNU\IAR\PRJ_UNITEST\src\utest_frame.c"
#        "\\vmware-host\Shared
#        Folders\Projects\WMNU\IAR\PRJ_UNITEST\src\utest_Frames.c"
#        "\\vmware-host\Shared
#        Folders\Projects\WMNU\IAR\PRJ_UNITEST\src\utest_LLC.c"
#        "\\vmware-host\Shared
#        Folders\Projects\WMNU\IAR\PRJ_UNITEST\src\utest_MAC.c"
#        "\\vmware-host\Shared
#        Folders\Projects\WMNU\IAR\PRJ_UNITEST\src\utest_malloc.c"
#        "\\vmware-host\Shared
#        Folders\Projects\WMNU\IAR\PRJ_UNITEST\src\utest_NTMR.c"
#        "\\vmware-host\Shared
#        Folders\Projects\WMNU\IAR\PRJ_UNITEST\src\utest_printf_uart.c"
#        "\\vmware-host\Shared
#        Folders\Projects\WMNU\IAR\PRJ_UNITEST\src\utest_radio.c"
#        "\\vmware-host\Shared
#        Folders\Projects\WMNU\IAR\PRJ_UNITEST\src\utest_suite.c"
#        "\\vmware-host\Shared
#        Folders\Projects\WMNU\IAR\PRJ_UNITEST\src\utest_TIC.c")
#    Locale             =  Russian_Russia.1251
#    List file          =  
#        \\vmware-host\Shared
#        Folders\Projects\WMNU\IAR\PRJ_UNITEST\Debug\List\coder.lst
#    Object file        =  
#        \\vmware-host\Shared
#        Folders\Projects\WMNU\IAR\PRJ_UNITEST\Debug\Obj\coder.r51
#
###############################################################################

\\vmware-host\Shared Folders\Projects\WMNU\IAR\SHARE_PRJ_SRC\coder.c
      1          /*!
      2          \file Модуль шифрования данных
      3          \brief Функции кодирования данных
      4          */
      5          
      6          #include "coder.h"
      7          #include "ioCC2530.h"
      8          #include "string.h"
      9          #include "delays.h" // Для профилирования, Отладка
     10          
     11          #define AES_START()  {ENCCS |= 0x01;} //!< Запуск выполнения команды  
     12          #define AES_SET_MODE(mode) {ENCCS &= ~0x70; ENCCS |= mode;} //!< Установка режима
     13          #define AES_SET_OPERATION(op) {ENCCS = (ENCCS & ~0x07) | op;} 
     14          #define AES_RDY() (ENCCS & 8) //!< Состояние модуля
     15          
     16          #define ST_DEF(STRUCT, FILD, VAL)  STRUCT.FILD = VAL
     17          #define HADDR(ADDR) ((uint16_t)ADDR >> 8)
     18          #define LADDR(ADDR) ((uint16_t)ADDR)
     19          #define BV(n)                   (1 << (n))
     20          #define MIC_2_MICLEN(m)         (BV((m&3)+1) & ~3)
     21          
     22          // Режимы шифрования
     23          #define AES_MODE_CBC            0x00
     24          #define AES_MODE_CFB            0x10
     25          #define AES_MODE_OFB            0x20
     26          #define AES_MODE_CTR            0x30
     27          #define AES_MODE_ECB            0x40
     28          #define AES_MODE_CBCMAC         0x50
     29          
     30          // Операции 
     31          #define AES_ENCRYPT             0x00
     32          #define AES_DECRYPT             0x02
     33          #define AES_LOAD_KEY            0x04
     34          #define AES_LOAD_IV             0x06
     35          
     36          #define ENC_DW 29 // DMA AES тригер запрос загрузки
     37          #define ENC_UP 30 // DMA AES тригер запрос выгрузки
     38          
     39          #define STREAM_ENC_MODE     AES_MODE_OFB //!< Метод шифрования потока данных
     40          
     41          // Доступные методы
     42          void AES_StreamCoder(bool enc_mode, uint8_t *src, uint8_t *dst, 
     43                               uint8_t *key, uint8_t *nonce, uint8_t len);
     44          
     45          // Приватные функции
     46          static inline uint8_t generateAuthData(uint8_t *src, uint8_t *nonce, uint8_t c,
     47                                                 uint8_t f, uint8_t lm);
     48          static void CBCMAC_buf_encrypt(uint8_t len, uint8_t *key, uint8_t *mac);
     49          
     50          /**
     51          @brief Локальный буфер для работы режима CCM
     52          @detail 128 длина сообщения. 18 длинна блока B0 и строки состояния.
     53           16 длина дополнения нулями
     54          */
     55          static uint8_t buf[128+18+16]; 
     56          
     57          
     58          typedef struct //!< Структура блока B0 для режима CCM
     59          {
     60            struct 
     61            {
     62              uint8_t L:3;
     63              uint8_t M:3;
     64              uint8_t A_Data:1;
     65            } flag;
     66            uint16_t nonce[9];
     67            uint8_t L_M[6];
     68          } __attribute__((packed)) B0_s;
     69          
     70          typedef struct //!< Структура блока A0 для режима CCM
     71          {
     72            struct 
     73            {
     74              uint8_t L:3;
     75            } flag;
     76            uint8_t nonce[11];
     77            uint8_t ctr;
     78          } __attribute__((packed)) A0_s;
     79          
     80          typedef struct //!< Структура с настройками DMA 
     81          {
     82            uint8_t  SRCADDRH;
     83            uint8_t  SRCADDRL;
     84            uint8_t  DSTADDRH;
     85            uint8_t  DSTADDRL;
     86            struct  {
     87            uint8_t   LENH        :5;
     88            uint8_t   VLEN        :3;
     89            };
     90            struct  {
     91            uint8_t   LENL        :8;
     92            };
     93            struct  {
     94            uint8_t   TRIG        :5;
     95            uint8_t   TMODE       :2;
     96            uint8_t   WORDSIZE    :1;
     97            };
     98            struct {
     99            uint8_t   PRIORITY    :2;
    100            uint8_t   M8          :1;
    101            uint8_t   IRQMASK     :1;
    102            uint8_t   DESTINC     :2;
    103            uint8_t   SRCINC      :2;
    104            };
    105          } __attribute__((packed)) DMA_AES_s ;
    106          
    107          DMA_AES_s DMA_AES_DW; //!< DMA на запись
    108          DMA_AES_s DMA_AES_UP; //!< DMA на чтение
    109          
    110          
    111          /**
    112          @brief Иницилизация модуля
    113          @detail Модуль использует DMA каналы 0 и 1
    114          */
    115          void AES_init(void)
    116          {
    117            // Настроим канал 0 DMA для загрузки данных в AES
    118            uint16_t CONF_ADDR = (uint16_t)&DMA_AES_DW;
    119            DMA0CFGH = CONF_ADDR >> 8;
    120            DMA0CFGL = CONF_ADDR & 0xFF;
    121            
    122            // Настроим канал 1 DMA для выгрузки данных из AES
    123            CONF_ADDR = (uint16_t)&DMA_AES_UP;
    124            DMA1CFGH = CONF_ADDR >> 8;
    125            DMA1CFGL = CONF_ADDR & 0xFF;
    126            
    127            ST_DEF(DMA_AES_DW, DSTADDRH, 0x70); // Пишем данные XENCDI = 0xB1 
    128            ST_DEF(DMA_AES_DW, DSTADDRL, 0xB1); //  
    129            ST_DEF(DMA_AES_DW, PRIORITY, 0x00); // Низкий приоритет
    130            ST_DEF(DMA_AES_DW, M8, 0x00); // Используем 8 бит для счетика длинны
    131            ST_DEF(DMA_AES_DW, IRQMASK, 0x00); // Запрещаем генерировать перывания
    132            ST_DEF(DMA_AES_DW, DESTINC, 0x00); // Не увеличиваем адресс назначения
    133            ST_DEF(DMA_AES_DW, SRCINC, 0x01); // Увеличиваем адресс источника
    134            ST_DEF(DMA_AES_DW, TRIG, ENC_DW); // Тригер по загрузке
    135            ST_DEF(DMA_AES_DW, WORDSIZE, 0x00); // Копируем по 1 байту
    136            ST_DEF(DMA_AES_DW, TMODE, 0x01); //  Блочное копирование по тригеру
    137            ST_DEF(DMA_AES_DW, VLEN, 0x00); //  Количество байт определяет поле LEN  
    138            ST_DEF(DMA_AES_DW, LENH, 0x00); 
    139            
    140            ST_DEF(DMA_AES_UP, SRCADDRH, 0x70); // Читаем данные из X_ENCDO  
    141            ST_DEF(DMA_AES_UP, SRCADDRL, 0xB2);  
    142            ST_DEF(DMA_AES_UP, PRIORITY, 0x00); // Низкий приоритет
    143            ST_DEF(DMA_AES_UP, M8, 0x00); // Используем 8 бит для счетика длинны
    144            ST_DEF(DMA_AES_UP, IRQMASK, 0x00); // Запрещаем генерировать перывания
    145            ST_DEF(DMA_AES_UP, DESTINC, 0x01); // Увеличиваем адресс назначения
    146            ST_DEF(DMA_AES_UP, SRCINC, 0x00); // Не увеличиваем адресс источника
    147            ST_DEF(DMA_AES_UP, TRIG, ENC_UP); // Тригер по выгрузке
    148            ST_DEF(DMA_AES_UP, WORDSIZE, 0x00); // Копируем по 1 байту
    149            ST_DEF(DMA_AES_UP, TMODE, 0x01); //  Блочное копирование по тригеру
    150            ST_DEF(DMA_AES_UP, VLEN, 0x00); //  Количество байт определяет поле LEN  
    151            ST_DEF(DMA_AES_UP, LENH, 0x00); 
    152          }
    153          
    154          /**
    155          @brief Шифрует/дешифрует поток данных во время радиопередачи. Без проверки MIC
    156          @param[in] enc_mode Режим работы процедуры. true - шифрование.
    157          @param[in] src Указатель на данные подлежащии шифрованию
    158          @param[in] dst Указтель куда будут помещены зашифрованные данные
    159          @param[in] key Указатье на ключ. 16 байт
    160          @param[in] iv  Указатель на вектор иницилизации. 16 байт 
    161          @param[in] len Длинна данных
    162          */
    163          void AES_StreamCoder(bool enc_mode, uint8_t *src, uint8_t *dst, uint8_t *key,
    164                                   uint8_t *iv, uint8_t len)
    165          {
    166            // Установим метод кодироваения
    167            AES_SET_MODE(STREAM_ENC_MODE);
    168              
    169            // Загружаем ключ
    170            AES_SET_OPERATION(AES_LOAD_KEY);
    171            ST_DEF(DMA_AES_DW, SRCADDRL, LADDR(key));
    172            ST_DEF(DMA_AES_DW, SRCADDRH, HADDR(key));
    173            ST_DEF(DMA_AES_DW, LENL, 16);
    174            DMAARM |= 0x01;
    175            while(!AES_RDY());
    176            AES_START();
    177            while (DMAARM);
    178          
    179            // Загружаем IV
    180            AES_SET_OPERATION(AES_LOAD_IV);
    181            ST_DEF(DMA_AES_DW, SRCADDRL, LADDR(iv));
    182            ST_DEF(DMA_AES_DW, SRCADDRH, HADDR(iv));
    183            ST_DEF(DMA_AES_DW, LENL, 16);
    184            DMAARM |= 0x01;
    185            while(!AES_RDY());
    186            AES_START();
    187            while (DMAARM);
    188          
    189            // Установим необходимую операцию AES
    190            if (enc_mode) 
    191              AES_SET_OPERATION(AES_ENCRYPT)
    192            else 
    193              AES_SET_OPERATION(AES_DECRYPT)
    194            
    195            switch(STREAM_ENC_MODE) 
    196            {
    197            case AES_MODE_ECB: // ECB, CBC не реализованы
    198            case AES_MODE_CBC:
    199              break;
    200            case AES_MODE_CFB:
    201            case AES_MODE_OFB:
    202            case AES_MODE_CTR:
    203              {
    204                // Загрузка блоками по 128 бит с разделением на под-блоки по 32 бита
    205                uint8_t nbrBlocks = len / 16; // Количество целых блоков по 128 бит
    206                uint8_t ptr, sub_ptr; // Смещение
    207                uint8_t *download, *upload;
    208                
    209                // Для этих типов шифрования длина блоков по 4 байта
    210                ST_DEF(DMA_AES_DW, LENL, 4);
    211                ST_DEF(DMA_AES_UP, LENL, 4);
    212                
    213                // Шифруем все целые блоки
    214                for (uint8_t block = 0; block < nbrBlocks; block ++)
    215                {
    216                  ptr = 16 * block;
    217                  while(!AES_RDY());
    218                  AES_START();
    219                  for (uint8_t j = 0; j < 4; j++)
    220                  {
    221                    sub_ptr = ptr + 4*j;
    222                    download = &src[sub_ptr];
    223                    upload = &dst[sub_ptr];
    224                    // Указываем адресс DMA откуда читать данные
    225                    ST_DEF(DMA_AES_DW, SRCADDRL, LADDR(download));
    226                    ST_DEF(DMA_AES_DW, SRCADDRH, HADDR(download));
    227                    // Указываем адрес DMA куда записывать данные          
    228                    ST_DEF(DMA_AES_UP, DSTADDRL, LADDR(upload));
    229                    ST_DEF(DMA_AES_UP, DSTADDRH, HADDR(upload));
    230                    // Активируем DMA
    231                    DMAARM |= 0x03;  
    232                    DMAREQ |= 0x01;
    233                    while (DMAARM);          
    234                  }
    235                }     
    236                // Шифруем последний блок
    237                uint8_t block_len = len % 16; // Размер последнего блока
    238                
    239                // Завершаем работу если блок пустой
    240                if (!block_len)
    241                  return;
    242                
    243                uint8_t padding_block[16]; // Блок заполненый нулями
    244                ptr = 16*nbrBlocks; // Смещение на первый байт последнего блока в src
    245                memset(padding_block, 0x00, sizeof(padding_block)); // Заполняем нулями
    246                memcpy(padding_block, &src[ptr], block_len); // Копируем данные
    247                
    248                while(!AES_RDY());
    249                AES_START();
    250                for (uint8_t j = 0; j < 4; j++)
    251                  {
    252                    sub_ptr = 4*j;
    253                    download = &padding_block[sub_ptr];
    254                    // Указываем адресс DMA откуда читать данные
    255                    ST_DEF(DMA_AES_DW, SRCADDRL, LADDR(download));
    256                    ST_DEF(DMA_AES_DW, SRCADDRH, HADDR(download));
    257                    // Указываем аддрес DMA куда записывать данные          
    258                    ST_DEF(DMA_AES_UP, DSTADDRL, LADDR(download));
    259                    ST_DEF(DMA_AES_UP, DSTADDRH, HADDR(download));
    260                    // Активируем DMA
    261                    DMAARM |= 0x03;  
    262                    DMAREQ |= 0x01;
    263                    while (DMAARM);
    264                  }
    265                memcpy(&dst[ptr], padding_block, block_len); // Копируем в src
    266                
    267              } //CASE
    268              
    269              break;
    270            } 
    271          }
    272          
    273          /**
    274          @brief Шифрует/дешифрует поток данных во время радиопередачи. Без проверки MIC
    275          @param[in] enc_mode Режим работы процедуры. true - шифрование.
    276          @param[in] src Указатель на данные подлежащии шифрованию
    277          @param[in] dst Указтель куда будут помещены зашифрованные данные
    278          @param[in] key Указатье на ключ. 16 байт
    279          @param[in] iv  Указатель на вектор иницилизации. 16 байт 
    280          @param[in] len Длинна данных
    281          */
    282          static void CTR_enc_decrypt(bool enc_mode, uint8_t *src, uint8_t *dst, uint8_t *key,
    283                                   uint8_t *iv, uint8_t len)
    284          {
    285            // Установим метод кодироваения
    286            AES_SET_MODE(AES_MODE_CTR);
    287            
    288            // Загружаем ключ
    289            AES_SET_OPERATION(AES_LOAD_KEY);
    290            ST_DEF(DMA_AES_DW, SRCADDRL, LADDR(key));
    291            ST_DEF(DMA_AES_DW, SRCADDRH, HADDR(key));
    292            ST_DEF(DMA_AES_DW, LENL, 16);
    293            DMAARM |= 0x01;
    294            while(!AES_RDY());
    295            AES_START();
    296            while (DMAARM);
    297          
    298            // Загружаем IV
    299            AES_SET_OPERATION(AES_LOAD_IV);
    300            ST_DEF(DMA_AES_DW, SRCADDRL, LADDR(iv));
    301            ST_DEF(DMA_AES_DW, SRCADDRH, HADDR(iv));
    302            ST_DEF(DMA_AES_DW, LENL, 16);
    303            DMAARM |= 0x01;
    304            while(!AES_RDY());
    305            AES_START();
    306            while (DMAARM);
    307          
    308            // Установим необходимую операцию AES
    309            if (enc_mode) 
    310              AES_SET_OPERATION(AES_ENCRYPT)
    311            else 
    312              AES_SET_OPERATION(AES_DECRYPT)
    313            
    314            // Загрузка блоками по 128 бит с разделением на под-блоки по 32 бита
    315            uint8_t nbrBlocks = len / 16; // Количество целых блоков по 128 бит
    316            uint8_t ptr, sub_ptr; // Смещение
    317            uint8_t *download, *upload;
    318                
    319            // Для этих типов шифрования длина блоков по 4 байта
    320            ST_DEF(DMA_AES_DW, LENL, 4);
    321            ST_DEF(DMA_AES_UP, LENL, 4);
    322                
    323            // Шифруем все целые блоки
    324            for (uint8_t block = 0; block < nbrBlocks; block ++)
    325              {
    326                ptr = 16 * block;
    327                while(!AES_RDY());
    328                AES_START();
    329                for (uint8_t j = 0; j < 4; j++)
    330                  {
    331                    sub_ptr = ptr + 4*j;
    332                    download = &src[sub_ptr];
    333                    upload = &dst[sub_ptr];
    334                    // Указываем адресс DMA откуда читать данные
    335                    ST_DEF(DMA_AES_DW, SRCADDRL, LADDR(download));
    336                    ST_DEF(DMA_AES_DW, SRCADDRH, HADDR(download));
    337                    // Указываем адрес DMA куда записывать данные          
    338                    ST_DEF(DMA_AES_UP, DSTADDRL, LADDR(upload));
    339                    ST_DEF(DMA_AES_UP, DSTADDRH, HADDR(upload));
    340                    // Активируем DMA
    341                    DMAARM |= 0x03;  
    342                    DMAREQ |= 0x01;
    343                    while (DMAARM);          
    344                  }
    345              }     
    346              // Шифруем последний блок
    347              uint8_t block_len = len % 16; // Размер последнего блока
    348                
    349              // Завершаем работу если блок пустой
    350              if (!block_len)
    351                return;
    352                
    353              uint8_t padding_block[16]; // Блок заполненый нулями
    354              ptr = 16*nbrBlocks; // Смещение на первый байт последнего блока в src
    355              memset(padding_block, 0x00, sizeof(padding_block)); // Заполняем нулями
    356              memcpy(padding_block, &src[ptr], block_len); // Копируем данные
    357              
    358              while(!AES_RDY());
    359              AES_START();
    360              for (uint8_t j = 0; j < 4; j++)
    361                {
    362                  sub_ptr = 4*j;
    363                  download = &padding_block[sub_ptr];
    364                  // Указываем адресс DMA откуда читать данные
    365                  ST_DEF(DMA_AES_DW, SRCADDRL, LADDR(download));
    366                  ST_DEF(DMA_AES_DW, SRCADDRH, HADDR(download));
    367                  // Указываем аддрес DMA куда записывать данные          
    368                  ST_DEF(DMA_AES_UP, DSTADDRL, LADDR(download));
    369                  ST_DEF(DMA_AES_UP, DSTADDRH, HADDR(download));
    370                  // Активируем DMA
    371                  DMAARM |= 0x03;  
    372                  DMAREQ |= 0x01;
    373                  while (DMAARM);
    374                }
    375              memcpy(&dst[ptr], padding_block, block_len); // Копируем в src
    376          }
    377          
    378          /**
    379          @brief Зашифровывает buf в режиме CBC-MAC с IV = 0
    380          @param[in] len улинна последовательности для вычисления MAC
    381          @param[out] mac указатель на память куда будет записан mac (до 16 байт)
    382          */
    383          static void CBCMAC_buf_encrypt(uint8_t len, uint8_t *key, uint8_t *mac)
    384          {
    385            uint8_t IV[16];
    386            
    387            // Заполняем вектор нулями
    388            memset(IV, 0x00, sizeof(IV));
    389            
    390            // Установим метод кодироваения
    391            AES_SET_MODE(AES_MODE_CBCMAC);  
    392            
    393            { // Сворачиваем код для улучшения чтения
    394            // Загружаем ключ
    395            AES_SET_OPERATION(AES_LOAD_KEY);
    396            ST_DEF(DMA_AES_DW, SRCADDRL, LADDR(key));
    397            ST_DEF(DMA_AES_DW, SRCADDRH, HADDR(key));
    398            ST_DEF(DMA_AES_DW, LENL, 16);
    399            DMAARM |= 0x01;
    400            while(!AES_RDY());
    401            AES_START();
    402            while (DMAARM);
    403          
    404            // Загружаем IV
    405            AES_SET_OPERATION(AES_LOAD_IV);
    406            ST_DEF(DMA_AES_DW, SRCADDRL, LADDR(IV));
    407            ST_DEF(DMA_AES_DW, SRCADDRH, HADDR(IV));
    408            ST_DEF(DMA_AES_DW, LENL, 16);
    409            DMAARM |= 0x01;
    410            while(!AES_RDY());
    411            AES_START();
    412            while (DMAARM);
    413            };
    414            
    415            // Устанавливаем операцию шифрования
    416            AES_SET_OPERATION(AES_ENCRYPT);
    417            
    418            // Загрузка блоками по 128 бит
    419            uint8_t nbrBlocks = len / 16; // Количество целых блоков по 128 бит
    420            uint8_t block_len = len % 16; // Размер последнего блока
    421            uint8_t ptr; // Смещение
    422                
    423            // Для этого типа шифрования длина блоков по 16 байт
    424            ST_DEF(DMA_AES_DW, LENL, 16);
    425            // Устанавливаем куда будем выгружать вычисленный MAC
    426            ST_DEF(DMA_AES_UP, DSTADDRL, LADDR(mac));
    427            ST_DEF(DMA_AES_UP, DSTADDRH, HADDR(mac));
    428            ST_DEF(DMA_AES_UP, LENL, 16);
    429            
    430            // Шифруем все целые блоки
    431            for (uint8_t block = 0; block < nbrBlocks; block ++)
    432              {
    433                // Последний блок шифруем в режиме CBC при условии что нет блок не 
    434                // кратного 16 байтам.
    435                if (!block_len && (block == nbrBlocks - 1))
    436                  AES_SET_MODE(AES_MODE_CBC);
    437                    
    438                ptr = 16 * block;
    439                while(!AES_RDY());
    440                AES_START();
    441                // Указываем адресс DMA откуда читать данные
    442                ST_DEF(DMA_AES_DW, SRCADDRL, LADDR(buf[ptr]));
    443                ST_DEF(DMA_AES_DW, SRCADDRH, HADDR(buf[ptr]));
    444                // Активируем DMA
    445                DMAARM |= 0x01;  
    446                // Активируем выгрузку только последнего блока
    447                if (!block_len && (block == nbrBlocks - 1))
    448                  DMAARM = 0x03;
    449                
    450                DMAREQ |= 0x01;
    451                while (DMAARM);          
    452               }
    453                 
    454            // Шифруем последний блок в режиме CBC
    455            AES_SET_MODE(AES_MODE_CBC);
    456                    
    457            // Завершаем работу если блок пустой
    458            if (!block_len)
    459              return;
    460                
    461            uint8_t padding_block[16]; // Блок заполненый нулями
    462            ptr = 16*nbrBlocks; // Смещение на первый байт последнего блока в src
    463            memset(padding_block, 0x00, sizeof(padding_block)); // Заполняем нулями
    464            memcpy(padding_block, &buf[ptr], block_len); // Копируем данные
    465                
    466            while(!AES_RDY());
    467            AES_START();
    468            // Указываем адресс DMA откуда читать данные
    469            ST_DEF(DMA_AES_DW, SRCADDRL, LADDR(padding_block));
    470            ST_DEF(DMA_AES_DW, SRCADDRH, HADDR(padding_block));
    471            // Активируем DMA и выгрузку MAC
    472            DMAARM |= 0x03;  
    473            DMAREQ |= 0x01;
    474            while (DMAARM);
    475          }
    476          
    477          static inline uint8_t generateAuthData(uint8_t *src, uint8_t *nonce, uint8_t c,
    478                                                 uint8_t f, uint8_t lm)
    479          {
    480            memcpy(buf, nonce,16);
    481            
    482            // Буфер от 0 до 15 байта специальный блок B0
    483            // Настраиваем флаг. У нас длинна 2 байта. nonce 13 байт => L_M = L-1=0x01
    484            buf[0]=  0x01;  
    485            // Если есть данные для авторизации установим A_Data 
    486            if (f > 0)
    487              buf[0] |= 0x40;
    488            
    489            buf[0] |= ((lm - 2) / 2 ) << 3;   // см. документацию M'= (lm-2) / 2;
    490            
    491            // Устанавливаем длинну сообщения
    492            buf[14] = 0x00;
    493            buf[15] = c;
    494            
    495            // Добавляем строку авторизации L(a). если данных нет, то она пустая. f=0
    496            buf[16]= 0;
    497            buf[17]= f;
    498            
    499            // Копируем данные авторизации в буфер
    500            memcpy(&buf[18], src, f);
    501            
    502            // Смещение на следующий байт после данных авторизации.
    503            // Данные авторизации занимают положение в буфере [18, 18+f]
    504            uint8_t ptr_end= 18 + f;
    505            // Заполняем нулями до границы 16 байт  
    506            while (ptr_end & 0x0f)
    507              buf[ptr_end++] = 0x00;
    508            
    509            // Копируем данные для шифрования в буфер после нулей
    510            memcpy(&buf[ptr_end], &src[f], c);
    511            
    512            // Возвращаем размер данных в буфере
    513            return ptr_end+c;
    514          };
    515          
    516          /**
    517          @brief Шифрует/дешифрует данные с проверкой MIC
    518          @param[in] src Указатель на данные подлежащии шифрованию
    519          @param[in] len Размер данных
    520          @param[in] с Количество байт для шифрования
    521          @param[in] f Количество байт для авторизации
    522          @param[in] m Размер MIC (m=1,2,3 l(m) = 4,8,16 байт)
    523          @param[in] iv  Указатель на вектор иницилизации. 16 байт 
    524          @param[in] len Длинна данных
    525          @param[in,out] MIC Указатель на массив соответсвующий длинне (4,8,16 байт)
    526          */
    527          void AES_CCMEncrypt( uint8_t *src, uint8_t c, uint8_t f, uint8_t m,
    528                              uint8_t *key, uint8_t *nonce, uint8_t *MIC)
    529          {
    530            uint8_t lm = MIC_2_MICLEN(m);
    531            
    532            // Генерируем данные для авторизации
    533            uint8_t dlen = generateAuthData(src, nonce, c, f, lm);
    534            
    535            uint8_t mac[16]; // Сюда пишем мак
    536            CBCMAC_buf_encrypt(dlen, key, mac);
    537            
    538            // Шифруем MAC
    539            uint8_t CTR_IV[16];
    540            memcpy(CTR_IV, nonce, 16);
    541            CTR_IV[0] = 0x01; // Флаг режима CTR
    542            CTR_IV[15] = 0;   // Значение счетчика
    543            CTR_enc_decrypt(true, mac, mac, key, CTR_IV, 16);
    544            
    545            // Шифруем текст. он имеет размер 'c' и находится в буфере начиная с
    546            // dlen-c, dlen
    547            uint8_t ds = dlen - c; // Начало данных для шифрования
    548            
    549            // 0x0F & (16 - (dlen & 0x0f)) оставляет числа от 0 до 15  
    550            memset(buf+dlen, 0x00, 0x0F & (16 - (dlen & 0x0f)) ); // Дополняем нулями
    551            CTR_IV[15] = 1; // Счетчик CTR
    552            CTR_enc_decrypt(true, &buf[ds], &buf[ds], key, CTR_IV, c); // Шифруем
    553            
    554            // Заполняем буфер буфер src. src[0,f] это данные авторизации. 
    555            // src[f, f+c] это шифрованные данные.
    556            memcpy(&src[f], &buf[ds], c); 
    557            memcpy(MIC, mac, lm);
    558            
    559            //https://github.com/zhaohengyi/CC2530Example/blob/
    560            //master/source/components/radios/cc2530/hal_rf_security.c
    561          }
    562          
    563          /**
    564          @brief Дешифрует данные с проверкой MIC
    565          @param[in] src Указатель на данные подлежащии шифрованию
    566          @param[in] len Размер данных
    567          @param[in] с Количество байт для шифрования
    568          @param[in] f Количество байт для авторизации
    569          @param[in] m Размер MIC (m=1,2,3 l(m) = 4,8,16 байт)
    570          @param[in] iv  Указатель на вектор иницилизации. 16 байт 
    571          @param[in] len Длинна данных
    572          @param[in,out] MIC Указатель на массив соответсвующий длинне (4,8,16 байт)
    573          */
    574          bool AES_CCMDecrypt( uint8_t *src, uint8_t c, uint8_t f, uint8_t m,
    575                              uint8_t *key, uint8_t *nonce, uint8_t *MIC)
    576          {
    577            uint8_t lm = MIC_2_MICLEN(m);
    578            
    579            // Расшифровываем MAC
    580            uint8_t mac[16]; // Расшифрованый мак
    581            uint8_t CTR_IV[16];
    582            memcpy(CTR_IV, nonce, 16);
    583            CTR_IV[0] = 0x01; // Флаг режима CTR
    584            CTR_IV[15] = 0;   // Значение счетчика
    585            CTR_enc_decrypt(false, MIC, mac, key, CTR_IV, lm);  
    586            
    587            // Генерируем данные для авторизации
    588            uint8_t dlen = generateAuthData(src, nonce, c, f, lm);
    589            
    590            // Дешифруем текст. он имеет размер 'c' и находится в буфере начиная с
    591            // dlen-c, dlen
    592            uint8_t ds = dlen - c; // Начало данных для дешифрования
    593            
    594            // 0x0F & (16 - (dlen & 0x0f)) оставляет числа от 0 до 15  
    595            memset(buf+dlen, 0x00, 0x0F & (16 - (dlen & 0x0f)) ); // Дополняем нулями
    596            CTR_IV[15] = 1; // Счетчик CTR
    597            CTR_enc_decrypt(false, &buf[ds], &buf[ds], key, CTR_IV, c); // Дешифруем
    598            
    599            uint8_t new_mac[16]; // мак полученный в ходе рашифровки сообщения
    600            CBCMAC_buf_encrypt(dlen, key, new_mac);
    601            
    602            // Проверяем что маки совпадают, значит дешифровано верно
    603            bool mac_equal = true;
    604            for (uint8_t i = 0 ; i < lm ; i++)
    605            {
    606              if (mac[i] != new_mac[i])
    607              mac_equal = false;
    608              break;
    609            }
    610            
    611            // Выходим если MACи не совпали  
    612            if (!mac_equal)
    613              return false;
    614            
    615            // Копируем  расшифрованные данные
    616            memcpy(&src[f], &buf[ds], c); 
    617            return true;
    618          }
\\vmware-host\Shared Folders\Projects\WMNU\IAR\SHARE_PRJ_SRC\delays.c
      1          /*!
      2          \file  Модуль измерения интервалов времени и функция задержки времени
      3          \brief Функции измерения времени и задержки
      4          */
      5          
      6          #include "ioCC2530.h"
      7          #include "delays.h"
      8          #include "string.h"
      9          
     10          #define TICK_NS  31.25 // Количество нс в одном такте TIM2
     11          #define TICK_US  0.03125 // Количество мкс в одном такте TIM2
     12          #define TICK_PER_US 32 // Количество тактов в одной микросекунде
     13          
     14          // Максимальное кол-во тактов таймера. Константа 40 бит, 5 байт
     15          static const uint32_t MAC_TIMER_MAX = 0xFFFFFFFFUL; 
     16          static uint32_t DELAY_CALIBRATE_TICS; // Колибровка функции задержки
     17          
     18          // Публичные методы
     19          void TIM_init(void);
     20          void TIM_TimeStamp(TimeStamp_s* timestamp);
     21          void TIM_delay(uint32_t delay);
     22          uint32_t TIM_passedTime(TimeStamp_s* start, TimeStamp_s* stop);
     23          void TIM_copy(TimeStamp_s *src, TimeStamp_s *dst);
     24          
     25          // Приватные
     26          static inline uint32_t Interval(TimeStamp_s* start, TimeStamp_s* stop);
     27          static void DelayCalibrate(void);
     28          
     29          /**
     30          @brief Иницилизация таймера
     31          @brief Используется таймер 2. MAC таймер
     32          */
     33          void TIM_init(void)
     34          {
     35            // Запускаем таймер, LATCH MODE = 1
     36            // Latch mode фиксирует значение таймера переполнения при чтении T2M0
     37            // ЗАпускаем MAC таймер без синхронизации с кварцем 32.768к
     38            T2CTRL = (1<<0) | (1<<3); 
     39            // Калибровка функции задержки
     40            DelayCalibrate();
     41          }
     42          
     43          /**
     44          @brief Возвращает временую метку.
     45          @params[out] timestamp указатель на временную метку 
     46          */
     47          void TIM_TimeStamp(TimeStamp_s* timestamp)
     48          {
     49            timestamp->byte[0] = T2M0;
     50            timestamp->byte[1] = T2M1;
     51            timestamp->byte[2] = T2MOVF0;
     52            timestamp->byte[3] = T2MOVF1;
     53          }
     54          
     55          /**
     56          @brief Калибровка функции задержки TIM_delay
     57          */
     58          static void DelayCalibrate(void)
     59          {
     60            #define ACCURATE_VAL_US 500 
     61            DELAY_CALIBRATE_TICS = 0;
     62            TimeStamp_s start, stop;
     63            uint32_t passed, cal;
     64            
     65            TIM_TimeStamp(&start);
     66            TIM_delay(ACCURATE_VAL_US);
     67            TIM_TimeStamp(&stop);
     68            passed = TIM_passedTime(&start, &stop);
     69            
     70            cal = passed - ACCURATE_VAL_US;
     71            DELAY_CALIBRATE_TICS = cal * TICK_PER_US; 
     72          };
     73          
     74          /**
     75          @brief Вычисляет количество тактов между двумя времеными метками
     76          @return Количество тактов
     77          */
     78          static inline uint32_t Interval(TimeStamp_s* start, TimeStamp_s* stop)
     79          {
     80            uint32_t ret;
     81          
     82            if (stop->timer >= start->timer)
     83              ret = stop->timer - start->timer;
     84            else
     85            { 
     86              ret = (MAC_TIMER_MAX - start->timer) + stop->timer;
     87            }
     88            return ret;
     89          }
     90          
     91          /**
     92          @brief Вычисляет прошедшее время между двумя времеными метками
     93          @return Время в мкс.
     94          */
     95          uint32_t TIM_passedTime(TimeStamp_s* start, TimeStamp_s* stop)
     96          {
     97            uint32_t ret = Interval(start, stop);
     98            
     99            ret = (uint32_t)((float)ret * TICK_US);
    100            return ret;
    101          }
    102          
    103          /**
    104          @brief Задержка на заданное количество мкс. 
    105          @details Погрешность около 20 мкс при значениях выше 150 мкс.
    106           Рекомендуется использовать для организации задержек не менее 200 мкс.
    107          @params[in] delay количество микросекунд. Не более 134217727 мкс (134.2 сек)
    108          */
    109          void TIM_delay(uint32_t delay)
    110          {
    111            uint32_t passed = 0;
    112            TimeStamp_s start, now;
    113            TIM_TimeStamp(&start);
    114            
    115            // Конвертируем мкс в такты и вносим поправку
    116            delay = delay * TICK_PER_US; 
    117            if (delay > DELAY_CALIBRATE_TICS)
    118              delay -= DELAY_CALIBRATE_TICS;
    119            
    120            do
    121            {
    122              TIM_TimeStamp(&now);
    123              passed = Interval(&start, &now);
    124            } while (passed < delay);
    125          }
    126          
    127          /**
    128          @brief Копирование временной метки
    129          @param[in] src указатель на исходную метку для копирование
    130          @param[out] dst указатель на метку назначения
    131          */
    132          void TIM_copy(TimeStamp_s *src, TimeStamp_s *dst)
    133          {
    134            memcpy(src, dst, sizeof(TimeStamp_s));
    135          }
\\vmware-host\Shared Folders\Projects\WMNU\IAR\SHARE_PRJ_SRC\ethernet.c
      1          #include "frame.h"
      2          #include "Net_frames.h"
      3          #include "stdint.h"
      4          #include "nwdebuger.h"
      5          #include "LLC.h"
      6          #include "mem.h"
      7          
      8          void ETH_Send(frame_s *fr);
      9          
     10          static void ETH_RX_HNDL(frame_s *fr);
     11          static void (*RXCallback)(frame_s *fr); //frame_s RAW_LAY, wthout ETH_LAY
     12          static bool validate(ETH_LAY *eth);
     13          static ETH_LAY* extract_header(frame_s *fr);
     14          static void send_ack(ETH_LAY *eth);
     15          static frame_s* strip_header(frame_s *fr);
     16          
     17          /**
     18          @brief Иницилизация модуля
     19          */
     20          void ETH_Init(void)
     21          {
     22            RXCallback = NULL; 
     23            LLC_SetRXCallback(ETH_RX_HNDL);
     24          }
     25          
     26          /**
     27          @brief Установка обработчика приема пакета ETH
     28          */
     29          void ETH_Set_RXCallback(void (*fn)(frame_s *fr))
     30          {
     31            ASSERT_HALT(fn != NULL, "NULL pointer not allow");
     32            RXCallback = fn;
     33          }
     34          
     35          /**
     36          @brief Обработка принятого пакет сети.
     37          @detail После валидации пакета, уничтожается заголовок ETH и пакет передается
     38           на дальнейшую обработку вверх по стеку с помощью обратного вызова RXCallback
     39          */
     40          static void ETH_RX_HNDL(frame_s *fr)
     41          {
     42            ASSERT_HALT(fr != NULL, "fr is NULL");
     43            
     44            bool valid;
     45            frame_s *striped_frame;
     46            
     47            ETH_LAY* eth_h = extract_header(fr);
     48            
     49            // Извлечь заголовок не удалось
     50            if (eth_h == NULL)
     51              goto ERR_FRAME;
     52            
     53            valid = validate(eth_h);
     54           
     55            // Заголовок не верный
     56            if (!valid)
     57              goto ERR_FRAME;
     58           
     59            // Требуется отправить подтверждение приема пакета
     60            if (eth_h->ETH_T.bits.ACK)
     61              send_ack(eth_h);
     62            
     63            // Создаем новый пакет без заголовка и удаляем исходный
     64            striped_frame = strip_header(fr);
     65            frame_delete(fr);
     66            ASSERT_HALT(striped_frame != NULL, "Striped_frame is NULL");
     67            
     68            // Передаем обработчику выше по стеку
     69            ASSERT_HALT(RXCallback != NULL, "RXCallback is NULL");
     70            RXCallback(striped_frame);
     71            
     72            re_free(eth_h);
     73            return;
     74            
     75          ERR_FRAME:
     76            frame_delete(fr);
     77            re_free(eth_h);
     78            return;
     79          }
     80          
     81          /**
     82          @brief Создает новый пакет без заголовка ETH_H
     83          @return указатель на новый frame_s*. NULL - не удалось создать пакет
     84          */
     85          static frame_s* strip_header(frame_s *fr)
     86          {
     87          }
                 ^
Warning[Pe940]: missing return statement at end of non-void function
          "strip_header"
          detected during compilation of secondary translation unit
                    "\\vmware-host\Shared
                    Folders\Projects\WMNU\IAR\SHARE_PRJ_SRC\ethernet.c"
     88          
     89          /**
     90          @brief Подготавливает и отпправляет подтверждение приема пакета
     91          */
     92          static void send_ack(ETH_LAY *eth)
     93          {
     94           
     95          }
     96          
     97          static bool validate(ETH_LAY *eth)
     98          {
     99            return true;
    100          }
    101          
    102          static ETH_LAY* extract_header(frame_s *fr)
    103          {
    104            ETH_LAY* eth_h = (ETH_LAY*)re_malloc(ETH_LAY_SIZE);
    105            ASSERT_HALT(eth_h != NULL, "No memory");
    106            
    107            uint8_t len = frame_len(fr);
    108            ASSERT_HALT(len >= ETH_LAY_SIZE, "Incorrect eth size");
    109            
    110            fbuf_s *fb = frame_get_fbuf_head(fr);
    111            re_memcpy(eth_h, fb->payload, ETH_LAY_SIZE);
    112            return eth_h;
    113          }
\\vmware-host\Shared Folders\Projects\WMNU\IAR\SHARE_PRJ_SRC\fbuf.c
      1          /*!
      2          \file Модуль реализует связанные буфера данных
      3          \brief 
      4          */
      5          
      6          #include "fbuf.h"
      7          #include "string.h"
      8          #include "mem.h"
      9          #include "Net_frames.h"
     10          #include "nwdebuger.h"
     11          
     12          // Макросы для выравнивания памяти
     13          // На текущий момент выравниевание не используется, так как были ошибки
     14          // в работе макросов.
     15          typedef uint16_t mem_ptr_t;
     16          #define MEM_ALIGNMENT 2 //!< Кратность в байтах для выравнивания памяти
     17          #define MEM_ALIGN_SIZE(size) (((size) + MEM_ALIGNMENT - 1) & ~(MEM_ALIGNMENT-1))
     18          #define MEM_ALIGN(addr) ((void *)(((mem_ptr_t)(addr) + MEM_ALIGNMENT - 1) & ~(mem_ptr_t)(MEM_ALIGNMENT-1)))
     19          
     20          // Доступные методы
     21          fbuf_s* fbuf_create(uint8_t type, void* payload, uint8_t len);
     22          void fbuf_delete(fbuf_s *fb);
     23          void fbuf_chain(fbuf_s *h, fbuf_s *t);
     24          fbuf_s* fbuf_next(fbuf_s *fb);
     25          uint8_t fbuf_getCount(void);
     26          
     27          // Локальные переменные модуля
     28          static uint8_t NBR_BUF = 0; //!< Количество буферов в памяти
     29          
     30          
     31          /**
     32          @brief Создает fbuf указанного типа
     33          @details 
     34          @param type
     35          @param payload
     36          @param len
     37          */
     38          fbuf_s* fbuf_create(uint8_t type, void* payload, uint8_t len)
     39          {
     40            uint8_t req_len;
     41            // Определим длинну данных fbuf
     42            switch (type)
     43            {
     44              case FB_ETH_LAY:
     45                req_len = ETH_LAY_SIZE;
     46                break;
     47              case FB_IP_LAY:
     48                req_len = IP_LAY_SIZE;
     49                break;
     50              case FB_SYNC_LAY:
     51                req_len = SYNC_LAY_SIZE;
     52                break;
     53              case FB_TRANSPORT_LAY:
     54              case FB_RAW_LAY:
     55                req_len = len;
     56                break;
     57            default:
     58              ASSERT_HALT(false, "Incorrect fbuf type");
     59            } 
     60            
     61            // Выделяем память под структуру и данные и выравниваем в памяти
     62            // Выравнивание с помощью макросов приводило к пиздецу.
     63            fbuf_s* fb = (fbuf_s*)re_malloc(FBUF_S_SIZE + req_len);
     64            ASSERT_HALT(fb != NULL, "No memory");
     65            
     66            memset(fb, 0x77 , FBUF_S_SIZE + req_len);
     67            fb->payload = (uint8_t*)fb + FBUF_S_SIZE;
     68            
     69            // Заполним структуру
     70            fb->type = type;
     71            fb->next = NULL;
     72            fb->len = req_len;
     73            
     74            // Если пользователю нужно разместить сырые данные или транспортный
     75            // уровень, то скопируем данные
     76            if ((type == FB_TRANSPORT_LAY) || (type == FB_RAW_LAY))
     77              memcpy(fb->payload, payload, req_len);
     78            
     79            NBR_BUF++;
     80            return fb;
     81          }
     82          
     83          /**
     84          @brief Получить количество буферов в памяти
     85          @return Возвращает количество буферов
     86          */
     87          uint8_t fbuf_getCount(void)
     88          {
     89            return NBR_BUF;
     90          }
     91          
     92          /**
     93          @brief Удаляем буфер
     94          */
     95          void fbuf_delete(fbuf_s *fb)
     96          {
     97            re_free(fb);
     98            NBR_BUF--;
     99          }
    100          
    101          /**
    102          @brief Переход к следующему буферу
    103          @return Указатель на следующий буфер или NULL
    104          */
    105          fbuf_s* fbuf_next(fbuf_s *fb)
    106          {
    107            if (fb->next == NULL)
    108              return NULL;
    109            return  fb->next;
    110          }
    111          
    112          /**
    113          @brief Связывает два буфера. Head->Tail
    114          @param[in,out] h head
    115          @param[in] t tail
    116          */
    117          void fbuf_chain(fbuf_s *h, fbuf_s *t)
    118          {
    119            h->next = t;
    120          }
\\vmware-host\Shared Folders\Projects\WMNU\IAR\SHARE_PRJ_SRC\frame.c
      1          /**
      2          @file Модуль описывает сетевой кадр и связанные с ним буферы данных
      3          @brief Типы frame
      4          */
      5          
      6          #include "frame.h"
      7          #include "string.h"
      8          #include "mem.h"
      9          #include "Net_frames.h"
     10          #include "nwdebuger.h"
     11          
     12          frame_s* frame_create(void);
     13          void frame_delete(frame_s *fr);
     14          void frame_insert_head(frame_s *fr , fbuf_s *fb);
     15          void frame_insert_tail(frame_s *fr , fbuf_s *fb);
     16          fbuf_s* frame_get_fbuf_head(frame_s *fr);
     17          fbuf_s* frame_get_fbuf_tail(frame_s *fr);
     18          void* frame_merge(frame_s *fr, uint8_t *len);
     19          uint8_t frame_len(frame_s *fr);
     20          uint8_t frame_getCount(void);
     21          
     22          static uint8_t NBR_FRAME = 0; //!< Количество фреймов в памяти
     23          
     24          /**
     25          @brief Получить количество буферов в памяти
     26          @return Возвращает количество буферов
     27          */
     28          uint8_t frame_getCount(void)
     29          {
     30            return NBR_FRAME;
     31          }
     32          
     33          /**
     34          @brief Создание структуры frame
     35          @return Указатель на структуру frame
     36          */
     37          frame_s* frame_create(void)
     38          {
     39              frame_s* fr= (frame_s*)re_malloc(FRAME_S_SIZE);
     40              ASSERT_HALT(fr != NULL, "No memory");
     41              
     42              fr->head = NULL;
     43              fr->tail = NULL;
     44              memset(&fr->meta, 0x00, META_S_SIZE);
     45              NBR_FRAME++;
     46              return fr;
     47          };
     48          
     49          /**
     50          @brief Удаление frame
     51          @detail Проуедура так же удаляет все связанные с ней буфера fbuf
     52          @param[in] fr указатель на структуру frame
     53          */
     54          void frame_delete(frame_s *fr)
     55          {
     56            fbuf_s *fb = fr->head;
     57            fbuf_s *next = fb;
     58            
     59            // Удаляем все связанные буфера
     60            while (fb != NULL)
     61            {
     62                next = fb->next;
     63                fbuf_delete(fb);
     64                fb = next;
     65            };
     66            
     67            NBR_FRAME--;
     68            re_free(fr);
     69          }
     70          
     71          /**
     72          @brief Вставить буфер в начало цепочки
     73          @param[in,out] fr указатель на структуру frame
     74          @param[in] fb указатель на буфер для вставки
     75          */
     76          void frame_insert_head(frame_s *fr , fbuf_s *fb)
     77          {
     78            if (fr->head == NULL)
     79            {
     80              fr->head = fb;
     81              fr->tail = fb;
     82              return;
     83            }
     84            
     85            fb->next = fr->head; 
     86            fr->head = fb;
     87          }
     88          
     89          /**
     90          @brief Вставить буфер в конец цепочки
     91          @param[in,out] fr указатель на структуру frame
     92          @param[in] fb указатель на буфер для вставки
     93          */
     94          void frame_insert_tail(frame_s *fr , fbuf_s *fb)
     95          {
     96            ASSERT_HALT(fr != NULL, "No fr");
     97            ASSERT_HALT(fb != NULL, "No fb");
     98            
     99            if (fr->tail == NULL)
    100            {
    101              fr->head = fb;
    102              fr->tail = fb;
    103              return;
    104            }
    105            
    106            fr->tail->next = fb;
    107            fr->tail = fb;
    108          }
    109          
    110          /**
    111          @brief Получить указатель на первый элемент в цепочке
    112          @param[in] fr указатель на структуру frame
    113          @return указатель на первый буфер или NULL
    114          */
    115          fbuf_s* frame_get_fbuf_head(frame_s *fr)
    116          {
    117            return fr->head;
    118          }
    119          
    120          /**
    121          @brief Получить указатель на последний элемент в цепочке
    122          @param[in] fr указатель на структуру frame
    123          @return указатель на последний буфер или NULL
    124          */
    125          fbuf_s* frame_get_fbuf_tail(frame_s *fr)
    126          {
    127            return fr->tail;
    128          }
    129          
    130          /**
    131          @brief Производит слияние всех данных в один массив
    132          @details Данные требуют удаления после использования re_free(..)
    133          @param[in] fr указатель на frame
    134          @param[out] len длинна результирующего массива данных
    135          @return Указатель на начало данных
    136          */
    137          void* frame_merge(frame_s *fr, uint8_t *len)
    138          {
    139            ASSERT_HALT(fr != NULL, "No fr");
    140            
    141            uint8_t tot_len = frame_len(fr); // Общая длинна данных
    142            *len = tot_len;
    143            
    144            // Выходим если данных нет
    145            if (!tot_len) 
    146              return NULL;
    147            
    148            // Выделяем память
    149            void* mem = re_malloc(tot_len);
    150            ASSERT_HALT(mem != NULL, "No memory");
    151            
    152            uint8_t *ptr = (uint8_t*)mem;
    153            
    154            // Копируем данные
    155            fbuf_s *fb = fr->head;
    156            while (fb!= NULL)
    157            {
    158              memcpy(ptr, fb->payload, fb->len);
    159              ptr += fb->len;
    160              fb = fb->next;
    161            }
    162            return mem;
    163          }
    164          
    165          /**
    166          @brief Вычисляет размер цепочки fbuf
    167          @param[in] fr указатель на frame_s
    168          @return Количество байт в цепочке буферов
    169          */
    170          uint8_t frame_len(frame_s *fr)
    171          {
    172            uint8_t tot_len = 0;
    173            fbuf_s *fb = fr->head;
    174           
    175            while (fb != NULL)
    176            {
    177              tot_len += fb->len;
    178              fb = fb->next;
    179            }
    180            return tot_len;
    181          }
\\vmware-host\Shared Folders\Projects\WMNU\IAR\SHARE_PRJ_SRC\LLC.c
      1          /**
      2          @file 
      3          @brief Модуль содержит реализацию интерфейса радио для приема/передачи данных.
      4          */
      5          
      6          #include "LLC.h"
      7          #include "MAC.h"
      8          #include "TIC.h"
      9          #include "mem.h"
     10          #include "nwdebuger.h"
     11          #include "ioCC2530.h"
     12          
     13          // Публичные методы
     14          void LLC_Init(void);
     15          
     16          // Методы модуля
     17          void LLC_SetRXCallback(void (*fn)(frame_s *fr));
     18          void LLC_TimeAlloc(void (*fn)(void)); 
     19          bool LLC_AddTask(frame_s* fr);
     20          uint8_t LLC_GetTaskLen(void);
     21          
     22          // Закрытые методы
     23          static void LLC_SE_HNDL(uint8_t TS); //!< Обработчик завешения слота TIC
     24          static void LLC_Shelduler(uint8_t TS);
     25          static void LLC_RX_HNDL(frame_s *fr); //!< Обработчик примема пакета
     26          static void LLC_RunTimeAlloc(void);
     27          
     28          // Переменные модуля
     29          #define UNICAST_SEND_ATEMPTS 5 //!< Количество попыток передачи пакета 
     30          #define MAX_nbrTASKS 20 //!< Максимальное количество задач в очередях
     31          
     32          typedef struct LLCTask LLCTask;
     33          typedef struct TimeAllocFunc TimeAllocFunc;
     34          static bool tasksBLOCK; //!< блокировка доступа к LLCTask
     35          
     36          /**
     37          @brief Описание задачи модуля LLC
     38          */
     39          struct LLCTask
     40          {
     41            LLCTask *next; //!< Указатель на следующую задачу. NULL - конец очереди
     42            uint8_t TS; //!< Номер временого канала для передачи сообщения
     43            uint8_t CH; //!< Номера радиоканала для передачи сообщения
     44            frame_s *fr; //!< Указатель на данные для передачи
     45          };
     46          
     47          /**
     48          @brief Список функций вызываемых по завешению временного слота
     49          */
     50          struct TimeAllocFunc
     51          {
     52            TimeAllocFunc *next; //!< Указатель на следующую функцию. NULL - конец списка
     53            void (*fn)(void); //!< Указатель на функцию. NULL - нет обработчика
     54          };
     55          
     56          static LLCTask *FirstTask; //!< Указатель на первый элемент очереди задач
     57          static uint8_t nbrTasks; // Количество задач в очереди
     58          
     59          /**
     60          @brief Обратный вызов при приеме пакета данных
     61          */
     62          static void (*RXCallback)(frame_s *fr);
     63          
     64          /**
     65          @brief Первый элемент обработчика конца временного слота
     66          @details Элемент создается статически, все остальные задачи создаются re_malloc
     67          и добавляются к HeadAllocFunc.
     68          */
     69          static TimeAllocFunc HeadAllocFunc;
     70          
     71          /**
     72          @brief Инициализация модуля
     73          @detail Иницилизирует MAC
     74          */
     75          void LLC_Init(void)
     76          {  
     77            MAC_Init();
     78            nbrTasks = 0; 
     79            tasksBLOCK = false;
     80            FirstTask = NULL;
     81            // TODO Очистить очередь HeadTask
     82            // Регистрируем обработчики
     83            TIC_SetSECallback(LLC_SE_HNDL); // Завершение временного слота
     84            MAC_SetRXCallback(LLC_RX_HNDL); // Принято сообщение
     85          }
     86          
     87          /**
     88          @brief Количество задач в очереди
     89          @return количество задач в очереди
     90          */
     91          uint8_t LLC_GetTaskLen(void)
     92          {
     93            return nbrTasks;
     94          }
     95          
     96          void LLC_SetRXCallback(void (*fn)(frame_s *fr))
     97          {
     98            ASSERT_HALT(fn != NULL, "NULL pointer not allow");
     99            RXCallback = fn;
    100          }
    101          
    102          /**
    103          @brief Добавляет обработчик заверешения временого слота в список
    104          */
    105          void LLC_TimeAlloc(void (*fn)(void))
    106          {
    107            TimeAllocFunc *ta = re_malloc(sizeof(TimeAllocFunc));
    108            ASSERT_HALT(ta != NULL, "Memory allocation fails");
    109            ta->next = NULL;
    110            ta->fn = fn;
    111          
    112            // Перебираемся в конец списка
    113            TimeAllocFunc *next = &HeadAllocFunc;
    114            while (next->next != NULL)
    115              next = next->next;
    116            
    117            // Добавляем новый элемент
    118            next->next = ta;
    119          };
    120          
    121          /**
    122          @brief Добавляем задачу в очередь
    123          @brief Взовращает true если задача добавлена в очередь. false, если размер 
    124           очереди достиг максимального размера.
    125          */
    126          bool LLC_AddTask(frame_s* fr)
    127          {
    128             ASSERT_HALT(fr != NULL, "fr NULL");
    129           
    130              if (nbrTasks == MAX_nbrTASKS)
    131                return false;
    132              
    133             // Ждем пока разбокируется доступ.
    134             while (tasksBLOCK);
    135             tasksBLOCK = true;
    136             
    137             // Создаем новую задачу
    138             LLCTask *new_task = (LLCTask*)re_malloc(sizeof(LLCTask));
    139             ASSERT_HALT(new_task !=NULL, "LLC re_malloc for new_task"); 
    140                
    141             new_task->TS = fr->meta.TS;
    142             new_task->CH = fr->meta.CH;
    143             new_task->fr = fr;
    144             
    145            LOG(MSG_OFF | MSG_INFO | MSG_TRACE, "Add task = %u, CH = %d, TS = %d, OTS = %d. fr = %d\r\n",
    146                (uint16_t)new_task,new_task->CH, new_task->TS, fr->meta.TS, (uint16_t)fr);
    147            
    148             // Если в очереди нет задач, добавим первую
    149             if (FirstTask == NULL) 
    150             {
    151               new_task->next = NULL;
    152               FirstTask = new_task;
    153             }
    154             // Если в очереди были задачи то вставим новую в голову списка
    155             else 
    156             {
    157               new_task->next = FirstTask;
    158               FirstTask = new_task;  
    159             }
    160             
    161             nbrTasks ++;
    162             tasksBLOCK = false;
    163             return true;
    164          }
    165          
    166          /**
    167          @brief Планировщик задач
    168          @details Соотносит задачи в очереди и свободные временные слоты MAC уровня.
    169          При освобождении временных слотов, планировщик устанавливает данные для 
    170          передачи в MAC.
    171          @param[in] TS номер текущего временого слота
    172          */
    173          static void LLC_Shelduler(uint8_t TS)
    174          {
    175            // Если работает функция добавления задачи, то обслуживание очереди не
    176            // производится. Это может привести к необычным последствиям
    177            if (tasksBLOCK)
    178              return;
    179            
    180            tasksBLOCK = true;
    181            // Перебираем попорядку весь список на отправку
    182            // HeadTask только указатель на первый элемент, сам он не подлежит отправке
    183            LLCTask *task = FirstTask;
    184            LLCTask *last = FirstTask;
    185            LLCTask *next = FirstTask;
    186            
    187            while (task != NULL)
    188            {    
    189              
    190              if (MAC_GetTXState(task->TS)) // Занят ли временой слот
    191              {
    192                // Если слот занят переходим к следующей задаче
    193                last = task;
    194                task = task->next;
    195                continue; 
    196              }
    197              
    198              MAC_Send(task->fr, UNICAST_SEND_ATEMPTS);
    199              
    200              next = task->next; // Запомним следующую задачу
    201              
    202              // Удаляем текущую задачу из списка
    203              if (task == FirstTask)
    204              {
    205              // Удаляемым элементом является указателем на голову
    206                 FirstTask = next;
    207                 last = FirstTask;
    208              }
    209              else
    210              {
    211                // Удаляемым элементом является промежуточный элемент
    212                last->next = next;
    213              }
    214              
    215              nbrTasks--;
    216              LOG(MSG_OFF | MSG_INFO | MSG_TRACE, "Free task = %u, nbrTasks = %d\r\n",
    217                  (uint16_t)task, nbrTasks); 
    218              re_free(task);
    219              task = next;
    220            }
    221            
    222            tasksBLOCK = false;
    223          }
    224          
    225          /**
    226          @brief Обработчик заверешния временого слота
    227          @details Обратный вызов из TIC. Обработчик вызывает планировщик задач очереди
    228          и передает управление зарегистрированым функциям с помощью LLC_TimeAlloc.
    229          @param[in] TS номер завершенного временого слота
    230          */
    231          static void LLC_SE_HNDL(uint8_t TS)
    232          {
    233            LLC_Shelduler(TS);
    234            LLC_RunTimeAlloc();
    235          }
    236          
    237          static void LLC_RX_HNDL(frame_s *fr)
    238          {
    239            ASSERT_HALT(RXCallback !=NULL, "RXCallback func NULL");
    240            RXCallback(fr);
    241          }
    242          
    243          /**
    244          @brief Передаем управление зарегистрированным функциям
    245          */
    246          static void LLC_RunTimeAlloc(void)
    247          {
    248              TimeAllocFunc *next = &HeadAllocFunc;
    249            // HeadAllocFunc служит только для указания на первый элемент в очереди
    250            // так что его нужно пропустить и переходить сразу к next
    251            while (next->next != NULL)
    252            {
    253              next->next->fn();
    254              next = next->next;
    255            }
    256          }
\\vmware-host\Shared Folders\Projects\WMNU\IAR\SHARE_PRJ_SRC\MAC.c
      1          #include "MAC.h"
      2          #include "frame.h"
      3          #include "string.h"
      4          #include "nwdebuger.h"
      5          #include "coder.h"
      6          #include "TIC.h"
      7          
      8          // Обработчики прерываний
      9          static void MAC_RX_HNDL(uint8_t TS);
     10          static void MAC_TX_HNDL(uint8_t TS);
     11          static void (*RXCallback)(frame_s *fr);
     12          bool (*isACK_OK)(frame_s *fr, frame_s *fr_ack);
     13          
     14          // Публичные методы
     15          void MAC_Init(void);
     16          void MAC_OpenRXSlot(uint8_t TS, uint8_t CH);
     17          void MAC_CloseRXSlot(uint8_t TS);
     18          void MAC_Send(frame_s *fr, uint8_t attempts);
     19          bool MAC_ACK_Send(frame_s *fr);
     20          void MAC_SetRXCallback(void (*fn)(frame_s *fr));
     21          void MAC_Set_isACK_OK_Callback(bool(*fn)(frame_s *fr, frame_s *fr_ack));
     22          bool MAC_GetTXState(uint8_t TS);
     23          bool MAC_GetRXState(uint8_t TS);
     24          
     25          // Ключ потокового шифрования и вектор иницилизации
     26          uint8_t KEY[16] = {18,11,12,13,14,15,16,17,10,11,12,13,14,15,16,17};
     27          uint8_t IV[16] = {18,11,12,13,14,15,16,17,10,11,12,13,14,15,16,17};
     28            
     29          #define RECV_TIMEOUT 3000UL // Время ожидания приема пакета в мкс
     30          #define ACK_RECV_TIMEOUT 1000UL // Время ожидания приема подтверждения в мкс
     31          // Задержка перед приемом ACK в мкс если данные шифруются
     32          #define DELAY_BEFORE_ACK_RECV_CRYPT 2000UL 
     33          // Задержка перед приемом ACK в мкс если данные не шифруются
     34          #define DELAY_BEFORE_ACK_RECV_NOCRYPT 1000UL
     35          
     36          #define RARIO_STREAM_ENCRYPT true // Шифрование данных включенно 
     37          
     38          typedef struct
     39          {
     40           struct 
     41           {
     42             bool enable;
     43             uint8_t attempts;
     44             uint8_t CH;
     45             frame_s *fr;
     46           } __attribute__((packed)) TX;
     47           
     48           struct
     49           {
     50            bool enable; 
     51            uint8_t CH;
     52           } __attribute__((packed)) RX;
     53          } __attribute__((packed)) MACSState_s; 
     54          
     55          
     56          // Таблица состояний слотов приема/передачи
     57          MACSState_s MACSlotTable[50];
     58          
     59          
     60          /**
     61          @brief Установка обработчика функции  isACK_OK
     62          @param[in] fn(frame_s *fr, frame_s *fr_ack) указатель на функцию
     63          */
     64          void MAC_Set_isACK_OK_Callback(bool(*fn)(frame_s *fr, frame_s *fr_ack))
     65          {
     66            isACK_OK = fn;
     67          }
     68          
     69          /**
     70          @brief Иницилизация MAC
     71          @detail Инизилизирует TIM, TIC, RI, AES
     72          */
     73          void MAC_Init(void)
     74          {
     75            TIM_init();
     76            TIC_Init();
     77            RI_init();
     78            AES_init();
     79            
     80            TIC_SetRXCallback(MAC_RX_HNDL);
     81            TIC_SetTXCallback(MAC_TX_HNDL);
     82            RI_StreamCrypt(RARIO_STREAM_ENCRYPT);
     83            RI_setKEY(KEY);
     84            RI_setIV(IV);  
     85            memset(MACSlotTable, 0x00, 50*sizeof(MACSState_s));
     86          }
     87          
     88          /**
     89          @brief Открыть временой слот приема данных
     90          @param[in] TS номер слота от 0 до 49
     91          @param[in] CH номер радиоканала
     92          */
     93          void MAC_OpenRXSlot(uint8_t TS, uint8_t CH)
     94          {
     95              ASSERT_HALT(TS < 50, "Incorrect TS");
     96              MACSlotTable[TS].RX.enable = true;
     97              MACSlotTable[TS].RX.CH = CH;
     98              TIC_SetRXState(TS, true);
     99          }
    100          
    101          /**
    102          @brief Закрыть временой слот приема данных
    103          @param[in] TS номер слота от 0 до 49
    104          */
    105          void MAC_CloseRXSlot(uint8_t TS)
    106          {
    107            ASSERT_HALT(TS < 50, "Incorrect TS");
    108            MACSlotTable[TS].RX.enable = false;
    109            TIC_SetRXState(TS, false);
    110          }
    111          
    112          /**
    113          @brief Поставить пакет в таблицу отправки сообщений
    114          @param[in] fr указатель на пакет
    115          @param[in] attempts количество попыток
    116          */
    117          void MAC_Send(frame_s *fr, uint8_t attempts)
    118          {
    119              ASSERT_HALT(fr != NULL, "*fr null");
    120              ASSERT_HALT(attempts != 0, "attempts = 0");
    121              
    122              uint8_t TS = fr->meta.TS; 
    123              MACSlotTable[TS].TX.attempts = attempts;
    124              MACSlotTable[TS].TX.CH = fr->meta.CH;
    125              MACSlotTable[TS].TX.enable = true;
    126              MACSlotTable[TS].TX.fr = fr;
    127              TIC_SetTXState(TS, true);
    128          }
    129          
    130          /**
    131          @brief Посылает подтверждение приема пакета
    132          @param[in] fr указатель на кадр подтверждения
    133          */
    134          bool MAC_ACK_Send(frame_s *fr)
    135          {
    136            RI_SetChannel(fr->meta.CH);
    137            bool res = RI_Send(fr);
    138            frame_delete(fr);
    139            return res;
    140          }
    141          
    142          /**          *********** TODO ************ прием из Ethernet протокола
    143          @brief Посылает подтверждение приема пакета
    144          @param[in] fr указатель на кадр подтверждения
    145          */
    146          frame_s* MAC_ACK_Recv(void)
    147          {
    148            // ACK RECV TIMEOUT
    149            //RI_SetChannel(fr->meta.CH);
    150            //RI_Send(fr);
    151            //frame_delete(fr);
    152            return NULL;
    153          }
    154          
    155          /**
    156          @brief Устанавливает функцию обратного вызова при приеме пакета
    157          @param[in] fn указатель на функцию обработчик
    158          */
    159          void MAC_SetRXCallback(void (*fn)(frame_s *fr))
    160          {
    161            RXCallback = fn;
    162          }
    163          
    164          /**
    165          @brief Состояние слота TS передача
    166          @return возвращает true, если слот содержит пакет для передачи
    167          */
    168          bool MAC_GetTXState(uint8_t TS)
    169          {
    170            ASSERT_HALT(TS < 50, "Incorrect TS");
    171            return MACSlotTable[TS].TX.enable;
    172          }
    173          
    174          /**
    175          @brief Состояние слота TS приема
    176          @return возвращает true, если слот принимает пакет
    177          */
    178          bool MAC_GetRXState(uint8_t TS)
    179          {
    180            ASSERT_HALT(TS < 50, "Incorrect TS");
    181            return MACSlotTable[TS].RX.enable;
    182          }
    183          
    184          /**
    185          @brief Обработчик слота приема пакета
    186          @detail Отправкой подтвеждения приема пакета занимается ethernet протокол
    187          @param[in] TS номер временного слота
    188          */
    189          static void MAC_RX_HNDL(uint8_t TS)
    190          {
    191            ASSERT_HALT(TS < 50, "Incorrect TS");
    192            
    193            RI_SetChannel(MACSlotTable[TS].RX.CH);
    194            frame_s *fr = RI_Receive(RECV_TIMEOUT);
    195            
    196            // Если пакета нет, выходим из обработчика
    197            if (fr == NULL)
    198              return;
    199            
    200            RXCallback(fr);   // Передаем пакет на дальнейшую обработку
    201            // Удаление пакета не наша забота
    202          }
    203          
    204          /**
    205          @brief Обработчик слота пердачи пакета
    206          @detail После отправки пакета требуется подтверждение приема если meta.ACK = 1.
    207           После отправки ждем приема ACK. Проверка подлинности ACK происходит с помощью
    208           обратного вызова isACK_OK(*fr, *fr_ACK). Результат true или false.
    209          @param[in] TS номер временного слота
    210          */
    211          static void MAC_TX_HNDL(uint8_t TS)
    212          {
    213            ASSERT_HALT(TS < 50, "Incorrect TS");
    214            
    215            // По ошибки вызвали. Такого быть не должно, но подстрахуемся.
    216            if ((!MACSlotTable[TS].TX.enable) || (MACSlotTable[TS].TX.attempts == 0)) 
    217              TIC_SetTXState(TS, false);
    218             
    219            RI_SetChannel(MACSlotTable[TS].TX.CH); // Устанавливаем канал передачи
    220          
    221            // Пробуем передать данные
    222            bool tx_success = RI_Send(MACSlotTable[TS].TX.fr); 
    223            bool send_success = false;  
    224            
    225            LOG(MSG_OFF | MSG_INFO | MSG_TRACE, "RI_Send = %d, CH = %d, TS = %d\r\n",
    226                tx_success, MACSlotTable[TS].TX.CH, TS);
    227              
    228            // Если отправка была успешна и требуется прием подтверждения ACK
    229            if (tx_success && MACSlotTable[TS].TX.fr->meta.ACK)
    230            {
    231              // TODO ждем пакета ACK
    232              // Задержка отправки подтверждения пока что не известна.
    233              // Если есть шифрование это на 1 мс дольше чем без него
    234              // Можно подумать над тем , что бы пакет ACK был не ETH формата.
    235              // К примеру ACK = LEN, FRAME_LEN, FCS1, FCS2 и он существовал
    236              // на уровне MAC и не использовал ETH. Отправка ACK без шифрования.
    237              // Это увеличит время работы узла. Или вместо FRAME_LEN отправлять
    238              // FCS1, FCS2 отправленного пакета что бы его подтвердить или использовать
    239              // свой алгоритм расчета CRC
    240              
    241              // Если включено шифрование, то можно выключать радиоприемник для экономии
    242              // Шифрование данных занимает некоторое время (минимум 1 мс)
    243              if (RARIO_STREAM_ENCRYPT)
    244                TIM_delay(DELAY_BEFORE_ACK_RECV_CRYPT);
    245              else
    246                TIM_delay(DELAY_BEFORE_ACK_RECV_NOCRYPT);
    247              
    248              frame_s *fr_ACK = RI_Receive(ACK_RECV_TIMEOUT);
    249            
    250              if (fr_ACK == NULL) // Не приняли ACK
    251                goto LABEL_MAC_TX_HNDL_END;
    252              
    253              else // Приняли ACK
    254              {
    255                ASSERT_HALT(isACK_OK !=NULL, "isACK_OK func NULL");
    256               
    257                // Проверим является ли принятый пакет ACK подтверждением 
    258                // переданного пакета 
    259                bool isACK = isACK_OK(MACSlotTable[TS].TX.fr, fr_ACK); 
    260               
    261                if (isACK) // Пакет подтвержден
    262                  send_success = true;
    263                
    264                frame_delete(fr_ACK); // Удаляем принятый пакет ACK
    265                goto LABEL_MAC_TX_HNDL_END;
    266              }
    267            }
    268           
    269            // Если отправка была успешна и НЕ требуется подтверждение ACK
    270            if (tx_success && !MACSlotTable[TS].TX.fr->meta.ACK) 
    271              send_success = true;
    272            
    273            
    274          LABEL_MAC_TX_HNDL_END:  
    275            if (send_success) // В случаи успеха удаляем данные и закрываем слоты 
    276            { 
    277              frame_delete(MACSlotTable[TS].TX.fr);
    278              MACSlotTable[TS].TX.enable = false;
    279              TIC_SetTXState(TS, false);      
    280            }
    281            else // Уменьшаем счетчик попыток передачи и удаляем пакет при достижении 0.
    282            {
    283              MACSlotTable[TS].TX.attempts --;
    284              if (MACSlotTable[TS].TX.attempts == 0)
    285                {
    286                  frame_delete(MACSlotTable[TS].TX.fr);
    287                  MACSlotTable[TS].TX.enable = false;
    288                  TIC_SetTXState(TS, false);  
    289                }
    290            }
    291          }
\\vmware-host\Shared Folders\Projects\WMNU\IAR\SHARE_PRJ_SRC\mem.c
      1          #include "ioCC2530.h"
      2          #include "stdlib.h"
      3          #include "stdint.h"
      4          #include "string.h"
      5          
      6          void re_free(void* ptr);
      7          void* re_malloc(size_t size);
      8          uint16_t heap_ptr(size_t size);
      9          void re_memcpy(void *dst, const void *src, size_t n);
     10          
     11          /**
     12          @brief Возвращает адрес следующего свободного участка памяти
     13          @detail Функция нужна для оценки использования стека
     14          @param[in] size размер запрашиваемой области
     15          @return если памяти нету возвращает 0, иначе адрес свободного участка.
     16          */
     17          uint16_t heap_ptr(size_t size)
     18          {
     19            uint16_t *heap_ptr;
     20            heap_ptr = (uint16_t*)re_malloc(size);
     21            re_free(heap_ptr);
     22            return (uint16_t)heap_ptr;
     23          }
     24          
     25          /**
     26          @brief Реентерабельное копирование памяти
     27          */
     28          void re_memcpy(void *dst, const void *src, size_t n)
     29          {
     30            unsigned short EA_save = EA;
     31            
     32            EA = 0;
     33            memcpy(dst, src, n);
     34            EA = EA_save;  
     35          }
     36          
     37          /**
     38          @brief Реентерабельное выделение памяти
     39          */
     40          void* re_malloc(size_t size)
     41          {
     42            void* ptr;
     43            unsigned short EA_save = EA;
     44            
     45            EA = 0;
     46            ptr = malloc(size);
     47            EA = EA_save;
     48            
     49            return ptr;
     50          }
     51          
     52          /**
     53          @brief Реентерабельное освобождение памяти
     54          */
     55          void re_free(void* ptr)
     56          {
     57            unsigned short EA_save = EA;
     58            
     59            EA = 0;
     60            free(ptr);
     61            EA = EA_save;
     62          }
\\vmware-host\Shared Folders\Projects\WMNU\IAR\SHARE_PRJ_SRC\NTMR.c
      1          #include "NTMR.h"
      2          #include "stdlib.h"
      3          #include "ioCC2530.h"
      4          #include "nwdebuger.h"
      5          
      6          /**
      7          @file 
      8          @brief Модуль управления таймером сна
      9          @details При создании обьекта с помощью NT_Create, производится иницилизация
     10           аппаратного таймера сна и он переходит в активное состояние. Если установлено 
     11           определение #define USE_OSC32K будет использван внешний кварц.
     12           За установку глобального прерывания IE отвечает пользователь.
     13           Для использования модуля необходимо установить обработчик прерывания
     14           NT_SetEventCallback(..). Далее с помощью NT_SetCompare(..) установить
     15           время срабатывания прерывания, она же включит прерывание таймера. 
     16           Перед вызовом пользовательского обработчика, запрещается прерывание таймера,
     17           пользователь должен установить его повторно на необходимое время.
     18           Модуль сна пробуждает МК из режимов PM1,PM2, но не переводит их обратно.
     19           После завершения обработки прерывание, продолжится выполнение основного 
     20           потока программы. Пользователь самостоятельно должен перевести МК в режим сна.
     21           Функция NT_SetTime(..) производит подстройку времени сети и корректирует время
     22           срабатывания прерывания. Что бы было понятнее приведу пример: 
     23           Время сети 400 и установленно прерывание на 700.
     24           Пользователь корректирует время на 300, но из-за разной разрядности счетчиков
     25           прерывание произойдет по "старым часам", так как NT_SetTime только изменит
     26           переменную относительного смещения, а не непосредственно значение счетчика.
     27           Поэтому необходимо пересчитать время прерывания 700 к новому смещению.
     28           Из найденных особенностей: когда вызывается обработчик прерывания, значение
     29           времени всегда больше на 2 тика. Предполагаю из за ожидания синхронизации при
     30           чтении значения таймера. 
     31          */
     32          
     33          
     34          // После вызова EventCallback аппаратное прерывание завершается
     35          // и управление передается в главный цикл main.
     36          // Пользователь сам должен положить систему в сон
     37          // Для работы используется sleep timer.
     38          // Значение таймера изменить нельзя, он автоматически стартует после
     39          // Включения микроконтроллера. Нам нужно выбрать XOSC вместо RCOSC,
     40          // Но на отладочной плате нет резонатора
     41          // Чтение значения ST2:ST1:ST0 первым из ST0
     42          // Таймер работает во всех режимах кроме PM3
     43          // После пробуждения нужно убеиться что SLEEPSTA.CLK32K бит установлен прежде 
     44          // чем считывать ST0-3
     45          
     46          
     47          //#define USE_OSC32K // Использовать внешний квац 32.768 кГц
     48          
     49          // Методы модуля
     50          bool NT_SetTime(uint16_t ticks);
     51          void NT_SetCompare(uint16_t ticks);
     52          void NT_SetEventCallback(void (*fn)(uint16_t ticks));
     53          uint16_t NT_GetTime(void);
     54          uint16_t NT_WaitTime(uint16_t ticks);
     55          
     56          // Приватные методы
     57          static uint32_t ReadTimer(void);
     58          static void loadTimerCompare(uint32_t ticks);
     59          static inline bool isIRQEnable(void);
     60          static inline void NT_IRQEnable(bool state);
     61          
     62          // Переменные модуля
     63          static void (*EventCallback)(uint16_t ticks);
     64          static uint32_t COMPARE_TIME; //!< Значение загруженное в регистр compare
     65          
     66          /**
     67          @details Смещение времени сети относительно времени таймера.
     68           NETWORK TIME = TIMER + TOFFSET
     69          */
     70          uint16_t TOFFSET; 
     71          
     72          /**
     73          @brief Инизиализация таймера
     74          */
     75          void NT_Init(void)
     76          {
     77            TOFFSET = 0;
     78            COMPARE_TIME = 0;
     79            EventCallback = NULL;
     80          
     81            #ifdef USE_OSC32K
     82            CLKCONCMD &= ~(1<<7); // Сбрасываем бит OSC32K, будет выбран 32.768 кварц
     83            while (CLKCONSTA & (1<<7)); // Ждем пока бит не станет 0
     84            #endif
     85          
     86            NT_IRQEnable(false);
     87          }
     88          
     89          /**
     90          @brief Устанавливаем текущее время сети и переустанавливает capture time
     91          @param[in] ticks время от 0-32767. Один tick 1/32768
     92          @return true если аргумент в диапазоне
     93          */
     94          bool NT_SetTime(uint16_t ticks)
     95          {
     96            ASSERT_HALT(ticks < 32768, "Incorrect ticks");
     97            if (ticks > 32767)
     98              return false;
     99           
    100            uint16_t timer = ReadTimer();
    101            TOFFSET = ticks - timer;
    102            TOFFSET &= 0x7FFF;
    103          
    104            // После установки времени нужно изменить compare time в таймере
    105            // Но только в случаи если прерывание активно
    106            if (isIRQEnable())
    107            {
    108              NT_SetCompare(COMPARE_TIME);
    109            }
    110          
    111            return true;
    112          }
    113          
    114          /**
    115          @brief Вычисляет значение, которое нужно установить в регистр compare таймера.
    116          @params[in] ticks время сети в тикак
    117          */
    118          static inline uint32_t calcCompareTime(uint16_t ticks)
    119          {   
    120              uint32_t timer = ReadTimer(); // Текущее значение счетчика
    121              
    122              //NETWORK TIME = TIMER + TOFFSET  
    123              // Приводим такты к тактам таймера
    124              uint16_t ticks_offset = (ticks - TOFFSET) & 0x7FFF;
    125              
    126              uint32_t cmp_time = timer & ~0x7FFF; // Убираем младшие 15 бит
    127              cmp_time |= ticks_offset; // Вычисляем новое время
    128              
    129              if (cmp_time <= timer)
    130              {
    131                cmp_time += 0x8000;
    132                cmp_time &=0xFFFFFF;
    133              }
    134                
    135               LOG(MSG_OFF | MSG_INFO | MSG_TRACE, 
    136                   "Timer = %lu, Ticks = %d,CMP = %lu \r\n",
    137                    timer, ticks, cmp_time );
    138              return cmp_time;
    139          }
    140          
    141          /**
    142          @brief Устанавливает время прерывания
    143          @details Время прерывания устанавливается относительно времени сети
    144          ,к примеру, что бы проснуться в таймслот номер 0, нужно установить ticks = 0.
    145          Процедура учитывает текущее значение таймера и перерасчитывает значение ticks. 
    146          @params[in] ticks время сети в тиках когда нужно проснуться
    147          */
    148          void NT_SetCompare(uint16_t ticks)
    149          {
    150            ASSERT_HALT(ticks < 32768, "Incorrect ticks");
    151            
    152            COMPARE_TIME = ticks; // Сохраняем установленное значение
    153           
    154            uint32_t compare_time = calcCompareTime(ticks);
    155           
    156            loadTimerCompare(compare_time);
    157            NT_IRQEnable(true);
    158          }
    159          
    160          /**
    161          @brief Разрешение прерываний таймера сна
    162          @params[in] state = true - разрешить обработку прерываний
    163          */
    164          static inline void NT_IRQEnable(bool state)
    165          {
    166            STIF = 0;
    167            if (state)
    168            {
    169              STIE = 1;
    170            }
    171            else
    172            {
    173              STIE = 0;
    174            }
    175          }
    176          
    177          /**
    178          @brief Проверка активности прерывания таймера
    179          @return true если прерывание установленно
    180          */
    181          static inline bool isIRQEnable(void)
    182          {
    183            if (STIE)
    184              return true;
    185            else 
    186              return false;
    187          }
    188          
    189          /**
    190          @brief Устанавливает обработчик прерывания таймера
    191          @param[in] fn(uint16_t ticks) указатель на функцию-обработчик
    192          */
    193          void NT_SetEventCallback(void (*fn)(uint16_t ticks))
    194          {
    195            EventCallback = fn;
    196          }
    197          
    198          /**
    199          @brief Возвращает время сети 
    200          @return Время сети в тиках
    201          */
    202          uint16_t NT_GetTime(void)
    203          {
    204            uint32_t val = ReadTimer();
    205            // TOFFSET = NETWORK TIME - TIMER
    206            // NETWORK TIME = TIMER + TOFFSET
    207            val +=TOFFSET;
    208            val &= 0x7FFF; // Приводим значения таймера к 0-32767
    209            return val;
    210          }
    211          
    212          /**
    213          @brief Обработчик прерывания таймера сна
    214          */
    215          #pragma vector=ST_VECTOR
    216          __interrupt void TimerCompareInterrupt(void)
    217          {  
    218            uint16_t ticks = NT_GetTime();
    219            if (EventCallback == NULL)
    220              return;
    221            // Отключаем прерывание таймера. Забота пользователя его включить
    222            NT_IRQEnable(false); 
    223            EventCallback(ticks); // Вызываем пользовательский обработчик
    224            STIF = 0; // Очищаем флаг прерывания
    225          }
    226          
    227          /**
    228          @breif Ожидание наступления времени сети
    229          @param[in] ticks время в тактах
    230          @return фактическое время сети
    231          */
    232          uint16_t NT_WaitTime(uint16_t ticks)
    233          {
    234            static union 
    235            {
    236              uint32_t val;
    237              uint8_t fild[4];
    238            } val;
    239            
    240            val.val = 0;
    241            // TOFFSET = NETWORK TIME - TIMER
    242            // NETWORK TIME = TIMER + TOFFSET
    243            
    244            // Ждем синхронизацию таймера после пробуждения
    245            while (!(SLEEPSTA & 0x01));
    246            
    247            do
    248            {
    249              // Соблюдаем порядок чтения регисторов ST  
    250              val.fild[0] = ST0;
    251              val.fild[1] = ST1;
    252              val.fild[2] = ST2;
    253              val.val +=TOFFSET;
    254              val.val &= 0x7FFF; // Приводим значения таймера к 0-32767    
    255            } while (val.val < ticks);
    256            return val.val;
    257          }
    258          
    259          /**
    260          @brief Возвращает текущее значение таймера
    261          @return Текущие ticks
    262          */
    263          static uint32_t ReadTimer(void)
    264          {
    265            static union 
    266            {
    267              uint32_t val;
    268              uint8_t fild[4];
    269            } ret_val;
    270            
    271            ret_val.val = 0;
    272            
    273            // Ждем синхронизацию таймера после пробуждения
    274            while (!(SLEEPSTA & 0x01));
    275            
    276            // Соблюдаем порядок чтения регисторов ST  
    277            ret_val.fild[0] = ST0;
    278            ret_val.fild[1] = ST1;
    279            ret_val.fild[2] = ST2;
    280            return ret_val.val;
    281          }
    282          
    283          /**
    284          @brief Устанавливает время пробуждения микроконтролера
    285          @params[in] ticks 24 битное значение времени пробуждения в ticks
    286          */
    287          static void loadTimerCompare(uint32_t ticks)
    288          {
    289            union 
    290            {
    291              uint32_t val;
    292              uint8_t fild[4];
    293            } value;
    294            
    295            value.val = ticks;
    296            
    297            // Ждем разрешения на запись нового значения
    298            while (!(STLOAD & 0x01));
    299            
    300            // Регистр ST0 должен быть записан в последнию очередь
    301            ST2 = value.fild[2];
    302            ST1 = value.fild[1];
    303            ST0 = value.fild[0];
    304          }
\\vmware-host\Shared Folders\Projects\WMNU\IAR\SHARE_PRJ_SRC\nwdebuger.c
      1          #include "nwdebuger.h"
      2          #include "ioCC2530.h"
      3          #include "stdint.h"
      4          #include "stdio.h"
      5          
      6          
      7          #define UART_DEBUG // Если определено, то вывод в uart
      8          
      9          // Настройка выводов SIG и порта uart для отладки
     10          
     11          static void uart_init(void)
     12          {
     13            // Выбор расположения UART на выводах
     14            uint8_t U0CFG = 0; // 0={TX=P0_3, RX=P0_2
     15            PERCFG |= (U0CFG<<0); 
     16            
     17            // U0UCR регистр настройки режима uart. меня устраивает по умолчанию
     18            U0CSR = (1<<7); // Выбираем режим uart 
     19            
     20            // Настройка скорости передачи данных на 2М  
     21            U0BAUD = 0;  // табличные значения из pdf
     22            U0GCR =  16;
     23            
     24            // Включаем альтернативные функции выводов
     25            P0SEL = (1<<2)|(1<<3);
     26          }
     27          
     28          static void SetCPU32M(void)
     29          {
     30            CLKCONCMD = 0x88;
     31            while (CLKCONSTA&(1<<6));
     32          }
     33          
     34          void nwDebugerInit(void)
     35          {
     36            SetCPU32M();
     37          #ifdef UART_DEBUG
     38            uart_init();
     39          #endif
     40          }
     41          
     42          __attribute__((weak)) void STACK_FAILURE(char* msg)
     43          {
     44            LOG(MSG_ON | MSG_ALARM | MSG_ALL, "STACK FAILURE. HALT\n");
     45            while(1);
     46          }
     47          
     48          // Переопределяем функцию записи в порт
     49          #ifdef UART_DEBUG
     50          #include <yfuns.h>
     51          
     52          _STD_BEGIN
     53          
     54          #pragma module_name = "?__write"
     55          
     56          int MyLowLevelPutchar(int x);
     57          
     58          int MyLowLevelPutchar(int x){
     59            while( U0CSR&(1<<0));
     60            U0DBUF = x;
     61            return x;
     62          }
     63          /*
     64           * If the __write implementation uses internal buffering, uncomment
     65           * the following line to ensure that we are called with "buffer" as 0
     66           * (i.e. flush) when the application terminates.
     67           */
     68          
     69          size_t __write(int handle, const unsigned char * buffer, size_t size)
     70          {
     71            /* Remove the #if #endif pair to enable the implementation */
     72             
     73          
     74            size_t nChars = 0;
     75          
     76            if (buffer == 0)
     77            {
     78              /*
     79               * This means that we should flush internal buffers.  Since we
     80               * don't we just return.  (Remember, "handle" == -1 means that all
     81               * handles should be flushed.)
     82               */
     83              return 0;
     84            }
     85          
     86            /* This template only writes to "standard out" and "standard err",
     87             * for all other file handles it returns failure. */
     88            if (handle != _LLIO_STDOUT && handle != _LLIO_STDERR)
     89            {
     90              return _LLIO_ERROR;
     91            }
     92          
     93            for (/* Empty */; size != 0; --size)
     94            {
     95              if (MyLowLevelPutchar(*buffer++) < 0)
     96              {
     97                return _LLIO_ERROR;
     98              }
     99          
    100              ++nChars;
    101            }
    102          
    103            return nChars;
    104          
    105          }
    106          
    107          _STD_END
    108          #endif
\\vmware-host\Shared Folders\Projects\WMNU\IAR\SHARE_PRJ_SRC\RADIO.c
      1          /*!
      2          \file 
      3          \brief Модуль содержит реализацию интерфейса радио для приема/передачи данных.
      4          */
      5          
      6          #include "RADIO.h"
      7          #include "mem.h"
      8          #include "nwdebuger.h"
      9          #include "Radio_defs.h"
     10          #include "TIC.h"
     11          #include "delays.h"
     12          #include "frame.h"
     13          #include "string.h"
     14          #include "coder.h"
     15          #include "NTMR.h"
     16          
     17          // Открытые методы модуля
     18          void RI_init(void);
     19          bool RI_SetChannel(uint8_t CH);
     20          bool RI_Send(frame_s *fr);
     21          frame_s* RI_Receive(uint16_t timeout);
     22          uint32_t RI_GetCRCError(void);
     23          uint32_t RI_GetCCAReject(void);
     24          float RI_GetUptime(void);
     25          void RI_StreamCrypt(bool state);
     26          void RI_setKEY(void* ptr_KEY);
     27          void RI_setIV(void* ptr_IV);
     28          
     29          // Приватные методы
     30          static void random_core_init(void);
     31          static void RI_cfg(void);
     32          
     33          // TODO можно добавть простой алгоритм перестановки для сокрытия данных 
     34          // при передаче RAW формата. Алгоритм должен быть достаточно простой и 
     35          // перестанавливать биты, смешивать их с ключом. Алгорим не производит 
     36          // контроль дешифровки с помощью цифровых подписей.
     37          // Шифрование можно включаеть/отключаеть
     38          // Возможно попробовать аппаратный модуль, так как к уже зашифрованому пакету
     39          // IP добавятся данные и зашифруются еще одним ключем, надежность возрастет.
     40          // Думаю это не будет являтся двойным шифрованием и будет устойчиво к взлому
     41          static void RI_BitRawCrypt(uint8_t *src, uint8_t size); // Шифрование передачи
     42          static void RI_BitRawDecrypt(uint8_t *src, uint8_t size); // Дешифрока приема
     43          static inline void setFreq(uint8_t CH); // Установка частоты передатчика
     44          static void LoadTXData(uint8_t *src, uint8_t len); // Загрузка данных в tx buf
     45          static void UnLoadRXData(uint8_t *src, uint8_t len);
     46          static bool SendData(frame_s *fc);
     47          static bool RecvData(uint32_t timeout_us, uint16_t *SFD_TimeStamp);
     48          
     49          // Переменные модуля
     50          static float RI_UPTIME = 0; // Время работы радио в мс. 49 дней максимум
     51          static uint32_t RI_CRC_ERROR = 0; // Количество ошибок CRC
     52          static uint32_t RI_CCA_REJECT = 0; // Количество отказов передач из-за CCA
     53          static uint8_t IV[16];  // Вектор иницилизации для кодирования
     54          static uint8_t KEY[16]; // Ключ для кодирования
     55          
     56          /*!
     57          \brief Константы для установки выходной мощности радиопередатчика.
     58          Пример: p4x5 = +4,5 дБ. m0x5 = -0.5 дБ
     59          */
     60          enum TX_POWER_e 
     61          {
     62            // +4.5дБ = p4x5, -1.5дБ = m1x5.
     63            // +4.5 = 34мА, +1 = 29мА, -4 = 26мА, -10 = 25 мА, -22 = 23 мА
     64            p4x5 = 0xF5, p2x5 = 0xE5, p1x0 = 0xD5, m0x5 = 0xC5, m1x5 = 0xB5, m3x0 = 0xA5,
     65            m4x0 = 0x95, m6x0 = 0x85, m8x0 = 0x75, m10x0 = 0x65, m12x0 = 0x55, 
     66            m14x0 = 0x45, m16x0 = 0x35, m20x0 = 0x15, m22x0 = 0x05
     67          };
     68          
     69          
     70          #define IEEE_MODE 0     //!< Режимы фазы сигнала
     71          #define NOT_IEEE_MODE 1 //!< Режимы фазы сигнала
     72          #define RSSI_OFFSET -76 //!< Константа для вычисления реальной мощности
     73          
     74          /*!
     75          \details 
     76           Расчет качества связи. Коэффициенты получаются эксперементально.
     77           Есть предположение, что количество ошибок будет пропорционально квадрату
     78           коеффициента корреляции сигнала.
     79           LIQ = 255 передача 1000 пакетов без ошибок CRC
     80           LIQ = 127 передача 1000 пакетов с 50% ошибок CRC
     81           LIQ = 0   передача 1000 пакетов с 100% ошибок CRC
     82          */ 
     83          #define CONST_A (int8_t)0 //!< Коэффициент A
     84          #define CONST_B (int8_t)1 //!< Коэффициент B
     85          #define LIQ_CALC(corr) ((corr-CONST_A)*CONST_B) //!< Формула вычисление LIQ 
     86          #define FRQ_CALC(x) (11+5*(x-11)) //!< Формул вычисления частоты сигнала
     87          
     88          /// Глобальные параметры модуля
     89          struct
     90          {
     91            uint8_t CH;       //!< Номер канала с 11 до 26 включительно
     92            uint8_t TX_POWER; //!< Мощность радиопередатчика по умолчанию. 7 бит
     93            bool MODULATION_MODE; //!< false - совместимость с IEEE 802.15.4
     94            bool STREAM_CRYPT_ENABLE; //!< Шифрование выходного потока данных
     95          } RADIO_CFG;
     96          
     97          /**
     98          @brief Установить вектор иницилизации для шифрования
     99          @param[in] ptr_IV указатель на 16 байтный вектор иницилизации
    100          */
    101          void RI_setIV(void* ptr_IV)
    102          {
    103            memcpy(IV, ptr_IV, 16);
    104          }
    105          
    106          /**
    107          @brief Установить ключ шифрования
    108          @param[in] ptr_KEY указатель на 16 байтный ключ
    109          */
    110          void RI_setKEY(void* ptr_KEY)
    111          {
    112            memcpy(KEY, ptr_KEY, 16);
    113          }
    114          
    115          /*!
    116          \brief Иницилизация радио интерфейса
    117          */
    118          void RI_init(void)
    119          {
    120            // Настройки поумолчанию
    121            RADIO_CFG.CH = CH11;
    122            RADIO_CFG.TX_POWER = m0x5;
    123            RADIO_CFG.MODULATION_MODE = IEEE_MODE;
    124            RADIO_CFG.STREAM_CRYPT_ENABLE = true;
    125            // Пост действия с радио
    126            random_core_init();
    127          }
    128          
    129          /*!
    130          \brief Переводит радио в активный режим и устанавливает параметры.
    131          */
    132          static void RI_cfg(void)
    133          {
    134          /*
    135          APPEND_DATA_MODE = 0. FCS1 = signed rssi, FCS2.7 CRC OK, FCS2.6-0 Correlation
    136          A correlation value of ~110 indicates a maximum quality frame while a value 
    137          of ~50 is typically the lowest quality frames detectable by CC2520. 
    138          */
    139          /* После включения радио находится в активном режиме но приемник выключен */
    140            
    141            // Устанавливаем частоту радиопередатчика
    142            setFreq(RADIO_CFG.CH);
    143            
    144            // Устанавливаем мощность выходного сигнала
    145            TXPOWER = RADIO_CFG.TX_POWER;
    146           
    147            FRMFILT0 = 0x00; // Отключаем фильтрацию пакетов
    148            
    149            // Устанавливаем режим модуляции
    150            MDMTEST1_u MDM1;
    151            MDM1.value = MDMTEST1;
    152            MDM1.bits.MODULATION_MODE = RADIO_CFG.MODULATION_MODE;
    153            MDMTEST1 = MDM1.value; 
    154          }
    155          
    156          /*!
    157          \brief Устанавливает канал радиопередатчика.
    158          \param[in] CH Номера каналов [11..26]
    159          \return Возвращает true если аргументы верны
    160          */
    161          bool RI_SetChannel(uint8_t CH)
    162          {
    163            if ((CH >=11) && (CH<=26))
    164            {
    165              RADIO_CFG.CH = CH;
    166              return true;
    167            }
    168            return false;
    169          }
    170          
    171          /*!
    172          \brief Передает данные в эфир
    173          \details Функция может самостоятельно шифровать поток данных, увеличивает 
    174           RI_CCA_REJECT при невозможности отправки сообщения, расчитывает время работы 
    175           радио передатчика. Отправка сообщения в заданное сетевое время 
    176           fr->meta.SEND_TIME. Если равно 0, то отправка через случайноу время в мкс.
    177           Данные автоматически оборачиваются в LEN, CRC1,CRC2
    178          \param[in] *fr Указатель на структуру frame_s RAW_LAY
    179          \return Возвращает true в случаи успешной передачи
    180          */
    181          bool RI_Send(frame_s *fr)
    182          {
    183            ASSERT_HALT(fr != NULL, "fr NULL");
    184            
    185            // Устанавливаем частоту передачи пакета
    186            RI_cfg();
    187            
    188            bool send_res; // Результат передачи данных
    189            TimeStamp_s start,stop; // Измерение времени
    190            
    191            TIM_TimeStamp(&start); // Начало измерения времени
    192            send_res = SendData(fr);
    193            TIM_TimeStamp(&stop); // Конец измерения времени
    194            
    195            uint32_t passed = TIM_passedTime(&start, &stop);
    196            RI_UPTIME += (float)passed/1000; // Микросекунды в милисекунды
    197            
    198            // В случаи ошибки передачи увеличиваем счетчик RI_CCA_REJECT
    199            if (!send_res)
    200              RI_CCA_REJECT++;
    201            
    202            return send_res;
    203          }
    204          
    205          /**
    206          @brief Отправка сообщения
    207          @detail Время отправки с шифрованием 10 байт в мкс. Merge = 155, Crypt = 239,
    208           Load TX = 30, RSSI_OK = 328, ISTXON = 11, SFD(192us+5*8*4us) = 400, TX = 370, Full = 1535.
    209          Время работы радио RSSI_OK+ISTXON+SFD+TX = 1109 us
    210          @return true в случаи успеха
    211          */
    212          static bool SendData(frame_s *fr)
    213          {
    214          ////TimeStamp_s ts_start, ts_frame_merge, ts_crypt, ts_load_tx, 
    215          ////ts_rssistat, ts_istxon, ts_sfd, ts_stop;
    216            
    217          ////TIM_TimeStamp(&ts_start);  
    218            uint8_t data_size;
    219            uint8_t *data = (uint8_t*)frame_merge(fr, &data_size); 
    220          ////TIM_TimeStamp(&ts_frame_merge);  
    221            bool result = true;
    222            switch(true)
    223            {
    224              case true:
    225                // Шифруем данные при необходимости
    226                RI_BitRawCrypt(data, data_size);
    227          ////TIM_TimeStamp(&ts_crypt); 
    228                // Копируем данные в буфер. Очистка буфера автоматическая
    229                LoadTXData(data, data_size);
    230          ////TIM_TimeStamp(&ts_load_tx); 
    231                // Для начала передачи по команде STXONCCA нужно включить приемник
    232                ISRXON();
    233                // Ждем пока статус RSSI_VALID станет true
    234                while(!RSSISTAT);
    235          ////TIM_TimeStamp(&ts_rssistat); 
    236                // Очищаем флаг завершения передачи сообщения
    237                RFIRQF1 &= ~RFIRQF1_TXDONE;
    238                RFIRQF0 &= ~RFIRQF0_SFD;
    239                
    240                // Время отправки сообщения измеряется в тактах сетевого времени NTMR
    241                // Он работатаеи намного лучше чем MAC таймер(меньше погрешность)
    242                // Отправка в обозначенное время или по факту готовности
    243                uint16_t timer = 0; // Для отлалки. 
                                ^
Warning[Pe550]: variable "timer" was set but never used
          detected during compilation of secondary translation unit
                    "\\vmware-host\Shared
                    Folders\Projects\WMNU\IAR\SHARE_PRJ_SRC\RADIO.c"
    244                if (fr->meta.SEND_TIME != 0)
    245                  timer = NT_WaitTime(fr->meta.SEND_TIME);
    246          
    247                // Начинаем передачу данных
    248                // Transmission of preamble begins 192 μs after the STXON or STXONCCA 
    249                // command strobe
    250                // 192+(4(pream)+1(sfd))*8bit*4us = 352 мкс. Измерил 360мкс
    251                // Измерил в тактах NT_GetTimer() получилось 13 тиков. 396 мкс 
    252                ISTXONCCA();
    253          ////TIM_TimeStamp(&ts_istxon); 
    254                // Произошла ошибка передачи если SAMPLED_CCA false
    255                if (!(FSMSTAT1 & 1<<3)) //SAMPLED_CCA == 0
    256                {
    257                  result = false;
    258                  break;
    259                }
    260          
    261                // Ждем завершения отправки SFD
    262                while (!(RFIRQF0 & RFIRQF0_SFD));
    263                fr->meta.TIMESTAMP = NT_GetTime(); 
    264          ////TIM_TimeStamp(&ts_sfd); 
    265                // Проверим переданно ли сообщение TX_FRM_DONE
    266                while (!(RFIRQF1 & RFIRQF1_TXDONE));
    267                break;
    268            }
    269          ////TIM_TimeStamp(&ts_stop);
    270          
    271            re_free(data);
    272            ISRFOFF();
    273          ////  LOG(MSG_ON | MSG_INFO | MSG_TRACE, 
    274          ////"Merge = %lu. Crypt = %lu. Load TX = %lu. RSSI_OK = %lu. ISTXON = %lu. SFD = %lu. TX = %lu. FULL = %lu \n", 
    275          ////      TIM_passedTime(&ts_start, &ts_frame_merge),
    276          ////      TIM_passedTime(&ts_frame_merge, &ts_crypt),
    277          ////      TIM_passedTime(&ts_crypt, &ts_load_tx),
    278          ////      TIM_passedTime(&ts_load_tx, &ts_rssistat),
    279          ////      TIM_passedTime(&ts_rssistat, &ts_istxon),
    280          ////      TIM_passedTime(&ts_istxon, &ts_sfd),
    281          ////      TIM_passedTime(&ts_sfd, &ts_stop),
    282          ////      TIM_passedTime(&ts_start, &ts_stop)
    283          ////      );
    284            
    285            if (result)
    286              return true;
    287            return false; 
    288          }
    289          
    290          /**
    291          @brief Загрузка данных для передачи в буфер. 
    292          @detail Поля LEN, FCS1, FCS2 добавляются автоматически
    293          @param[in] src указатель на данные
    294          @param[in] len размер данных
    295          */
    296          static void LoadTXData(uint8_t *src, uint8_t len)
    297          {
    298            // Очищаем буфер передатчика
    299            ISFLUSHTX(); 
    300            // Поле LEN на два байта больше
    301            RFD = len + 2;
    302            
    303            for (uint8_t i = 0 ; i < len; i++)
    304              RFD = src[i];
    305            
    306            // Добавляем CRC1,2
    307            RFD = 0x00;
    308            RFD = 0x00;
    309          };
    310          
    311          /**
    312          @brief Выгружаем принятый пакет из радио
    313          @param[out] src указатель на буфер приемника
    314          @param[in] len размер выгружаемых данных
    315          */
    316          static void UnLoadRXData(uint8_t *src, uint8_t len)
    317          {
    318            for (uint8_t i = 0 ; i < len; i++)
    319              src[i] = RFD;
    320          };
    321          
    322          static inline void setFreq(uint8_t CH)
    323          {
    324            ASSERT_HALT( (CH >= 11) && (CH <= 26), "Incorrect radio channel");
    325            // Устанавливаем частоту радиопередатчика
    326            FREQCTRL_u FRQ;
    327            FRQ.value = FRQ_CALC(RADIO_CFG.CH);
    328            FREQCTRL = FRQ.value;  
    329          }
    330          
    331          /*!
    332          \brief Принимает данные из эфира
    333          \details Функция принимает данные из эфира. Проводит проверку CRC, увеличивает
    334          RI_CRC_ERROR. Дешифрует данные при необходимости. Отмечает время прихода SFD 
    335           в тактах сетевого времени .
    336          \param[in] timeout Время ожидания данных в милисекундах
    337          \return Возвращает NULL если данных нет
    338          */
    339          frame_s* RI_Receive(uint16_t timeout)
    340          {
    341            // Устанавливаем частоту передачи пакета
    342            RI_cfg();
    343            uint16_t SFD_TimeStamp;
    344            
    345            // Принимаем пакет 
    346            uint32_t timeout_us = timeout*1000UL; // Переводим мс->мкс
    347            TimeStamp_s start,stop; // Измерение времени
    348            TIM_TimeStamp(&start); // Начало измерения времени работы радио
    349            bool recv_res = RecvData(timeout_us, &SFD_TimeStamp);
    350            TIM_TimeStamp(&stop); // Конец измерения времени радио
    351            uint32_t passed = TIM_passedTime(&start, &stop);
    352            RI_UPTIME += (float)passed/(float)1000; // Микросекунды в милисекунды
    353            
    354            // Если ничего не приняли возвращаем NULL
    355            if (!recv_res)
    356              return NULL;
    357            
    358            uint8_t frame_size = RXFIFOCNT; // Количество принятых данных
    359            
    360            // Минимальный размер FCS1,FCS2 - 2 байта. LEN не включен в подсчет 
    361            if (frame_size <= 2)
    362              return NULL;
    363            
    364            // Выгружаем данные из приемника
    365            uint8_t *frame_raw = re_malloc(frame_size); 
    366            UnLoadRXData(frame_raw, frame_size);
    367            
    368            int8_t  FCS1 = frame_raw[frame_size - 2]; // RSSI
    369            uint8_t FCS2 = frame_raw[frame_size - 1]; // bit7 = CRCOK, bit[6..0] Corr_val
    370            uint8_t LEN_F = frame_raw[0]; // Поле LEN
    371            
    372            // Проверим поле LEN. Размер данных в заголовке должен совпадать
    373            // с фактической длинной принятых данных
    374            if (LEN_F != frame_size - 1)
    375            {
    376              re_free(frame_raw);
    377              RI_CRC_ERROR ++;
    378              return NULL;
    379            }
    380            
    381            // Проверим поле CRCOK
    382            if (!(FCS2 && 1<<7))
    383            {
    384              re_free(frame_raw);
    385              RI_CRC_ERROR ++;
    386              return NULL;
    387            }
    388            
    389            // Создаем буфер, последнии два байта FCS1,2 и поле LEN не копируем
    390            fbuf_s* fb = fbuf_create(FB_RAW_LAY, &frame_raw[1], frame_size - 2);
    391            RI_BitRawDecrypt(fb->payload, fb->len); // Декодируем поток если нужно
    392            
    393            // Создаем фрейм
    394            frame_s *fr = frame_create();
    395            frame_insert_head(fr ,fb); // Добавляем буферы
    396           
    397            // Копируем метку времени SFD
    398            fr->meta.TIMESTAMP = SFD_TimeStamp;
    399            
    400            // Расчитываем мощность принятого сигнала
    401            fr->meta.RSSI_SIG =  FCS1 + RSSI_OFFSET;
    402            // Расчитываем качество сигнала
    403            uint8_t corr = FCS2 & 0x7F;
    404            fr->meta.LIQ = LIQ_CALC(corr); // Значение коэфф. корреляции
    405          
    406            fr->meta.CH = RADIO_CFG.CH;
    407          
    408            re_free(frame_raw);
    409            return fr;
    410          }
    411          
    412          /**
    413          @brief Прием данных из эфира
    414          @param[in] timeout_us время ожидания в микросекундах
    415          @param[out] SFD_TimeStamp отметка времени завершения приема SFD
    416          */
    417          static bool RecvData(uint32_t timeout_us, uint16_t *SFD_TimeStamp)
    418          {
    419            TimeStamp_s start,stop; // Измерение времени  
    420            ISFLUSHRX(); // Очищаем буфер приема
    421            
    422            TIM_TimeStamp(&start);
    423            
    424            // Очищаем флаг завершения передачи сообщения и приема SFD
    425            RFIRQF0 &= ~RFIRQF0_RXPKTDONE;  
    426            RFIRQF0 &= ~RFIRQF0_SFD; 
    427            ISRXON(); // Включаем радиопередатчик
    428          
    429            bool time_out = false; // Истекло время ожидания пакета
    430            bool packet_received = false; // Приняли пакет
    431            bool sfd_received = false; // Приняли sfd
    432            
    433            // Цикл приема пакета
    434            while (true)
    435            {
    436              TIM_TimeStamp(&stop);
    437              if (TIM_passedTime(&start, &stop) >= timeout_us)
    438              {
    439                time_out = true;
    440                break;
    441              }
    442             
    443              // Принят сигнал SFD
    444              if ((RFIRQF0 & RFIRQF0_SFD))
    445              {
    446                *SFD_TimeStamp = NT_GetTime(); 
    447                sfd_received = true;
    448              }
    449              
    450              //  Завершен ли прием сообщения RX_FRM_DONE (RXPKTDONE)
    451              if ((RFIRQF0 & RFIRQF0_RXPKTDONE))
    452              {
    453                packet_received = true;
    454                break;
    455              }
    456            } // while 
    457            
    458            ISRFOFF();
    459            if (packet_received && sfd_received && !time_out)
    460              return true;
    461            else
    462              return false;
    463          }
    464          
    465          /*!
    466          \brief Возвращает количество ошибок возникших с момента иницилизации
    467          \return Количество CRC ошибок
    468          */
    469          uint32_t RI_GetCRCError(void)
    470          {
    471            return RI_CRC_ERROR;
    472          }
    473          
    474          /*!
    475          \brief Возвращает количестов отказов передачи пакета из-за занятости канала.
    476          \return Количество отказов CCA
    477          */
    478          uint32_t RI_GetCCAReject(void)
    479          {
    480            return RI_CCA_REJECT;
    481          }
    482          
    483          /*!
    484          \brief Возвращает суммарное время работы радио в режиме прием/передача
    485          \return Вермя в милисекундах
    486          */
    487          float RI_GetUptime(void)
    488          {
    489            return RI_UPTIME;
    490          }
    491          
    492          /**
    493          @breif Подссчет количества бит в байте
    494          @return Возвращает количество бит
    495          */
    496          static uint8_t bits_count(uint8_t value) {
    497            int ret = 0;
    498            for ( ; value; value = value >> 1 )
    499              ret += value & 1;
    500            return ret;
    501          }
    502          
    503          /**
    504          @brief Возращает 1 байт случайного числа
    505          @details Радио выдает всего лишь дви бита, нам нужно 8 
    506          */
    507          static inline uint8_t getRNDByte(void)
    508          {
    509            uint8_t val = 0;
    510            val |= RFRND << 0;
    511            val |= RFRND << 2;
    512            val |= RFRND << 4;
    513            val |= RFRND << 6;
    514            return val;
    515          }
    516          
    517          /**
    518          @brief Возвращает случайное число с числом включеных бит от 2 до 6 включительно
    519          @details Случайные числа появляются в регистре с частотой 170нс. Функция 
    520          возвращает гарантированно новое значение. 
    521          @return возвращает случайное число.
    522          */
    523          static inline uint8_t readRandom(void)
    524          {
    525            uint8_t rnd_val = 0;
    526            uint8_t bit_cnt = 0;
    527            while ( bit_cnt <= 2 || bit_cnt >= 6 )
    528            {
    529              rnd_val = getRNDByte();
    530              while (rnd_val == getRNDByte());
    531              rnd_val = getRNDByte();
    532              bit_cnt = bits_count(rnd_val);
    533            }
    534            return rnd_val;
    535          }
    536          
    537          /*!
    538          \brief Иницилизирует ядро генератора случайных чисел данными из эфира
    539          */
    540          static void random_core_init(void)  
    541          {
    542            unsigned int rnd_core = 0;;
    543               
    544            RI_cfg();
    545            FREQCTRL = 0x00; // Выбираем не используемую частоту
    546          
    547            // TODO По какой то причине OP_EXE не выполняет команду.
    548            // регистра RFST читается как 0xD0. это его состояние при reset
    549            // Включаем демодулятор
    550            ISRXON();
    551            
    552            // Ждем пока статус RSSI_VALID станет true
    553            while(!RSSISTAT);
    554            
    555            // Ждем случайных чисел
    556            while (RFRND == 0);
    557            
    558            // Настраиваем ядро случайного генератора
    559            rnd_core = readRandom();
    560            rnd_core |= (unsigned int)readRandom()<<8;
    561            srand(rnd_core);
    562            
    563            // Включаем демодулятор
    564            ISRFOFF();
    565            // Первая генерация случайного числа занимает много времени.
    566            // Влияло на работу радио, так как использовались случайные посылки
    567            rand(); 
    568          }
    569          
    570          /*!
    571          \brief Установка разрешения шифрования потока данных
    572          \param[in] true - включить шифрование
    573          */
    574          void RI_StreamCrypt(bool state)
    575          {
    576            RADIO_CFG.STREAM_CRYPT_ENABLE = state;
    577          }
    578          
    579          /*!
    580          \brief Шифрует область памяти если шифрование разрешено
    581          \param[in,out] *src Указатель на начало области шифрования
    582          \param[in] size Размер шифруемых данных
    583          */
    584          static void RI_BitRawCrypt(uint8_t *src, uint8_t size)
    585          {
    586            if (!RADIO_CFG.STREAM_CRYPT_ENABLE)
    587              return;
    588            
    589            AES_StreamCoder(true, src, src, KEY, IV, size);
    590          }
    591          
    592          /*!
    593          \brief Расшифровка область памяти если шифрование разрешено
    594          \param[in,out] *src Указатель на начало области дешифрования
    595          \param[in] size Размер расшифруемых данных
    596          */
    597          static void RI_BitRawDecrypt(uint8_t *src, uint8_t size)
    598          {
    599             if (!RADIO_CFG.STREAM_CRYPT_ENABLE)
    600              return;
    601             
    602            AES_StreamCoder(false, src, src, KEY, IV, size);
    603          }
\\vmware-host\Shared Folders\Projects\WMNU\IAR\SHARE_PRJ_SRC\TIC.c
      1          #include "TIC.h"
      2          #include "NTMR.h"
      3          #include "stdlib.h"
      4          #include "nwdebuger.h"
      5          #include "delays.h"
      6          
      7          /**
      8          @file 
      9          @brief 
     10          @details
     11          */
     12          
     13          // Публичные методы
     14          void TIC_Init(void);
     15          
     16          // Методы класса
     17          void TIC_SetTimer(uint16_t ticks);
     18          uint16_t TIC_GetTimer(void);
     19          bool TIC_SetTXState(uint8_t TS, bool state);
     20          bool TIC_SetRXState(uint8_t TS, bool state);
     21          bool TIC_GetTXState(uint8_t TS);
     22          bool TIC_GetRXState(uint8_t TS);
     23          void TIC_SetRXCallback(void (*fn)(uint8_t TS));
     24          void TIC_SetTXCallback(void (*fn)(uint8_t TS));
     25          void TIC_SetSECallback(void (*fn)(uint8_t TS));
     26          uint32_t TIC_GetUptime(void);
     27          uint32_t TIC_GetRTC(void);
     28          bool TIC_SetRTC(uint32_t RTC);
     29          void TIC_SetNonce(uint32_t nonce);
     30          uint32_t TIC_GetNonce(void);
     31          uint32_t TIC_TimeUsFromTS0();
     32          TimeStamp_s* TIC_GetTimeStampTS0(void);
     33           
     34          // Приватные методы
     35          static uint8_t TIC_getCurrentTS(uint16_t ticks);
     36          static void TIC_TDMAShelduler(uint8_t TS);
     37          static void TIC_HW_Timer_IRQ(uint16_t ticks);
     38          static inline void set_capture_time(uint8_t TS);
     39          static inline void Callback_execution(void (*fn)(uint8_t TS), uint8_t TS);
     40          static inline void incrementTS(uint8_t *TS);
     41          static void clocks_update(void);
     42          
     43          // Переменные модуля
     44          
     45          // Всего 50 слотов. (50 активных и 50 слотов сна)
     46          // Кварц имеет 32768 тактов в секунду. После 100 слотов
     47          // Остается 68 неучтеных тактов. Их нужно учитывать.
     48          #define MAX_TS (uint8_t)50
     49          #define TS_ACTIVE (uint16_t)327 // 9.979 мс
     50          #define TS_SLEEP (uint16_t)327  // 2.075 мс
     51          #define TS_UNACCOUNTED 68
     52          // Целый цикл-это сумма времени активного периода и сна
     53          #define FULL_SLOT  (TS_ACTIVE+TS_SLEEP)
     54          #define NO_TIME_SLOT 0xFF
     55          
     56          #define TS_RX (uint8_t)(1<<0)
     57          #define TS_TX (uint8_t)(1<<1)
     58          #define DAILY_SEC (uint32_t)86400
     59          #define MAX_TICKS (uint16_t)32768
     60          
     61          static uint32_t NODE_UPTIME = 0;
     62          static uint32_t NODE_RTC = 0;
     63          static uint32_t NODE_NONCE = 0;
     64          static void (*RXCallback)(uint8_t TS);
     65          static void (*TXCallback)(uint8_t TS);
     66          static void (*SECallback)(uint8_t TS);
     67          static uint8_t TSStateTable[MAX_TS];
     68          static TimeStamp_s TimeStampTS0;
     69          
     70          
     71          TimeStamp_s* TIC_GetTimeStampTS0(void)
     72          {
     73            return &TimeStampTS0;
     74          }
     75          
     76          void TIC_Init(void)
     77          {    
     78            // Устанавливаем обработчик прерываний таймера
     79            NT_SetEventCallback(TIC_HW_Timer_IRQ);
     80            // Запускаем процесс планировщика
     81            NT_SetCompare(0); 
     82            TIC_SetTimer(0);
     83            TIM_TimeStamp(&TimeStampTS0);
     84          }
     85          
     86          uint32_t TIC_TimeUsFromTS0()
     87          {
     88            uint32_t passed;
     89            TimeStamp_s now;
     90            TIM_TimeStamp(&now);
     91            passed = TIM_passedTime(&TimeStampTS0, &now);
     92            return passed;
     93          }
     94          
     95          void TIC_SetTimer(uint16_t ticks)
     96          {
     97            ASSERT_HALT(ticks < MAX_TICKS, "Ticks not in range");
     98            if (ticks >= MAX_TICKS)
     99              return ;
    100            
    101            NT_SetTime(ticks);
    102          }
    103          
    104          uint16_t TIC_GetTimer(void)
    105          {
    106            return NT_GetTime();
    107          }
    108          
    109          bool TIC_SetTXState(uint8_t TS, bool state)
    110          {
    111            if (TS>=MAX_TS)
    112            {
    113              return false;
    114            }
    115            ASSERT_HALT(TS<MAX_TS, "TS not in range");
    116            
    117            if (state)
    118              TSStateTable[TS] |= TS_TX;
    119            else
    120              TSStateTable[TS] &= ~TS_TX;
    121            
    122            return true;
    123          }
    124          
    125          bool TIC_SetRXState(uint8_t TS, bool state)
    126          {
    127            if (TS>=MAX_TS)
    128            {
    129              return false;
    130            }
    131            ASSERT_HALT(TS<MAX_TS, "TS not in range");
    132            
    133            if (state)
    134              TSStateTable[TS] |= TS_RX;
    135            else
    136              TSStateTable[TS] &= ~TS_RX;
    137            
    138            return true;
    139          }
    140          
    141          bool TIC_GetTXState(uint8_t TS)
    142          {
    143              if (TS>=MAX_TS)
    144            {
    145              return false;
    146            }
    147            ASSERT_HALT(TS<MAX_TS, "TS not in range");
    148            
    149            return (TSStateTable[TS] & TS_TX) ;
    150          }
    151          
    152          bool TIC_GetRXState(uint8_t TS)
    153          {
    154              if (TS>=MAX_TS)
    155            {
    156              return false;
    157            }
    158            ASSERT_HALT(TS<MAX_TS, "TS not in range");
    159            
    160            return (TSStateTable[TS] & TS_RX) ;
    161          }
    162          
    163          void TIC_SetRXCallback(void (*fn)(uint8_t TS))
    164          {
    165            ASSERT_HALT(fn != NULL, "Fn is NULL");
    166            RXCallback = fn;
    167          }
    168          
    169          void TIC_SetTXCallback(void (*fn)(uint8_t TS))
    170          {
    171            ASSERT_HALT(fn != NULL, "Fn is NULL");
    172            TXCallback = fn;
    173          }
    174          
    175          void TIC_SetSECallback(void (*fn)(uint8_t TS))
    176          {
    177            ASSERT_HALT(fn != NULL, "Fn is NULL");
    178            SECallback = fn;
    179          }
    180          
    181          uint32_t TIC_GetUptime(void)
    182          {
    183            return NODE_UPTIME;
    184          }
    185          
    186          uint32_t TIC_GetRTC(void)
    187          {
    188            return NODE_RTC;
    189          }
    190          
    191          bool TIC_SetRTC(uint32_t RTC)
    192          {
    193            if (RTC >= DAILY_SEC)
    194              return false;
    195            
    196            NODE_RTC = RTC;
    197            return true;
    198          }
    199          
    200          static uint8_t TIC_getCurrentTS(uint16_t ticks)
    201          {
    202            //uint16_t ticks = nt->NT_GetTime();
    203            // Вычисляем количество целых циклов
    204            uint8_t full_slot_num = ticks/FULL_SLOT;
    205            
    206            // Вычисляем остаток от деления. Остаток - смещение внутри
    207            // временного слота.
    208            uint16_t time_remainder = ticks % FULL_SLOT; 
    209            // Если значение внутри интервала 0..TS_ACTIVE. 
    210            if (time_remainder < TS_ACTIVE)
    211              return full_slot_num;
    212            
    213            return NO_TIME_SLOT;
    214          }
    215          
    216          static inline void incrementTS(uint8_t *TS)
    217          {
    218            // Выбираем следующий тайм слот
    219            (*TS)++;
    220            if (*TS >= MAX_TS)
    221              *TS = 0;
    222          }
    223          
    224          static inline void set_capture_time(uint8_t TS)
    225          {
    226            uint16_t ct = FULL_SLOT*(uint16_t)TS;
    227            
    228            LOG(MSG_OFF | MSG_INFO | MSG_TRACE, "Set compare = %d, TS = %d \r\n", ct, TS);
    229            // Установка прерывания на нужный слот
    230            NT_SetCompare(FULL_SLOT*(uint16_t)TS);
    231          }
    232          
    233          static void TIC_TDMAShelduler(uint8_t TS)
    234          {
    235            // Устанавливает прерывание на ближайший активный слот
    236            // Если слот 0 ближе, то на него. 
    237            // Cлот - обработка секундных таймеров 
    238            
    239            // Ищем следующий активный слот или слот 0
    240            incrementTS(&TS);
    241            while ((TS != 0) && !TSStateTable[TS])  
    242              incrementTS(&TS); 
    243            
    244            set_capture_time(TS);
    245          }
    246          
    247          static inline void Callback_execution(void (*fn)(uint8_t TS), uint8_t TS)
    248          {
    249            // Помошник вызова функций. Упрощает проверки
    250            ASSERT_HALT(fn != NULL, "Callback is NULL");
    251            if (fn == NULL)
    252              return;
    253            fn(TS);
    254          }
    255          
    256          static void TIC_HW_Timer_IRQ(uint16_t ticks)
    257          {
    258            // TODO Обработка TS=0xFF
    259            // Номер текущего слота 
    260            uint8_t c_TS = TIC_getCurrentTS(ticks);
    261            
    262            // Обновляем часы NODE_RTC и NODE_UPTIME
    263            if (c_TS == 0)
    264            {
    265              TIM_TimeStamp(&TimeStampTS0); // Первым делом обновим отметку точного времени
    266              clocks_update();
    267            }
    268            // Если что то пошло не так и мы промахнулись мимо слота
    269            // запускаем планировщик заново
    270            if (c_TS == NO_TIME_SLOT)
    271            {
    272              TIC_TDMAShelduler(c_TS);
    273              LOG(MSG_ON | MSG_INFO | MSG_TRACE, "TS = 255 \r\n");
    274              return;
    275            }
    276              
    277            // Вызываем один из указанных обработчиков.
    278            // Передача имеет приоритет над приемом.
    279            if (TSStateTable[c_TS] & TS_TX) 
    280              Callback_execution(TXCallback, c_TS);
    281            else if (TSStateTable[c_TS] & TS_RX)
    282              Callback_execution(RXCallback, c_TS);
    283              
    284            // Вызываем обработчик завершения слота
    285            Callback_execution(SECallback, c_TS);
    286            
    287            // Запускаем планировщик таймера
    288            TIC_TDMAShelduler(c_TS);
    289          }
    290          
    291          static void clocks_update(void)
    292          {
    293            NODE_UPTIME++;
    294            NODE_RTC++;
    295            NODE_NONCE++;
    296            if (NODE_RTC >= DAILY_SEC)
    297              NODE_RTC = 0;
    298          }
    299          
    300          void TIC_SetNonce(uint32_t nonce)
    301          {
    302            NODE_NONCE = nonce;
    303          }
    304          
    305          uint32_t TIC_GetNonce(void)
    306          {
    307            return NODE_NONCE;
    308          }
\\vmware-host\Shared Folders\Projects\WMNU\IAR\PRJ_UNITEST\src\utest.c
      1          #include "utest_suite.h"
      2          #include "nwdebuger.h"
      3          #include "assert.h"
      4          
      5          extern void suite_fbuf(void);
      6          extern void suite_TIC(void);
      7          extern void suite_TIC_HW(void);
      8          extern void suite_MAC(void);
      9          extern void suite_LLC(void);
     10          extern void suite_NT_HW(void);
     11          extern void suite_Frames(void);
     12          extern void suite_RADIO_HW(void);
     13          extern void suite_RADIO(void);
     14          extern void suite_delays_HW(void);
     15          extern void suite_delays(void);
     16          extern void suite_coder(void);
     17          extern void suite_frame(void);
     18          extern void suite_LLC_HW(void);
     19          extern void suite_printf_uart(void);
     20          extern void suite_malloc(void);
     21          
     22          int main()
     23          {
     24            nwDebugerInit();
     25            utestSigTraceInit();
     26            LOG(MSG_ON | MSG_INFO | MSG_TRACE, "Test log output\r\n");
     27            ASSERT(false, "Test assert output\r\n");
     28            
     29            // Вызов функций тестирования
     30            // Аппаратное тестирование
     31            {
     32              //suite_RADIO_HW();
     33              //suite_delays_HW();    //12.11 Работает
     34              //suite_TIC_HW();       //12.11 Работает
     35              //suite_NT_HW();        // 12.11 Работает
     36              suite_LLC_HW();
     37            };
     38            // Юнит тестирование
     39            {
     40              //suite_delays();
     41              //suite_coder();
     42              //suite_fbuf();
     43             // suite_frame();
     44              //suite_RADIO();
     45             // suite_MAC();
     46            // suite_printf_uart();
     47              //suite_malloc();
     48            }
     49          
     50          	//run_utest_framepart();
     51          
     52          // Добавляем результаты тестов
     53          	umsg_summary();
     54           //     while(1);
     55          	return 0;
     56          }
\\vmware-host\Shared Folders\Projects\WMNU\IAR\PRJ_UNITEST\src\utest_coder.c
      1          #include "utest_suite.h"
      2          #include "coder.h"
      3          #include "delays.h"
      4          #include "string.h"
      5          #include "stdio.h"
      6          #include "nwdebuger.h"
      7          
      8          static void aes_test(void)
      9          {
     10            AES_init();
     11            
     12            TimeStamp_s start,stop;
     13            uint32_t passed;
     14            #define max_len 10 
     15            uint8_t data[max_len] = "0123456789";
     16            uint8_t chiper[max_len];
     17            
     18            uint8_t key[16] = {18,11,12,13,14,15,16,17,10,11,12,13,14,15,16,17};
     19            uint8_t nonce[16] = {18,11,12,13,14,15,16,17,10,11,12,13,14,15,16,17};
     20            TIM_init();
     21            
     22            memset(chiper, 0 , max_len);
     23            
     24            TIM_TimeStamp(&start);
     25            AES_StreamCoder(true, data, chiper, key, nonce, max_len);
     26            TIM_TimeStamp(&stop);
     27            passed = TIM_passedTime(&start, &stop);
     28            printf("passed %lu \r\n", passed);
     29            
     30            memset(data, 0 , max_len);
     31            TIM_TimeStamp(&start);
     32            AES_StreamCoder(false, chiper, data, key, nonce, max_len);
     33            TIM_TimeStamp(&stop);
     34            passed = TIM_passedTime(&start, &stop);
     35          
     36            return;
     37          }
     38          
     39          static void CCM_test(void)
     40          {
     41            AES_init();
     42            TIM_init();
     43            
     44            #define DATA_LEN 10
     45            uint8_t data[DATA_LEN];
     46            uint8_t key[16] = {1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16};
     47            uint8_t nonce[16] = {1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16};
     48            uint8_t MIC[4];
     49            
     50            memset(MIC, 0, 4);
     51            for (uint8_t i = 0; i < DATA_LEN; i++)
     52              data[i] = i ;
     53            
     54            AES_CCMEncrypt( data, 7, 3, 1, key, nonce, MIC);
     55            
     56            bool res = AES_CCMDecrypt( data, 7, 3, 1, key, nonce, MIC);
     57          }
     58          
     59          static void single_speed_test(uint8_t *data, uint8_t f, uint8_t c, uint8_t m,
     60                                        uint8_t *key, uint8_t *nonce, uint8_t *MIC)
     61          {
     62            TimeStamp_s start,stop;
     63            TIM_TimeStamp(&start);
     64            AES_CCMEncrypt( data, f, c , m, key, nonce, MIC);
     65            TIM_TimeStamp(&stop);
     66            uint32_t time = TIM_passedTime(&start, &stop);
     67            LOG(MSG_ON | MSG_INFO | MSG_TRACE, "m=%d f=%d c=%d. Time = %lu\n",
     68                m, f, c, time);
     69          }
     70          
     71          static void CCM_speed_test(void)
     72          {
     73            #define SPEED_DATA_LEN 100
     74            uint8_t data[SPEED_DATA_LEN];
     75          
     76            uint8_t key[16] = {1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16};
     77            uint8_t nonce[16] = {1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16};
     78            uint8_t MIC[16];
     79          
     80            AES_init();
     81            TIM_init();
     82            
     83            for (uint8_t i = 10 ; i <= 50 ; i +=10)
     84              single_speed_test(data, i, 10, 1, key, nonce, MIC);
     85            
     86            for (uint8_t i = 10 ; i <= 50 ; i +=10)
     87              single_speed_test(data, 10, i, 1, key, nonce, MIC);
     88            
     89            for (uint8_t i = 10 ; i <= 50 ; i +=10)
     90              single_speed_test(data, i, 10, 2, key, nonce, MIC);
     91            
     92            for (uint8_t i = 10 ; i <= 50 ; i +=10)
     93              single_speed_test(data, 10, i, 2, key, nonce, MIC);
     94          }
     95          
     96          static bool single_enc_dec_test(uint8_t *data, uint8_t f, uint8_t c, uint8_t m,
     97                                        uint8_t *key, uint8_t *nonce, uint8_t *MIC)
     98          {
     99            AES_CCMEncrypt( data, f, c, m, key, nonce, MIC);  
    100            bool res = AES_CCMDecrypt( data, f, c, m, key, nonce, MIC); 
    101            return res;
    102          }
    103          
    104          static void CCM_code_decode_test(void)
    105          {
    106            #define CODE_DATA_LEN 128
    107            uint8_t data[CODE_DATA_LEN];
    108          
    109            uint8_t key[16] = {1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16};
    110            uint8_t nonce[16] = {1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16};
    111            uint8_t MIC[16];
    112          
    113            AES_init();
    114            TIM_init();  
    115            
    116            bool res;
    117           
    118            LOG(MSG_ON | MSG_INFO | MSG_TRACE, "CCM full size test 60 sec\n");
    119            
    120            res = true;
    121            for (uint8_t m = 0; m < 3; m++)
    122              for (uint8_t f = 0; f < 128 ; f++)
    123                for (uint8_t c = 0; c < (128 - f) ; c++) 
    124                {
    125                  res = res && single_enc_dec_test(data, f, c, m, key, nonce, MIC);
    126                  if (res)
    127                    continue;
    128                  
    129                  LOG(MSG_ON | MSG_INFO | MSG_TRACE, 
    130                      "Coder test stub on m=%d f=%d c=%d \n", m, f, c);
    131                  break;
    132                }
    133            umsg("coder", "CCM full coder test", res == true);
    134            
    135            res = single_enc_dec_test(data, 10, 10, 1, key, nonce, MIC);
    136          }
    137          
    138          static void mem_control(void)
    139          {
    140            #define MEM_CNTR_SIZE 10
    141            #define MAGIC_NUM 0x73
    142            
    143            uint8_t key[16] = {1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16};
    144            uint8_t nonce[16] = {1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16};
    145            
    146            struct 
    147            {
    148              uint8_t cnt_byte1;
    149              uint8_t data[MEM_CNTR_SIZE];
    150              uint8_t cnt_byte2;
    151            } __attribute__((packed)) data_struct;
    152           
    153              struct 
    154            {
    155              uint8_t cnt_byte1;
    156              uint8_t key[16];
    157              uint8_t cnt_byte2;
    158            } __attribute__((packed)) key_struct;
    159            
    160            struct 
    161            {
    162              uint8_t cnt_byte1;
    163              uint8_t nonce[16];
    164              uint8_t cnt_byte2;
    165            } __attribute__((packed)) nonce_struct;
    166            
    167            struct 
    168            {
    169              uint8_t cnt_byte1;
    170              uint8_t MIC[16];
    171              uint8_t cnt_byte2;
    172            } __attribute__((packed)) mic_struct;
    173            
    174            AES_init();
    175            TIM_init();
    176            
    177            data_struct.cnt_byte1 = MAGIC_NUM;
    178            data_struct.cnt_byte2 = MAGIC_NUM;
    179            key_struct.cnt_byte1 = MAGIC_NUM;  
    180            key_struct.cnt_byte2 = MAGIC_NUM;
    181            nonce_struct.cnt_byte1 = MAGIC_NUM;  
    182            nonce_struct.cnt_byte2 = MAGIC_NUM;
    183            mic_struct.cnt_byte1 = MAGIC_NUM;  
    184            mic_struct.cnt_byte2 = MAGIC_NUM;
    185            
    186            memcpy(key_struct.key , key, 16);
    187            memcpy(nonce_struct.nonce , nonce, 16);
    188            for (uint8_t i = 0; i < MEM_CNTR_SIZE; i++)
    189              data_struct.data[i] = i;
    190          
    191            for (uint8_t i = 0; i < 16; i++)
    192            {
    193              key_struct.key[i] = i + 100;
    194              nonce_struct.nonce[i] = i + 200;
    195            }
    196            
    197            AES_CCMEncrypt( data_struct.data, 5, MEM_CNTR_SIZE - 5, 1, key_struct.key,
    198                           nonce_struct.nonce, mic_struct.MIC);  
    199            
    200            bool data_mem_corrupt = false;
    201            bool key_mem_corrupt = false;
    202            bool nonce_mem_corrupt = false;
    203            bool mic_mem_corrupt = false;
    204            if ((data_struct.cnt_byte1 != MAGIC_NUM) || 
    205                (data_struct.cnt_byte2 != MAGIC_NUM))
    206            data_mem_corrupt = true;
    207            if ((key_struct.cnt_byte1 != MAGIC_NUM) || 
    208                (key_struct.cnt_byte2 != MAGIC_NUM))
    209            key_mem_corrupt = true;
    210            if ((nonce_struct.cnt_byte1 != MAGIC_NUM) || 
    211                (nonce_struct.cnt_byte2 != MAGIC_NUM))
    212            nonce_mem_corrupt = true;  
    213            if ((mic_struct.cnt_byte1 != MAGIC_NUM) || 
    214                (mic_struct.cnt_byte2 != MAGIC_NUM))
    215            mic_mem_corrupt = true;  
    216            
    217            umsg("coder", "CCM coder corrupt data memory", data_mem_corrupt == false);
    218            umsg("coder", "CCM coder corrupt key memory", key_mem_corrupt == false);
    219            umsg("coder", "CCM coder corrupt nonce memory", nonce_mem_corrupt == false);
    220            umsg("coder", "CCM coder corrupt mic memory", mic_mem_corrupt == false);
    221            
    222            
    223            data_struct.cnt_byte1 = MAGIC_NUM;
    224            data_struct.cnt_byte2 = MAGIC_NUM;
    225            key_struct.cnt_byte1 = MAGIC_NUM;  
    226            key_struct.cnt_byte2 = MAGIC_NUM;
    227            nonce_struct.cnt_byte1 = MAGIC_NUM;  
    228            nonce_struct.cnt_byte2 = MAGIC_NUM;
    229            mic_struct.cnt_byte1 = MAGIC_NUM;  
    230            mic_struct.cnt_byte2 = MAGIC_NUM;
    231            
    232            bool res = AES_CCMDecrypt( data_struct.data, 5, MEM_CNTR_SIZE - 5, 1, key_struct.key,
    233                           nonce_struct.nonce, mic_struct.MIC); 
    234            
    235            if ((data_struct.cnt_byte1 != MAGIC_NUM) || 
    236                (data_struct.cnt_byte2 != MAGIC_NUM))
    237            data_mem_corrupt = true;
    238            if ((key_struct.cnt_byte1 != MAGIC_NUM) || 
    239                (key_struct.cnt_byte2 != MAGIC_NUM))
    240            key_mem_corrupt = true;
    241            if ((nonce_struct.cnt_byte1 != MAGIC_NUM) || 
    242                (nonce_struct.cnt_byte2 != MAGIC_NUM))
    243            nonce_mem_corrupt = true;  
    244            if ((mic_struct.cnt_byte1 != MAGIC_NUM) || 
    245                (mic_struct.cnt_byte2 != MAGIC_NUM))
    246            mic_mem_corrupt = true;
    247          
    248            umsg("coder", "CCM decoder corrupt data memory", data_mem_corrupt == false);
    249            umsg("coder", "CCM decoder corrupt key memory", key_mem_corrupt == false);
    250            umsg("coder", "CCM decoder corrupt nonce memory", nonce_mem_corrupt == false);
    251            umsg("coder", "CCM decoder corrupt mic memory", mic_mem_corrupt == false);
    252            
    253            bool not_changed = true;
    254            for (uint8_t i = 0; i < MEM_CNTR_SIZE; i++)
    255              if (data_struct.data[i] != i)
    256                not_changed = true;
    257            umsg("coder", "CCM decoded data correct", not_changed == true);
    258              
    259            for (uint8_t i = 0; i < 16; i++)
    260              if (key_struct.key[i] != i + 100)
    261                not_changed = true;
    262            umsg("coder", "CCM key data correct", not_changed == true);  
    263           
    264            for (uint8_t i = 0; i < 16; i++)
    265              if (nonce_struct.nonce[i] != i + 200)
    266                not_changed = true;
    267            umsg("coder", "CCM nonce data correct", not_changed == true); 
    268          }
    269          
    270          //  umsg("FChain", "TODO memory malloc and free", false);
    271          void suite_coder(void)
    272          {
    273            umsg_line("coder module");
    274          //  CCM_speed_test();
    275            mem_control();
    276            CCM_code_decode_test();
    277            CCM_test();
    278            aes_test();
    279          }
\\vmware-host\Shared Folders\Projects\WMNU\IAR\PRJ_UNITEST\src\utest_delays.c
      1          #include "delays.h"
      2          #include "utest_suite.h"
      3          
      4          static void alg_test(void)
      5          {
      6            TIM_init();
      7            
      8            uint32_t passed;
      9            TimeStamp_s start, stop;
     10           
     11            TIM_TimeStamp(&start);
     12            TIM_TimeStamp(&stop);
     13            passed = TIM_passedTime(&start, &stop);
     14            umsg("delays", "TIM_passedTimeNs meas add op ", passed  < 10);
     15          }
     16          
     17          static void manual(void)
     18          {
     19            TIM_init();
     20            
     21            uint32_t passed;
     22            TimeStamp_s start, stop;
     23            
     24            //Это ручная проверка работы модуля
     25            TIM_TimeStamp(&start);
     26            TIM_delay(500);
     27            TIM_TimeStamp(&stop);
     28            passed = TIM_passedTime(&start, &stop);
     29            umsg("delays", "TIM_passedTimeNs meas add op ", passed  < 10);
     30            
     31            TIM_TimeStamp(&start);
     32            TIM_delay(60*Tsec);
     33            TIM_TimeStamp(&stop);
     34            passed = TIM_passedTime(&start, &stop);
     35            umsg("delays", "TIM_passedTimeNs meas add op ", passed  < 10);
     36          }
     37          
     38          void suite_delays_HW(void)
     39          {
     40            //umsg_line("delays module");
     41            manual();
     42          }
     43          
     44          
     45          void suite_delays(void)
     46          {
     47            umsg_line("delays module");
     48            alg_test();
     49          }
\\vmware-host\Shared Folders\Projects\WMNU\IAR\PRJ_UNITEST\src\utest_fbuf.c
      1          #include "utest_suite.h"
      2          #include "fbuf.h"
      3          #include "Net_frames.h"
      4          
      5          static void test_create(void)
      6          { 
      7            fbuf_s *fb = fbuf_create(FB_ETH_LAY, NULL, NULL);
      8            umsg("fbuf", "fbuf FB_ETH_LAY created", fb != NULL);
      9            umsg("fbuf", "fbuf FB_ETH_LAY lenght", fb->len == ETH_LAY_SIZE);
     10            fbuf_delete(fb);
     11           
     12            fb = fbuf_create(FB_IP_LAY, NULL, NULL);
     13            umsg("fbuf", "fbuf FB_IP_LAY created", fb != NULL);
     14            umsg("fbuf", "fbuf FB_IP_LAY lenght", fb->len == IP_LAY_SIZE);
     15            fbuf_delete(fb);
     16            
     17            fb = fbuf_create(FB_SYNC_LAY, NULL, NULL);
     18            umsg("fbuf", "fbuf FB_SYNC_LAY created", fb != NULL);
     19            umsg("fbuf", "fbuf FB_SYNC_LAY lenght", fb->len == SYNC_LAY_SIZE);
     20            fbuf_delete(fb);
     21          }
     22          
     23          static void test_logic(void)
     24          {
     25            fbuf_s *fb1 = fbuf_create(FB_ETH_LAY, NULL, NULL);
     26            fbuf_s *fb2 = fbuf_create(FB_IP_LAY, NULL, NULL);
     27            fbuf_s *fb3 = fbuf_create(FB_SYNC_LAY, NULL, NULL);
     28            
     29            fbuf_chain(fb1, fb2);
     30            fbuf_chain(fb2, fb3);
     31            
     32            umsg("fbuf", "chain fb1 -> fb2", fb1->next == fb2);
     33            umsg("fbuf", "chain fb2 -> fb3", fb2->next == fb3);
     34            umsg("fbuf", "chain fb3 next NULL", fb3->next == NULL);
     35            
     36            fbuf_s *iterator = fb1;
     37            umsg("fbuf", "iterator = fb1", iterator == fb1);
     38            
     39            iterator = fbuf_next(iterator);
     40            umsg("fbuf", "iterator = fb2", iterator == fb2);
     41            
     42            iterator = fbuf_next(iterator);
     43            umsg("fbuf", "iterator = fb3", iterator == fb3);
     44            
     45            iterator = fbuf_next(iterator);
     46            umsg("fbuf", "iterator = NULL", iterator == NULL);
     47            
     48            fbuf_delete(fb1);
     49            fbuf_delete(fb2);
     50            fbuf_delete(fb3);
     51          }
     52          
     53          static void raw_data_test(void)
     54          {
     55            #define RAW_LEN 100 
     56            uint8_t data[RAW_LEN];
     57            
     58            for (uint8_t i = 0; i < RAW_LEN; i++)
     59              data[i] = i;
     60            
     61            fbuf_s *fb = fbuf_create(FB_RAW_LAY, data, RAW_LEN);
     62            bool flag = memory_compare((char*)data, fb->payload, RAW_LEN);
     63            umsg("fbuf", "FB_RAW_LAY mem is equal", flag == true);
     64            
     65            ((uint8_t*)fb->payload)[6] = 10;
     66            flag = memory_compare((char*)data, fb->payload, RAW_LEN);
     67            umsg("fbuf", "FB_RAW_LAY mem is not qual", flag == false);
     68            
     69            umsg("fbuf", "FB_RAW_LAY len is equal", fb->len == RAW_LEN);
     70            fbuf_delete(fb);
     71          }
     72          
     73          static void delete_test(void)
     74          {
     75            fbuf_s *fb = fbuf_create(FB_SYNC_LAY, NULL, NULL);
     76            fbuf_delete(fb);
     77            fbuf_s *fb1 = fbuf_create(FB_SYNC_LAY, NULL, NULL);
     78            umsg("fbuf", "fbuf_delete", fb == fb1);
     79          }
     80          
     81          void suite_fbuf(void)
     82          {
     83            umsg_line("fbuf module");
     84            test_create();
     85            delete_test();
     86            raw_data_test();
     87            test_logic();
     88          }
\\vmware-host\Shared Folders\Projects\WMNU\IAR\PRJ_UNITEST\src\utest_frame.c
      1          #include "utest_suite.h"
      2          #include "frame.h"
      3          #include "Net_frames.h"
      4          #include "stdbool.h"
      5          
      6          static void insert1_test(void)
      7          {
      8            fbuf_s *fb1 = fbuf_create(FB_ETH_LAY, NULL, NULL);
      9            
     10            frame_s* fr = frame_create();
     11            frame_insert_head(fr, fb1);
     12            umsg("frame", "Insert head. head = fb1", fr->head == fb1);
     13            umsg("frame", "Insert head. tail = fb1", fr->tail == fb1);
     14            frame_delete(fr);
     15          }
     16          
     17          static void insert2_test(void)
     18          {
     19            fbuf_s *fb1 = fbuf_create(FB_ETH_LAY, NULL, NULL);
     20            
     21            frame_s *fr = frame_create();
     22            frame_insert_tail(fr, fb1);
     23            umsg("frame", "Insert tail. head = fb1", fr->head == fb1);
     24            umsg("frame", "Insert tail. tail = fb1", fr->tail == fb1);
     25            frame_delete(fr);
     26          }
     27          
     28          static void insert3_test(void)
     29          {
     30            fbuf_s *fb1 = fbuf_create(FB_ETH_LAY, NULL, NULL);
     31            fbuf_s *fb2 = fbuf_create(FB_IP_LAY, NULL, NULL);
     32            fbuf_s *fb3 = fbuf_create(FB_SYNC_LAY, NULL, NULL);
     33          
     34            frame_s *fr = frame_create();
     35            frame_insert_head(fr, fb1);
     36            frame_insert_head(fr, fb2);
     37            frame_insert_head(fr, fb3);
     38            
     39            fbuf_s *iterator = frame_get_fbuf_head(fr);
     40            umsg("frame", "iterator = fb3", iterator == fb3);
     41            
     42            iterator = fbuf_next(iterator);
     43            umsg("frame", "iterator = fb2", iterator == fb2);
     44            
     45            iterator = fbuf_next(iterator);
     46            umsg("frame", "iterator = fb1", iterator == fb1); 
     47            
     48            iterator = fbuf_next(iterator);
     49            umsg("frame", "iterator = NULL", iterator == NULL);
     50            
     51            fbuf_s *tail = frame_get_fbuf_tail(fr);
     52            umsg("frame", "iterator = fb1", tail == fb1);
     53            
     54            frame_delete(fr);
     55          
     56          }
     57          
     58          static void delete_test(void)
     59          {
     60            // Тест основан на том что malloc выделит ранее освобожденные
     61            // участки памяти после освобождения памяти. 
     62            fbuf_s *fb01 = fbuf_create(FB_ETH_LAY, NULL, NULL);
     63            fbuf_s *fb02 = fbuf_create(FB_ETH_LAY, NULL, NULL);
     64            fbuf_s *fb03 = fbuf_create(FB_ETH_LAY, NULL, NULL);
     65            fbuf_s *fb04 = fbuf_create(FB_ETH_LAY, NULL, NULL);
     66            
     67            frame_s *fr = frame_create();
     68            frame_insert_head(fr, fb01);
     69            frame_insert_head(fr, fb02);
     70            frame_insert_head(fr, fb03);
     71            frame_insert_head(fr, fb04);
     72            frame_delete(fr);
     73            
     74            fbuf_s *fb11 = fbuf_create(FB_ETH_LAY, NULL, NULL);
     75            fbuf_s *fb12 = fbuf_create(FB_ETH_LAY, NULL, NULL);
     76            fbuf_s *fb13 = fbuf_create(FB_ETH_LAY, NULL, NULL);
     77            fbuf_s *fb14 = fbuf_create(FB_ETH_LAY, NULL, NULL);
     78            
     79            umsg("frame", "delete test. fb1", fb01 == fb11);
     80            umsg("frame", "delete test. fb2", fb02 == fb12);
     81            umsg("frame", "delete test. fb3", fb03 == fb13);
     82            umsg("frame", "delete test. fb4", fb04 == fb14);
     83            
     84            fbuf_delete(fb11);
     85            fbuf_delete(fb12);
     86            fbuf_delete(fb13);
     87            fbuf_delete(fb14);
     88            fbuf_delete(fb01);
     89            fbuf_delete(fb02);
     90            fbuf_delete(fb03);
     91            fbuf_delete(fb04);
     92          }
     93          
     94          static void insert4_test(void)
     95          {
     96            fbuf_s *fb1 = fbuf_create(FB_ETH_LAY, NULL, NULL);
     97            fbuf_s *fb2 = fbuf_create(FB_IP_LAY, NULL, NULL);
     98            fbuf_s *fb3 = fbuf_create(FB_SYNC_LAY, NULL, NULL);
     99          
    100            frame_s *fr = frame_create();
    101            frame_insert_tail(fr, fb1);
    102            frame_insert_tail(fr, fb2);
    103            frame_insert_tail(fr, fb3);
    104            
    105            fbuf_s *iterator = frame_get_fbuf_head(fr);
    106            umsg("frame", "iterator = fb1", iterator == fb1);
    107            
    108            iterator = fbuf_next(iterator);
    109            umsg("frame", "iterator = fb2", iterator == fb2);
    110            
    111            iterator = fbuf_next(iterator);
    112            umsg("frame", "iterator = fb3", iterator == fb3); 
    113            
    114            iterator = fbuf_next(iterator);
    115            umsg("frame", "iterator = NULL", iterator == NULL);
    116            
    117            fbuf_s *tail = frame_get_fbuf_head(fr);
    118            umsg("frame", "iterator = fb1", tail == fb1);
    119            
    120            frame_delete(fr);
    121          }
    122          
    123          static void tot_len_test(void)
    124          {
    125            uint8_t tmp[10];
    126            fbuf_s *fb1 = fbuf_create(FB_ETH_LAY, NULL, NULL);
    127            fbuf_s *fb2 = fbuf_create(FB_IP_LAY, NULL, NULL);
    128            fbuf_s *fb3 = fbuf_create(FB_SYNC_LAY, NULL, NULL);
    129            fbuf_s *fb4 = fbuf_create(FB_RAW_LAY, tmp, sizeof(tmp));
    130            
    131            frame_s *fr = frame_create();
    132            frame_insert_tail(fr, fb1);
    133            frame_insert_tail(fr, fb2);
    134            frame_insert_tail(fr, fb3);
    135            frame_insert_tail(fr, fb4);
    136            
    137            uint8_t data_len = ETH_LAY_SIZE + IP_LAY_SIZE + SYNC_LAY_SIZE + sizeof(tmp);
    138            uint8_t tot_len = frame_len(fr);
    139            umsg("frame", "frame_len calc", tot_len == data_len);
    140            frame_delete(fr);
    141          }
    142          
    143          static void test_frame_merge(void)
    144          {
    145            uint8_t data[10] = {0,1,2,3,4,5,6,7,8,9};
    146            uint8_t len;
    147            
    148            fbuf_s *fb = fbuf_create(FB_RAW_LAY, data, sizeof(data));
    149            frame_s *fr = frame_create();
    150            frame_insert_tail(fr, fb);
    151            uint8_t *raw_data = frame_merge(fr, &len);
    152            
    153            bool test_res;
    154            test_res = memory_compare((char*)raw_data, (char*)data, sizeof(data));
    155            umsg("frame", "Memory corr", test_res == true);
    156          }
    157          
    158          void suite_frame(void)
    159          {
    160            umsg_line("fbuf module");
    161            test_frame_merge();
    162            tot_len_test();
    163            delete_test();
    164            insert1_test();
    165            insert2_test();
    166            insert3_test();
    167            insert4_test();  
    168          }
\\vmware-host\Shared Folders\Projects\WMNU\IAR\PRJ_UNITEST\src\utest_Frames.c
      1          #include "utest_suite.h"
      2          #include "string.h"
      3          #include "frame.h"
      4          #include "stdio.h"
      5          
      6          void suite_Frames(void)
      7          {
      8            umsg_line("Frames module");
      9          
     10          }
\\vmware-host\Shared Folders\Projects\WMNU\IAR\PRJ_UNITEST\src\utest_LLC.c
      1          #include "utest_suite.h"
      2          #include "LLC.h"
      3          #include "NTMR.h"
      4          #include "nwdebuger.h"
      5          #include "ioCC2530.h"
      6          #include "frame.h"
      7          #include "RADIO.h"
      8          #include "TIC.h"
      9          #include "mem.h"
     10          
     11          static void timealloc(void)
     12          {
     13            static bool led_stat = false;
     14              LED(D1, led_stat);
     15              led_stat = !led_stat;
     16          }
     17          
     18          static frame_s* getFrame(uint8_t *src, uint8_t len, uint8_t CH, uint8_t TS)
     19          {
     20            frame_s *fr;
     21            EA=0;
     22            fr = frame_create();
     23            
     24            fbuf_s *fb = fbuf_create(FB_RAW_LAY, src, len);
     25            EA=1;
     26            fr->meta.SEND_TIME = 0;
     27            fr->meta.TS = TS;
     28            fr->meta.CH = CH;
     29            frame_insert_head(fr, fb);
     30            return fr;
     31          }
     32          
     33          static void show_heap_ptr(void)
     34          { 
     35            uint16_t *heap_ptr;
     36            heap_ptr = (uint16_t*)re_malloc(1);
     37            LOG(MSG_ON | MSG_INFO | MSG_TRACE, "HEAP_PTR = %d\r\n", (uint16_t)heap_ptr ); 
     38            re_free(heap_ptr);
     39          }
     40          
     41          static void test_create()
     42          {
     43            LLC_Init();
     44            LLC_TimeAlloc(timealloc);
     45            EA = 1;
     46            uint8_t DATA_SEND[10] = {0,1,2,3,4,5,6,7,8,9};  
     47            
     48            frame_s *fr;
     49            
     50            uint16_t TS = 0;
     51            uint8_t *ptr_stack = (uint8_t*)0x100;
     52            
     53            fr = getFrame(DATA_SEND, sizeof(DATA_SEND), CH11, TS);
     54            uint16_t fr_size = sizeof(frame_s);
     55            uint16_t bf_size = frame_len(fr);
     56            uint16_t HEAP_PTR_MAX = 0;
     57            uint16_t heap;
     58            uint8_t nbr_bufs, nbr_frames;
                           ^
Warning[Pe550]: variable "nbr_bufs" was set but never used
          detected during compilation of secondary translation unit
                    "\\vmware-host\Shared
                    Folders\Projects\WMNU\IAR\PRJ_UNITEST\src\utest_LLC.c"

    uint8_t nbr_bufs, nbr_frames;
                      ^
"\\vmware-host\Shared Folders\Projects\WMNU\IAR\PRJ_UNITEST\src\utest_LLC.c",58  Warning[Pe550]: 
          variable "nbr_frames" was set but never used
          detected during compilation of secondary translation unit
                    "\\vmware-host\Shared
                    Folders\Projects\WMNU\IAR\PRJ_UNITEST\src\utest_LLC.c"
     59            
     60            LOG(MSG_ON | MSG_INFO | MSG_TRACE, 
     61                "Frame_s size = %d. Fbuf data = %d. Full =%d\r\n",
     62                fr_size, bf_size, bf_size+fr_size );
     63            frame_delete(fr);
     64            
     65            while(true)
     66            {  
     67              nbr_bufs = fbuf_getCount();
     68              nbr_frames = frame_getCount();
     69              if (LLC_GetTaskLen() < 20)
     70              {
     71                fr = getFrame(DATA_SEND, sizeof(DATA_SEND), CH11, TS);
     72                LOG(MSG_OFF | MSG_INFO | MSG_TRACE, "Create frame = %d.\r\n", (uint16_t)fr);    
     73                LLC_AddTask(fr);
     74                TS ++;
     75                if (TS == 49)
     76                TS = 0;
     77              }   
     78              if (*ptr_stack != 0xcd) // Контроль переполнения стека
     79                while(1);
     80             
     81              heap =  heap_ptr(10);
     82              if (heap > HEAP_PTR_MAX)
     83              {
     84                HEAP_PTR_MAX = heap;
     85                LOG(MSG_ON | MSG_INFO | MSG_TRACE, 
     86                "HEAP_PTR = %d\r\n", HEAP_PTR_MAX );
     87              }
     88            }
     89          }
     90          
     91          static void find_mem_problem(void)
     92          {
     93            LLC_Init();
     94            LLC_TimeAlloc(timealloc);
     95            EA = 1;
     96            uint8_t DATA_SEND[10] = {0,1,2,3,4,5,6,7,8,9};  
     97            
     98            frame_s *fr;
     99            
    100            uint16_t TS = 0;
    101            uint8_t *ptr_stack = (uint8_t*)0x100;
    102            
    103            uint16_t HEAP_PTR_MAX = 0;
                            ^
Warning[Pe177]: variable "HEAP_PTR_MAX" was declared but never referenced
          detected during compilation of secondary translation unit
                    "\\vmware-host\Shared
                    Folders\Projects\WMNU\IAR\PRJ_UNITEST\src\utest_LLC.c"
    104            uint16_t *heap_ptr;
                             ^
Warning[Pe177]: variable "heap_ptr" was declared but never referenced
          detected during compilation of secondary translation unit
                    "\\vmware-host\Shared
                    Folders\Projects\WMNU\IAR\PRJ_UNITEST\src\utest_LLC.c"
    105            
    106            while(true)
    107            {  
    108              if (fbuf_getCount() == 0)
    109              {
    110                show_heap_ptr();
    111                for (uint8_t i = 0; i < 20 ; i++)
    112                {
    113                    fr = getFrame(DATA_SEND, sizeof(DATA_SEND), CH11, TS);
    114                    TS++;
    115                    if (TS == 49)
    116                      TS = 0;
    117                    LLC_AddTask(fr);
    118                }
    119              }   
    120              
    121              if (*ptr_stack != 0xcd) // Контроль переполнения стека
    122                while(1);
    123            }
    124            
    125            
    126          }
    127          
    128          // Тест на максимальное количество фреймов 
    129          static void test_mem(void)
    130          {
    131            frame_s *FR[150];
                            ^
Warning[Pe550]: variable "FR" was set but never used
          detected during compilation of secondary translation unit
                    "\\vmware-host\Shared
                    Folders\Projects\WMNU\IAR\PRJ_UNITEST\src\utest_LLC.c"
    132            uint8_t DATA_SEND[10] = {0,1,2,3,4,5,6,7,8,9}; 
    133            
    134            for (uint8_t i = 0; i < 105; i++) 
    135              FR[i] = getFrame(DATA_SEND, sizeof(DATA_SEND), CH11, 5);
    136          }
    137          
    138          
    139          void suite_LLC_HW(void)
    140          {
    141           // umsg_line("LLC module");
    142            
    143            // Устанавливает и поддерживает в очереди 20 пакетов.
    144            // Для приема пакетов испольуеться второй модуль с прошивкой RadioRecvTest1
    145            test_create(); 
    146           // test_mem();
    147           // find_mem_problem();
    148             
    149          }
\\vmware-host\Shared Folders\Projects\WMNU\IAR\PRJ_UNITEST\src\utest_MAC.c
      1          #include "utest_suite.h"
      2          #include "MAC.h"
      3          #include "frame.h"
      4          #include "delays.h"
      5          #include "nwdebuger.h"
      6          #include "ioCC2530.h"
      7          
      8          static void test_ACK_SEND(void)
      9          {
     10            MAC_Init();
     11            
     12            bool res;
     13            uint8_t DATA_SEND[10] = {0,1,2,3,4,5,6,7,8,9};
     14            TimeStamp_s start, stop;
     15          while(1)
     16          {
     17            // Подготовим данные к отправке
     18            frame_s *fr = frame_create();
     19            fbuf_s *fb = fbuf_create(FB_RAW_LAY, DATA_SEND, sizeof(DATA_SEND));
     20            fr->meta.SEND_TIME = 0;
     21            fr->meta.CH = CH11;
     22            frame_insert_head(fr, fb);
     23             
     24            // Нам не важно что структура не соотетсвует ACK. Важно чтоб пакет ушел
     25            TIM_TimeStamp(&start);
     26            res = MAC_ACK_Send(fr);
     27            TIM_TimeStamp(&stop);
     28            uint32_t passed = TIM_passedTime(&start, &stop);
     29            LOG(MSG_ON | MSG_INFO | MSG_TRACE, 
     30                "MAC_ACK_Send time = %lu. Success %d \n", passed, res);
     31          }
     32          }
     33          
     34          static void stub_se(uint8_t ts)
     35          {
     36          }
     37          
     38          static void test_TS_Send(void)
     39          {
     40            MAC_Init();
     41            TIC_SetSECallback(stub_se);
     42            EA = 1;
     43            uint8_t DATA_SEND[10] = {0,1,2,3,4,5,6,7,8,9};  
     44            uint8_t TS = 5, attempts = 3;
     45            
     46            frame_s *fr; 
     47            
     48            while (true)
     49            {
     50              if (!MAC_GetTXState(TS))
     51              {
     52                fr = frame_create();
     53                fbuf_s *fb = fbuf_create(FB_RAW_LAY, DATA_SEND, sizeof(DATA_SEND));
     54                fr->meta.SEND_TIME = 0;
     55                fr->meta.TS = TS;
     56                fr->meta.CH = CH11;
     57                frame_insert_head(fr, fb);
     58                MAC_Send(fr, attempts);
     59                LOG(MSG_ON | MSG_INFO | MSG_TRACE, "Frame puted to MAC layer at %lu sec\n", TIC_GetRTC());
     60              }
     61            }
     62          }
     63          
     64          void suite_MAC(void)
     65          {
     66            // test_TS_Send отсылает пакеты по расписанию тайм слотов
     67            // Нужно запрограмировать второе устройство RadioRecvTest1
     68            // тогда будет гореть светодиод при приеме сигнала
     69            test_TS_Send(); 
     70            test_ACK_SEND();
     71          }
\\vmware-host\Shared Folders\Projects\WMNU\IAR\PRJ_UNITEST\src\utest_malloc.c
      1          #include "utest_suite.h"
      2          #include "stdlib.h"
      3          
      4          static  uint16_t getMallocSize(void *ptr)
      5          {
      6            uint16_t *size = (uint16_t*)ptr - 1;
      7            return *size-2;
      8          }
      9          
     10          
     11          static void test_1(void)
     12          {
     13            // Проверка как хранит размер памяти фун-я маллок
     14            // Перед указатель выделяется 2 байта и длинна на 2 байта увеличиается
     15            void *ptr_1 = malloc(0x32);
     16            void *ptr_2 = malloc(0x78);
     17            uint16_t size_1 = getMallocSize(ptr_1);
     18            uint16_t size_2 = getMallocSize(ptr_2);
     19          }
     20          
     21          void suite_malloc(void)
     22          {
     23           // umsg_line("LLC module");
     24            
     25            // Устанавливает и поддерживает в очереде 10 пакетов.
     26            // Мигает зеленым светодиодом. В TS0 включается, в TS5 выключаеться
     27            test_1();  
     28          }
\\vmware-host\Shared Folders\Projects\WMNU\IAR\PRJ_UNITEST\src\utest_NTMR.c
      1          #include "utest_suite.h"
      2          #include "NTMR.h"
      3          #include "ioCC2530.h"
      4          
      5          static bool finised;
      6          
      7          static inline bool isNear(uint16_t A, uint16_t B, uint16_t x)
      8          {
      9            if (A>B)
     10              A = A - B;
     11            else
     12              A = B - A;
     13            if (A<=x)
     14              return true;
     15            return false;
     16          }
     17          
     18          
     19          static void TimerHndl(uint16_t ticks)
     20          {    
     21            if (isNear(ticks, 0 , 3))
     22            {
     23              NT_SetCompare(1000);
     24              P0_0 = 1;
     25              P0_0 = 0;
     26            }
     27            else if (isNear(ticks, 1000 , 3))
     28            {
     29              NT_SetCompare(2000);
     30              P0_0 = 1;
     31              P0_0 = 0;
     32            }
     33            else if (isNear(ticks, 2000 , 3))
     34            {
     35              NT_SetCompare(25000);
     36              P0_0 = 1;
     37              P0_0 = 0;
     38            }  
     39            else if (isNear(ticks, 25000 , 3))
     40            {
     41              NT_SetCompare(26000);
     42              P0_0 = 1;
     43              P0_0 = 0;
     44            }
     45            else if (isNear(ticks, 26000 , 3))
     46            {
     47              NT_SetCompare(27000);
     48              P0_0 = 1;
     49              P0_0 = 0;
     50            }
     51            else if (isNear(ticks, 27000 , 3))
     52            {
     53              P0_0 = 1;
     54              P0_0 = 0;
     55              finised = true;
     56            }                    
     57          }
     58          
     59          /** 
     60          @brief Тестирование алгоритмов которые нельзя вынести из модуля 
     61          @deails Использует вывод P0_0 для индикации работы таймера
     62           Генерирует импульсы при каждом срабатывании. Нужно настроить логический
     63           анализатор на высокую частоту и работать с 1 каналом, иначе импульсы
     64           проглатывает.
     65          */
     66          static void alg_test(void)
     67          {
     68            EA = 1;
     69          
     70            P0DIR = 0x01;
     71            P0_0 = 0;
     72            
     73            NT_Init();
     74            NT_SetEventCallback(TimerHndl);
     75            
     76            // Тут поставить точку останова и запустить анализатор
     77            // Вы должны увидеть 6 импульсов. Измерения по переднему фронту
     78            // Работаем на внутреннем RC генераторе
     79            // И0-И1 30.508мс
     80            // И1-И2 30.521мс
     81            for (uint16_t i = 0 ; i < 1000; i++)
     82            {
     83              finised = false;
     84              NT_SetCompare(0);
     85              while (!finised);
     86            }
     87            // Тут поставить точку останова
     88          }
     89          
     90          void suite_NT_HW(void)
     91          {
     92            //umsg_line("NTMR module");
     93            alg_test();
     94          }
\\vmware-host\Shared Folders\Projects\WMNU\IAR\PRJ_UNITEST\src\utest_printf_uart.c
      1          #include "nwdebuger.h"
      2          #include "utest_suite.h"
      3          #include "delays.h"
      4          #include "stdio.h"
      5          
      6          void test_1(void)
      7          {
      8            const char test_string1[] = "Hello world\n";
      9            const char test_string2[] = "Hello worldHello worldHello worldHello world\n";
     10            TimeStamp_s start, stop;
     11            
     12            TIM_init();
     13            TIM_TimeStamp(&start);
     14            printf(test_string1);
     15            TIM_TimeStamp(&stop);
     16            
     17            uint32_t passed = TIM_passedTime(&start, &stop);
     18            
     19            LOG(MSG_ON | MSG_INFO | MSG_TRACE, 
     20                "String 1 len = %d. Print time = %lu us\n",
     21                sizeof(test_string1), passed);
     22            
     23            TIM_TimeStamp(&start);
     24            printf(test_string2);
     25            TIM_TimeStamp(&stop);
     26            
     27            passed = TIM_passedTime(&start, &stop);
     28            
     29            LOG(MSG_ON | MSG_INFO | MSG_TRACE, 
     30                "String 2 len = %d. Print time = %lu us.\n",
     31                sizeof(test_string2), passed);  
     32          }
     33          
     34          void suite_printf_uart(void)
     35          {
     36            umsg_line("printf speed uart");
     37            test_1();
     38            
     39          }
\\vmware-host\Shared Folders\Projects\WMNU\IAR\PRJ_UNITEST\src\utest_radio.c
      1          #include "utest_suite.h"
      2          #include "RADIO.h"
      3          #include "ioCC2530.h"
      4          #include "delays.h"
      5          #include "frame.h"
      6          #include "coder.h"
      7          #include "nwdebuger.h"
      8          #include "TIC.h"
      9          #include "NTMR.h"
     10          
     11          static void RadioSendTest1(void)
     12          {
     13            uint8_t DATA_SEND[10] = {0,1,2,3,4,5,6,7,8,9};
     14            uint8_t key[16] = {18,11,12,13,14,15,16,17,10,11,12,13,14,15,16,17};
     15            uint8_t nonce[16] = {18,11,12,13,14,15,16,17,10,11,12,13,14,15,16,17};
     16            
     17            TIM_init();
     18            RI_init();
     19            AES_init();
     20            
     21            RI_StreamCrypt(true);
     22            RI_SetChannel(CH11);
     23            RI_setKEY(key);
     24            RI_setIV(nonce);
     25            
     26            // Подготовим данные к отправке
     27            frame_s *fr = frame_create();
     28            fbuf_s *fb = fbuf_create(FB_RAW_LAY, DATA_SEND, sizeof(DATA_SEND));
     29            fr->meta.SEND_TIME = 3000;
     30            frame_insert_head(fr, fb);
     31            
     32            // Передача данных
     33            bool res;
     34            while(true)
     35            {
     36              LED(D1, true);
     37              TIM_delay(100UL*Tmsec);
     38              LED(D1, false);
     39              res = RI_Send(fr);
     40              if (!res)
     41                LED(D2, true);
     42              else
     43                LED(D2, false);
     44              TIM_delay(900UL*Tmsec);
     45            };
     46            
     47            frame_delete(fr);
                   ^
Warning[Pe111]: statement is unreachable
          detected during compilation of secondary translation unit
                    "\\vmware-host\Shared
                    Folders\Projects\WMNU\IAR\PRJ_UNITEST\src\utest_radio.c"
     48          }
     49          
     50          static void RadioRecvTest1(void)
     51          {
     52            uint8_t DATA_RECV[10] = {0,1,2,3,4,5,6,7,8,9};
     53            uint8_t key[16] = {18,11,12,13,14,15,16,17,10,11,12,13,14,15,16,17};
     54            uint8_t nonce[16] = {18,11,12,13,14,15,16,17,10,11,12,13,14,15,16,17};
     55            
     56            NT_Init(); // Управление прериваниями таймера сна
     57            TIM_init();// Таймер MAC для измерения интервалов времени
     58            TIC_Init();// Контроллер интервалов времени (зависит от NT)
     59            RI_init(); // Иницилизация радио ( использует TIM и NT)
     60            AES_init();// Иницилизация шифровальщика
     61            
     62            RI_StreamCrypt(true);
     63            RI_SetChannel(CH11);
     64            RI_setKEY(key);
     65            RI_setIV(nonce);
     66            
     67            // Примем данных
     68            frame_s *fr;
     69            
     70            // Прием данных
     71            bool res;
     72            while(true)
     73            {
     74              fr = RI_Receive(2000);
     75              LED(D2, false);
     76              if (fr == NULL)
     77                continue;
     78              
     79              if (memory_compare((char*)DATA_RECV, fr->head->payload, 10))
     80                LED(D2, true);
     81              
     82              frame_delete(fr);
     83            };
     84            
     85            frame_delete(fr);
                   ^
Warning[Pe111]: statement is unreachable
          detected during compilation of secondary translation unit
                    "\\vmware-host\Shared
                    Folders\Projects\WMNU\IAR\PRJ_UNITEST\src\utest_radio.c"

    bool res;
         ^
"\\vmware-host\Shared Folders\Projects\WMNU\IAR\PRJ_UNITEST\src\utest_radio.c",71  Warning[Pe177]: 
          variable "res" was declared but never referenced
          detected during compilation of secondary translation unit
                    "\\vmware-host\Shared
                    Folders\Projects\WMNU\IAR\PRJ_UNITEST\src\utest_radio.c"
     86          }
     87          
     88          static void one_speed_test(frame_s *fr)
     89          {
     90            bool res;
     91            TimeStamp_s start, stop, *ts0;
                                             ^
Warning[Pe177]: variable "ts0" was declared but never referenced
          detected during compilation of secondary translation unit
                    "\\vmware-host\Shared
                    Folders\Projects\WMNU\IAR\PRJ_UNITEST\src\utest_radio.c"

  static void CCM_speed_test(void)
              ^
"\\vmware-host\Shared Folders\Projects\WMNU\IAR\PRJ_UNITEST\src\utest_coder.c",71  Warning[Pe177]: 
          function "CCM_speed_test" was declared but never referenced
          detected during compilation of secondary translation unit
                    "\\vmware-host\Shared
                    Folders\Projects\WMNU\IAR\PRJ_UNITEST\src\utest_coder.c"

  static void find_mem_problem(void)
              ^
"\\vmware-host\Shared Folders\Projects\WMNU\IAR\PRJ_UNITEST\src\utest_LLC.c",91  Warning[Pe177]: 
          function "find_mem_problem" was declared but never referenced
          detected during compilation of secondary translation unit
                    "\\vmware-host\Shared
                    Folders\Projects\WMNU\IAR\PRJ_UNITEST\src\utest_LLC.c"

  static void test_mem(void)
              ^
"\\vmware-host\Shared Folders\Projects\WMNU\IAR\PRJ_UNITEST\src\utest_LLC.c",129  Warning[Pe177]: 
          function "test_mem" was declared but never referenced
          detected during compilation of secondary translation unit
                    "\\vmware-host\Shared
                    Folders\Projects\WMNU\IAR\PRJ_UNITEST\src\utest_LLC.c"

  static void RadioSendTest1(void)
              ^
"\\vmware-host\Shared Folders\Projects\WMNU\IAR\PRJ_UNITEST\src\utest_radio.c",11  Warning[Pe177]: 
          function "RadioSendTest1" was declared but never referenced
          detected during compilation of secondary translation unit
                    "\\vmware-host\Shared
                    Folders\Projects\WMNU\IAR\PRJ_UNITEST\src\utest_radio.c"
     92            do
     93            {
     94              TIM_TimeStamp(&start);
     95              res = RI_Send(fr);
     96              TIM_TimeStamp(&stop);
     97            } while (!res);
     98            
     99            uint32_t passed = TIM_passedTime(&start, &stop);
    100            uint16_t passed_sfd = fr->meta.TIMESTAMP;
    101            LOG(MSG_ON | MSG_INFO | MSG_TRACE, 
    102                "Data size = %d. Full time = %lu us. SFD time = %d us\n"
    103                ,fr->head->len, passed, passed_sfd);
    104           
    105          }
    106          static void speed_test(void)
    107          {
    108            uint8_t DATA_SEND[100];
    109            uint8_t key[16] = {18,11,12,13,14,15,16,17,10,11,12,13,14,15,16,17};
    110            uint8_t nonce[16] = {18,11,12,13,14,15,16,17,10,11,12,13,14,15,16,17};
    111            uint8_t size_tests[] = {10, 50, 100, 125};
    112            
    113            TIM_init();
    114            RI_init();
    115            AES_init();
    116            
    117            RI_StreamCrypt(true);
    118            RI_SetChannel(CH11);
    119            RI_setKEY(key);
    120            RI_setIV(nonce);
    121            
    122            // Подготовим данные к отправке
    123            
    124            LOG(MSG_ON | MSG_INFO | MSG_TRACE, "SEND SPEED TEST WITH DATA ENCODE\n");  
    125            for (uint8_t s = 0; s < sizeof(size_tests) ; s++)
    126            {
    127              frame_s *fr = frame_create();
    128              fbuf_s *fb = fbuf_create(FB_RAW_LAY, DATA_SEND, size_tests[s]);
    129              frame_insert_head(fr, fb);
    130              one_speed_test(fr);
    131              frame_delete(fr);
    132            }
    133            
    134            RI_StreamCrypt(false);
    135            LOG(MSG_ON | MSG_INFO | MSG_TRACE, "SEND SPEED TEST WITHOUT DATA ENCODE\n"); 
    136            for (uint8_t s = 0; s < sizeof(size_tests) ; s++)
    137            {
    138              frame_s *fr = frame_create();
    139              fbuf_s *fb = fbuf_create(FB_RAW_LAY, DATA_SEND, size_tests[s]);
    140              frame_insert_head(fr, fb);
    141              one_speed_test(fr);
    142              frame_delete(fr);
    143            }
    144            
    145            RI_StreamCrypt(true);
    146            LOG(MSG_ON | MSG_INFO | MSG_TRACE, "SEND IN SEND_TIME 1000 ticks AFTER TS0\n"); 
    147            for (uint8_t s = 0; s < sizeof(size_tests) ; s++)
    148            {
    149              frame_s *fr = frame_create();
    150              fbuf_s *fb = fbuf_create(FB_RAW_LAY, DATA_SEND, size_tests[s]);
    151              frame_insert_head(fr, fb);
    152              fr->meta.SEND_TIME = 1000;
    153              TIC_Init(); // При иницилизации TS0 отсчитываеться с этого момента
    154              one_speed_test(fr);
    155              frame_delete(fr);
    156            }  
    157            
    158          
    159            RI_StreamCrypt(true);
    160            LOG(MSG_ON | MSG_INFO | MSG_TRACE, "SEND IN SEND_TIME 1000 ticks AFTER TS0\n"); 
    161            for (uint8_t s = 0; s < sizeof(size_tests) ; s++)
    162            {
    163              frame_s *fr = frame_create();
    164              fbuf_s *fb = fbuf_create(FB_RAW_LAY, DATA_SEND, size_tests[s]);
    165              frame_insert_head(fr, fb);
    166              fr->meta.SEND_TIME = 1000;
    167              TIC_Init(); // При иницилизации TS0 отсчитываеться с этого момента
    168              one_speed_test(fr);
    169              frame_delete(fr);
    170            } 
    171            
    172            RI_StreamCrypt(true);
    173            LOG(MSG_ON | MSG_INFO | MSG_TRACE, "SEND IN SEND_TIME 1000 ticks AFTER TS0\n"); 
    174            for (uint8_t s = 0; s < sizeof(size_tests) ; s++)
    175            {
    176              frame_s *fr = frame_create();
    177              fbuf_s *fb = fbuf_create(FB_RAW_LAY, DATA_SEND, size_tests[s]);
    178              frame_insert_head(fr, fb);
    179              fr->meta.SEND_TIME = 1000;
    180              TIC_Init(); // При иницилизации TS0 отсчитываеться с этого момента
    181              one_speed_test(fr);
    182              frame_delete(fr);
    183            } 
    184            
    185          }
    186          
    187          // Тесты скорости
    188          void suite_RADIO(void)
    189          {
    190            umsg_line("RADIO module");
    191            speed_test();
    192          }
    193          // Для тестирования радио запрограмируй два узла. Первый узел RadioSendTest1();
    194          // Второй узел RadioRecvTest1(); Первый будет раз в секунду передавать
    195          // шифрованные данные. Второй при приеме и удачном декодировании включит
    196          // светодиод.
    197          void suite_RADIO_HW(void)
    198          {
    199            //umsg_line("NTMR module");
    200            //RadioSendTest1();
    201            //
    202            RadioRecvTest1();
    203          }
\\vmware-host\Shared Folders\Projects\WMNU\IAR\PRJ_UNITEST\src\utest_suite.c
      1          #include "stdio.h"
      2          #include "utest_suite.h"
      3          #include "ioCC2530.h"
      4          
      5          /**
      6          @brief Иницилизируем выводы светодидов
      7          */
      8          void utestSigTraceInit(void)
      9          {
     10            P1DIR = 0x13; // Включаем светодиоды
     11          }
     12          
     13          void LED(uint8_t led, bool state)
     14          {
     15            switch(led)
     16            {
     17              case D1:
     18                P1_0 = !state;
     19                break;
     20              case D2:
     21                P1_1 = !state;
     22                break;
     23              case D3:
     24                P1_4 = !state;
     25                break;
     26            }
     27          }
     28          
     29          
     30          static struct utest_summary_s
     31          {
     32          	uint16_t passed;
     33          	uint16_t failed;
     34          } utest_summary = {.passed =0, .failed = 0};;
     35          
     36          //utest_summary_s utest_summary = {.passed =0, .failed = 0};
     37          
     38          // Требует много програмной памяти
     39          size_t heap_size(void)
     40          { 
     41            return 0;
     42          }
     43          
     44          bool memory_compare(char* area1, char* area2, uint16_t size)
     45          {
     46          	while (size > 0)
     47          	{
     48          		if (*area1 != *area2)
     49          			return false;
     50          		area1++;
     51          		area2++;
     52                  size--;
     53          	} 
     54          	return true;
     55          }
     56          
     57          void umsg(char* module, char* name, bool status)
     58          {
     59          	if (status){
     60          		utest_summary.passed++;
     61          		printf("Module: %-15s Name: %-50s Status: %-10s\r\n", module, name, "PASSED");
     62          		}
     63          	else{
     64          		utest_summary.failed++;
     65          		printf("Module: %-15s Name: %-50s Status: %-10s\r\n", module, name, "FAILED <----");
     66          		}
     67          }
     68          
     69          void umsg_line(char* name)
     70          {
     71          	printf("**************************************\r\n");
     72          	printf("%s\r\n", name);
     73          	printf("**************************************\r\n");
     74          }
     75          
     76          void umsg_summary()
     77          {
     78          	umsg_line("Unit test symmary");
     79          	printf("PASSED: %d\r\n", utest_summary.passed);
     80          	printf("FAILD : %d\r\n", utest_summary.failed);
     81          	if (utest_summary.failed == 0)
     82                printf("Tests PASSED\r\n");
     83          	else
     84          		printf("Tests FAILED\r\n");
     85          }
\\vmware-host\Shared Folders\Projects\WMNU\IAR\PRJ_UNITEST\src\utest_TIC.c
      1          #include "utest_suite.h"
      2          #include "TIC.h"
      3          #include "NTMR.h"
      4          #include "ioCC2530.h"
      5          
      6          static void RXC(uint8_t TS)
      7          {
      8            P0_1 = 1;
      9            P0_1 = 0;
     10          }
     11          
     12          static void TXC(uint8_t TS)
     13          {
     14            P0_4 = 1;
     15            P0_4 = 0;
     16          }
     17          
     18          static void SEC(uint8_t TS)
     19          {
     20            if (TS == 0)
     21            {
     22              P0_0 = 1;
     23              P0_0 = 0;
     24            }
     25          }
     26          
     27          /**
     28          @details Аппаратный тест TIC. Выводит сигналы
     29          на выводы P0_0 завершение нулевого слота. P0_1 прием, P0_4 передача.
     30          Тайм слот 11 показывает приоритет передачи над приемом.
     31          */
     32          static void test_hw(void)
     33          {
     34            NT_Init();
     35            TIC_Init();
     36            EA = 1;
     37            P0DIR = 0xff;
     38            P0_0 = 0;
     39            P0_1 = 0;
     40            P0_2 = 0;
     41            
     42            TIC_SetRXCallback(RXC);
     43            TIC_SetTXCallback(TXC);
     44            TIC_SetSECallback(SEC);
     45            
     46            TIC_SetRXState(10, true);
     47            TIC_SetRXState(11, true);
     48            TIC_SetRXState(20, true);
     49            TIC_SetRXState(21, true);
     50            
     51            TIC_SetTXState(5, true);
     52            TIC_SetTXState(11, true);
     53           
     54            TIC_SetRTC(10000);
     55            TIC_SetNonce(5000);
     56            volatile uint32_t rtc, ut, nonce;
     57            while(true)
     58            {
     59              // тут можно остановить программу и посмотреть работу таймеров
     60              // rtc больше на 10000 чем uptime, nonce больше на 5000
     61              ut = TIC_GetUptime(); 
     62              rtc = TIC_GetRTC();
     63              nonce = TIC_GetNonce();
     64            }
     65          }
     66          
     67          void suite_TIC_HW(void)
     68          {
     69            test_hw();
     70          }

   Maximum stack usage in bytes:

   ISTACK XSTACK Function
   ------ ------ --------
      1    184   AES_CCMDecrypt
        0     66   -> CBCMAC_buf_encrypt
        0     70   -> CTR_enc_decrypt
        0     68   -> generateAuthData
        0     68   -> memcpy
        0     68   -> memset
      1    168   AES_CCMEncrypt
        0     50   -> CBCMAC_buf_encrypt
        0     54   -> CTR_enc_decrypt
        0     52   -> generateAuthData
        0     52   -> memcpy
        0     52   -> memset
      0    127   AES_StreamCoder
        0     39   -> memcpy
        0     39   -> memset
      2    188   AES_init
      0    116   CBCMAC_buf_encrypt
        0     50   -> memcpy
        0     50   -> memset
      0    194   CCM_code_decode_test
        0    188   -> AES_init
        0    188   -> TIM_init
        0    188   -> printf
        0    192   -> printf
        0    194   -> printf
        0    194   -> single_enc_dec_test
        0    188   -> umsg
      1     62   CCM_test
        0     62   -> AES_CCMDecrypt
        0     62   -> AES_CCMEncrypt
        0     56   -> AES_init
        0     56   -> TIM_init
        0     58   -> memset
      0    109   CTR_enc_decrypt
        0     39   -> memcpy
        0     39   -> memset
      0     28   Callback_execution
        0     12   -> STACK_FAILURE
        0     12   -> printf
        0     16   -> printf
      0     40   DelayCalibrate
        0     40   -> TIM_TimeStamp
        0     40   -> TIM_delay
        0     40   -> TIM_passedTime
      2      0   ETH_Init
        2      0   -> LLC_SetRXCallback
      0     18   ETH_RX_HNDL
        0     14   -> STACK_FAILURE
        0     14   -> extract_header
        0     14   -> frame_delete
        0     14   -> printf
        0     18   -> printf
        0     14   -> re_free
        0     14   -> send_ack
        0     14   -> strip_header
        0     14   -> validate
      0     14   ETH_Set_RXCallback
        0     10   -> STACK_FAILURE
        0     10   -> printf
        0     14   -> printf
      0     54   Interval
      0     52   LED
      1     50   LLC_AddTask
        0     12   -> STACK_FAILURE
        0     12   -> printf
        0     16   -> printf
        0     12   -> re_malloc
      2     34   LLC_GetTaskLen
      2     34   LLC_Init
        2      0   -> MAC_Init
        2      0   -> MAC_SetRXCallback
        2      0   -> TIC_SetSECallback
      0     14   LLC_RX_HNDL
        0     10   -> STACK_FAILURE
        0     10   -> printf
        0     14   -> printf
      0     18   LLC_RunTimeAlloc
      0      9   LLC_SE_HNDL
        0      9   -> LLC_RunTimeAlloc
        0      9   -> LLC_Shelduler
      0     14   LLC_SetRXCallback
        0     10   -> STACK_FAILURE
        0     10   -> printf
        0     14   -> printf
      0     22   LLC_Shelduler
        0     13   -> MAC_GetTXState
        0     13   -> MAC_Send
        0     13   -> re_free
      0     50   LLC_TimeAlloc
        0     12   -> STACK_FAILURE
        0     12   -> printf
        0     16   -> printf
        0     12   -> re_malloc
      2     15   LoadTXData
      0      0   MAC_ACK_Recv
      0     51   MAC_ACK_Send
        0      9   -> RI_Send
        0      9   -> RI_SetChannel
        0      9   -> frame_delete
      1     14   MAC_CloseRXSlot
        0     10   -> STACK_FAILURE
        0     10   -> TIC_SetRXState
        0     10   -> printf
        0     14   -> printf
      0     14   MAC_GetRXState
        0     10   -> STACK_FAILURE
        0     10   -> printf
        0     14   -> printf
      0     40   MAC_GetTXState
        0     10   -> STACK_FAILURE
        0     10   -> printf
        0     14   -> printf
      0     54   MAC_Init
        0     10   -> AES_init
        0     10   -> RI_StreamCrypt
        0     10   -> RI_init
        0     10   -> RI_setIV
        0     10   -> RI_setKEY
        0     10   -> TIC_Init
        0     10   -> TIC_SetRXCallback
        0     10   -> TIC_SetTXCallback
        0     10   -> TIM_init
        0     12   -> memset
      1     14   MAC_OpenRXSlot
        0     10   -> STACK_FAILURE
        0     10   -> TIC_SetRXState
        0     10   -> printf
        0     14   -> printf
      0     16   MAC_RX_HNDL
        0     12   -> RI_Receive
        0     12   -> RI_SetChannel
        0     12   -> STACK_FAILURE
        0     12   -> printf
        0     16   -> printf
      1     42   MAC_Send
        0     12   -> STACK_FAILURE
        0     12   -> TIC_SetTXState
        0     12   -> printf
        0     16   -> printf
      2      0   MAC_SetRXCallback
      2      0   MAC_Set_isACK_OK_Callback
      1     16   MAC_TX_HNDL
        0     12   -> RI_Receive
        0     12   -> RI_Send
        0     12   -> RI_SetChannel
        0     12   -> STACK_FAILURE
        0     12   -> TIC_SetTXState
        0     12   -> TIM_delay
        0     12   -> frame_delete
        0     12   -> printf
        0     16   -> printf
      0     16   MyLowLevelPutchar
      0     48   NT_GetTime
        0     16   -> ReadTimer
      0     15   NT_IRQEnable
      2     52   NT_Init
        2      0   -> NT_IRQEnable
      0     30   NT_SetCompare
        0     12   -> NT_IRQEnable
        0     12   -> STACK_FAILURE
        0     12   -> calcCompareTime
        0     12   -> loadTimerCompare
        0     12   -> printf
        0     16   -> printf
      2      9   NT_SetEventCallback
      0     28   NT_SetTime
        0     14   -> NT_SetCompare
        0     14   -> ReadTimer
        0     14   -> STACK_FAILURE
        0     14   -> isIRQEnable
        0     14   -> printf
        0     18   -> printf
      0     27   NT_WaitTime
      0     31   RI_BitRawCrypt
        0     16   -> AES_StreamCoder
      0     62   RI_BitRawDecrypt
        0     16   -> AES_StreamCoder
      2      0   RI_GetCCAReject
      2      0   RI_GetCRCError
      2      0   RI_GetUptime
      1    100   RI_Receive
        0     46   -> RI_BitRawDecrypt
        0     46   -> RI_cfg
        0     48   -> RecvData
        0     46   -> TIM_TimeStamp
        0     46   -> TIM_passedTime
        0     46   -> UnLoadRXData
        0     46   -> fbuf_create
        0     46   -> frame_create
        0     46   -> frame_insert_head
        0     46   -> re_free
        0     46   -> re_malloc
      0     72   RI_Send
        0     36   -> RI_cfg
        0     36   -> STACK_FAILURE
        0     36   -> SendData
        0     36   -> TIM_TimeStamp
        0     36   -> TIM_passedTime
        0     36   -> printf
        0     40   -> printf
      2    150   RI_SetChannel
      2    150   RI_StreamCrypt
      3     47   RI_cfg
        2      1   -> setFreq
      2    150   RI_init
        2      0   -> random_core_init
      0    162   RI_setIV
        0     12   -> memcpy
      0    162   RI_setKEY
        0     12   -> memcpy
      0      0   RXC
      0     54   RadioRecvTest1
        0     52   -> AES_init
        0     52   -> LED
        0     52   -> NT_Init
        0     52   -> RI_Receive
        0     52   -> RI_SetChannel
        0     52   -> RI_StreamCrypt
        0     52   -> RI_init
        0     52   -> RI_setIV
        0     52   -> RI_setKEY
        0     52   -> TIC_Init
        0     52   -> TIM_init
        0     52   -> frame_delete
        0     54   -> memory_compare
      2     22   ReadTimer
      0     80   RecvData
        0     32   -> NT_GetTime
        0     32   -> TIM_TimeStamp
        0     32   -> TIM_passedTime
      0      0   SEC
      0     36   STACK_FAILURE
      0     51   SendData
        0     15   -> LoadTXData
        0     15   -> NT_GetTime
        0     15   -> NT_WaitTime
        0     15   -> RI_BitRawCrypt
        0     15   -> frame_merge
        0     15   -> re_free
      0      0   SetCPU32M
      2     12   TIC_GetNonce
      2     26   TIC_GetRTC
      0     14   TIC_GetRXState
        0     10   -> STACK_FAILURE
        0     10   -> printf
        0     14   -> printf
      0     14   TIC_GetTXState
        0     10   -> STACK_FAILURE
        0     10   -> printf
        0     14   -> printf
      0      0   TIC_GetTimeStampTS0
      2      0   TIC_GetTimer
        2      0   -> NT_GetTime
      2     12   TIC_GetUptime
      0     16   TIC_HW_Timer_IRQ
        0     12   -> Callback_execution
        0     12   -> TIC_TDMAShelduler
        0     12   -> TIC_getCurrentTS
        0     12   -> TIM_TimeStamp
        0     12   -> clocks_update
        0     12   -> printf
        0     16   -> printf
      2    150   TIC_Init
        2      0   -> NT_SetCompare
        2      0   -> NT_SetEventCallback
        2      0   -> TIC_SetTimer
        2      0   -> TIM_TimeStamp
      0     24   TIC_SetNonce
      0     24   TIC_SetRTC
      0     26   TIC_SetRXCallback
        0     10   -> STACK_FAILURE
        0     10   -> printf
        0     14   -> printf
      0     26   TIC_SetRXState
        0     10   -> STACK_FAILURE
        0     10   -> printf
        0     14   -> printf
      0     40   TIC_SetSECallback
        0     10   -> STACK_FAILURE
        0     10   -> printf
        0     14   -> printf
      0     26   TIC_SetTXCallback
        0     10   -> STACK_FAILURE
        0     10   -> printf
        0     14   -> printf
      0     26   TIC_SetTXState
        0     10   -> STACK_FAILURE
        0     10   -> printf
        0     14   -> printf
      0     14   TIC_SetTimer
        0     10   -> NT_SetTime
        0     10   -> STACK_FAILURE
        0     10   -> printf
        0     14   -> printf
      3     13   TIC_TDMAShelduler
        2      1   -> incrementTS
        2      1   -> set_capture_time
      0     24   TIC_TimeUsFromTS0
        0     24   -> TIM_TimeStamp
        0     24   -> TIM_passedTime
      0     22   TIC_getCurrentTS
      3     91   TIM_TimeStamp
      0     14   TIM_copy
        0     14   -> memcpy
      0     76   TIM_delay
        0     36   -> Interval
        0     36   -> TIM_TimeStamp
      2    188   TIM_init
        2      0   -> DelayCalibrate
      0    109   TIM_passedTime
        0     18   -> Interval
      0      0   TXC
      0     15   TimerCompareInterrupt
        0     15   -> NT_GetTime
        0     15   -> NT_IRQEnable
      0     12   TimerHndl
        0     10   -> NT_SetCompare
        0     12   -> isNear
      3     46   UnLoadRXData
      0     18   __write
        0     16   -> MyLowLevelPutchar
      0     88   aes_test
        0     88   -> AES_StreamCoder
        0     84   -> AES_init
        0     84   -> TIM_TimeStamp
        0     84   -> TIM_init
        0     84   -> TIM_passedTime
        0     86   -> memset
        0     88   -> printf
      0      9   alg_test
        0      9   -> NT_Init
        0      9   -> NT_SetCompare
        0      9   -> NT_SetEventCallback
      0     32   alg_test
        0     32   -> TIM_TimeStamp
        0     32   -> TIM_init
        0     32   -> TIM_passedTime
        0     32   -> umsg
      0      9   bits_count
      2     34   calcCompareTime
        0     22   -> ReadTimer
      0     24   clocks_update
      0     12   delete_test
        0     12   -> fbuf_create
        0     12   -> fbuf_delete
        0     12   -> umsg
      0     26   delete_test
        0     26   -> fbuf_create
        0     26   -> fbuf_delete
        0     26   -> frame_create
        0     26   -> frame_delete
        0     26   -> frame_insert_head
        0     26   -> umsg
      0     34   extract_header
        0     16   -> STACK_FAILURE
        0     16   -> frame_get_fbuf_head
        0     16   -> frame_len
        0     16   -> printf
        0     20   -> printf
        0     16   -> re_malloc
        0     18   -> re_memcpy
      2     16   fbuf_chain
      1    170   fbuf_create
        0     16   -> STACK_FAILURE
        0     18   -> memcpy
        0     18   -> memset
        0     16   -> printf
        0     20   -> printf
        0     16   -> re_malloc
      0    119   fbuf_delete
        0      9   -> re_free
      2     34   fbuf_getCount
      2     20   fbuf_next
      0    164   frame_create
        0     10   -> STACK_FAILURE
        0     12   -> memset
        0     10   -> printf
        0     14   -> printf
        0     10   -> re_malloc
      0    162   frame_delete
        0     12   -> fbuf_delete
        0     12   -> re_free
      2     34   frame_getCount
      2     20   frame_get_fbuf_head
      2     20   frame_get_fbuf_tail
      0    159   frame_insert_head
      0     44   frame_insert_tail
        0     12   -> STACK_FAILURE
        0     12   -> printf
        0     16   -> printf
      2     34   frame_len
      1     49   frame_merge
        0     20   -> STACK_FAILURE
        0     20   -> frame_len
        0     22   -> memcpy
        0     20   -> printf
        0     24   -> printf
        0     20   -> re_malloc
      0     19   free
        0      9   -> __xdata_free
      0     86   generateAuthData
        0     18   -> memcpy
      1     52   getFrame
        0     18   -> fbuf_create
        0     18   -> frame_create
        0     18   -> frame_insert_head
      2     14   getMallocSize
      2      9   getRNDByte
      0     46   heap_ptr
        0     12   -> re_free
        0     12   -> re_malloc
      0      0   heap_size
      2      1   incrementTS
      0     12   insert1_test
        0     12   -> fbuf_create
        0     12   -> frame_create
        0     12   -> frame_delete
        0     12   -> frame_insert_head
        0     12   -> umsg
      0     12   insert2_test
        0     12   -> fbuf_create
        0     12   -> frame_create
        0     12   -> frame_delete
        0     12   -> frame_insert_tail
        0     12   -> umsg
      0     20   insert3_test
        0     20   -> fbuf_create
        0     20   -> fbuf_next
        0     20   -> frame_create
        0     20   -> frame_delete
        0     20   -> frame_get_fbuf_head
        0     20   -> frame_get_fbuf_tail
        0     20   -> frame_insert_head
        0     20   -> umsg
      0     20   insert4_test
        0     20   -> fbuf_create
        0     20   -> fbuf_next
        0     20   -> frame_create
        0     20   -> frame_delete
        0     20   -> frame_get_fbuf_head
        0     20   -> frame_insert_tail
        0     20   -> umsg
      0     14   isIRQEnable
      2     12   isNear
      0     28   loadTimerCompare
      0      4   main
        0      0   -> nwDebugerInit
        0      0   -> printf
        0      4   -> printf
        0      0   -> suite_LLC_HW
        0      0   -> umsg_summary
        0      0   -> utestSigTraceInit
      0     23   malloc
        0      9   -> __xdata_malloc
      0     32   manual
        0     32   -> TIM_TimeStamp
        0     32   -> TIM_delay
        0     32   -> TIM_init
        0     32   -> TIM_passedTime
        0     32   -> umsg
      1    114   mem_control
        0    114   -> AES_CCMDecrypt
        0    114   -> AES_CCMEncrypt
        0    108   -> AES_init
        0    108   -> TIM_init
        0    110   -> memcpy
        0    108   -> umsg
      0    121   memory_compare
      2      0   nwDebugerInit
        2      0   -> SetCPU32M
        2      0   -> uart_init
      0    190   one_speed_test
        0     32   -> RI_Send
        0     32   -> TIM_TimeStamp
        0     32   -> TIM_passedTime
        0     36   -> printf
        0     40   -> printf
      0      9   random_core_init
        0      9   -> RI_cfg
        0      9   -> rand
        0      9   -> readRandom
        0      9   -> srand
      1    112   raw_data_test
        0    110   -> fbuf_create
        0    110   -> fbuf_delete
        0    112   -> memory_compare
        0    110   -> umsg
      0     56   re_free
        0     10   -> free
      0     60   re_malloc
        0     14   -> malloc
      0     34   re_memcpy
        0     16   -> memcpy
      0     18   readRandom
        0      9   -> bits_count
        0      9   -> getRNDByte
      0     14   send_ack
      1     16   setFreq
        0     11   -> STACK_FAILURE
        0     11   -> printf
        0     15   -> printf
      0     10   set_capture_time
        0      9   -> NT_SetCompare
      0    214   single_enc_dec_test
        0     20   -> AES_CCMDecrypt
        0     20   -> AES_CCMEncrypt
      0    154   speed_test
        0    150   -> AES_init
        0    150   -> RI_SetChannel
        0    150   -> RI_StreamCrypt
        0    150   -> RI_init
        0    150   -> RI_setIV
        0    150   -> RI_setKEY
        0    150   -> TIC_Init
        0    150   -> TIM_init
        0    150   -> fbuf_create
        0    150   -> frame_create
        0    150   -> frame_delete
        0    150   -> frame_insert_head
        0    150   -> one_speed_test
        0    150   -> printf
        0    154   -> printf
      0     14   strip_header
      0      0   stub_se
      2      0   suite_Frames
        2      0   -> umsg_line
      2      0   suite_LLC_HW
        2      0   -> test_create
      2      0   suite_MAC
        2      0   -> test_ACK_SEND
        2      0   -> test_TS_Send
      2      0   suite_NT_HW
        2      0   -> alg_test
      2      0   suite_RADIO
        2      0   -> speed_test
        2      0   -> umsg_line
      2      0   suite_RADIO_HW
        2      0   -> RadioRecvTest1
      2      0   suite_TIC_HW
        2      0   -> test_hw
      2      0   suite_coder
        2      0   -> CCM_code_decode_test
        2      0   -> CCM_test
        2      0   -> aes_test
        2      0   -> mem_control
        2      0   -> umsg_line
      2      0   suite_delays
        2      0   -> alg_test
        2      0   -> umsg_line
      2      0   suite_delays_HW
        2      0   -> manual
      2      0   suite_fbuf
        2      0   -> delete_test
        2      0   -> raw_data_test
        2      0   -> test_create
        2      0   -> test_logic
        2      0   -> umsg_line
      2      0   suite_frame
        2      0   -> delete_test
        2      0   -> insert1_test
        2      0   -> insert2_test
        2      0   -> insert3_test
        2      0   -> insert4_test
        2      0   -> test_frame_merge
        2      0   -> tot_len_test
        2      0   -> umsg_line
      2      0   suite_malloc
        2      0   -> test_1
      2      0   suite_printf_uart
        2      0   -> test_1
        2      0   -> umsg_line
      0     14   test_1
        0     14   -> getMallocSize
        0     14   -> malloc
      0     97   test_1
        0     91   -> TIM_TimeStamp
        0     91   -> TIM_init
        0     91   -> TIM_passedTime
        0     91   -> printf
        0     95   -> printf
        0     97   -> printf
      0     48   test_ACK_SEND
        0     42   -> MAC_ACK_Send
        0     42   -> MAC_Init
        0     42   -> TIM_TimeStamp
        0     42   -> TIM_passedTime
        0     42   -> fbuf_create
        0     42   -> frame_create
        0     42   -> frame_insert_head
        0     46   -> printf
        0     48   -> printf
      1     30   test_TS_Send
        0     26   -> MAC_GetTXState
        0     26   -> MAC_Init
        0     26   -> MAC_Send
        0     26   -> TIC_GetRTC
        0     26   -> TIC_SetSECallback
        0     26   -> fbuf_create
        0     26   -> frame_create
        0     26   -> frame_insert_head
        0     30   -> printf
      0     10   test_create
        0     10   -> fbuf_create
        0     10   -> fbuf_delete
        0     10   -> umsg
      1     40   test_create
        0     34   -> LLC_AddTask
        0     34   -> LLC_GetTaskLen
        0     34   -> LLC_Init
        0     34   -> LLC_TimeAlloc
        0     34   -> fbuf_getCount
        0     34   -> frame_delete
        0     34   -> frame_getCount
        0     34   -> frame_len
        0     34   -> getFrame
        0     34   -> heap_ptr
        0     36   -> printf
        0     38   -> printf
        0     40   -> printf
      0     27   test_frame_merge
        0     25   -> fbuf_create
        0     25   -> frame_create
        0     25   -> frame_insert_tail
        0     25   -> frame_merge
        0     27   -> memory_compare
        0     25   -> umsg
      2     12   test_hw
        2     12   -> NT_Init
        2     12   -> TIC_GetNonce
        2     12   -> TIC_GetRTC
        2     12   -> TIC_GetUptime
        2     12   -> TIC_Init
        2     12   -> TIC_SetNonce
        2     12   -> TIC_SetRTC
        2     12   -> TIC_SetRXCallback
        2     12   -> TIC_SetRXState
        2     12   -> TIC_SetSECallback
        2     12   -> TIC_SetTXCallback
        2     12   -> TIC_SetTXState
      0     16   test_logic
        0     16   -> fbuf_chain
        0     16   -> fbuf_create
        0     16   -> fbuf_delete
        0     16   -> fbuf_next
        0     16   -> umsg
      2      0   timealloc
        2      0   -> LED
      0     28   tot_len_test
        0     28   -> fbuf_create
        0     28   -> frame_create
        0     28   -> frame_delete
        0     28   -> frame_insert_tail
        0     28   -> frame_len
        0     28   -> umsg
      0      0   uart_init
      0    208   umsg
        0     20   -> printf
      0     12   umsg_line
        0     10   -> printf
        0     12   -> printf
      2      2   umsg_summary
        2      0   -> printf
        2      2   -> printf
        2      0   -> umsg_line
      0      0   utestSigTraceInit
      0     14   validate


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
       5  ?<Constant "%s\r\n">
      41  ?<Constant "*********************...">
      19  ?<Constant "*ASSERT* %s:%d -> ">
      17  ?<Constant "*ASSERT* %s:%d->">
      17  ?<Constant "*ASSERT* %s:%d->">_1
      17  ?<Constant "*ASSERT* %s:%d->">_2
      17  ?<Constant "*ASSERT* %s:%d->">_3
      17  ?<Constant "*ASSERT* %s:%d->">_4
      17  ?<Constant "*ASSERT* %s:%d->">_5
      17  ?<Constant "*ASSERT* %s:%d->">_6
      17  ?<Constant "*ASSERT* %s:%d->">_7
      19  ?<Constant "*LOGGER* %s:%d -> ">
      19  ?<Constant "*LOGGER* %s:%d -> ">_1
      19  ?<Constant "*LOGGER* %s:%d -> ">_2
      19  ?<Constant "*LOGGER* %s:%d -> ">_3
      19  ?<Constant "*LOGGER* %s:%d -> ">_4
      19  ?<Constant "*LOGGER* %s:%d -> ">_5
      19  ?<Constant "*LOGGER* %s:%d -> ">_6
       9  ?<Constant "*fr null">
      27  ?<Constant ".Program execution ha...">
      27  ?<Constant ".Program execution ha...">_1
      27  ?<Constant ".Program execution ha...">_2
      27  ?<Constant ".Program execution ha...">_3
      27  ?<Constant ".Program execution ha...">_4
      27  ?<Constant ".Program execution ha...">_5
      27  ?<Constant ".Program execution ha...">_6
      27  ?<Constant ".Program execution ha...">_7
      10  ?<Constant "0123456789">
      13  ?<Constant "Assert fails">
      13  ?<Constant "Assert fails">_1
      13  ?<Constant "Assert fails">_2
      13  ?<Constant "Assert fails">_3
      13  ?<Constant "Assert fails">_4
      13  ?<Constant "Assert fails">_5
      13  ?<Constant "Assert fails">_6
      13  ?<Constant "Assert fails">_7
      30  ?<Constant "CCM coder corrupt dat...">
      29  ?<Constant "CCM coder corrupt key...">
      29  ?<Constant "CCM coder corrupt mic...">
      31  ?<Constant "CCM coder corrupt non...">
      25  ?<Constant "CCM decoded data correct">
      32  ?<Constant "CCM decoder corrupt d...">
      31  ?<Constant "CCM decoder corrupt k...">
      31  ?<Constant "CCM decoder corrupt m...">
      33  ?<Constant "CCM decoder corrupt n...">
      20  ?<Constant "CCM full coder test">
      27  ?<Constant "CCM full size test 60...">
      21  ?<Constant "CCM key data correct">
      23  ?<Constant "CCM nonce data correct">
      17  ?<Constant "Callback is NULL">
      36  ?<Constant "Coder test stub on m=...">
      54  ?<Constant "Data size = %d. Full ...">
      13  ?<Constant "FAILD : %d\r\n">
      13  ?<Constant "FAILED <----">
      24  ?<Constant "FB_RAW_LAY len is equal">
      24  ?<Constant "FB_RAW_LAY mem is equal">
      27  ?<Constant "FB_RAW_LAY mem is not...">
      11  ?<Constant "Fn is NULL">
      37  ?<Constant "Frame puted to MAC la...">
      46  ?<Constant "Frame_s size = %d. Fb...">
      14  ?<Constant "Frames module">
      16  ?<Constant "HEAP_PTR = %d\r\n">
      46  ?<Constant "Hello worldHello worl...">
      13  ?<Constant "Hello world\n">
      13  ?<Constant "Incorrect TS">
      19  ?<Constant "Incorrect eth size">
      20  ?<Constant "Incorrect fbuf type">
      24  ?<Constant "Incorrect radio channel">
      16  ?<Constant "Incorrect ticks">
      24  ?<Constant "Insert head. head = fb1">
      24  ?<Constant "Insert head. tail = fb1">
      24  ?<Constant "Insert tail. head = fb1">
      24  ?<Constant "Insert tail. tail = fb1">
      27  ?<Constant "LLC re_malloc for new...">
       6  ?<Constant "LLC.c">
       6  ?<Constant "MAC.c">
      38  ?<Constant "MAC_ACK_Send time = %...">
      24  ?<Constant "Memory allocation fails">
      12  ?<Constant "Memory corr">
      42  ?<Constant "Module: %-15s Name: %...">
       7  ?<Constant "NTMR.c">
      23  ?<Constant "NULL pointer not allow">
      23  ?<Constant "NULL pointer not allow">_1
       6  ?<Constant "No fb">
       6  ?<Constant "No fr">
      10  ?<Constant "No memory">
      10  ?<Constant "No memory">_1
      10  ?<Constant "No memory">_2
       7  ?<Constant "PASSED">
      13  ?<Constant "PASSED: %d\r\n">
      13  ?<Constant "RADIO module">
       8  ?<Constant "RADIO.c">
      21  ?<Constant "RXCallback func NULL">
      19  ?<Constant "RXCallback is NULL">
      40  ?<Constant "SEND IN SEND_TIME 100...">
      34  ?<Constant "SEND SPEED TEST WITH ...">
      37  ?<Constant "SEND SPEED TEST WITHO...">
      40  ?<Constant "String 1 len = %d. Pr...">
      41  ?<Constant "String 2 len = %d. Pr...">
      22  ?<Constant "Striped_frame is NULL">
       6  ?<Constant "TIC.c">
      30  ?<Constant "TIM_passedTimeNs meas...">
      12  ?<Constant "TS = 255 \r\n">
      16  ?<Constant "TS not in range">
      21  ?<Constant "Test assert output\r\n">
      18  ?<Constant "Test log output\r\n">
      15  ?<Constant "Tests FAILED\r\n">
      15  ?<Constant "Tests PASSED\r\n">
      19  ?<Constant "Ticks not in range">
      18  ?<Constant "Unit test symmary">
       3  ?<Constant "\r\n">
      13  ?<Constant "attempts = 0">
      17  ?<Constant "chain fb1 -> fb2">
      17  ?<Constant "chain fb2 -> fb3">
      20  ?<Constant "chain fb3 next NULL">
      13  ?<Constant "coder module">
       6  ?<Constant "coder">
      14  ?<Constant "delays module">
       7  ?<Constant "delays">
      17  ?<Constant "delete test. fb1">
      17  ?<Constant "delete test. fb2">
      17  ?<Constant "delete test. fb3">
      17  ?<Constant "delete test. fb4">
      11  ?<Constant "ethernet.c">
      24  ?<Constant "fbuf FB_ETH_LAY created">
      23  ?<Constant "fbuf FB_ETH_LAY lenght">
      23  ?<Constant "fbuf FB_IP_LAY created">
      22  ?<Constant "fbuf FB_IP_LAY lenght">
      25  ?<Constant "fbuf FB_SYNC_LAY created">
      24  ?<Constant "fbuf FB_SYNC_LAY lenght">
      12  ?<Constant "fbuf module">
      12  ?<Constant "fbuf module">_1
       5  ?<Constant "fbuf">
       7  ?<Constant "fbuf.c">
      12  ?<Constant "fbuf_delete">
       8  ?<Constant "fr NULL">
       8  ?<Constant "fr NULL">_1
      11  ?<Constant "fr is NULL">
       6  ?<Constant "frame">
       8  ?<Constant "frame.c">
      15  ?<Constant "frame_len calc">
      19  ?<Constant "isACK_OK func NULL">
      16  ?<Constant "iterator = NULL">
      16  ?<Constant "iterator = NULL">_1
      15  ?<Constant "iterator = fb1">
      15  ?<Constant "iterator = fb1">_1
      15  ?<Constant "iterator = fb2">
      15  ?<Constant "iterator = fb2">_1
      15  ?<Constant "iterator = fb3">
      15  ?<Constant "iterator = fb3">_1
      14  ?<Constant "passed %lu \r\n">
      18  ?<Constant "printf speed uart">
       8  ?<Constant "utest.c">
      12  ?<Constant "utest_LLC.c">
      12  ?<Constant "utest_MAC.c">
      14  ?<Constant "utest_coder.c">
      20  ?<Constant "utest_printf_uart.c">
      14  ?<Constant "utest_radio.c">
      10  ?<Constant {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}>
      10  ?<Constant {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}>_1
      10  ?<Constant {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}>_2
      10  ?<Constant {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}>_3
      10  ?<Constant {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}>_4
      16  ?<Constant {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11,
      16  ?<Constant {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11,_1
      16  ?<Constant {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11,_2
      16  ?<Constant {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11,_3
      16  ?<Constant {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11,_4
      16  ?<Constant {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11,_5
       4  ?<Constant {10, 50, 100, 125}>
      16  ?<Constant {18, 11, 12, 13, 14, 15, 16, 17, 10
      16  ?<Constant {18, 11, 12, 13, 14, 15, 16, 17, 10_1
      16  ?<Constant {18, 11, 12, 13, 14, 15, 16, 17, 10_2
      16  ?<Constant {18, 11, 12, 13, 14, 15, 16, 17, 10_3
      16  ?<Constant {18, 11, 12, 13, 14, 15, 16, 17, 10_4
      16  ?<Constant {18, 11, 12, 13, 14, 15, 16, 17, 10_5
       5  ?<Initializer for <Constant "%s\r\n">>
      41  ?<Initializer for <Constant "*****************
      19  ?<Initializer for <Constant "*ASSERT* %s:%d ->
      17  ?<Initializer for <Constant "*ASSERT* %s:%d->"
      17  ?<Initializer for <Constant "*ASSERT* %s:%d->"_1
      17  ?<Initializer for <Constant "*ASSERT* %s:%d->"_2
      17  ?<Initializer for <Constant "*ASSERT* %s:%d->"_3
      17  ?<Initializer for <Constant "*ASSERT* %s:%d->"_4
      17  ?<Initializer for <Constant "*ASSERT* %s:%d->"_5
      17  ?<Initializer for <Constant "*ASSERT* %s:%d->"_6
      17  ?<Initializer for <Constant "*ASSERT* %s:%d->"_7
      19  ?<Initializer for <Constant "*LOGGER* %s:%d ->
      19  ?<Initializer for <Constant "*LOGGER* %s:%d ->_1
      19  ?<Initializer for <Constant "*LOGGER* %s:%d ->_2
      19  ?<Initializer for <Constant "*LOGGER* %s:%d ->_3
      19  ?<Initializer for <Constant "*LOGGER* %s:%d ->_4
      19  ?<Initializer for <Constant "*LOGGER* %s:%d ->_5
      19  ?<Initializer for <Constant "*LOGGER* %s:%d ->_6
       9  ?<Initializer for <Constant "*fr null">>
      27  ?<Initializer for <Constant ".Program executio
      27  ?<Initializer for <Constant ".Program executio_1
      27  ?<Initializer for <Constant ".Program executio_2
      27  ?<Initializer for <Constant ".Program executio_3
      27  ?<Initializer for <Constant ".Program executio_4
      27  ?<Initializer for <Constant ".Program executio_5
      27  ?<Initializer for <Constant ".Program executio_6
      27  ?<Initializer for <Constant ".Program executio_7
      10  ?<Initializer for <Constant "0123456789">>
      13  ?<Initializer for <Constant "Assert fails">>
      13  ?<Initializer for <Constant "Assert fails">>_1
      13  ?<Initializer for <Constant "Assert fails">>_2
      13  ?<Initializer for <Constant "Assert fails">>_3
      13  ?<Initializer for <Constant "Assert fails">>_4
      13  ?<Initializer for <Constant "Assert fails">>_5
      13  ?<Initializer for <Constant "Assert fails">>_6
      13  ?<Initializer for <Constant "Assert fails">>_7
      30  ?<Initializer for <Constant "CCM coder corrupt
      29  ?<Initializer for <Constant "CCM coder corrupt_1
      31  ?<Initializer for <Constant "CCM coder corrupt_2
      29  ?<Initializer for <Constant "CCM coder corrupt_3
      25  ?<Initializer for <Constant "CCM decoded data
      32  ?<Initializer for <Constant "CCM decoder corru
      31  ?<Initializer for <Constant "CCM decoder corru_1
      33  ?<Initializer for <Constant "CCM decoder corru_2
      31  ?<Initializer for <Constant "CCM decoder corru_3
      20  ?<Initializer for <Constant "CCM full coder te
      27  ?<Initializer for <Constant "CCM full size tes
      21  ?<Initializer for <Constant "CCM key data corr
      23  ?<Initializer for <Constant "CCM nonce data co
      17  ?<Initializer for <Constant "Callback is NULL"
      36  ?<Initializer for <Constant "Coder test stub o
      54  ?<Initializer for <Constant "Data size = %d. F
      13  ?<Initializer for <Constant "FAILD : %d\r\n">>
      13  ?<Initializer for <Constant "FAILED <----">>
      24  ?<Initializer for <Constant "FB_RAW_LAY len is
      24  ?<Initializer for <Constant "FB_RAW_LAY mem is
      27  ?<Initializer for <Constant "FB_RAW_LAY mem is_1
      11  ?<Initializer for <Constant "Fn is NULL">>
      37  ?<Initializer for <Constant "Frame puted to MA
      46  ?<Initializer for <Constant "Frame_s size = %d
      14  ?<Initializer for <Constant "Frames module">>
      16  ?<Initializer for <Constant "HEAP_PTR = %d\r\n
      46  ?<Initializer for <Constant "Hello worldHello
      13  ?<Initializer for <Constant "Hello world\n">>
      13  ?<Initializer for <Constant "Incorrect TS">>
      19  ?<Initializer for <Constant "Incorrect eth siz
      20  ?<Initializer for <Constant "Incorrect fbuf ty
      24  ?<Initializer for <Constant "Incorrect radio c
      16  ?<Initializer for <Constant "Incorrect ticks">
      24  ?<Initializer for <Constant "Insert head. head
      24  ?<Initializer for <Constant "Insert head. tail
      24  ?<Initializer for <Constant "Insert tail. head
      24  ?<Initializer for <Constant "Insert tail. tail
      27  ?<Initializer for <Constant "LLC re_malloc for
       6  ?<Initializer for <Constant "LLC.c">>
       6  ?<Initializer for <Constant "MAC.c">>
      38  ?<Initializer for <Constant "MAC_ACK_Send time
      24  ?<Initializer for <Constant "Memory allocation
      12  ?<Initializer for <Constant "Memory corr">>
      42  ?<Initializer for <Constant "Module: %-15s Nam
       7  ?<Initializer for <Constant "NTMR.c">>
      23  ?<Initializer for <Constant "NULL pointer not
      23  ?<Initializer for <Constant "NULL pointer not _1
       6  ?<Initializer for <Constant "No fb">>
       6  ?<Initializer for <Constant "No fr">>
      10  ?<Initializer for <Constant "No memory">>
      10  ?<Initializer for <Constant "No memory">>_1
      10  ?<Initializer for <Constant "No memory">>_2
       7  ?<Initializer for <Constant "PASSED">>
      13  ?<Initializer for <Constant "PASSED: %d\r\n">>
      13  ?<Initializer for <Constant "RADIO module">>
       8  ?<Initializer for <Constant "RADIO.c">>
      21  ?<Initializer for <Constant "RXCallback func N
      19  ?<Initializer for <Constant "RXCallback is NUL
      40  ?<Initializer for <Constant "SEND IN SEND_TIME
      34  ?<Initializer for <Constant "SEND SPEED TEST W
      37  ?<Initializer for <Constant "SEND SPEED TEST W_1
      40  ?<Initializer for <Constant "String 1 len = %d
      41  ?<Initializer for <Constant "String 2 len = %d
      22  ?<Initializer for <Constant "Striped_frame is
       6  ?<Initializer for <Constant "TIC.c">>
      30  ?<Initializer for <Constant "TIM_passedTimeNs
      12  ?<Initializer for <Constant "TS = 255 \r\n">>
      16  ?<Initializer for <Constant "TS not in range">
      21  ?<Initializer for <Constant "Test assert outpu
      18  ?<Initializer for <Constant "Test log output\r
      15  ?<Initializer for <Constant "Tests FAILED\r\n"
      15  ?<Initializer for <Constant "Tests PASSED\r\n"
      19  ?<Initializer for <Constant "Ticks not in rang
      18  ?<Initializer for <Constant "Unit test symmary
       3  ?<Initializer for <Constant "\r\n">>
      13  ?<Initializer for <Constant "attempts = 0">>
      17  ?<Initializer for <Constant "chain fb1 -> fb2"
      17  ?<Initializer for <Constant "chain fb2 -> fb3"
      20  ?<Initializer for <Constant "chain fb3 next NU
      13  ?<Initializer for <Constant "coder module">>
       6  ?<Initializer for <Constant "coder">>
      14  ?<Initializer for <Constant "delays module">>
       7  ?<Initializer for <Constant "delays">>
      17  ?<Initializer for <Constant "delete test. fb1"
      17  ?<Initializer for <Constant "delete test. fb2"
      17  ?<Initializer for <Constant "delete test. fb3"
      17  ?<Initializer for <Constant "delete test. fb4"
      11  ?<Initializer for <Constant "ethernet.c">>
      24  ?<Initializer for <Constant "fbuf FB_ETH_LAY c
      23  ?<Initializer for <Constant "fbuf FB_ETH_LAY l
      23  ?<Initializer for <Constant "fbuf FB_IP_LAY cr
      22  ?<Initializer for <Constant "fbuf FB_IP_LAY le
      25  ?<Initializer for <Constant "fbuf FB_SYNC_LAY
      24  ?<Initializer for <Constant "fbuf FB_SYNC_LAY _1
      12  ?<Initializer for <Constant "fbuf module">>
      12  ?<Initializer for <Constant "fbuf module">>_1
       5  ?<Initializer for <Constant "fbuf">>
       7  ?<Initializer for <Constant "fbuf.c">>
      12  ?<Initializer for <Constant "fbuf_delete">>
       8  ?<Initializer for <Constant "fr NULL">>
       8  ?<Initializer for <Constant "fr NULL">>_1
      11  ?<Initializer for <Constant "fr is NULL">>
       6  ?<Initializer for <Constant "frame">>
       8  ?<Initializer for <Constant "frame.c">>
      15  ?<Initializer for <Constant "frame_len calc">>
      19  ?<Initializer for <Constant "isACK_OK func NUL
      16  ?<Initializer for <Constant "iterator = NULL">
      16  ?<Initializer for <Constant "iterator = NULL">_1
      15  ?<Initializer for <Constant "iterator = fb1">>
      15  ?<Initializer for <Constant "iterator = fb1">>_1
      15  ?<Initializer for <Constant "iterator = fb2">>
      15  ?<Initializer for <Constant "iterator = fb2">>_1
      15  ?<Initializer for <Constant "iterator = fb3">>
      15  ?<Initializer for <Constant "iterator = fb3">>_1
      14  ?<Initializer for <Constant "passed %lu \r\n">
      18  ?<Initializer for <Constant "printf speed uart
       8  ?<Initializer for <Constant "utest.c">>
      12  ?<Initializer for <Constant "utest_LLC.c">>
      12  ?<Initializer for <Constant "utest_MAC.c">>
      14  ?<Initializer for <Constant "utest_coder.c">>
      20  ?<Initializer for <Constant "utest_printf_uart
      14  ?<Initializer for <Constant "utest_radio.c">>
      10  ?<Initializer for <Constant {0, 1, 2, 3, 4, 5,
      10  ?<Initializer for <Constant {0, 1, 2, 3, 4, 5,_1
      10  ?<Initializer for <Constant {0, 1, 2, 3, 4, 5,_2
      10  ?<Initializer for <Constant {0, 1, 2, 3, 4, 5,_3
      10  ?<Initializer for <Constant {0, 1, 2, 3, 4, 5,_4
      16  ?<Initializer for <Constant {1, 2, 3, 4, 5, 6,
      16  ?<Initializer for <Constant {1, 2, 3, 4, 5, 6,_1
      16  ?<Initializer for <Constant {1, 2, 3, 4, 5, 6,_2
      16  ?<Initializer for <Constant {1, 2, 3, 4, 5, 6,_3
      16  ?<Initializer for <Constant {1, 2, 3, 4, 5, 6,_4
      16  ?<Initializer for <Constant {1, 2, 3, 4, 5, 6,_5
       4  ?<Initializer for <Constant {10, 50, 100, 125}
      16  ?<Initializer for <Constant {18, 11, 12, 13, 1
      16  ?<Initializer for <Constant {18, 11, 12, 13, 1_1
      16  ?<Initializer for <Constant {18, 11, 12, 13, 1_2
      16  ?<Initializer for <Constant {18, 11, 12, 13, 1_3
      16  ?<Initializer for <Constant {18, 11, 12, 13, 1_4
      16  ?<Initializer for <Constant {18, 11, 12, 13, 1_5
      16  ?<Initializer for IV>
      16  ?<Initializer for KEY>
       4  ?<Initializer for MAC_TIMER_MAX>
       4  ?<Initializer for __Constant_1388>
       4  ?<Initializer for __Constant_15180>
       4  ?<Initializer for __Constant_1>
       4  ?<Initializer for __Constant_1f4>
       4  ?<Initializer for __Constant_20>
       4  ?<Initializer for __Constant_2710>
       4  ?<Initializer for __Constant_3938700>
       4  ?<Initializer for __Constant_3d000000>
       4  ?<Initializer for __Constant_3e8>
       4  ?<Initializer for __Constant_447a0000>
       4  ?<Initializer for __Constant_7d0>
       4  ?<Initializer for __Constant_7fff>
       4  ?<Initializer for __Constant_8000>
       4  ?<Initializer for __Constant_a>
       4  ?<Initializer for __Constant_ffff8000>
       4  ?<Initializer for __Constant_fffffe0c>
       4  ?<Initializer for __Constant_ffffff>
     476  AES_CCMDecrypt
       6  AES_CCMDecrypt::?relay
     446  AES_CCMEncrypt
       6  AES_CCMEncrypt::?relay
     600  AES_StreamCoder
       6  AES_StreamCoder::?relay
     239  AES_init
       6  AES_init::?relay
     461  CBCMAC_buf_encrypt
       6  CBCMAC_buf_encrypt::?relay
     397  CCM_code_decode_test
       6  CCM_code_decode_test::?relay
     238  CCM_test
       6  CCM_test::?relay
       1  CLKCONCMD
       1  CLKCONSTA
       4  COMPARE_TIME
     600  CTR_enc_decrypt
       6  CTR_enc_decrypt::?relay
      88  Callback_execution
       6  Callback_execution::?relay
       4  DELAY_CALIBRATE_TICS
       1  DMA0CFGH
       1  DMA0CFGL
       1  DMA1CFGH
       1  DMA1CFGL
       1  DMAARM
       1  DMAREQ
       8  DMA_AES_DW
       8  DMA_AES_UP
     147  DelayCalibrate
       6  DelayCalibrate::?relay
       1  ENCCS
      28  ETH_Init
       6  ETH_Init::?relay
     322  ETH_RX_HNDL
       6  ETH_RX_HNDL::?relay
      81  ETH_Set_RXCallback
       6  ETH_Set_RXCallback::?relay
       2  EventCallback
       2  FirstTask
       4  HeadAllocFunc
      16  IV
      16  IV
     163  Interval
       6  Interval::?relay
      16  KEY
      16  KEY
      37  LED
       6  LED::?relay
     314  LLC_AddTask
       6  LLC_AddTask::?relay
      16  LLC_GetTaskLen
       6  LLC_GetTaskLen::?relay
      50  LLC_Init
       6  LLC_Init::?relay
      99  LLC_RX_HNDL
       6  LLC_RX_HNDL::?relay
      67  LLC_RunTimeAlloc
       6  LLC_RunTimeAlloc::?relay
      20  LLC_SE_HNDL
       6  LLC_SE_HNDL::?relay
      81  LLC_SetRXCallback
       6  LLC_SetRXCallback::?relay
     201  LLC_Shelduler
       6  LLC_Shelduler::?relay
     149  LLC_TimeAlloc
       6  LLC_TimeAlloc::?relay
      50  LoadTXData
       6  LoadTXData::?relay
     350  MACSlotTable
       7  MAC_ACK_Recv
       6  MAC_ACK_Recv::?relay
      50  MAC_ACK_Send
       6  MAC_ACK_Send::?relay
     122  MAC_CloseRXSlot
       6  MAC_CloseRXSlot::?relay
     111  MAC_GetRXState
       6  MAC_GetRXState::?relay
     111  MAC_GetTXState
       6  MAC_GetTXState::?relay
      82  MAC_Init
       6  MAC_Init::?relay
     165  MAC_OpenRXSlot
       6  MAC_OpenRXSlot::?relay
     152  MAC_RX_HNDL
       6  MAC_RX_HNDL::?relay
     338  MAC_Send
       6  MAC_Send::?relay
      19  MAC_SetRXCallback
       6  MAC_SetRXCallback::?relay
      19  MAC_Set_isACK_OK_Callback
       6  MAC_Set_isACK_OK_Callback::?relay
       4  MAC_TIMER_MAX
     808  MAC_TX_HNDL
       6  MAC_TX_HNDL::?relay
      12  MyLowLevelPutchar
       6  MyLowLevelPutchar::?relay
       1  NBR_BUF
       1  NBR_FRAME
       4  NODE_NONCE
       4  NODE_RTC
       4  NODE_UPTIME
      55  NT_GetTime
       6  NT_GetTime::?relay
      19  NT_IRQEnable
       6  NT_IRQEnable::?relay
      54  NT_Init
       6  NT_Init::?relay
     130  NT_SetCompare
       6  NT_SetCompare::?relay
      19  NT_SetEventCallback
       6  NT_SetEventCallback::?relay
     157  NT_SetTime
       6  NT_SetTime::?relay
     126  NT_WaitTime
       6  NT_WaitTime::?relay
       1  P0DIR
       1  P0SEL
       1  P1DIR
       1  PERCFG
       4  RADIO_CFG
       1  RFD
       1  RFIRQF0
       1  RFIRQF1
       1  RFST
      64  RI_BitRawCrypt
       6  RI_BitRawCrypt::?relay
      64  RI_BitRawDecrypt
       6  RI_BitRawDecrypt::?relay
       4  RI_CCA_REJECT
       4  RI_CRC_ERROR
      17  RI_GetCCAReject
       6  RI_GetCCAReject::?relay
      17  RI_GetCRCError
       6  RI_GetCRCError::?relay
      17  RI_GetUptime
       6  RI_GetUptime::?relay
     613  RI_Receive
       6  RI_Receive::?relay
     217  RI_Send
       6  RI_Send::?relay
      32  RI_SetChannel
       6  RI_SetChannel::?relay
      23  RI_StreamCrypt
       6  RI_StreamCrypt::?relay
       4  RI_UPTIME
     109  RI_cfg
       6  RI_cfg::?relay
      38  RI_init
       6  RI_init::?relay
      41  RI_setIV
       6  RI_setIV::?relay
      41  RI_setKEY
       6  RI_setKEY::?relay
       7  RXC
       6  RXC::?relay
       2  RXCallback
       2  RXCallback
       2  RXCallback
       2  RXCallback
     176  RadioRecvTest1
       6  RadioRecvTest1::?relay
      59  ReadTimer
       6  ReadTimer::?relay
     152  RecvData
       6  RecvData::?relay
      10  SEC
       6  SEC::?relay
       2  SECallback
       1  SLEEPSTA
       1  ST0
       1  ST1
       1  ST2
       2  STACK_FAILURE
       6  STACK_FAILURE::?relay
       1  STLOAD
     204  SendData
       6  SendData::?relay
      12  SetCPU32M
       6  SetCPU32M::?relay
       1  T2CTRL
       1  T2M0
       1  T2M1
       1  T2MOVF0
       1  T2MOVF1
      17  TIC_GetNonce
       6  TIC_GetNonce::?relay
      17  TIC_GetRTC
       6  TIC_GetRTC::?relay
      99  TIC_GetRXState
       6  TIC_GetRXState::?relay
      99  TIC_GetTXState
       6  TIC_GetTXState::?relay
       7  TIC_GetTimeStampTS0
       6  TIC_GetTimeStampTS0::?relay
      14  TIC_GetTimer
       6  TIC_GetTimer::?relay
      17  TIC_GetUptime
       6  TIC_GetUptime::?relay
     178  TIC_HW_Timer_IRQ
       6  TIC_HW_Timer_IRQ::?relay
      39  TIC_Init
       6  TIC_Init::?relay
      26  TIC_SetNonce
       6  TIC_SetNonce::?relay
      40  TIC_SetRTC
       6  TIC_SetRTC::?relay
      81  TIC_SetRXCallback
       6  TIC_SetRXCallback::?relay
     129  TIC_SetRXState
       6  TIC_SetRXState::?relay
      81  TIC_SetSECallback
       6  TIC_SetSECallback::?relay
      81  TIC_SetTXCallback
       6  TIC_SetTXCallback::?relay
     129  TIC_SetTXState
       6  TIC_SetTXState::?relay
      94  TIC_SetTimer
       6  TIC_SetTimer::?relay
      92  TIC_TDMAShelduler
       6  TIC_TDMAShelduler::?relay
      66  TIC_TimeUsFromTS0
       6  TIC_TimeUsFromTS0::?relay
      61  TIC_getCurrentTS
       6  TIC_getCurrentTS::?relay
      61  TIM_TimeStamp
       6  TIM_TimeStamp::?relay
      45  TIM_copy
       6  TIM_copy::?relay
     133  TIM_delay
       6  TIM_delay::?relay
      17  TIM_init
       6  TIM_init::?relay
      94  TIM_passedTime
       6  TIM_passedTime::?relay
       2  TOFFSET
      50  TSStateTable
       7  TXC
       6  TXC::?relay
       2  TXCallback
       8  TimeStampTS0
      60  TimerCompareInterrupt
       3  TimerCompareInterrupt::??INTVEC 43
     265  TimerHndl
       6  TimerHndl::?relay
       1  U0BAUD
       1  U0CSR
       1  U0DBUF
       1  U0GCR
      40  UnLoadRXData
       6  UnLoadRXData::?relay
       1  _A_IEN0
       1  _A_IRCON
       1  _A_P0
       1  _A_P1
       4  __Constant_1
       4  __Constant_1388
       4  __Constant_15180
       4  __Constant_1f4
       4  __Constant_20
       4  __Constant_2710
       4  __Constant_3938700
       4  __Constant_3d000000
       4  __Constant_3e8
       4  __Constant_447a0000
       4  __Constant_7d0
       4  __Constant_7fff
       4  __Constant_8000
       4  __Constant_a
       4  __Constant_ffff8000
       4  __Constant_fffffe0c
       4  __Constant_ffffff
     156  __write
       6  __write::?relay
     332  aes_test
       6  aes_test::?relay
      66  alg_test
      97  alg_test
       6  alg_test::?relay
       6  alg_test::?relay
      34  bits_count
       6  bits_count::?relay
     162  buf
     189  calcCompareTime
       6  calcCompareTime::?relay
      94  clocks_update
       6  clocks_update::?relay
      84  delete_test
     506  delete_test
       6  delete_test::?relay
       6  delete_test::?relay
     217  extract_header
       6  extract_header::?relay
      20  fbuf_chain
       6  fbuf_chain::?relay
     346  fbuf_create
       6  fbuf_create::?relay
      28  fbuf_delete
       6  fbuf_delete::?relay
      16  fbuf_getCount
       6  fbuf_getCount::?relay
      43  fbuf_next
       6  fbuf_next::?relay
       1  finised
     149  frame_create
       6  frame_create::?relay
      73  frame_delete
       6  frame_delete::?relay
      16  frame_getCount
       6  frame_getCount::?relay
      20  frame_get_fbuf_head
       6  frame_get_fbuf_head::?relay
      22  frame_get_fbuf_tail
       6  frame_get_fbuf_tail::?relay
      72  frame_insert_head
       6  frame_insert_head::?relay
     213  frame_insert_tail
       6  frame_insert_tail::?relay
      49  frame_len
       6  frame_len::?relay
     348  frame_merge
       6  frame_merge::?relay
      21  free
       6  free::?relay
     241  generateAuthData
       6  generateAuthData::?relay
     150  getFrame
       6  getFrame::?relay
      34  getMallocSize
       6  getMallocSize::?relay
      53  getRNDByte
       6  getRNDByte::?relay
      40  heap_ptr
       6  heap_ptr::?relay
       7  heap_size
       6  heap_size::?relay
      36  incrementTS
       6  incrementTS::?relay
     134  insert1_test
       6  insert1_test::?relay
     134  insert2_test
       6  insert2_test::?relay
     375  insert3_test
       6  insert3_test::?relay
     375  insert4_test
       6  insert4_test::?relay
       2  isACK_OK
      11  isIRQEnable
       6  isIRQEnable::?relay
      56  isNear
       6  isNear::?relay
       1  led_stat
      70  loadTimerCompare
       6  loadTimerCompare::?relay
     108  main
       6  main::?relay
      21  malloc
       6  malloc::?relay
     189  manual
       6  manual::?relay
    1008  mem_control
       6  mem_control::?relay
      70  memory_compare
       6  memory_compare::?relay
       1  nbrTasks
      17  nwDebugerInit
       6  nwDebugerInit::?relay
     177  one_speed_test
       6  one_speed_test::?relay
      78  random_core_init
       6  random_core_init::?relay
     242  raw_data_test
       6  raw_data_test::?relay
      35  re_free
       6  re_free::?relay
      49  re_malloc
       6  re_malloc::?relay
      65  re_memcpy
       6  re_memcpy::?relay
      54  readRandom
       6  readRandom::?relay
       4  ret_val
       3  send_ack
       6  send_ack::?relay
     121  setFreq
       6  setFreq::?relay
      67  set_capture_time
       6  set_capture_time::?relay
     114  single_enc_dec_test
       6  single_enc_dec_test::?relay
     840  speed_test
       6  speed_test::?relay
       3  strip_header
       6  strip_header::?relay
       3  stub_se
       6  stub_se::?relay
      18  suite_Frames
       6  suite_Frames::?relay
      14  suite_LLC_HW
       6  suite_LLC_HW::?relay
      17  suite_MAC
       6  suite_MAC::?relay
      14  suite_NT_HW
       6  suite_NT_HW::?relay
      21  suite_RADIO
       6  suite_RADIO::?relay
      14  suite_RADIO_HW
       6  suite_RADIO_HW::?relay
      14  suite_TIC_HW
       6  suite_TIC_HW::?relay
      30  suite_coder
       6  suite_coder::?relay
      21  suite_delays
       6  suite_delays::?relay
      14  suite_delays_HW
       6  suite_delays_HW::?relay
      30  suite_fbuf
       6  suite_fbuf::?relay
      39  suite_frame
       6  suite_frame::?relay
      14  suite_malloc
       6  suite_malloc::?relay
      21  suite_printf_uart
       6  suite_printf_uart::?relay
       1  tasksBLOCK
      74  test_1
     271  test_1
       6  test_1::?relay
       6  test_1::?relay
     214  test_ACK_SEND
       6  test_ACK_SEND::?relay
     215  test_TS_Send
       6  test_TS_Send::?relay
     244  test_create
     424  test_create
       6  test_create::?relay
       6  test_create::?relay
     143  test_frame_merge
       6  test_frame_merge::?relay
     143  test_hw
       6  test_hw::?relay
     375  test_logic
       6  test_logic::?relay
      37  timealloc
       6  timealloc::?relay
     211  tot_len_test
       6  tot_len_test::?relay
      19  uart_init
       6  uart_init::?relay
     118  umsg
       6  umsg::?relay
      45  umsg_line
       6  umsg_line::?relay
      82  umsg_summary
       6  umsg_summary::?relay
       6  utestSigTraceInit
       6  utestSigTraceInit::?relay
       4  utest_summary
       4  val
       4  validate
       6  validate::?relay

 
 22 967 bytes in segment BANKED_CODE
  1 104 bytes in segment BANK_RELAYS
      3 bytes in segment INTVEC
     60 bytes in segment NEAR_CODE
     35 bytes in segment SFR_AN
  3 366 bytes in segment XDATA_I
  3 366 bytes in segment XDATA_ID
    696 bytes in segment XDATA_Z
 
  4 444 bytes of CODE     memory (+ 89 bytes shared)
      0 bytes of DATA     memory (+ 35 bytes shared)
 22 923 bytes of HUGECODE memory (+ 44 bytes shared)
  3 994 bytes of XDATA    memory (+ 68 bytes shared)

Errors: none
Warnings: 15
