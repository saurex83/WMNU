###############################################################################
#
# IAR C/C++ Compiler V10.10.1.4655 for 8051               15/Jan/2020  20:35:21
# Copyright 2004-2017 IAR Systems AB.
# PC-locked license - IAR Embedded Workbench for 8051
#
#    Core               =  plain
#    Code model         =  banked
#    Data model         =  large
#    Calling convention =  xdata reentrant
#    Constant location  =  data
#    Dptr setup         =  1,16
#                          
#    Source file        =  
#        \\vmware-host\Shared Folders\Projects\WMNU\IAR\SHARE_PRJ_SRC\coder.c
#    Command line       =  
#        -f C:\Users\08A4~1\AppData\Local\Temp\EW120B.tmp
#        ("\\vmware-host\Shared
#        Folders\Projects\WMNU\IAR\SHARE_PRJ_SRC\coder.c" -lc
#        "\\vmware-host\Shared
#        Folders\Projects\WMNU\IAR\PRJ_UNITEST\Debug\List" -o
#        "\\vmware-host\Shared Folders\Projects\WMNU\IAR\PRJ_UNITEST\Debug\Obj"
#        -e --debug --core=plain --dptr=16,1 --data_model=large
#        --code_model=banked --calling_convention=xdata_reentrant
#        --place_constants=data --nr_virtual_regs 8 --dlib_config "C:\Program
#        Files (x86)\IAR Systems\Embedded Workbench
#        8.0\8051\LIB\DLIB\dl8051Normal.h" --no_path_in_file_macros -I
#        "\\vmware-host\Shared Folders\Projects\WMNU\IAR\SHARE_PRJ_SRC\" -Oh
#        --mfc "\\vmware-host\Shared
#        Folders\Projects\WMNU\IAR\SHARE_PRJ_SRC\config.c"
#        "\\vmware-host\Shared
#        Folders\Projects\WMNU\IAR\SHARE_PRJ_SRC\delays.c"
#        "\\vmware-host\Shared
#        Folders\Projects\WMNU\IAR\SHARE_PRJ_SRC\ethernet.c"
#        "\\vmware-host\Shared Folders\Projects\WMNU\IAR\SHARE_PRJ_SRC\frame.c"
#        "\\vmware-host\Shared Folders\Projects\WMNU\IAR\SHARE_PRJ_SRC\LLC.c"
#        "\\vmware-host\Shared Folders\Projects\WMNU\IAR\SHARE_PRJ_SRC\MAC.c"
#        "\\vmware-host\Shared
#        Folders\Projects\WMNU\IAR\SHARE_PRJ_SRC\manager.c"
#        "\\vmware-host\Shared Folders\Projects\WMNU\IAR\SHARE_PRJ_SRC\mem.c"
#        "\\vmware-host\Shared Folders\Projects\WMNU\IAR\SHARE_PRJ_SRC\NTMR.c"
#        "\\vmware-host\Shared
#        Folders\Projects\WMNU\IAR\SHARE_PRJ_SRC\nwdebuger.c"
#        "\\vmware-host\Shared Folders\Projects\WMNU\IAR\SHARE_PRJ_SRC\RADIO.c"
#        "\\vmware-host\Shared Folders\Projects\WMNU\IAR\SHARE_PRJ_SRC\sync.c"
#        "\\vmware-host\Shared Folders\Projects\WMNU\IAR\SHARE_PRJ_SRC\TIC.c"
#        "\\vmware-host\Shared
#        Folders\Projects\WMNU\IAR\PRJ_UNITEST\src\utest.c"
#        "\\vmware-host\Shared
#        Folders\Projects\WMNU\IAR\PRJ_UNITEST\src\utest_GW.c"
#        "\\vmware-host\Shared
#        Folders\Projects\WMNU\IAR\PRJ_UNITEST\src\utest_NODE.c"
#        "\\vmware-host\Shared
#        Folders\Projects\WMNU\IAR\PRJ_UNITEST\src\utest_suite.c")
#    Locale             =  Russian_Russia.1251
#    List file          =  
#        \\vmware-host\Shared
#        Folders\Projects\WMNU\IAR\PRJ_UNITEST\Debug\List\coder.lst
#    Object file        =  
#        \\vmware-host\Shared
#        Folders\Projects\WMNU\IAR\PRJ_UNITEST\Debug\Obj\coder.r51
#
###############################################################################

\\vmware-host\Shared Folders\Projects\WMNU\IAR\SHARE_PRJ_SRC\coder.c
      1          /*!
      2          \file Модуль шифрования данных
      3          \brief Функции кодирования данных
      4          */
      5          
      6          #include "coder.h"
      7          #include "ioCC2530.h"
      8          #include "string.h"
      9          #include "delays.h" // Для профилирования, Отладка
     10          
     11          #define AES_START()  {ENCCS |= 0x01;} //!< Запуск выполнения команды  
     12          #define AES_SET_MODE(mode) {ENCCS &= ~0x70; ENCCS |= mode;} //!< Установка режима
     13          #define AES_SET_OPERATION(op) {ENCCS = (ENCCS & ~0x07) | op;} 
     14          #define AES_RDY() (ENCCS & 8) //!< Состояние модуля
     15          
     16          #define ST_DEF(STRUCT, FILD, VAL)  STRUCT.FILD = VAL
     17          #define HADDR(ADDR) ((uint16_t)ADDR >> 8)
     18          #define LADDR(ADDR) ((uint16_t)ADDR)
     19          #define BV(n)                   (1 << (n))
     20          #define MIC_2_MICLEN(m)         (BV((m&3)+1) & ~3)
     21          
     22          // Режимы шифрования
     23          #define AES_MODE_CBC            0x00
     24          #define AES_MODE_CFB            0x10
     25          #define AES_MODE_OFB            0x20
     26          #define AES_MODE_CTR            0x30
     27          #define AES_MODE_ECB            0x40
     28          #define AES_MODE_CBCMAC         0x50
     29          
     30          // Операции 
     31          #define AES_ENCRYPT             0x00
     32          #define AES_DECRYPT             0x02
     33          #define AES_LOAD_KEY            0x04
     34          #define AES_LOAD_IV             0x06
     35          
     36          #define ENC_DW 29 // DMA AES тригер запрос загрузки
     37          #define ENC_UP 30 // DMA AES тригер запрос выгрузки
     38          
     39          #define STREAM_ENC_MODE     AES_MODE_OFB //!< Метод шифрования потока данных
     40          
     41          // Доступные методы
     42          void AES_StreamCoder(bool enc_mode, uint8_t *src, uint8_t *dst, 
     43                               uint8_t *key, uint8_t *nonce, uint8_t len);
     44          
     45          // Приватные функции
     46          static inline uint8_t generateAuthData(uint8_t *src, uint8_t *nonce, uint8_t c,
     47                                                 uint8_t f, uint8_t lm);
     48          static void CBCMAC_buf_encrypt(uint8_t len, uint8_t *key, uint8_t *mac);
     49          
     50          /**
     51          @brief Локальный буфер для работы режима CCM
     52          @detail 128 длина сообщения. 18 длинна блока B0 и строки состояния.
     53           16 длина дополнения нулями
     54          */
     55          static uint8_t buf[128+18+16]; 
     56          
     57          
     58          typedef struct //!< Структура блока B0 для режима CCM
     59          {
     60            struct 
     61            {
     62              uint8_t L:3;
     63              uint8_t M:3;
     64              uint8_t A_Data:1;
     65            } flag;
     66            uint16_t nonce[9];
     67            uint8_t L_M[6];
     68          } __attribute__((packed)) B0_s;
     69          
     70          typedef struct //!< Структура блока A0 для режима CCM
     71          {
     72            struct 
     73            {
     74              uint8_t L:3;
     75            } flag;
     76            uint8_t nonce[11];
     77            uint8_t ctr;
     78          } __attribute__((packed)) A0_s;
     79          
     80          typedef struct //!< Структура с настройками DMA 
     81          {
     82            uint8_t  SRCADDRH;
     83            uint8_t  SRCADDRL;
     84            uint8_t  DSTADDRH;
     85            uint8_t  DSTADDRL;
     86            struct  {
     87            uint8_t   LENH        :5;
     88            uint8_t   VLEN        :3;
     89            };
     90            struct  {
     91            uint8_t   LENL        :8;
     92            };
     93            struct  {
     94            uint8_t   TRIG        :5;
     95            uint8_t   TMODE       :2;
     96            uint8_t   WORDSIZE    :1;
     97            };
     98            struct {
     99            uint8_t   PRIORITY    :2;
    100            uint8_t   M8          :1;
    101            uint8_t   IRQMASK     :1;
    102            uint8_t   DESTINC     :2;
    103            uint8_t   SRCINC      :2;
    104            };
    105          } __attribute__((packed)) DMA_AES_s ;
    106          
    107          DMA_AES_s DMA_AES_DW; //!< DMA на запись
    108          DMA_AES_s DMA_AES_UP; //!< DMA на чтение
    109          
    110          
    111          /**
    112          @brief Иницилизация модуля
    113          @detail Модуль использует DMA каналы 0 и 1
    114          */
    115          void AES_init(void)
    116          {
    117            // Настроим канал 0 DMA для загрузки данных в AES
    118            uint16_t CONF_ADDR = (uint16_t)&DMA_AES_DW;
    119            DMA0CFGH = CONF_ADDR >> 8;
    120            DMA0CFGL = CONF_ADDR & 0xFF;
    121            
    122            // Настроим канал 1 DMA для выгрузки данных из AES
    123            CONF_ADDR = (uint16_t)&DMA_AES_UP;
    124            DMA1CFGH = CONF_ADDR >> 8;
    125            DMA1CFGL = CONF_ADDR & 0xFF;
    126            
    127            ST_DEF(DMA_AES_DW, DSTADDRH, 0x70); // Пишем данные XENCDI = 0xB1 
    128            ST_DEF(DMA_AES_DW, DSTADDRL, 0xB1); //  
    129            ST_DEF(DMA_AES_DW, PRIORITY, 0x00); // Низкий приоритет
    130            ST_DEF(DMA_AES_DW, M8, 0x00); // Используем 8 бит для счетика длинны
    131            ST_DEF(DMA_AES_DW, IRQMASK, 0x00); // Запрещаем генерировать перывания
    132            ST_DEF(DMA_AES_DW, DESTINC, 0x00); // Не увеличиваем адресс назначения
    133            ST_DEF(DMA_AES_DW, SRCINC, 0x01); // Увеличиваем адресс источника
    134            ST_DEF(DMA_AES_DW, TRIG, ENC_DW); // Тригер по загрузке
    135            ST_DEF(DMA_AES_DW, WORDSIZE, 0x00); // Копируем по 1 байту
    136            ST_DEF(DMA_AES_DW, TMODE, 0x01); //  Блочное копирование по тригеру
    137            ST_DEF(DMA_AES_DW, VLEN, 0x00); //  Количество байт определяет поле LEN  
    138            ST_DEF(DMA_AES_DW, LENH, 0x00); 
    139            
    140            ST_DEF(DMA_AES_UP, SRCADDRH, 0x70); // Читаем данные из X_ENCDO  
    141            ST_DEF(DMA_AES_UP, SRCADDRL, 0xB2);  
    142            ST_DEF(DMA_AES_UP, PRIORITY, 0x00); // Низкий приоритет
    143            ST_DEF(DMA_AES_UP, M8, 0x00); // Используем 8 бит для счетика длинны
    144            ST_DEF(DMA_AES_UP, IRQMASK, 0x00); // Запрещаем генерировать перывания
    145            ST_DEF(DMA_AES_UP, DESTINC, 0x01); // Увеличиваем адресс назначения
    146            ST_DEF(DMA_AES_UP, SRCINC, 0x00); // Не увеличиваем адресс источника
    147            ST_DEF(DMA_AES_UP, TRIG, ENC_UP); // Тригер по выгрузке
    148            ST_DEF(DMA_AES_UP, WORDSIZE, 0x00); // Копируем по 1 байту
    149            ST_DEF(DMA_AES_UP, TMODE, 0x01); //  Блочное копирование по тригеру
    150            ST_DEF(DMA_AES_UP, VLEN, 0x00); //  Количество байт определяет поле LEN  
    151            ST_DEF(DMA_AES_UP, LENH, 0x00); 
    152          }
    153          
    154          /**
    155          @brief Шифрует/дешифрует поток данных во время радиопередачи. Без проверки MIC
    156          @param[in] enc_mode Режим работы процедуры. true - шифрование.
    157          @param[in] src Указатель на данные подлежащии шифрованию
    158          @param[in] dst Указтель куда будут помещены зашифрованные данные
    159          @param[in] key Указатье на ключ. 16 байт
    160          @param[in] iv  Указатель на вектор иницилизации. 16 байт 
    161          @param[in] len Длинна данных
    162          */
    163          void AES_StreamCoder(bool enc_mode, uint8_t *src, uint8_t *dst, uint8_t *key,
    164                                   uint8_t *iv, uint8_t len)
    165          {
    166            // Установим метод кодироваения
    167            AES_SET_MODE(STREAM_ENC_MODE);
    168              
    169            // Загружаем ключ
    170            AES_SET_OPERATION(AES_LOAD_KEY);
    171            ST_DEF(DMA_AES_DW, SRCADDRL, LADDR(key));
    172            ST_DEF(DMA_AES_DW, SRCADDRH, HADDR(key));
    173            ST_DEF(DMA_AES_DW, LENL, 16);
    174            DMAARM |= 0x01;
    175            while(!AES_RDY());
    176            AES_START();
    177            while (DMAARM);
    178          
    179            // Загружаем IV
    180            AES_SET_OPERATION(AES_LOAD_IV);
    181            ST_DEF(DMA_AES_DW, SRCADDRL, LADDR(iv));
    182            ST_DEF(DMA_AES_DW, SRCADDRH, HADDR(iv));
    183            ST_DEF(DMA_AES_DW, LENL, 16);
    184            DMAARM |= 0x01;
    185            while(!AES_RDY());
    186            AES_START();
    187            while (DMAARM);
    188          
    189            // Установим необходимую операцию AES
    190            if (enc_mode) 
    191              AES_SET_OPERATION(AES_ENCRYPT)
    192            else 
    193              AES_SET_OPERATION(AES_DECRYPT)
    194            
    195            switch(STREAM_ENC_MODE) 
    196            {
    197            case AES_MODE_ECB: // ECB, CBC не реализованы
    198            case AES_MODE_CBC:
    199              break;
    200            case AES_MODE_CFB:
    201            case AES_MODE_OFB:
    202            case AES_MODE_CTR:
    203              {
    204                // Загрузка блоками по 128 бит с разделением на под-блоки по 32 бита
    205                uint8_t nbrBlocks = len / 16; // Количество целых блоков по 128 бит
    206                uint8_t ptr, sub_ptr; // Смещение
    207                uint8_t *download, *upload;
    208                
    209                // Для этих типов шифрования длина блоков по 4 байта
    210                ST_DEF(DMA_AES_DW, LENL, 4);
    211                ST_DEF(DMA_AES_UP, LENL, 4);
    212                
    213                // Шифруем все целые блоки
    214                for (uint8_t block = 0; block < nbrBlocks; block ++)
    215                {
    216                  ptr = 16 * block;
    217                  while(!AES_RDY());
    218                  AES_START();
    219                  for (uint8_t j = 0; j < 4; j++)
    220                  {
    221                    sub_ptr = ptr + 4*j;
    222                    download = &src[sub_ptr];
    223                    upload = &dst[sub_ptr];
    224                    // Указываем адресс DMA откуда читать данные
    225                    ST_DEF(DMA_AES_DW, SRCADDRL, LADDR(download));
    226                    ST_DEF(DMA_AES_DW, SRCADDRH, HADDR(download));
    227                    // Указываем адрес DMA куда записывать данные          
    228                    ST_DEF(DMA_AES_UP, DSTADDRL, LADDR(upload));
    229                    ST_DEF(DMA_AES_UP, DSTADDRH, HADDR(upload));
    230                    // Активируем DMA
    231                    DMAARM |= 0x03;  
    232                    DMAREQ |= 0x01;
    233                    while (DMAARM);          
    234                  }
    235                }     
    236                // Шифруем последний блок
    237                uint8_t block_len = len % 16; // Размер последнего блока
    238                
    239                // Завершаем работу если блок пустой
    240                if (!block_len)
    241                  return;
    242                
    243                uint8_t padding_block[16]; // Блок заполненый нулями
    244                ptr = 16*nbrBlocks; // Смещение на первый байт последнего блока в src
    245                memset(padding_block, 0x00, sizeof(padding_block)); // Заполняем нулями
    246                memcpy(padding_block, &src[ptr], block_len); // Копируем данные
    247                
    248                while(!AES_RDY());
    249                AES_START();
    250                for (uint8_t j = 0; j < 4; j++)
    251                  {
    252                    sub_ptr = 4*j;
    253                    download = &padding_block[sub_ptr];
    254                    // Указываем адресс DMA откуда читать данные
    255                    ST_DEF(DMA_AES_DW, SRCADDRL, LADDR(download));
    256                    ST_DEF(DMA_AES_DW, SRCADDRH, HADDR(download));
    257                    // Указываем аддрес DMA куда записывать данные          
    258                    ST_DEF(DMA_AES_UP, DSTADDRL, LADDR(download));
    259                    ST_DEF(DMA_AES_UP, DSTADDRH, HADDR(download));
    260                    // Активируем DMA
    261                    DMAARM |= 0x03;  
    262                    DMAREQ |= 0x01;
    263                    while (DMAARM);
    264                  }
    265                memcpy(&dst[ptr], padding_block, block_len); // Копируем в src
    266                
    267              } //CASE
    268              
    269              break;
    270            } 
    271          }
    272          
    273          /**
    274          @brief Шифрует/дешифрует поток данных во время радиопередачи. Без проверки MIC
    275          @param[in] enc_mode Режим работы процедуры. true - шифрование.
    276          @param[in] src Указатель на данные подлежащии шифрованию
    277          @param[in] dst Указтель куда будут помещены зашифрованные данные
    278          @param[in] key Указатье на ключ. 16 байт
    279          @param[in] iv  Указатель на вектор иницилизации. 16 байт 
    280          @param[in] len Длинна данных
    281          */
    282          static void CTR_enc_decrypt(bool enc_mode, uint8_t *src, uint8_t *dst, uint8_t *key,
    283                                   uint8_t *iv, uint8_t len)
    284          {
    285            // Установим метод кодироваения
    286            AES_SET_MODE(AES_MODE_CTR);
    287            
    288            // Загружаем ключ
    289            AES_SET_OPERATION(AES_LOAD_KEY);
    290            ST_DEF(DMA_AES_DW, SRCADDRL, LADDR(key));
    291            ST_DEF(DMA_AES_DW, SRCADDRH, HADDR(key));
    292            ST_DEF(DMA_AES_DW, LENL, 16);
    293            DMAARM |= 0x01;
    294            while(!AES_RDY());
    295            AES_START();
    296            while (DMAARM);
    297          
    298            // Загружаем IV
    299            AES_SET_OPERATION(AES_LOAD_IV);
    300            ST_DEF(DMA_AES_DW, SRCADDRL, LADDR(iv));
    301            ST_DEF(DMA_AES_DW, SRCADDRH, HADDR(iv));
    302            ST_DEF(DMA_AES_DW, LENL, 16);
    303            DMAARM |= 0x01;
    304            while(!AES_RDY());
    305            AES_START();
    306            while (DMAARM);
    307          
    308            // Установим необходимую операцию AES
    309            if (enc_mode) 
    310              AES_SET_OPERATION(AES_ENCRYPT)
    311            else 
    312              AES_SET_OPERATION(AES_DECRYPT)
    313            
    314            // Загрузка блоками по 128 бит с разделением на под-блоки по 32 бита
    315            uint8_t nbrBlocks = len / 16; // Количество целых блоков по 128 бит
    316            uint8_t ptr, sub_ptr; // Смещение
    317            uint8_t *download, *upload;
    318                
    319            // Для этих типов шифрования длина блоков по 4 байта
    320            ST_DEF(DMA_AES_DW, LENL, 4);
    321            ST_DEF(DMA_AES_UP, LENL, 4);
    322                
    323            // Шифруем все целые блоки
    324            for (uint8_t block = 0; block < nbrBlocks; block ++)
    325              {
    326                ptr = 16 * block;
    327                while(!AES_RDY());
    328                AES_START();
    329                for (uint8_t j = 0; j < 4; j++)
    330                  {
    331                    sub_ptr = ptr + 4*j;
    332                    download = &src[sub_ptr];
    333                    upload = &dst[sub_ptr];
    334                    // Указываем адресс DMA откуда читать данные
    335                    ST_DEF(DMA_AES_DW, SRCADDRL, LADDR(download));
    336                    ST_DEF(DMA_AES_DW, SRCADDRH, HADDR(download));
    337                    // Указываем адрес DMA куда записывать данные          
    338                    ST_DEF(DMA_AES_UP, DSTADDRL, LADDR(upload));
    339                    ST_DEF(DMA_AES_UP, DSTADDRH, HADDR(upload));
    340                    // Активируем DMA
    341                    DMAARM |= 0x03;  
    342                    DMAREQ |= 0x01;
    343                    while (DMAARM);          
    344                  }
    345              }     
    346              // Шифруем последний блок
    347              uint8_t block_len = len % 16; // Размер последнего блока
    348                
    349              // Завершаем работу если блок пустой
    350              if (!block_len)
    351                return;
    352                
    353              uint8_t padding_block[16]; // Блок заполненый нулями
    354              ptr = 16*nbrBlocks; // Смещение на первый байт последнего блока в src
    355              memset(padding_block, 0x00, sizeof(padding_block)); // Заполняем нулями
    356              memcpy(padding_block, &src[ptr], block_len); // Копируем данные
    357              
    358              while(!AES_RDY());
    359              AES_START();
    360              for (uint8_t j = 0; j < 4; j++)
    361                {
    362                  sub_ptr = 4*j;
    363                  download = &padding_block[sub_ptr];
    364                  // Указываем адресс DMA откуда читать данные
    365                  ST_DEF(DMA_AES_DW, SRCADDRL, LADDR(download));
    366                  ST_DEF(DMA_AES_DW, SRCADDRH, HADDR(download));
    367                  // Указываем аддрес DMA куда записывать данные          
    368                  ST_DEF(DMA_AES_UP, DSTADDRL, LADDR(download));
    369                  ST_DEF(DMA_AES_UP, DSTADDRH, HADDR(download));
    370                  // Активируем DMA
    371                  DMAARM |= 0x03;  
    372                  DMAREQ |= 0x01;
    373                  while (DMAARM);
    374                }
    375              memcpy(&dst[ptr], padding_block, block_len); // Копируем в src
    376          }
    377          
    378          /**
    379          @brief Зашифровывает buf в режиме CBC-MAC с IV = 0
    380          @param[in] len улинна последовательности для вычисления MAC
    381          @param[out] mac указатель на память куда будет записан mac (до 16 байт)
    382          */
    383          static void CBCMAC_buf_encrypt(uint8_t len, uint8_t *key, uint8_t *mac)
    384          {
    385            uint8_t IV[16];
    386            
    387            // Заполняем вектор нулями
    388            memset(IV, 0x00, sizeof(IV));
    389            
    390            // Установим метод кодироваения
    391            AES_SET_MODE(AES_MODE_CBCMAC);  
    392            
    393            { // Сворачиваем код для улучшения чтения
    394            // Загружаем ключ
    395            AES_SET_OPERATION(AES_LOAD_KEY);
    396            ST_DEF(DMA_AES_DW, SRCADDRL, LADDR(key));
    397            ST_DEF(DMA_AES_DW, SRCADDRH, HADDR(key));
    398            ST_DEF(DMA_AES_DW, LENL, 16);
    399            DMAARM |= 0x01;
    400            while(!AES_RDY());
    401            AES_START();
    402            while (DMAARM);
    403          
    404            // Загружаем IV
    405            AES_SET_OPERATION(AES_LOAD_IV);
    406            ST_DEF(DMA_AES_DW, SRCADDRL, LADDR(IV));
    407            ST_DEF(DMA_AES_DW, SRCADDRH, HADDR(IV));
    408            ST_DEF(DMA_AES_DW, LENL, 16);
    409            DMAARM |= 0x01;
    410            while(!AES_RDY());
    411            AES_START();
    412            while (DMAARM);
    413            };
    414            
    415            // Устанавливаем операцию шифрования
    416            AES_SET_OPERATION(AES_ENCRYPT);
    417            
    418            // Загрузка блоками по 128 бит
    419            uint8_t nbrBlocks = len / 16; // Количество целых блоков по 128 бит
    420            uint8_t block_len = len % 16; // Размер последнего блока
    421            uint8_t ptr; // Смещение
    422                
    423            // Для этого типа шифрования длина блоков по 16 байт
    424            ST_DEF(DMA_AES_DW, LENL, 16);
    425            // Устанавливаем куда будем выгружать вычисленный MAC
    426            ST_DEF(DMA_AES_UP, DSTADDRL, LADDR(mac));
    427            ST_DEF(DMA_AES_UP, DSTADDRH, HADDR(mac));
    428            ST_DEF(DMA_AES_UP, LENL, 16);
    429            
    430            // Шифруем все целые блоки
    431            for (uint8_t block = 0; block < nbrBlocks; block ++)
    432              {
    433                // Последний блок шифруем в режиме CBC при условии что нет блок не 
    434                // кратного 16 байтам.
    435                if (!block_len && (block == nbrBlocks - 1))
    436                  AES_SET_MODE(AES_MODE_CBC);
    437                    
    438                ptr = 16 * block;
    439                while(!AES_RDY());
    440                AES_START();
    441                // Указываем адресс DMA откуда читать данные
    442                ST_DEF(DMA_AES_DW, SRCADDRL, LADDR(buf[ptr]));
    443                ST_DEF(DMA_AES_DW, SRCADDRH, HADDR(buf[ptr]));
    444                // Активируем DMA
    445                DMAARM |= 0x01;  
    446                // Активируем выгрузку только последнего блока
    447                if (!block_len && (block == nbrBlocks - 1))
    448                  DMAARM = 0x03;
    449                
    450                DMAREQ |= 0x01;
    451                while (DMAARM);          
    452               }
    453                 
    454            // Шифруем последний блок в режиме CBC
    455            AES_SET_MODE(AES_MODE_CBC);
    456                    
    457            // Завершаем работу если блок пустой
    458            if (!block_len)
    459              return;
    460                
    461            uint8_t padding_block[16]; // Блок заполненый нулями
    462            ptr = 16*nbrBlocks; // Смещение на первый байт последнего блока в src
    463            memset(padding_block, 0x00, sizeof(padding_block)); // Заполняем нулями
    464            memcpy(padding_block, &buf[ptr], block_len); // Копируем данные
    465                
    466            while(!AES_RDY());
    467            AES_START();
    468            // Указываем адресс DMA откуда читать данные
    469            ST_DEF(DMA_AES_DW, SRCADDRL, LADDR(padding_block));
    470            ST_DEF(DMA_AES_DW, SRCADDRH, HADDR(padding_block));
    471            // Активируем DMA и выгрузку MAC
    472            DMAARM |= 0x03;  
    473            DMAREQ |= 0x01;
    474            while (DMAARM);
    475          }
    476          
    477          static inline uint8_t generateAuthData(uint8_t *src, uint8_t *nonce, uint8_t c,
    478                                                 uint8_t f, uint8_t lm)
    479          {
    480            memcpy(buf, nonce,16);
    481            
    482            // Буфер от 0 до 15 байта специальный блок B0
    483            // Настраиваем флаг. У нас длинна 2 байта. nonce 13 байт => L_M = L-1=0x01
    484            buf[0]=  0x01;  
    485            // Если есть данные для авторизации установим A_Data 
    486            if (f > 0)
    487              buf[0] |= 0x40;
    488            
    489            buf[0] |= ((lm - 2) / 2 ) << 3;   // см. документацию M'= (lm-2) / 2;
    490            
    491            // Устанавливаем длинну сообщения
    492            buf[14] = 0x00;
    493            buf[15] = c;
    494            
    495            // Добавляем строку авторизации L(a). если данных нет, то она пустая. f=0
    496            buf[16]= 0;
    497            buf[17]= f;
    498            
    499            // Копируем данные авторизации в буфер
    500            memcpy(&buf[18], src, f);
    501            
    502            // Смещение на следующий байт после данных авторизации.
    503            // Данные авторизации занимают положение в буфере [18, 18+f]
    504            uint8_t ptr_end= 18 + f;
    505            // Заполняем нулями до границы 16 байт  
    506            while (ptr_end & 0x0f)
    507              buf[ptr_end++] = 0x00;
    508            
    509            // Копируем данные для шифрования в буфер после нулей
    510            memcpy(&buf[ptr_end], &src[f], c);
    511            
    512            // Возвращаем размер данных в буфере
    513            return ptr_end+c;
    514          };
    515          
    516          /**
    517          @brief Шифрует/дешифрует данные с проверкой MIC
    518          @param[in] src Указатель на данные подлежащии шифрованию
    519          @param[in] len Размер данных
    520          @param[in] с Количество байт для шифрования
    521          @param[in] f Количество байт для авторизации
    522          @param[in] m Размер MIC (m=1,2,3 l(m) = 4,8,16 байт)
    523          @param[in] iv  Указатель на вектор иницилизации. 16 байт 
    524          @param[in] len Длинна данных
    525          @param[in,out] MIC Указатель на массив соответсвующий длинне (4,8,16 байт)
    526          */
    527          void AES_CCMEncrypt( uint8_t *src, uint8_t c, uint8_t f, uint8_t m,
    528                              uint8_t *key, uint8_t *nonce, uint8_t *MIC)
    529          {
    530            uint8_t lm = MIC_2_MICLEN(m);
    531            
    532            // Генерируем данные для авторизации
    533            uint8_t dlen = generateAuthData(src, nonce, c, f, lm);
    534            
    535            uint8_t mac[16]; // Сюда пишем мак
    536            CBCMAC_buf_encrypt(dlen, key, mac);
    537            
    538            // Шифруем MAC
    539            uint8_t CTR_IV[16];
    540            memcpy(CTR_IV, nonce, 16);
    541            CTR_IV[0] = 0x01; // Флаг режима CTR
    542            CTR_IV[15] = 0;   // Значение счетчика
    543            CTR_enc_decrypt(true, mac, mac, key, CTR_IV, 16);
    544            
    545            // Шифруем текст. он имеет размер 'c' и находится в буфере начиная с
    546            // dlen-c, dlen
    547            uint8_t ds = dlen - c; // Начало данных для шифрования
    548            
    549            // 0x0F & (16 - (dlen & 0x0f)) оставляет числа от 0 до 15  
    550            memset(buf+dlen, 0x00, 0x0F & (16 - (dlen & 0x0f)) ); // Дополняем нулями
    551            CTR_IV[15] = 1; // Счетчик CTR
    552            CTR_enc_decrypt(true, &buf[ds], &buf[ds], key, CTR_IV, c); // Шифруем
    553            
    554            // Заполняем буфер буфер src. src[0,f] это данные авторизации. 
    555            // src[f, f+c] это шифрованные данные.
    556            memcpy(&src[f], &buf[ds], c); 
    557            memcpy(MIC, mac, lm);
    558            
    559            //https://github.com/zhaohengyi/CC2530Example/blob/
    560            //master/source/components/radios/cc2530/hal_rf_security.c
    561          }
    562          
    563          /**
    564          @brief Дешифрует данные с проверкой MIC
    565          @param[in] src Указатель на данные подлежащии шифрованию
    566          @param[in] len Размер данных
    567          @param[in] с Количество байт для шифрования
    568          @param[in] f Количество байт для авторизации
    569          @param[in] m Размер MIC (m=1,2,3 l(m) = 4,8,16 байт)
    570          @param[in] iv  Указатель на вектор иницилизации. 16 байт 
    571          @param[in] len Длинна данных
    572          @param[in,out] MIC Указатель на массив соответсвующий длинне (4,8,16 байт)
    573          */
    574          bool AES_CCMDecrypt( uint8_t *src, uint8_t c, uint8_t f, uint8_t m,
    575                              uint8_t *key, uint8_t *nonce, uint8_t *MIC)
    576          {
    577            uint8_t lm = MIC_2_MICLEN(m);
    578            
    579            // Расшифровываем MAC
    580            uint8_t mac[16]; // Расшифрованый мак
    581            uint8_t CTR_IV[16];
    582            memcpy(CTR_IV, nonce, 16);
    583            CTR_IV[0] = 0x01; // Флаг режима CTR
    584            CTR_IV[15] = 0;   // Значение счетчика
    585            CTR_enc_decrypt(false, MIC, mac, key, CTR_IV, lm);  
    586            
    587            // Генерируем данные для авторизации
    588            uint8_t dlen = generateAuthData(src, nonce, c, f, lm);
    589            
    590            // Дешифруем текст. он имеет размер 'c' и находится в буфере начиная с
    591            // dlen-c, dlen
    592            uint8_t ds = dlen - c; // Начало данных для дешифрования
    593            
    594            // 0x0F & (16 - (dlen & 0x0f)) оставляет числа от 0 до 15  
    595            memset(buf+dlen, 0x00, 0x0F & (16 - (dlen & 0x0f)) ); // Дополняем нулями
    596            CTR_IV[15] = 1; // Счетчик CTR
    597            CTR_enc_decrypt(false, &buf[ds], &buf[ds], key, CTR_IV, c); // Дешифруем
    598            
    599            uint8_t new_mac[16]; // мак полученный в ходе рашифровки сообщения
    600            CBCMAC_buf_encrypt(dlen, key, new_mac);
    601            
    602            // Проверяем что маки совпадают, значит дешифровано верно
    603            bool mac_equal = true;
    604            for (uint8_t i = 0 ; i < lm ; i++)
    605            {
    606              if (mac[i] != new_mac[i])
    607              mac_equal = false;
    608              break;
    609            }
    610            
    611            // Выходим если MACи не совпали  
    612            if (!mac_equal)
    613              return false;
    614            
    615            // Копируем  расшифрованные данные
    616            memcpy(&src[f], &buf[ds], c); 
    617            return true;
    618          }
\\vmware-host\Shared Folders\Projects\WMNU\IAR\SHARE_PRJ_SRC\config.c
      1          #include "stdint.h"
      2          #include "string.h"
      3          #include "stdbool.h"
      4          #include "string.h"
      5          #include "basic.h"
      6          #include "config.h"
      7          
      8          static uint8_t default_key[16] = DEFAULT_KEY;
      9          static uint8_t default_iv[16] = DEFAULT_IV;
     10          
     11          void CF_init()
     12          {
     13            // Загрузка данных из различных источников
     14            memcpy(CONFIG.stream_key, default_key, 16); 
     15            memcpy(CONFIG.stream_iv,  default_iv, 16);
     16            CONFIG.node_ver = NODE_VER;
     17            CONFIG.node_type = NODE_TYPE;
     18            CONFIG.sync_channel = DEFAULT_SYNC_CHANNEL;
     19            CONFIG.panid = DEFAULT_PANID;
                                  ^
Warning[Pe069]: integer conversion resulted in truncation
          detected during compilation of secondary translation unit
                    "\\vmware-host\Shared
                    Folders\Projects\WMNU\IAR\SHARE_PRJ_SRC\config.c"
     20          }
\\vmware-host\Shared Folders\Projects\WMNU\IAR\SHARE_PRJ_SRC\delays.c
      1          /*!
      2          \file  Модуль измерения интервалов времени и функция задержки времени
      3          \brief Функции измерения времени и задержки
      4          */
      5          
      6          #include "ioCC2530.h"
      7          #include "delays.h"
      8          #include "string.h"
      9          
     10          #define TICK_NS  31.25 // Количество нс в одном такте TIM2
     11          #define TICK_US  0.03125 // Количество мкс в одном такте TIM2
     12          #define TICK_PER_US 32 // Количество тактов в одной микросекунде
     13          
     14          // Максимальное кол-во тактов таймера. Константа 40 бит, 5 байт
     15          static const uint32_t MAC_TIMER_MAX = 0xFFFFFFFFUL; 
     16          static uint32_t DELAY_CALIBRATE_TICS; // Колибровка функции задержки
     17          
     18          // Публичные методы
     19          void TIM_init(void);
     20          void TIM_TimeStamp(TimeStamp_s* timestamp);
     21          void TIM_delay(uint32_t delay);
     22          uint32_t TIM_passedTime(TimeStamp_s* start, TimeStamp_s* stop);
     23          void TIM_copy(TimeStamp_s *src, TimeStamp_s *dst);
     24          
     25          // Приватные
     26          static inline uint32_t Interval(TimeStamp_s* start, TimeStamp_s* stop);
     27          static void DelayCalibrate(void);
     28          
     29          /**
     30          @brief Иницилизация таймера
     31          @brief Используется таймер 2. MAC таймер
     32          */
     33          void TIM_init(void)
     34          {
     35            // Запускаем таймер, LATCH MODE = 1
     36            // Latch mode фиксирует значение таймера переполнения при чтении T2M0
     37            // ЗАпускаем MAC таймер без синхронизации с кварцем 32.768к
     38            T2CTRL = (1<<0) | (1<<3); 
     39            // Калибровка функции задержки
     40            DelayCalibrate();
     41          }
     42          
     43          /**
     44          @brief Возвращает временую метку.
     45          @params[out] timestamp указатель на временную метку 
     46          */
     47          void TIM_TimeStamp(TimeStamp_s* timestamp)
     48          {
     49            timestamp->byte[0] = T2M0;
     50            timestamp->byte[1] = T2M1;
     51            timestamp->byte[2] = T2MOVF0;
     52            timestamp->byte[3] = T2MOVF1;
     53          }
     54          
     55          /**
     56          @brief Калибровка функции задержки TIM_delay
     57          */
     58          static void DelayCalibrate(void)
     59          {
     60            #define ACCURATE_VAL_US 500 
     61            DELAY_CALIBRATE_TICS = 0;
     62            TimeStamp_s start, stop;
     63            uint32_t passed, cal;
     64            
     65            TIM_TimeStamp(&start);
     66            TIM_delay(ACCURATE_VAL_US);
     67            TIM_TimeStamp(&stop);
     68            passed = TIM_passedTime(&start, &stop);
     69            
     70            cal = passed - ACCURATE_VAL_US;
     71            DELAY_CALIBRATE_TICS = cal * TICK_PER_US; 
     72          };
     73          
     74          /**
     75          @brief Вычисляет количество тактов между двумя времеными метками
     76          @return Количество тактов
     77          */
     78          static inline uint32_t Interval(TimeStamp_s* start, TimeStamp_s* stop)
     79          {
     80            uint32_t ret;
     81          
     82            if (stop->timer >= start->timer)
     83              ret = stop->timer - start->timer;
     84            else
     85            { 
     86              ret = (MAC_TIMER_MAX - start->timer) + stop->timer;
     87            }
     88            return ret;
     89          }
     90          
     91          /**
     92          @brief Вычисляет прошедшее время между двумя времеными метками
     93          @return Время в мкс.
     94          */
     95          uint32_t TIM_passedTime(TimeStamp_s* start, TimeStamp_s* stop)
     96          {
     97            uint32_t ret = Interval(start, stop);
     98            
     99            ret = (uint32_t)((float)ret * TICK_US);
    100            return ret;
    101          }
    102          
    103          /**
    104          @brief Задержка на заданное количество мкс. 
    105          @details Погрешность около 20 мкс при значениях выше 150 мкс.
    106           Рекомендуется использовать для организации задержек не менее 200 мкс.
    107          @params[in] delay количество микросекунд. Не более 134217727 мкс (134.2 сек)
    108          */
    109          void TIM_delay(uint32_t delay)
    110          {
    111            uint32_t passed = 0;
    112            TimeStamp_s start, now;
    113            TIM_TimeStamp(&start);
    114            
    115            // Конвертируем мкс в такты и вносим поправку
    116            delay = delay * TICK_PER_US; 
    117            if (delay > DELAY_CALIBRATE_TICS)
    118              delay -= DELAY_CALIBRATE_TICS;
    119            
    120            do
    121            {
    122              TIM_TimeStamp(&now);
    123              passed = Interval(&start, &now);
    124            } while (passed < delay);
    125          }
    126          
    127          /**
    128          @brief Копирование временной метки
    129          @param[in] src указатель на исходную метку для копирование
    130          @param[out] dst указатель на метку назначения
    131          */
    132          void TIM_copy(TimeStamp_s *src, TimeStamp_s *dst)
    133          {
    134            memcpy(src, dst, sizeof(TimeStamp_s));
    135          }
\\vmware-host\Shared Folders\Projects\WMNU\IAR\SHARE_PRJ_SRC\ethernet.c
      1          #include "frame.h"
      2          #include "Net_frames.h"
      3          #include "stdint.h"
      4          #include "nwdebuger.h"
      5          #include "LLC.h"
      6          #include "mem.h"
      7          
      8          void ETH_Send(frame_s *fr);
      9          
     10          static void ETH_RX_HNDL(frame_s *fr);
     11          static void (*RXCallback)(frame_s *fr); //frame_s RAW_LAY, wthout ETH_LAY
     12          static bool validate(ETH_LAY *eth);
     13          static ETH_LAY* extract_header(frame_s *fr);
     14          static void send_ack(ETH_LAY *eth);
     15          static frame_s* strip_header(frame_s *fr);
     16          
     17          /**
     18          @brief Иницилизация модуля
     19          */
     20          void ETH_Init(void)
     21          {
     22            RXCallback = NULL; 
     23            LLC_SetRXCallback(ETH_RX_HNDL);
     24          }
     25          
     26          /**
     27          @brief Установка обработчика приема пакета ETH
     28          */
     29          void ETH_Set_RXCallback(void (*fn)(frame_s *fr))
     30          {
     31            ASSERT(fn != NULL);
     32            RXCallback = fn;
     33          }
     34          
     35          /**
     36          @brief Обработка принятого пакет сети.
     37          @detail После валидации пакета, уничтожается заголовок ETH и пакет передается
     38           на дальнейшую обработку вверх по стеку с помощью обратного вызова RXCallback
     39          */
     40          static void ETH_RX_HNDL(frame_s *fr)
     41          {
     42            ASSERT(fr != NULL);
     43            
     44            bool valid;
     45            frame_s *striped_frame;
     46            
     47            ETH_LAY* eth_h = extract_header(fr);
     48            
     49            // Извлечь заголовок не удалось
     50            if (eth_h == NULL)
     51              goto ERR_FRAME;
     52            
     53            valid = validate(eth_h);
     54           
     55            // Заголовок не верный
     56            if (!valid)
     57              goto ERR_FRAME;
     58           
     59            // Требуется отправить подтверждение приема пакета
     60            if (eth_h->ETH_T.bits.ACK)
     61              send_ack(eth_h);
     62            
     63            // Создаем новый пакет без заголовка и удаляем исходный
     64            striped_frame = strip_header(fr);
     65            frame_delete(fr);
     66            ASSERT(striped_frame != NULL);
     67            
     68            // Передаем обработчику выше по стеку
     69            ASSERT(RXCallback != NULL);
     70            RXCallback(striped_frame);
     71            
     72            re_free(eth_h);
     73            return;
     74            
     75          ERR_FRAME:
     76            frame_delete(fr);
     77            re_free(eth_h);
     78            return;
     79          }
     80          
     81          /**
     82          @brief Создает новый пакет без заголовка ETH_H
     83          @return указатель на новый frame_s*. NULL - не удалось создать пакет
     84          */
     85          static frame_s* strip_header(frame_s *fr)
     86          {
     87          }
                 ^
Warning[Pe940]: missing return statement at end of non-void function
          "strip_header"
          detected during compilation of secondary translation unit
                    "\\vmware-host\Shared
                    Folders\Projects\WMNU\IAR\SHARE_PRJ_SRC\ethernet.c"
     88          
     89          /**
     90          @brief Подготавливает и отпправляет подтверждение приема пакета
     91          */
     92          static void send_ack(ETH_LAY *eth)
     93          {
     94           
     95          }
     96          
     97          static bool validate(ETH_LAY *eth)
     98          {
     99            return true;
    100          }
    101          
    102          static ETH_LAY* extract_header(frame_s *fr)
    103          {
    104            ETH_LAY* eth_h = (ETH_LAY*)re_malloc(ETH_LAY_SIZE);
    105            ASSERT(eth_h != NULL);
    106            
    107            uint8_t len = frame_len(fr);
    108            ASSERT(len >= ETH_LAY_SIZE);
    109            
    110            //fbuf_s *fb = frame_get_fbuf_head(fr);
    111            //re_memcpy(eth_h, fb->payload, ETH_LAY_SIZE);
    112            return eth_h;
    113          }
\\vmware-host\Shared Folders\Projects\WMNU\IAR\SHARE_PRJ_SRC\frame.c
      1          /**
      2          @file Модуль описывает сетевой кадр и связанные с ним буферы данных
      3          @brief Типы frame
      4          */
      5          
      6          #include "frame.h"
      7          #include "string.h"
      8          #include "mem.h"
      9          #include "nwdebuger.h"
     10          #include "ioCC2530.h"
     11          
     12          frame_s* frame_create(void);
     13          void frame_delete(frame_s *fr);
     14          uint8_t frame_len(frame_s *fr);
     15          uint8_t frame_getCount(void);
     16          
     17          static uint8_t NBR_FRAME = 0; //!< Количество фреймов в памяти
     18          
     19          /**
     20          @brief Получить количество фреймов в памяти
     21          @return Возвращает количество фреймов
     22          */
     23          uint8_t frame_getCount(void)
     24          {
     25            return NBR_FRAME;
     26          }
     27          
     28          /**
     29          @brief Добавить заголовок
     30          @param[in] fr указатель на фрейм
     31          @param[in] src данные для добавления
     32          @param[in] len размер данных
     33          */
     34          void frame_addHeader(frame_s *fr, void *src, uint8_t len)
     35          {
     36            unsigned short EA_save = EA;
     37            EA = 0; 
     38            // Ранее небыло создано данных 
     39            if (fr->payload == NULL)
     40              {
     41                fr->payload = re_malloc(len);
     42                fr->len = len;
     43                re_memcpy(fr->payload, src, len);
     44                EA = EA_save;
     45                return;
     46              }
     47            
     48            uint8_t new_len = fr->len + len; // Новый размер
     49            void *new_payload = re_malloc(new_len);
     50            ASSERT(new_payload != NULL);
     51            
     52            // Копируем данные в конец области
     53            re_memcpy((char*)new_payload + len, fr->payload, fr->len);
     54            // Копируем данные спереди в свободную область
     55            re_memcpy(new_payload, src, len);
     56            // Уничтожаем старые данные
     57            re_free(fr->payload);
     58            fr->payload = new_payload;
     59            fr->len = new_len;
     60            EA = EA_save;
     61          }
     62          
     63          /**
     64          @brief Удалить заголовок
     65          @param[in] fr указатель на фрейм
     66          @param[in] len размер  удаляемых данных
     67          */
     68          void frame_delHeader(frame_s *fr, uint8_t len)
     69          {
     70            if (fr->payload == NULL)
     71              return;
     72          
     73            if (fr->len <= len)
     74              return;  
     75            
     76            uint8_t new_len = fr->len - len; // Новый размер
     77            void *new_payload = re_malloc(new_len);
     78            ASSERT(new_payload != NULL);
     79            
     80            // Копируем данные с пропуском первых len байт
     81            re_memcpy((char*)new_payload, (char*)fr->payload + len, new_len);
     82            
     83            // Уничтожаем старые данные
     84            re_free(fr->payload);
     85            fr->payload = new_payload;
     86            fr->len = new_len;
     87          }
     88          
     89          /**
     90          @brief Создание структуры frame
     91          @return Указатель на структуру frame
     92          */
     93          frame_s* frame_create(void)
     94          {
     95              unsigned short EA_save = EA;
     96              EA = 0; 
     97              
     98              frame_s* fr= (frame_s*)re_malloc(FRAME_S_SIZE);
     99              ASSERT(fr != NULL);
    100              
    101              fr->payload = NULL;
    102              fr->len = 0;
    103              memset(&fr->meta, 0x00, META_S_SIZE);
    104              NBR_FRAME++;
    105              
    106              EA = EA_save;
    107              return fr;
    108          };
    109          
    110          /**
    111          @brief Удаление frame
    112          @detail Проуедура так же удаляет все связанные с ней буфера fbuf
    113          @param[in] fr указатель на структуру frame
    114          */
    115          void frame_delete(frame_s *fr)
    116          {
    117            unsigned short EA_save = EA;
    118            EA = 0;  
    119            
    120            if (fr->payload != NULL)
    121              re_free(fr->payload);
    122           
    123            NBR_FRAME--;
    124            re_free(fr);
    125            EA = EA_save;
    126          }
    127          
    128          
    129          /**
    130          @brief Вычисляет размер цепочки fbuf
    131          @param[in] fr указатель на frame_s
    132          @return Количество байт в цепочке буферов
    133          */
    134          uint8_t frame_len(frame_s *fr)
    135          {
    136            return fr->len;
    137          }
\\vmware-host\Shared Folders\Projects\WMNU\IAR\SHARE_PRJ_SRC\LLC.c
      1          /**
      2          @file 
      3          @brief Модуль содержит реализацию интерфейса радио для приема/передачи данных.
      4          */
      5          
      6          #include "LLC.h"
      7          #include "MAC.h"
      8          #include "TIC.h"
      9          #include "mem.h"
     10          #include "nwdebuger.h"
     11          #include "ioCC2530.h"
     12          
     13          // Публичные методы
     14          void LLC_Init(void);
     15          
     16          // Методы модуля
     17          void LLC_SetRXCallback(void (*fn)(frame_s *fr));
     18          void LLC_TimeAlloc(void (*fn)(void)); 
     19          bool LLC_AddTask(frame_s* fr);
     20          uint8_t LLC_GetTaskLen(void);
     21          void LLC_Reset(void);
     22          
     23          // Закрытые методы
     24          static void LLC_SE_HNDL(uint8_t TS); //!< Обработчик завешения слота TIC
     25          static void LLC_Shelduler(uint8_t TS);
     26          static void LLC_RX_HNDL(frame_s *fr); //!< Обработчик примема пакета
     27          static void LLC_RunTimeAlloc(void);
     28          
     29          // Переменные модуля
     30          #define UNICAST_SEND_ATEMPTS 5 //!< Количество попыток передачи пакета 
     31          #define BROADCAST_SEND_ATEMPTS 3 //!< Количество попыток передачи пакета 
     32          #define MAX_nbrTASKS 20 //!< Максимальное количество задач в очередях
     33          
     34          typedef struct LLCTask LLCTask;
     35          typedef struct TimeAllocFunc TimeAllocFunc;
     36          static bool tasksBLOCK; //!< блокировка доступа к LLCTask
     37          
     38          /**
     39          @brief Описание задачи модуля LLC
     40          */
     41          struct LLCTask
     42          {
     43            LLCTask *next; //!< Указатель на следующую задачу. NULL - конец очереди
     44            uint8_t TS; //!< Номер временого канала для передачи сообщения
     45            uint8_t CH; //!< Номера радиоканала для передачи сообщения
     46            frame_s *fr; //!< Указатель на данные для передачи
     47          };
     48          
     49          /**
     50          @brief Список функций вызываемых по завешению временного слота
     51          */
     52          struct TimeAllocFunc
     53          {
     54            TimeAllocFunc *next; //!< Указатель на следующую функцию. NULL - конец списка
     55            void (*fn)(void); //!< Указатель на функцию. NULL - нет обработчика
     56          };
     57          
     58          static LLCTask *FirstTask; //!< Указатель на первый элемент очереди задач
     59          static uint8_t nbrTasks; // Количество задач в очереди
     60          
     61          /**
     62          @brief Обратный вызов при приеме пакета данных
     63          */
     64          static void (*RXCallback)(frame_s *fr);
     65          
     66          /**
     67          @brief Первый элемент обработчика конца временного слота
     68          @details Элемент создается статически, все остальные задачи создаются re_malloc
     69          и добавляются к HeadAllocFunc.
     70          */
     71          static TimeAllocFunc HeadAllocFunc;
     72          
     73          /**
     74          @brief Инициализация модуля
     75          @detail Иницилизирует MAC
     76          */
     77          void LLC_Init(void)
     78          {  
     79            nbrTasks = 0; 
     80            tasksBLOCK = false;
     81            FirstTask = NULL;
     82            // TODO Очистить очередь HeadTask
     83            // Регистрируем обработчики
     84            TIC_SetSECallback(LLC_SE_HNDL); // Завершение временного слота
     85            MAC_SetRXCallback(LLC_RX_HNDL); // Принято сообщение
     86          }
     87          
     88          /**
     89          @brief Сброс модуля
     90          @detail Удаяляем все пакеты в очереди. Аллокатор времени не трогаем
     91          */
     92          void LLC_Reset(void)
     93          {
     94            LLCTask *task = FirstTask;
     95            LLCTask *next;
     96            
     97            while (task != NULL)
     98            {
     99              next = task;
    100              re_free(task);
    101              task = next;
    102            }
    103            
    104          }
    105          
    106          /**
    107          @brief Количество задач в очереди
    108          @return количество задач в очереди
    109          */
    110          uint8_t LLC_GetTaskLen(void)
    111          {
    112            return nbrTasks;
    113          }
    114          
    115          void LLC_SetRXCallback(void (*fn)(frame_s *fr))
    116          {
    117            ASSERT(fn != NULL);
    118            RXCallback = fn;
    119          }
    120          
    121          /**
    122          @brief Добавляет обработчик заверешения временого слота в список
    123          */
    124          void LLC_TimeAlloc(void (*fn)(void))
    125          {
    126            TimeAllocFunc *ta = re_malloc(sizeof(TimeAllocFunc));
    127            ASSERT(ta != NULL);
    128            ta->next = NULL;
    129            ta->fn = fn;
    130          
    131            // Перебираемся в конец списка
    132            TimeAllocFunc *next = &HeadAllocFunc;
    133            while (next->next != NULL)
    134              next = next->next;
    135            
    136            // Добавляем новый элемент
    137            next->next = ta;
    138          };
    139          
    140          /**
    141          @brief Добавляем задачу в очередь
    142          @brief Взовращает true если задача добавлена в очередь. false, если размер 
    143           очереди достиг максимального размера.
    144          */
    145          bool LLC_AddTask(frame_s* fr)
    146          {
    147             ASSERT(fr != NULL);
    148           
    149              if (nbrTasks == MAX_nbrTASKS)
    150                return false;
    151              
    152             // Ждем пока разблокируется доступ.
    153             while (tasksBLOCK);
    154             tasksBLOCK = true;
    155          
    156             // Создаем новую задачу
    157             LLCTask *new_task = (LLCTask*)re_malloc(sizeof(LLCTask));
    158             ASSERT(new_task !=NULL); 
    159                
    160             new_task->TS = fr->meta.TS;
    161             new_task->CH = fr->meta.CH;
    162             new_task->fr = fr;
    163             
    164            LOG_ON("Add task = %u, CH = %d, TS = %d, OTS = %d. fr = %d",
    165                (uint16_t)new_task,new_task->CH, new_task->TS, fr->meta.TS, (uint16_t)fr);
    166            
    167             // Если в очереди нет задач, добавим первую
    168             if (FirstTask == NULL) 
    169             {
    170               new_task->next = NULL;
    171               FirstTask = new_task;
    172             }
    173             // Если в очереди были задачи то вставим новую в голову списка
    174             else 
    175             {
    176               new_task->next = FirstTask;
    177               FirstTask = new_task;  
    178             }
    179             
    180             nbrTasks ++;
    181             tasksBLOCK = false;
    182          
    183             return true;
    184          }
    185          
    186          
    187          
    188          
    189          /**
    190          @brief Планировщик задач
    191          @details Соотносит задачи в очереди и свободные временные слоты MAC уровня.
    192          При освобождении временных слотов, планировщик устанавливает данные для 
    193          передачи в MAC.
    194          @param[in] TS номер текущего временого слота
    195          */
    196          static void LLC_Shelduler(uint8_t TS)
    197          {
    198            // Если работает функция добавления задачи, то обслуживание очереди не
    199            // производится. Это может привести к необычным последствиям
    200            if (tasksBLOCK)
    201              return;
    202            tasksBLOCK = true;
    203            
    204            // Перебираем попорядку весь список на отправку
    205            // HeadTask только указатель на первый элемент, сам он не подлежит отправке
    206            LLCTask *task = FirstTask;
    207            LLCTask *last = FirstTask;
    208            LLCTask *next = FirstTask;
    209            
    210            while (task != NULL)
    211            {    
    212              if (MAC_GetTXState(task->TS)) // Занят ли временой слот
    213              {
    214                // Если слот занят переходим к следующей задаче
    215                last = task;
    216                task = task->next;
    217                continue; 
    218              }
    219              
    220              //Выбераем количество попыток передачи в зависимости от типа пакета
    221              uint8_t attempts;
    222              if (task->fr->meta.TX_METHOD == UNICAST)
    223                attempts = UNICAST_SEND_ATEMPTS;
    224              else if (task->fr->meta.TX_METHOD == BROADCAST)
    225                attempts = BROADCAST_SEND_ATEMPTS;
    226              else
    227                ASSERT(false);
    228              
    229              MAC_Send(task->fr, attempts);
    230              
    231              next = task->next; // Запомним следующую задачу
    232              
    233              // Удаляем текущую задачу из списка
    234              if (task == FirstTask)
    235              {
    236              // Удаляемым элементом является указателем на голову
    237                 FirstTask = next;
    238                 last = FirstTask;
    239              }
    240              else
    241              {
    242                // Удаляемым элементом является промежуточный элемент
    243                last->next = next;
    244              }
    245              
    246              nbrTasks--;
    247              LOG_OFF("Free task = %u, nbrTasks = %d\r\n",
    248                  (uint16_t)task, nbrTasks); 
    249              re_free(task);
    250              task = next;
    251            }
    252            
    253            tasksBLOCK = false;
    254          }
    255          
    256          /**
    257          @brief Обработчик заверешния временого слота
    258          @details Обратный вызов из TIC. Обработчик вызывает планировщик задач очереди
    259          и передает управление зарегистрированым функциям с помощью LLC_TimeAlloc.
    260          @param[in] TS номер завершенного временого слота
    261          */
    262          static void LLC_SE_HNDL(uint8_t TS)
    263          {
    264            LLC_Shelduler(TS);
    265            LLC_RunTimeAlloc();
    266          }
    267          
    268          static void LLC_RX_HNDL(frame_s *fr)
    269          {
    270            ASSERT(RXCallback !=NULL);
    271            RXCallback(fr);
    272          }
    273          
    274          /**
    275          @brief Передаем управление зарегистрированным функциям
    276          */
    277          static void LLC_RunTimeAlloc(void)
    278          {
    279              TimeAllocFunc *next = &HeadAllocFunc;
    280            // HeadAllocFunc служит только для указания на первый элемент в очереди
    281            // так что его нужно пропустить и переходить сразу к next
    282            while (next->next != NULL)
    283            {
    284              next->next->fn();
    285              next = next->next;
    286            }
    287          }
\\vmware-host\Shared Folders\Projects\WMNU\IAR\SHARE_PRJ_SRC\MAC.c
      1          #include "MAC.h"
      2          #include "frame.h"
      3          #include "string.h"
      4          #include "nwdebuger.h"
      5          #include "coder.h"
      6          #include "TIC.h"
      7          #include "stdlib.h"
      8          #include "basic.h"
      9          
     10          // Обработчики прерываний
     11          static void MAC_RX_HNDL(uint8_t TS);
     12          static void MAC_TX_HNDL(uint8_t TS);
     13          static void (*RXCallback)(frame_s *fr);
     14          static void BitRawDecrypt(uint8_t *src, uint8_t size);
     15          static void BitRawCrypt(uint8_t *src, uint8_t size);
     16          static uint8_t xor_calc(frame_s *fr);
     17          
     18          // Публичные методы
     19          void MAC_Init(void);
     20          void MAC_Reset(void);
     21          void MAC_Enable(bool en);
     22          void MAC_OpenRXSlot(uint8_t TS, uint8_t CH);
     23          void MAC_CloseRXSlot(uint8_t TS);
     24          void MAC_Send(frame_s *fr, uint8_t attempts);
     25          bool MAC_ACK_Send(frame_s *fr);
     26          void MAC_SetRXCallback(void (*fn)(frame_s *fr));
     27          bool MAC_GetTXState(uint8_t TS);
     28          bool MAC_GetRXState(uint8_t TS);
     29          
     30          // Ключ потокового шифрования и вектор иницилизации
     31          static uint8_t KEY[16] = DEFAULT_KEY;
     32          static uint8_t IV[16] = DEFAULT_IV;
     33            
     34          #define RECV_TIMEOUT 3000UL // Время ожидания приема пакета в мкс с начала слота
     35          #define ACK_RECV_TIMEOUT 1000UL // Время ожидания приема подтверждения в мкс
     36          
     37          typedef struct // Формат структуры пакета ACK
     38          {
     39            uint16_t CRC8;
     40          } __attribute__((packed)) ACK_s;
     41          
     42          typedef struct
     43          {
     44           struct 
     45           {
     46             bool enable;
     47             uint8_t attempts;
     48             uint8_t CH;
     49             frame_s *fr;
     50           } __attribute__((packed)) TX;
     51           
     52           struct
     53           {
     54            bool enable; 
     55            uint8_t CH;
     56           } __attribute__((packed)) RX;
     57          } __attribute__((packed)) MACSState_s; 
     58          
     59          static bool MAC_ENABLE_MODULE = false; //!< Модуль активен
     60          
     61          
     62          // Таблица состояний слотов приема/передачи
     63          MACSState_s MACSlotTable[50];
     64          
     65          /**
     66          @brief Установить вектор иницилизации для шифрования
     67          @param[in] ptr_IV указатель на 16 байтный вектор иницилизации
     68          */
     69          void MAC_setIV(void* ptr_IV)
     70          {
     71            memcpy(IV, ptr_IV, 16);
     72          }
     73          
     74          /**
     75          @brief Установить ключ шифрования
     76          @param[in] ptr_KEY указатель на 16 байтный ключ
     77          */
     78          void MAC_setKEY(void* ptr_KEY)
     79          {
     80            memcpy(KEY, ptr_KEY, 16);
     81          }
     82          
     83          /**
     84          @brief Иницилизация MAC
     85          @detail Инизилизирует TIM, TIC, RI, AES
     86          */
     87          void MAC_Init(void)
     88          {
     89            MAC_ENABLE_MODULE = false;
     90            TIC_SetRXCallback(MAC_RX_HNDL);
     91            TIC_SetTXCallback(MAC_TX_HNDL);  
     92            memset(MACSlotTable, 0x00, 50*sizeof(MACSState_s));
     93          }
     94          
     95          /**
     96          @brief Сброс настроек модуля.
     97          @detail Удаяляет все пакеты для передачи. Активным остается TS1 обработчик sync
     98          */
     99          void MAC_Reset(void)
    100          {
    101            MAC_ENABLE_MODULE = false;
    102            // Удаляем все пакеты на передачу
    103            for (uint8_t i = 0; i < 50; i++)
    104              if (MACSlotTable[i].TX.enable)
    105                frame_delete(MACSlotTable[i].TX.fr);
    106            
    107            memset(MACSlotTable, 0x00, 50*sizeof(MACSState_s));
    108          }
    109          
    110          /**
    111          @brief Открыть временой слот приема данных
    112          @param[in] TS номер слота от 0 до 49
    113          @param[in] CH номер радиоканала
    114          */
    115          void MAC_OpenRXSlot(uint8_t TS, uint8_t CH)
    116          {
    117              ASSERT(TS < 50 || TS !=0 );
    118              MACSlotTable[TS].RX.enable = true;
    119              MACSlotTable[TS].RX.CH = CH;
    120              TIC_SetRXState(TS, true);
    121          }
    122          
    123          /**
    124          @brief Закрыть временой слот приема данных
    125          @param[in] TS номер слота от 0 до 49
    126          */
    127          void MAC_CloseRXSlot(uint8_t TS)
    128          {
    129            ASSERT(TS < 50 || TS !=0);
    130            MACSlotTable[TS].RX.enable = false;
    131            TIC_SetRXState(TS, false);
    132          }
    133          
    134          /**
    135          @brief Поставить пакет в таблицу отправки сообщений
    136          @param[in] fr указатель на пакет
    137          @param[in] attempts количество попыток
    138          */
    139          void MAC_Send(frame_s *fr, uint8_t attempts)
    140          {
    141              ASSERT(fr != NULL);
    142              ASSERT(attempts != 0);
    143              ASSERT(fr->meta.TS != 0);
    144              
    145              uint8_t TS = fr->meta.TS; 
    146              MACSlotTable[TS].TX.attempts = attempts;
    147              MACSlotTable[TS].TX.CH = fr->meta.CH;
    148              MACSlotTable[TS].TX.enable = true;
    149              MACSlotTable[TS].TX.fr = fr;
    150              
    151              #ifdef RARIO_STREAM_ENCRYPT
    152              BitRawCrypt(fr->payload, fr->len);
    153              #endif
    154              
    155              TIC_SetTXState(TS, true);
    156          }
    157          
    158          void MAC_Enable(bool en)
    159          {
    160            MAC_ENABLE_MODULE = en;
    161          }
    162          
    163          /**
    164          @brief Расчитывает CRC8 код
    165          @param[in] fr указатель на кадр
    166          @return CRC8
    167          */
    168          static uint8_t xor_calc(frame_s *fr)
    169          {
    170            uint8_t crc = 0x34; // Начальное значение
    171            uint8_t *val = fr->payload;
    172            
    173            for (uint8_t i = 0; i < fr->len; i++)
    174              crc ^= val[i];
    175            return crc;
    176          }
    177          
    178          /**
    179          @brief Посылает подтверждение приема пакета
    180          @param[in] fr указатель на кадр который нужно подтвердить
    181          @return true если передача подтверждения успешна (канал свободен)
    182          */
    183          static bool MAC_ACK_Send(frame_s *fr)
    184          {
    185            static ACK_s pACK;
    186            frame_s *fr_ACK;
    187            
    188            // Создаем подтверждение кадра
    189            pACK.CRC8 = xor_calc(fr);
    190            
    191            // Создаем кадр для отправки
    192            fr_ACK = frame_create();
    193            frame_addHeader(fr_ACK, &pACK, sizeof(ACK_s));
    194            fr_ACK->meta.SEND_TIME = 0;
    195            
    196           
    197            bool res = RI_Send(fr_ACK);
    198            frame_delete(fr_ACK);
    199            return res;
    200          }
    201          
    202          /**
    203          @brief Ожидает прием пакета подтверждения
    204          @param[in] fr указатель на пакет подтверждение которого ожидаем 
    205          @return true если приняли подтверждение
    206          */
    207          static bool MAC_ACK_Recv(frame_s *fr)
    208          {
    209            frame_s *fr_ACK = RI_Receive(ACK_RECV_TIMEOUT);
    210            
    211            // Если пакета нет, выходим из обработчика
    212            if (fr_ACK == NULL)
    213              return false;
    214            
    215            // Проверим размер пакета
    216            if (fr_ACK->len != sizeof(ACK_s))
    217            {
    218              frame_delete(fr_ACK);
    219              return false;
    220            }
    221              
    222            ACK_s *ptrACK;
    223            ptrACK = (ACK_s*)fr_ACK->payload;
    224            
    225            uint8_t crc8 = xor_calc(fr);
    226            uint8_t ack_crc8 = ptrACK->CRC8;
    227            frame_delete(fr_ACK);
    228            
    229            if (crc8 == ack_crc8)
    230              return true;
    231            return false;
    232          }
    233          
    234          /**
    235          @brief Устанавливает функцию обратного вызова при приеме пакета
    236          @param[in] fn указатель на функцию обработчик
    237          */
    238          void MAC_SetRXCallback(void (*fn)(frame_s *fr))
    239          {
    240            RXCallback = fn;
    241          }
    242          
    243          /**
    244          @brief Состояние слота TS передача
    245          @return возвращает true, если слот содержит пакет для передачи
    246          */
    247          bool MAC_GetTXState(uint8_t TS)
    248          {
    249            ASSERT(TS < 50  || TS !=0 );
    250            return MACSlotTable[TS].TX.enable;
    251          }
    252          
    253          /**
    254          @brief Состояние слота TS приема
    255          @return возвращает true, если слот принимает пакет
    256          */
    257          bool MAC_GetRXState(uint8_t TS)
    258          {
    259            ASSERT(TS < 50  || TS !=0);
    260            return MACSlotTable[TS].RX.enable;
    261          }
    262          
    263          /**
    264          @brief Обработчик слота приема пакета
    265          @detail При необходимости подтвеждает пакет
    266          @param[in] TS номер временного слота
    267          */
    268          static void MAC_RX_HNDL(uint8_t TS)
    269          {
    270            ASSERT(TS < 50  || TS !=0);
    271          
    272            if (!MAC_ENABLE_MODULE) // Модуль откючен
    273              return;
    274            
    275            RI_SetChannel(MACSlotTable[TS].RX.CH);
    276            frame_s *fr = RI_Receive(RECV_TIMEOUT);
    277            
    278            // Если пакета нет, выходим из обработчика
    279            if (fr == NULL)
    280              return;
    281            
    282            // Пакеты во временные слоты 0..49 требуют подтверждения
    283            if (TS > 1)
    284              MAC_ACK_Send(fr);
    285           
    286            #ifdef RARIO_STREAM_ENCRYPT
    287            BitRawDecrypt(fr->payload, fr->len);
    288            #endif
    289            
    290            RXCallback(fr);   // Передаем пакет на дальнейшую обработку
    291            // Удаление пакета не наша забота
    292          }
    293          
    294          /**
    295          @brief Обработчик слота пердачи пакета
    296          @detail После отправки пакета требуется подтверждение приема если meta.ACK = 1.
    297           После отправки ждем приема ACK. Проверка подлинности ACK происходит с помощью
    298           обратного вызова isACK_OK(*fr, *fr_ACK). Результат true или false.
    299          @param[in] TS номер временного слота
    300          */
    301          static void MAC_TX_HNDL(uint8_t TS)
    302          {
    303            ASSERT(TS < 50  || TS !=0);
    304            
    305            if (!MAC_ENABLE_MODULE) // Модуль отключен
    306              return;
    307            
    308            // По ошибки вызвали. Такого быть не должно, но подстрахуемся.
    309            if ((!MACSlotTable[TS].TX.enable) || (MACSlotTable[TS].TX.attempts == 0)) 
    310            {
    311              TIC_SetTXState(TS, false);
    312              return;
    313            }
    314            
    315            RI_SetChannel(MACSlotTable[TS].TX.CH); // Устанавливаем канал передачи
    316          
    317            // Пробуем передать данные
    318            bool tx_success = RI_Send(MACSlotTable[TS].TX.fr); 
    319            bool send_success = false;  
    320            
    321            LOG_OFF("RI_Send = %d, CH = %d, TS = %d\r\n",
    322                tx_success, MACSlotTable[TS].TX.CH, TS);
    323              
    324            if (tx_success)
    325            {
    326              if (TS > 1) // требуется подтверждение ACK
    327              {
    328                if (MAC_ACK_Recv(MACSlotTable[TS].TX.fr))
    329                    send_success = true;
    330              }
    331              else // не требуеться подтверждение
    332                send_success = true;
    333            }
    334            
    335          
    336            if (send_success) // В случаи успеха удаляем данные и закрываем слоты 
    337            { 
    338              frame_delete(MACSlotTable[TS].TX.fr);
    339              MACSlotTable[TS].TX.enable = false;
    340              TIC_SetTXState(TS, false);      
    341            }
    342            else // Уменьшаем счетчик попыток передачи и удаляем пакет при достижении 0.
    343            {
    344              MACSlotTable[TS].TX.attempts --;
    345              if (MACSlotTable[TS].TX.attempts == 0)
    346                {
    347                  frame_delete(MACSlotTable[TS].TX.fr);
    348                  MACSlotTable[TS].TX.enable = false;
    349                  TIC_SetTXState(TS, false);  
    350                }
    351            }
    352          }
    353          
    354          /*!
    355          \brief Расшифровка область памяти
    356          \param[in,out] *src Указатель на начало области дешифрования
    357          \param[in] size Размер расшифруемых данных
    358          */
    359          static void BitRawDecrypt(uint8_t *src, uint8_t size)
    360          {
    361            AES_StreamCoder(false, src, src, KEY, IV, size);
    362          }
    363          
    364          /*!
    365          \brief Шифрует область памяти
    366          \param[in,out] *src Указатель на начало области шифрования
    367          \param[in] size Размер шифруемых данных
    368          */
    369          static void BitRawCrypt(uint8_t *src, uint8_t size)
    370          {
    371            AES_StreamCoder(true, src, src, KEY, IV, size);
    372          }
    373          
\\vmware-host\Shared Folders\Projects\WMNU\IAR\SHARE_PRJ_SRC\manager.c
      1          #include "manager.h"
      2          #include "coder.h"
      3          #include "delays.h"
      4          #include "ethernet.h"
      5          #include "frame.h"
      6          #include "LLC.h"
      7          #include "MAC.h"
      8          #include "NTMR.h"
      9          #include "RADIO.h"
     10          #include "TIC.h"
     11          #include "sync.h"
     12          #include "config.h"
     13          #include "frame.h"
     14          #include "nwdebuger.h"
     15          #include "basic.h"
     16          #include "config.h"
     17          #include "ioCC2530.h"
     18          
     19          static void MG_Init();
     20          static void MG_Reset();
     21          static void re_start();
     22          static bool network_discovery();
     23          
     24          static bool MG_MODULES_INITED = false; //!< Были ли запущенны аппаратные модули
     25          
     26          // Публичные методы
     27          bool MG_Connect();
     28          
     29          // Переменные модуля
     30          
     31          
     32          static void MG_Init()
     33          {
     34            CF_init();
     35            NT_Init();
     36            TIM_init();
     37            TIC_Init();
     38            RI_init();
     39            AES_init();
     40            MAC_Init();
     41            SY_Init();
     42            LLC_Init();
     43            // TODO Необходимо очищать все ранее выделеную память malloc
     44          }
     45          
     46          static void MG_Reset()
     47          {   
     48            TIC_Reset();
     49            MAC_Reset();
     50            SY_Reset();
     51            LLC_Reset();
     52          }
     53          
     54          static void re_start()
     55          {
     56              if (!MG_MODULES_INITED)
     57            {
     58              MG_Init();
     59              MG_MODULES_INITED = true;
     60            }
     61            else
     62              MG_Reset(); 
     63              
     64            CF_init();
     65            MAC_setIV(CONFIG.stream_iv);
     66            MAC_setKEY(CONFIG.stream_key);
     67            SY_setIV(CONFIG.stream_iv);
     68            SY_setKEY(CONFIG.stream_key);
     69          }
     70          
     71          /**
     72          @brief Алгоритм подключения к сети
     73          */
     74          static bool network_discovery()
     75          {
     76            uint16_t panid;
     77            bool con = false;
     78            
     79            // Тупой алгоритм поиска сети.
     80            while (!con)
     81            {
     82              con = SY_SYNC_NETWORK(&panid, 5000);
     83            }
     84            return con;
     85          }
     86          
     87          /**
     88          @brief Создание сети в режиме шлюза
     89          */
     90          static bool master_mode()
     91          {
     92            // Включает обработку начала слота TS1 для программы собранной с ключом 
     93            // GATEWAY. MAC_TS1_HNDL_MASTER будет создавать пакеты синхронизации.
     94            MAC_Enable(true);
     95            SY_Enable(true);
     96            return true;
     97          }
     98          
     99          /**
    100          @brief Создание сети в режиме узла
    101          */
    102          static bool slave_mode()
    103          {
    104            // В режиме slave сначало нужно подключисться к сети
    105            network_discovery();
    106            
    107            // После синхронизации с сетью разрешаем обработку временных слотов
    108            // Программа собрана без ключа GATEWAY и активной функцией обработки TS1
    109            // будет MAC_TS1_HNDL_SLAVE. Она отвечает за поддержание синхронизации
    110            // и периодиескую ректрансляцию пакетов.
    111            
    112            MAC_Enable(true);
    113            SY_Enable(true);
    114            return true;
    115          }
    116          
    117          bool MG_Connect()
    118          {
    119            EA = 0;
    120            re_start();
    121            EA = 1;
    122            if (frame_getCount())
    123            {
    124              LOG_ON("Frame_s count: %d \r\n",frame_getCount());
    125              return false;
    126            }
    127            
    128          #ifdef GATEWAY
    129              bool con = master_mode();
    130          #else
    131              bool con = slave_mode();  
    132          #endif
    133              
    134              return con;
    135          }
    136           
    137            
\\vmware-host\Shared Folders\Projects\WMNU\IAR\SHARE_PRJ_SRC\mem.c
      1          #include "ioCC2530.h"
      2          #include "stdlib.h"
      3          #include "stdint.h"
      4          #include "string.h"
      5          #include "nwdebuger.h"
      6          
      7          void re_free(void* ptr);
      8          void* re_malloc(size_t size);
      9          uint16_t heap_ptr(size_t size);
     10          void re_memcpy(void *dst, const void *src, size_t n);
     11          
     12          /**
     13          @brief Возвращает адрес следующего свободного участка памяти
     14          @detail Функция нужна для оценки использования стека
     15          @param[in] size размер запрашиваемой области
     16          @return если памяти нету возвращает 0, иначе адрес свободного участка.
     17          */
     18          uint16_t heap_ptr(size_t size)
     19          {
     20            unsigned short EA_save = EA;
     21            EA = 0; 
     22            uint16_t *heap_ptr;
     23            heap_ptr = (uint16_t*)re_malloc(size);
     24            re_free(heap_ptr);
     25            EA = EA_save;
     26            return (uint16_t)heap_ptr;
     27          }
     28          
     29          /**
     30          @brief Реентерабельное копирование памяти
     31          */
     32          void re_memcpy(void *dst, const void *src, size_t n)
     33          {
     34            unsigned short EA_save = EA;
     35            EA = 0;
     36            memcpy(dst, src, n);
     37            EA = EA_save;  
     38          }
     39          
     40          /**
     41          @brief Реентерабельное выделение памяти
     42          */
     43          void* re_malloc(size_t size)
     44          {
     45            unsigned short EA_save = EA;
     46            void* ptr; 
     47            EA = 0;
     48            ptr = malloc(size);
     49            EA = EA_save;
     50            //LOG(MSG_OFF | MSG_INFO | MSG_TRACE, "malloc = %d, L= %d \r\n", (uint16_t)ptr, size);
     51            return ptr;
     52          }
     53          
     54          /**
     55          @brief Реентерабельное освобождение памяти
     56          */
     57          void re_free(void* ptr)
     58          {
     59            unsigned short EA_save = EA;
     60            EA = 0;
     61            free(ptr);
     62            EA = EA_save;
     63            //LOG(MSG_OFF | MSG_INFO | MSG_TRACE, "free = %d\r\n", (uint16_t)ptr);  
     64          }
\\vmware-host\Shared Folders\Projects\WMNU\IAR\SHARE_PRJ_SRC\NTMR.c
      1          #include "NTMR.h"
      2          #include "stdlib.h"
      3          #include "ioCC2530.h"
      4          #include "nwdebuger.h"
      5          
      6          /**
      7          @file 
      8          @brief Модуль управления таймером сна
      9          @details При создании обьекта с помощью NT_Create, производится иницилизация
     10           аппаратного таймера сна и он переходит в активное состояние. Если установлено 
     11           определение #define USE_OSC32K будет использван внешний кварц.
     12           За установку глобального прерывания IE отвечает пользователь.
     13           Для использования модуля необходимо установить обработчик прерывания
     14           NT_SetEventCallback(..). Далее с помощью NT_SetCompare(..) установить
     15           время срабатывания прерывания, она же включит прерывание таймера. 
     16           Перед вызовом пользовательского обработчика, запрещается прерывание таймера,
     17           пользователь должен установить его повторно на необходимое время.
     18           Модуль сна пробуждает МК из режимов PM1,PM2, но не переводит их обратно.
     19           После завершения обработки прерывание, продолжится выполнение основного 
     20           потока программы. Пользователь самостоятельно должен перевести МК в режим сна.
     21           Функция NT_SetTime(..) производит подстройку времени сети и корректирует время
     22           срабатывания прерывания. Что бы было понятнее приведу пример: 
     23           Время сети 400 и установленно прерывание на 700.
     24           Пользователь корректирует время на 300, но из-за разной разрядности счетчиков
     25           прерывание произойдет по "старым часам", так как NT_SetTime только изменит
     26           переменную относительного смещения, а не непосредственно значение счетчика.
     27           Поэтому необходимо пересчитать время прерывания 700 к новому смещению.
     28           Из найденных особенностей: когда вызывается обработчик прерывания, значение
     29           времени всегда больше на 2 тика. Предполагаю из за ожидания синхронизации при
     30           чтении значения таймера. 
     31          */
     32          
     33          
     34          // После вызова EventCallback аппаратное прерывание завершается
     35          // и управление передается в главный цикл main.
     36          // Пользователь сам должен положить систему в сон
     37          // Для работы используется sleep timer.
     38          // Значение таймера изменить нельзя, он автоматически стартует после
     39          // Включения микроконтроллера. Нам нужно выбрать XOSC вместо RCOSC,
     40          // Но на отладочной плате нет резонатора
     41          // Чтение значения ST2:ST1:ST0 первым из ST0
     42          // Таймер работает во всех режимах кроме PM3
     43          // После пробуждения нужно убеиться что SLEEPSTA.CLK32K бит установлен прежде 
     44          // чем считывать ST0-3
     45          
     46          
     47          #define USE_OSC32K // Использовать внешний квац 32.768 кГц
     48          
     49          // Методы модуля
     50          bool NT_SetTime(uint16_t ticks);
     51          void NT_SetCompare(uint16_t ticks);
     52          void NT_SetEventCallback(void (*fn)(uint16_t ticks));
     53          uint16_t NT_GetTime(void);
     54          uint16_t NT_WaitTime(uint16_t ticks);
     55          
     56          // Приватные методы
     57          static uint32_t ReadTimer(void);
     58          static void loadTimerCompare(uint32_t ticks);
     59          static inline bool isIRQEnable(void);
     60          static inline void NT_IRQEnable(bool state);
     61          
     62          // Переменные модуля
     63          static void (*EventCallback)(uint16_t ticks);
     64          static uint32_t COMPARE_TIME; //!< Значение загруженное в регистр compare
     65          
     66          /**
     67          @details Смещение времени сети относительно времени таймера.
     68           NETWORK TIME = TIMER + TOFFSET
     69          */
     70          uint16_t TOFFSET; 
     71          
     72          /**
     73          @brief Инизиализация таймера
     74          */
     75          void NT_Init(void)
     76          {
     77            TOFFSET = 0;
     78            COMPARE_TIME = 0;
     79            EventCallback = NULL;
     80          
     81            // Сначало нужно настроить кварц 32кГц только потом поднимать
     82            // основной квар до 32 Мгц
     83            #ifdef USE_OSC32K
     84            CLKCONCMD &= ~(1<<7); // Сбрасываем бит OSC32K, будет выбран 32.768 кварц
     85            while (CLKCONSTA & (1<<7)); // Ждем пока бит не станет 0
     86            #endif
     87          
     88            // Переходим на 32 Мгц
     89            CLKCONCMD = (1<<3);
     90            while (CLKCONSTA&(1<<6));
     91            
     92            NT_IRQEnable(false);
     93          }
     94          
     95          /**
     96          @brief Устанавливаем текущее время сети и переустанавливает capture time
     97          @param[in] ticks время от 0-32767. Один tick 1/32768
     98          @return true если аргумент в диапазоне
     99          */
    100          bool NT_SetTime(uint16_t ticks)
    101          {
    102            ASSERT(ticks < 32768);
    103            if (ticks > 32767)
    104              return false;
    105           
    106            uint16_t timer = ReadTimer();
    107            TOFFSET = ticks - timer;
    108            TOFFSET &= 0x7FFF;
    109          
    110            // После установки времени нужно изменить compare time в таймере
    111            // Но только в случаи если прерывание активно
    112            if (isIRQEnable())
    113            {
    114              NT_SetCompare(COMPARE_TIME);
    115            }
    116          
    117            return true;
    118          }
    119          
    120          /**
    121          @brief Вычисляет значение, которое нужно установить в регистр compare таймера.
    122          @params[in] ticks время сети в тикак
    123          */
    124          static inline uint32_t calcCompareTime(uint16_t ticks)
    125          {   
    126              uint32_t timer = ReadTimer(); // Текущее значение счетчика
    127              
    128              //NETWORK TIME = TIMER + TOFFSET  
    129              // Приводим такты к тактам таймера
    130              uint16_t ticks_offset = (ticks - TOFFSET) & 0x7FFF;
    131              
    132              uint32_t cmp_time = timer & ~0x7FFF; // Убираем младшие 15 бит
    133              cmp_time |= ticks_offset; // Вычисляем новое время
    134              
    135              if (cmp_time <= timer)
    136              {
    137                cmp_time += 0x8000;
    138                cmp_time &=0xFFFFFF;
    139              }
    140                
    141               LOG_OFF("Timer = %lu, Ticks = %d,CMP = %lu \r\n",
    142                    timer, ticks, cmp_time );
    143              return cmp_time;
    144          }
    145          
    146          /**
    147          @brief Устанавливает время прерывания
    148          @details Время прерывания устанавливается относительно времени сети
    149          ,к примеру, что бы проснуться в таймслот номер 0, нужно установить ticks = 0.
    150          Процедура учитывает текущее значение таймера и перерасчитывает значение ticks. 
    151          @params[in] ticks время сети в тиках когда нужно проснуться
    152          */
    153          void NT_SetCompare(uint16_t ticks)
    154          {
    155            ASSERT(ticks < 32768);
    156            
    157            COMPARE_TIME = ticks; // Сохраняем установленное значение
    158           
    159            uint32_t compare_time = calcCompareTime(ticks);
    160           
    161            loadTimerCompare(compare_time);
    162            NT_IRQEnable(true);
    163          }
    164          
    165          /**
    166          @brief Разрешение прерываний таймера сна
    167          @params[in] state = true - разрешить обработку прерываний
    168          */
    169          static inline void NT_IRQEnable(bool state)
    170          {
    171            STIF = 0;
    172            if (state)
    173            {
    174              STIE = 1;
    175            }
    176            else
    177            {
    178              STIE = 0;
    179            }
    180          }
    181          
    182          /**
    183          @brief Проверка активности прерывания таймера
    184          @return true если прерывание установленно
    185          */
    186          static inline bool isIRQEnable(void)
    187          {
    188            if (STIE)
    189              return true;
    190            else 
    191              return false;
    192          }
    193          
    194          /**
    195          @brief Устанавливает обработчик прерывания таймера
    196          @param[in] fn(uint16_t ticks) указатель на функцию-обработчик
    197          */
    198          void NT_SetEventCallback(void (*fn)(uint16_t ticks))
    199          {
    200            EventCallback = fn;
    201          }
    202          
    203          /**
    204          @brief Возвращает время сети 
    205          @return Время сети в тиках
    206          */
    207          uint16_t NT_GetTime(void)
    208          {
    209            uint32_t val = ReadTimer();
    210            // TOFFSET = NETWORK TIME - TIMER
    211            // NETWORK TIME = TIMER + TOFFSET
    212            val +=TOFFSET;
    213            val &= 0x7FFF; // Приводим значения таймера к 0-32767
    214            return val;
    215          }
    216          
    217          /**
    218          @brief Обработчик прерывания таймера сна
    219          */
    220          #pragma vector=ST_VECTOR
    221          __interrupt void TimerCompareInterrupt(void)
    222          {  
    223            uint16_t ticks = NT_GetTime();
    224            if (EventCallback == NULL)
    225              return;
    226            // Отключаем прерывание таймера. Забота пользователя его включить
    227            NT_IRQEnable(false); 
    228            EventCallback(ticks); // Вызываем пользовательский обработчик
    229            STIF = 0; // Очищаем флаг прерывания
    230          }
    231          
    232          /**
    233          @breif Ожидание наступления времени сети
    234          @param[in] ticks время в тактах
    235          @return фактическое время сети
    236          */
    237          uint16_t NT_WaitTime(uint16_t ticks)
    238          {
    239            static union 
    240            {
    241              uint32_t val;
    242              uint8_t fild[4];
    243            } val;
    244            
    245            val.val = 0;
    246            // TOFFSET = NETWORK TIME - TIMER
    247            // NETWORK TIME = TIMER + TOFFSET
    248            
    249            // Ждем синхронизацию таймера после пробуждения
    250            while (!(SLEEPSTA & 0x01));
    251            
    252            do
    253            {
    254              // Соблюдаем порядок чтения регисторов ST  
    255              val.fild[0] = ST0;
    256              val.fild[1] = ST1;
    257              val.fild[2] = ST2;
    258              val.val +=TOFFSET;
    259              val.val &= 0x7FFF; // Приводим значения таймера к 0-32767    
    260            } while (val.val < ticks);
    261            return val.val;
    262          }
    263          
    264          /**
    265          @brief Возвращает текущее значение таймера
    266          @return Текущие ticks
    267          */
    268          static uint32_t ReadTimer(void)
    269          {
    270            static union 
    271            {
    272              uint32_t val;
    273              uint8_t fild[4];
    274            } ret_val;
    275            
    276            ret_val.val = 0;
    277            
    278            // Ждем синхронизацию таймера после пробуждения
    279            while (!(SLEEPSTA & 0x01));
    280            
    281            // Соблюдаем порядок чтения регисторов ST  
    282            ret_val.fild[0] = ST0;
    283            ret_val.fild[1] = ST1;
    284            ret_val.fild[2] = ST2;
    285            return ret_val.val;
    286          }
    287          
    288          /**
    289          @brief Устанавливает время пробуждения микроконтролера
    290          @params[in] ticks 24 битное значение времени пробуждения в ticks
    291          */
    292          static void loadTimerCompare(uint32_t ticks)
    293          {
    294            union 
    295            {
    296              uint32_t val;
    297              uint8_t fild[4];
    298            } value;
    299            
    300            value.val = ticks;
    301            
    302            // Ждем разрешения на запись нового значения
    303            while (!(STLOAD & 0x01));
    304            
    305            // Регистр ST0 должен быть записан в последнию очередь
    306            ST2 = value.fild[2];
    307            ST1 = value.fild[1];
    308            ST0 = value.fild[0];
    309          }
\\vmware-host\Shared Folders\Projects\WMNU\IAR\SHARE_PRJ_SRC\nwdebuger.c
      1          #include "nwdebuger.h"
      2          #include "ioCC2530.h"
      3          #include "stdint.h"
      4          #include "stdio.h"
      5          
      6          // Настройка порта uart для отладки
      7          static void uart_init(void)
      8          {
      9            // Выбор расположения UART на выводах
     10            uint8_t U0CFG = 0; // 0={TX=P0_3, RX=P0_2
     11            PERCFG |= (U0CFG<<0); 
     12            
     13            // U0UCR регистр настройки режима uart. меня устраивает по умолчанию
     14            U0CSR = (1<<7); // Выбираем режим uart 
     15            
     16            // Настройка скорости передачи данных на 2М  
     17            U0BAUD = 0;  // табличные значения из pdf
     18            U0GCR =  16;
     19            
     20            // Включаем альтернативные функции выводов
     21            P0SEL = (1<<2)|(1<<3);
     22          }
     23          
     24          static void SetCPU32M(void)
     25          {
     26            CLKCONCMD = 0x88;
     27            while (CLKCONSTA&(1<<6));
     28          }
     29          
     30          void nwDebugerInit(void)
     31          {
     32           // SetCPU32M();
     33          #ifdef UART_DEBUG
     34            uart_init();
     35          #endif
     36          }
     37          
     38          __attribute__((weak)) void STACK_FAILURE(char* msg)
     39          {
     40            LOG_ON("STACK FAILURE. HALT");
     41            while(1);
     42          }
     43          
     44          // Переопределяем функцию записи в порт
     45          #ifdef UART_DEBUG
     46          #include <yfuns.h>
     47          
     48          _STD_BEGIN
     49          
     50          #pragma module_name = "?__write"
     51          
     52          int MyLowLevelPutchar(int x);
     53          
     54          int MyLowLevelPutchar(int x){
     55            while( U0CSR&(1<<0));
     56            U0DBUF = x;
     57            return x;
     58          }
     59          /*
     60           * If the __write implementation uses internal buffering, uncomment
     61           * the following line to ensure that we are called with "buffer" as 0
     62           * (i.e. flush) when the application terminates.
     63           */
     64          
     65          size_t __write(int handle, const unsigned char * buffer, size_t size)
     66          {
     67            /* Remove the #if #endif pair to enable the implementation */
     68             
     69          
     70            size_t nChars = 0;
     71          
     72            if (buffer == 0)
     73            {
     74              /*
     75               * This means that we should flush internal buffers.  Since we
     76               * don't we just return.  (Remember, "handle" == -1 means that all
     77               * handles should be flushed.)
     78               */
     79              return 0;
     80            }
     81          
     82            /* This template only writes to "standard out" and "standard err",
     83             * for all other file handles it returns failure. */
     84            if (handle != _LLIO_STDOUT && handle != _LLIO_STDERR)
     85            {
     86              return _LLIO_ERROR;
     87            }
     88          
     89            for (/* Empty */; size != 0; --size)
     90            {
     91              if (MyLowLevelPutchar(*buffer++) < 0)
     92              {
     93                return _LLIO_ERROR;
     94              }
     95          
     96              ++nChars;
     97            }
     98          
     99            return nChars;
    100          
    101          }
    102          
    103          _STD_END
    104          #endif
\\vmware-host\Shared Folders\Projects\WMNU\IAR\SHARE_PRJ_SRC\RADIO.c
      1          /*!
      2          \file 
      3          \brief Модуль содержит реализацию интерфейса радио для приема/передачи данных.
      4          */
      5          
      6          #include "RADIO.h"
      7          #include "mem.h"
      8          #include "nwdebuger.h"
      9          #include "Radio_defs.h"
     10          #include "TIC.h"
     11          #include "delays.h"
     12          #include "frame.h"
     13          #include "string.h"
     14          #include "NTMR.h"
     15          
     16          // Открытые методы модуля
     17          void RI_init(void);
     18          bool RI_SetChannel(uint8_t CH);
     19          bool RI_Send(frame_s *fr);
     20          frame_s* RI_Receive(uint16_t timeout);
     21          uint32_t RI_GetCRCError(void);
     22          uint32_t RI_GetCCAReject(void);
     23          float RI_GetUptime(void);
     24          
     25          // Приватные методы
     26          static void random_core_init(void);
     27          static void RI_cfg(void);
     28          
     29          static inline void setFreq(uint8_t CH); // Установка частоты передатчика
     30          static void LoadTXData(uint8_t *src, uint8_t len); // Загрузка данных в tx buf
     31          static void UnLoadRXData(uint8_t *src, uint8_t len);
     32          static bool SendData(frame_s *fc);
     33          static bool RecvData(uint32_t timeout_us, uint16_t *SFD_TimeStamp);
     34          
     35          // Переменные модуля
     36          static float RI_UPTIME = 0; // Время работы радио в мс. 49 дней максимум
     37          static uint32_t RI_CRC_ERROR = 0; // Количество ошибок CRC
     38          static uint32_t RI_CCA_REJECT = 0; // Количество отказов передач из-за CCA
     39          
     40          /*!
     41          \brief Константы для установки выходной мощности радиопередатчика.
     42          Пример: p4x5 = +4,5 дБ. m0x5 = -0.5 дБ
     43          */
     44          enum TX_POWER_e 
     45          {
     46            // +4.5дБ = p4x5, -1.5дБ = m1x5.
     47            // +4.5 = 34мА, +1 = 29мА, -4 = 26мА, -10 = 25 мА, -22 = 23 мА
     48            p4x5 = 0xF5, p2x5 = 0xE5, p1x0 = 0xD5, m0x5 = 0xC5, m1x5 = 0xB5, m3x0 = 0xA5,
     49            m4x0 = 0x95, m6x0 = 0x85, m8x0 = 0x75, m10x0 = 0x65, m12x0 = 0x55, 
     50            m14x0 = 0x45, m16x0 = 0x35, m20x0 = 0x15, m22x0 = 0x05
     51          };
     52          
     53          
     54          #define IEEE_MODE 0     //!< Режимы фазы сигнала
     55          #define NOT_IEEE_MODE 1 //!< Режимы фазы сигнала
     56          #define RSSI_OFFSET -76 //!< Константа для вычисления реальной мощности
     57          
     58          /*!
     59          \details 
     60           Расчет качества связи. Коэффициенты получаются эксперементально.
     61           Есть предположение, что количество ошибок будет пропорционально квадрату
     62           коеффициента корреляции сигнала.
     63           LIQ = 255 передача 1000 пакетов без ошибок CRC
     64           LIQ = 127 передача 1000 пакетов с 50% ошибок CRC
     65           LIQ = 0   передача 1000 пакетов с 100% ошибок CRC
     66          */ 
     67          #define CONST_A (int8_t)0 //!< Коэффициент A
     68          #define CONST_B (int8_t)1 //!< Коэффициент B
     69          #define LIQ_CALC(corr) ((corr-CONST_A)*CONST_B) //!< Формула вычисление LIQ 
     70          #define FRQ_CALC(x) (11+5*(x-11)) //!< Формул вычисления частоты сигнала
     71          
     72          /// Глобальные параметры модуля
     73          struct
     74          {
     75            uint8_t CH;       //!< Номер канала с 11 до 28 включительно
     76            uint8_t TX_POWER; //!< Мощность радиопередатчика по умолчанию. 7 бит
     77            bool MODULATION_MODE; //!< false - совместимость с IEEE 802.15.4
     78          } RADIO_CFG;
     79          
     80          /*!
     81          \brief Иницилизация радио интерфейса
     82          */
     83          void RI_init(void)
     84          {
     85            // Настройки поумолчанию
     86            RADIO_CFG.CH = CH11;
     87            RADIO_CFG.TX_POWER = m0x5;
     88            RADIO_CFG.MODULATION_MODE = IEEE_MODE;
     89            // Пост действия с радио
     90            random_core_init();
     91          }
     92          
     93          /*!
     94          \brief Переводит радио в активный режим и устанавливает параметры.
     95          */
     96          static void RI_cfg(void)
     97          {
     98          /*
     99          APPEND_DATA_MODE = 0. FCS1 = signed rssi, FCS2.7 CRC OK, FCS2.6-0 Correlation
    100          A correlation value of ~110 indicates a maximum quality frame while a value 
    101          of ~50 is typically the lowest quality frames detectable by CC2520. 
    102          */
    103          /* После включения радио находится в активном режиме но приемник выключен */
    104            
    105            // Устанавливаем частоту радиопередатчика
    106            setFreq(RADIO_CFG.CH);
    107            
    108            // Устанавливаем мощность выходного сигнала
    109            TXPOWER = RADIO_CFG.TX_POWER;
    110           
    111            FRMFILT0 = 0x00; // Отключаем фильтрацию пакетов
    112            
    113            // Устанавливаем режим модуляции
    114            MDMTEST1_u MDM1;
    115            MDM1.value = MDMTEST1;
    116            MDM1.bits.MODULATION_MODE = RADIO_CFG.MODULATION_MODE;
    117            MDMTEST1 = MDM1.value; 
    118          }
    119          
    120          /*!
    121          \brief Устанавливает канал радиопередатчика.
    122          \param[in] CH Номера каналов [11..28]
    123          \return Возвращает true если аргументы верны
    124          */
    125          bool RI_SetChannel(uint8_t CH)
    126          {
    127            if ((CH >=11) && (CH<=28))
    128            {
    129              RADIO_CFG.CH = CH;
    130              return true;
    131            }
    132            return false;
    133          }
    134          
    135          /*!
    136          \brief Передает данные в эфир
    137          \details Увеличивает  RI_CCA_REJECT при невозможности отправки сообщения, расчитывает время работы 
    138           радио передатчика. Отправка сообщения в заданное сетевое время 
    139           fr->meta.SEND_TIME. Если равно 0, то отправка через случайноу время в мкс.
    140           Данные автоматически оборачиваются в LEN, CRC1,CRC2
    141          \param[in] *fr Указатель на структуру frame_s RAW_LAY
    142          \return Возвращает true в случаи успешной передачи
    143          */
    144          bool RI_Send(frame_s *fr)
    145          {
    146            ASSERT(fr != NULL);
    147            
    148            // Устанавливаем частоту передачи пакета
    149            RI_cfg();
    150            
    151            bool send_res; // Результат передачи данных
    152            TimeStamp_s start,stop; // Измерение времени
    153            
    154            TIM_TimeStamp(&start); // Начало измерения времени
    155            send_res = SendData(fr);
    156            TIM_TimeStamp(&stop); // Конец измерения времени
    157            
    158            uint32_t passed = TIM_passedTime(&start, &stop);
    159            RI_UPTIME += (float)passed/1000; // Микросекунды в милисекунды
    160            
    161            // В случаи ошибки передачи увеличиваем счетчик RI_CCA_REJECT
    162            if (!send_res)
    163              RI_CCA_REJECT++;
    164            
    165            return send_res;
    166          }
    167          
    168          /**
    169          @brief Отправка сообщения
    170          @detail Время отправки с шифрованием 10 байт в мкс. Merge = 155, Crypt = 239,
    171           Load TX = 30, RSSI_OK = 328, ISTXON = 11, SFD(192us+5*8*4us) = 400, TX = 370, Full = 1535.
    172          Время работы радио RSSI_OK+ISTXON+SFD+TX = 1109 us
    173          @return true в случаи успеха
    174          */
    175          static bool SendData(frame_s *fr)
    176          {
    177          ////TimeStamp_s ts_start, ts_frame_merge, ts_crypt, ts_load_tx, 
    178          ////ts_rssistat, ts_istxon, ts_sfd, ts_stop;
    179            
    180          ////TIM_TimeStamp(&ts_start);  
    181                
    182          ////TIM_TimeStamp(&ts_frame_merge);  
    183            bool result = true;
    184            switch(true)
    185            {
    186              case true:
    187          ////TIM_TimeStamp(&ts_crypt); 
    188                // Копируем данные в буфер. Очистка буфера автоматическая
    189                LoadTXData(fr->payload, fr->len);
    190          ////TIM_TimeStamp(&ts_load_tx); 
    191                // Для начала передачи по команде STXONCCA нужно включить приемник
    192                ISRXON();
    193                // Ждем пока статус RSSI_VALID станет true
    194                while(!RSSISTAT);
    195          ////TIM_TimeStamp(&ts_rssistat); 
    196                // Очищаем флаг завершения передачи сообщения
    197                RFIRQF1 &= ~RFIRQF1_TXDONE;
    198                RFIRQF0 &= ~RFIRQF0_SFD;
    199                
    200                // Время отправки сообщения измеряется в тактах сетевого времени NTMR
    201                // Он работатаеи намного лучше чем MAC таймер(меньше погрешность)
    202                // Отправка в обозначенное время или по факту готовности
    203                //13 - поправка в тактах сети на передачу преамболы
    204                uint16_t timer = 0; // Для отлалки. 
                                ^
Warning[Pe550]: variable "timer" was set but never used
          detected during compilation of secondary translation unit
                    "\\vmware-host\Shared
                    Folders\Projects\WMNU\IAR\SHARE_PRJ_SRC\RADIO.c"

  static bool master_mode()
              ^
"\\vmware-host\Shared Folders\Projects\WMNU\IAR\SHARE_PRJ_SRC\manager.c",90  Warning[Pe177]: 
          function "master_mode" was declared but never referenced
          detected during compilation of secondary translation unit
                    "\\vmware-host\Shared
                    Folders\Projects\WMNU\IAR\SHARE_PRJ_SRC\manager.c"

  static void SetCPU32M(void)
              ^
"\\vmware-host\Shared Folders\Projects\WMNU\IAR\SHARE_PRJ_SRC\nwdebuger.c",24  Warning[Pe177]: 
          function "SetCPU32M" was declared but never referenced
          detected during compilation of secondary translation unit
                    "\\vmware-host\Shared
                    Folders\Projects\WMNU\IAR\SHARE_PRJ_SRC\nwdebuger.c"
    205                if (fr->meta.SEND_TIME != 0)
    206                  timer = NT_WaitTime(fr->meta.SEND_TIME - 13); 
    207          
    208                // Начинаем передачу данных
    209                // Transmission of preamble begins 192 μs after the STXON or STXONCCA 
    210                // command strobe
    211                // 192+(4(pream)+1(sfd))*8bit*4us = 352 мкс. Измерил 360мкс
    212                // Измерил в тактах NT_GetTimer() получилось 13 тиков. 396 мкс 
    213                ISTXONCCA();
    214          ////TIM_TimeStamp(&ts_istxon); 
    215                // Произошла ошибка передачи если SAMPLED_CCA false
    216                if (!(FSMSTAT1 & 1<<3)) //SAMPLED_CCA == 0
    217                {
    218                  result = false;
    219                  break;
    220                }
    221          
    222                // Ждем завершения отправки SFD
    223                while (!(RFIRQF0 & RFIRQF0_SFD));
    224                fr->meta.TIMESTAMP = NT_GetTime(); 
    225          ////TIM_TimeStamp(&ts_sfd); 
    226                // Проверим переданно ли сообщение TX_FRM_DONE
    227                while (!(RFIRQF1 & RFIRQF1_TXDONE));
    228                break;
    229            }
    230          ////TIM_TimeStamp(&ts_stop);
    231            
    232            ISRFOFF();
    233          ////  LOG(MSG_ON | MSG_INFO | MSG_TRACE, 
    234          ////"Merge = %lu. Crypt = %lu. Load TX = %lu. RSSI_OK = %lu. ISTXON = %lu. SFD = %lu. TX = %lu. FULL = %lu \n", 
    235          ////      TIM_passedTime(&ts_start, &ts_frame_merge),
    236          ////      TIM_passedTime(&ts_frame_merge, &ts_crypt),
    237          ////      TIM_passedTime(&ts_crypt, &ts_load_tx),
    238          ////      TIM_passedTime(&ts_load_tx, &ts_rssistat),
    239          ////      TIM_passedTime(&ts_rssistat, &ts_istxon),
    240          ////      TIM_passedTime(&ts_istxon, &ts_sfd),
    241          ////      TIM_passedTime(&ts_sfd, &ts_stop),
    242          ////      TIM_passedTime(&ts_start, &ts_stop)
    243          ////      );
    244            
    245            if (result)
    246              return true;
    247            return false; 
    248          }
    249          
    250          /**
    251          @brief Загрузка данных для передачи в буфер. 
    252          @detail Поля LEN, FCS1, FCS2 добавляются автоматически
    253          @param[in] src указатель на данные
    254          @param[in] len размер данных
    255          */
    256          static void LoadTXData(uint8_t *src, uint8_t len)
    257          {
    258            // Очищаем буфер передатчика
    259            ISFLUSHTX(); 
    260            // Поле LEN на два байта больше
    261            RFD = len + 2;
    262            
    263            for (uint8_t i = 0 ; i < len; i++)
    264              RFD = src[i];
    265            
    266            // Добавляем CRC1,2
    267            RFD = 0x00;
    268            RFD = 0x00;
    269          };
    270          
    271          /**
    272          @brief Выгружаем принятый пакет из радио
    273          @param[out] src указатель на буфер приемника
    274          @param[in] len размер выгружаемых данных
    275          */
    276          static void UnLoadRXData(uint8_t *src, uint8_t len)
    277          {
    278            for (uint8_t i = 0 ; i < len; i++)
    279              src[i] = RFD;
    280          };
    281          
    282          static inline void setFreq(uint8_t CH)
    283          {
    284            ASSERT( (CH >= 11) && (CH <= 28));
    285            // Устанавливаем частоту радиопередатчика
    286            FREQCTRL_u FRQ;
    287            FRQ.value = FRQ_CALC(RADIO_CFG.CH);
    288            FREQCTRL = FRQ.value;  
    289          }
    290          
    291          /*!
    292          \brief Принимает данные из эфира
    293          \details Функция принимает данные из эфира. Проводит проверку CRC, увеличивает
    294          RI_CRC_ERROR. Отмечает время прихода SFD в тактах сетевого времени .
    295          \param[in] timeout Время ожидания данных в милисекундах
    296          \return Возвращает NULL если данных нет
    297          */
    298          frame_s* RI_Receive(uint16_t timeout)
    299          {
    300            // Устанавливаем частоту передачи пакета
    301            RI_cfg();
    302            uint16_t SFD_TimeStamp;
    303            
    304            // Принимаем пакет 
    305            uint32_t timeout_us = timeout*1000UL; // Переводим мс->мкс
    306            TimeStamp_s start,stop; // Измерение времени
    307            TIM_TimeStamp(&start); // Начало измерения времени работы радио
    308            bool recv_res = RecvData(timeout_us, &SFD_TimeStamp);
    309            TIM_TimeStamp(&stop); // Конец измерения времени радио
    310            uint32_t passed = TIM_passedTime(&start, &stop);
    311            RI_UPTIME += (float)passed/(float)1000; // Микросекунды в милисекунды
    312            
    313            // Если ничего не приняли возвращаем NULL
    314            if (!recv_res)
    315              return NULL;
    316            
    317            uint8_t frame_size = RXFIFOCNT; // Количество принятых данных
    318            
    319            // Минимальный размер FCS1,FCS2 - 2 байта. LEN не включен в подсчет 
    320            if (frame_size <= 2)
    321              return NULL;
    322            
    323            // Выгружаем данные из приемника
    324            uint8_t *frame_raw = re_malloc(frame_size); 
    325            UnLoadRXData(frame_raw, frame_size);
    326            
    327            int8_t  FCS1 = frame_raw[frame_size - 2]; // RSSI
    328            uint8_t FCS2 = frame_raw[frame_size - 1]; // bit7 = CRCOK, bit[6..0] Corr_val
    329            uint8_t LEN_F = frame_raw[0]; // Поле LEN
    330            
    331            // Проверим поле LEN. Размер данных в заголовке должен совпадать
    332            // с фактической длинной принятых данных
    333            if (LEN_F != frame_size - 1)
    334            {
    335              re_free(frame_raw);
    336              RI_CRC_ERROR ++;
    337              return NULL;
    338            }
    339            
    340            // Проверим поле CRCOK
    341            if (!(FCS2 && 1<<7))
    342            {
    343              re_free(frame_raw);
    344              RI_CRC_ERROR ++;
    345              return NULL;
    346            }
    347            
    348            // Создаем буфер, последнии два байта FCS1,2 и поле LEN не копируем
    349            frame_s *raw_frame = frame_create();
    350            frame_addHeader(raw_frame, &frame_raw[1], frame_size - 3);
    351            
    352            // Копируем метку времени SFD
    353            raw_frame->meta.TIMESTAMP = SFD_TimeStamp;
    354            
    355            // Расчитываем мощность принятого сигнала
    356            raw_frame->meta.RSSI_SIG =  FCS1 + RSSI_OFFSET;
    357            // Расчитываем качество сигнала
    358            uint8_t corr = FCS2 & 0x7F;
    359            raw_frame->meta.LIQ = LIQ_CALC(corr); // Значение коэфф. корреляции
    360          
    361            raw_frame->meta.CH = RADIO_CFG.CH;
    362          
    363            re_free(frame_raw);
    364            return raw_frame;
    365          }
    366          
    367          /**
    368          @brief Прием данных из эфира
    369          @param[in] timeout_us время ожидания в микросекундах
    370          @param[out] SFD_TimeStamp отметка времени завершения приема SFD
    371          */
    372          static bool RecvData(uint32_t timeout_us, uint16_t *SFD_TimeStamp)
    373          {
    374            TimeStamp_s start,stop; // Измерение времени  
    375            ISFLUSHRX(); // Очищаем буфер приема
    376            
    377            TIM_TimeStamp(&start);
    378            
    379            // Очищаем флаг завершения передачи сообщения и приема SFD
    380            RFIRQF0 &= ~RFIRQF0_RXPKTDONE;  
    381            RFIRQF0 &= ~RFIRQF0_SFD; 
    382            ISRXON(); // Включаем радиопередатчик
    383          
    384            bool time_out = false; // Истекло время ожидания пакета
    385            bool packet_received = false; // Приняли пакет
    386            bool sfd_received = false; // Приняли sfd
    387            
    388            // Цикл приема пакета
    389            while (true)
    390            {
    391              TIM_TimeStamp(&stop);
    392              if (TIM_passedTime(&start, &stop) >= timeout_us)
    393              {
    394                time_out = true;
    395                break;
    396              }
    397             
    398              // Принят сигнал SFD
    399              if ((RFIRQF0 & RFIRQF0_SFD))
    400              {
    401                *SFD_TimeStamp = NT_GetTime(); 
    402                sfd_received = true;
    403              }
    404              
    405              //  Завершен ли прием сообщения RX_FRM_DONE (RXPKTDONE)
    406              if ((RFIRQF0 & RFIRQF0_RXPKTDONE))
    407              {
    408                packet_received = true;
    409                break;
    410              }
    411            } // while 
    412            
    413            ISRFOFF();
    414            if (packet_received && sfd_received && !time_out)
    415              return true;
    416            else
    417              return false;
    418          }
    419          
    420          /*!
    421          \brief Возвращает количество ошибок возникших с момента иницилизации
    422          \return Количество CRC ошибок
    423          */
    424          uint32_t RI_GetCRCError(void)
    425          {
    426            return RI_CRC_ERROR;
    427          }
    428          
    429          /*!
    430          \brief Возвращает количестов отказов передачи пакета из-за занятости канала.
    431          \return Количество отказов CCA
    432          */
    433          uint32_t RI_GetCCAReject(void)
    434          {
    435            return RI_CCA_REJECT;
    436          }
    437          
    438          /*!
    439          \brief Возвращает суммарное время работы радио в режиме прием/передача
    440          \return Вермя в милисекундах
    441          */
    442          float RI_GetUptime(void)
    443          {
    444            return RI_UPTIME;
    445          }
    446          
    447          /**
    448          @breif Подссчет количества бит в байте
    449          @return Возвращает количество бит
    450          */
    451          static uint8_t bits_count(uint8_t value) {
    452            int ret = 0;
    453            for ( ; value; value = value >> 1 )
    454              ret += value & 1;
    455            return ret;
    456          }
    457          
    458          /**
    459          @brief Возращает 1 байт случайного числа
    460          @details Радио выдает всего лишь дви бита, нам нужно 8 
    461          */
    462          static inline uint8_t getRNDByte(void)
    463          {
    464            uint8_t val = 0;
    465            val |= RFRND << 0;
    466            val |= RFRND << 2;
    467            val |= RFRND << 4;
    468            val |= RFRND << 6;
    469            return val;
    470          }
    471          
    472          /**
    473          @brief Возвращает случайное число с числом включеных бит от 2 до 6 включительно
    474          @details Случайные числа появляются в регистре с частотой 170нс. Функция 
    475          возвращает гарантированно новое значение. 
    476          @return возвращает случайное число.
    477          */
    478          static inline uint8_t readRandom(void)
    479          {
    480            uint8_t rnd_val = 0;
    481            uint8_t bit_cnt = 0;
    482            while ( bit_cnt <= 2 || bit_cnt >= 6 )
    483            {
    484              rnd_val = getRNDByte();
    485              while (rnd_val == getRNDByte());
    486              rnd_val = getRNDByte();
    487              bit_cnt = bits_count(rnd_val);
    488            }
    489            return rnd_val;
    490          }
    491          
    492          /*!
    493          \brief Иницилизирует ядро генератора случайных чисел данными из эфира
    494          */
    495          static void random_core_init(void)  
    496          {
    497            unsigned int rnd_core = 0;;
    498               
    499            RI_cfg();
    500            FREQCTRL = 0x00; // Выбираем не используемую частоту
    501          
    502            // TODO По какой то причине OP_EXE не выполняет команду.
    503            // регистра RFST читается как 0xD0. это его состояние при reset
    504            // Включаем демодулятор
    505            ISRXON();
    506            
    507            // Ждем пока статус RSSI_VALID станет true
    508            while(!RSSISTAT);
    509            
    510            // Ждем случайных чисел
    511            while (RFRND == 0);
    512            
    513            // Настраиваем ядро случайного генератора
    514            rnd_core = readRandom();
    515            rnd_core |= (unsigned int)readRandom()<<8;
    516            srand(rnd_core);
    517            
    518            // Включаем демодулятор
    519            ISRFOFF();
    520            // Первая генерация случайного числа занимает много времени.
    521            // Влияло на работу радио, так как использовались случайные посылки
    522            rand(); 
    523          }
    524          
\\vmware-host\Shared Folders\Projects\WMNU\IAR\SHARE_PRJ_SRC\sync.c
      1          #include "stdlib.h"
      2          #include "basic.h"
      3          #include "frame.h"
      4          #include "string.h"
      5          #include "nwdebuger.h"
      6          #include "coder.h"
      7          #include "TIC.h"
      8          #include "RADIO.h"
      9          #include "NTMR.h"
     10          #include "config.h"
     11          #include "ioCC2530.h" // ОТЛАДДКА
     12          
     13          void SY_Init(void);
     14          void SY_Reset(void);
     15          void SY_setIV(void* ptr_IV);
     16          void SY_setKEY(void* ptr_KEY);
     17          bool SY_SYNC_NETWORK(uint16_t *panid,uint16_t timeout);
     18          void SY_Enable(bool en);
     19          uint32_t SY_sync_sended(void);
     20          
     21          static void SY_TS1_HNDL_MASTER(void);
     22          static void SY_TS1_HNDL_SLAVE(void);
     23          static void SY_TIME_ALLOC_SLAVE(void);
     24          static void SY_TIME_ALLOC_MASTER(void);
     25          static void BitRawDecrypt(uint8_t *src, uint8_t size);
     26          static void BitRawCrypt(uint8_t *src, uint8_t size);
     27          static frame_s* get_sync(uint16_t timeout);
     28          static bool send_sync(void);
     29          
     30          static uint32_t LAST_SYNC_TIME = 0; //!< Время последней синхр.
     31          static uint32_t NEXT_SYNC_TIME = 0; //!< Время следующей синхр.
     32          static uint32_t SYNC_SENDED = 0; //!< Количество успешно ретранслированых пакетов
     33          static bool NEED_SEND_SYNC = false; //!< Нужно отослать синхропакет
     34          static bool SY_ENABLE_MODULE = false;
     35          
     36          // Ключ потокового шифрования и вектор иницилизации
     37          static uint8_t KEY[16] = DEFAULT_KEY;
     38          static uint8_t IV[16] = DEFAULT_IV;
     39          //@brief Точное время приема/передачи пакета синхронизации времени
     40          // Расчитывается при иницилизации
     41          static uint16_t SYNC_ACCURATE_NETWORK_TIME; 
     42          
     43          #define SYNC_TS 1 //!< Номер временного слота синхросигнала
     44          #define SYNC_RECV_TIMEOUT 2 // Время ожидания приема пакета в мс
     45          #define SYNC_TIMEOUT 110//!< Время в сек после которого сеть не синхронна
     46          
     47          typedef struct // Формат структуры пакета синхронизации
     48          {
     49              uint16_t panid;
     50              uint32_t magic;
     51          } __attribute__((packed)) SYNC_s;
     52          
     53          #define MAGIC 0x19833891 // Проверка что пакет действительно sync
     54          #define RAND_SYNC_RX_DELAY  9 // Фиксированое время приема rand()%10 + 5
     55          #define RAND_SYNC_TX_DELAY  10 // Фиксированное время передачи сигнала
     56          // Максимальное отклонение при приеме sync в тактах сети
     57          #define SYNC_TIME_DRIFT 35  
     58          
     59          #ifdef GATEWAY
     60            #define SYNC_MASTER     // Если определено, то узел является шлюзом
     61          #endif
     62          
     63          void SY_Init(void)
     64          {
     65            SYNC_SENDED = 0;
     66            LAST_SYNC_TIME = 0;
     67            NEXT_SYNC_TIME = 0;
     68            SY_ENABLE_MODULE = false;
     69            SYNC_ACCURATE_NETWORK_TIME = TIC_SlotTime(SYNC_TS) + TIC_SlotActivityTime()/2;
     70          #ifdef SYNC_MASTER
     71            TIC_SetTS1Callback(SY_TS1_HNDL_MASTER);
     72            TIC_SetSyncTimeAllocCallback(SY_TIME_ALLOC_MASTER);
     73          #else
     74            TIC_SetTS1Callback(SY_TS1_HNDL_SLAVE);
     75            TIC_SetSyncTimeAllocCallback(SY_TIME_ALLOC_SLAVE);
     76          #endif
     77          }
     78          
     79          void SY_Reset(void)
     80          {
     81            SYNC_SENDED = 0;
     82            LAST_SYNC_TIME = 0;
     83            NEXT_SYNC_TIME = 0;
     84            SY_ENABLE_MODULE = false;
     85          }
     86          
     87          void SY_Enable(bool en)
     88          {
     89            SY_ENABLE_MODULE = en;
     90          }
     91          
     92          /**
     93          @brief Количество успешно переданных пакетов синхронизации
     94          @return Количечтво пакетов
     95          */
     96          uint32_t SY_sync_sended(void)
     97          {
     98            return SYNC_SENDED;
     99          }
    100          
    101          /**
    102          @brief Установить вектор иницилизации для шифрования
    103          @param[in] ptr_IV указатель на 16 байтный вектор иницилизации
    104          */
    105          void SY_setIV(void* ptr_IV)
    106          {
    107            memcpy(IV, ptr_IV, 16);
    108          }
    109          
    110          /**
    111          @brief Установить ключ шифрования
    112          @param[in] ptr_KEY указатель на 16 байтный ключ
    113          */
    114          void SY_setKEY(void* ptr_KEY)
    115          {
    116            memcpy(KEY, ptr_KEY, 16);
    117          }
    118          
    119          /**
    120          @brief Эта функция вызывается после каждого завершенного слота времени
    121          */
    122          static void SY_TIME_ALLOC_SLAVE(void)
    123          { 
    124            if (!SY_ENABLE_MODULE) // Модуль отключен
    125              return;  
    126            
    127            // Потеря синхронизации
    128            if ( (TIC_GetUptime() - LAST_SYNC_TIME) > SYNC_TIMEOUT)
    129            {
    130                LOG_ON("Network out of sync.");
    131                return;
    132            }
    133            
    134            if (TIC_GetRXState(SYNC_TS)) // Если прием уже активен
    135              return;
    136            
    137            // Ретрансляция синхропакета
    138            if (NEED_SEND_SYNC)
    139            {
    140              LOG_OFF("Need to send resync");
    141              TIC_SetRXState(SYNC_TS, true);
    142              return;
    143            }
    144            
    145            // Необходимо начать процесс синхронизации
    146            if (TIC_GetUptime() > NEXT_SYNC_TIME)
    147            {
    148              LOG_ON("Begin resync");
    149              P1_0 = !true; 
    150              TIC_SetRXState(SYNC_TS, true);
    151            }
    152          }
    153          
    154          /**
    155          @brief Эта функция вызывается после каждого завершенного слота времени
    156          */
    157          static void SY_TIME_ALLOC_MASTER(void)
    158          { 
    159            static uint32_t sync_send_time = 0;
    160           
    161            if (!SY_ENABLE_MODULE) // Модуль отключен
    162            {
    163              sync_send_time = 0;
    164              return;  
    165            }
    166            
    167            if (TIC_GetTXState(SYNC_TS)) // Если передача уже активна.
    168              return;
    169            
    170            uint32_t now = TIC_GetUptime();
    171            if ( now < sync_send_time) // Если время новой передачи не наступило
    172              return;
    173            
    174            TIC_SetTXState(SYNC_TS,true); // Разрешаем передачу
    175             
    176             // Определяем следующее время передачи
    177             sync_send_time = now + RAND_SYNC_TX_DELAY;
    178          }
    179          
    180          /**
    181          @brief Вызывает при активности TS1 RX или TX
    182          @detail Выполняет две функции: синхронизацию с сетью или передачу синхр.
    183          */
    184          static void SY_TS1_HNDL_SLAVE(void)
    185          {
    186            if (!SY_ENABLE_MODULE) // Модуль отключен
    187              return;
    188              
    189            // Нужно отослать синхропакет
    190            if (NEED_SEND_SYNC)
    191            {
    192              if (send_sync())
    193                SYNC_SENDED++;
    194              LOG_ON("Resync TX. CNT=%d",(uint16_t)SYNC_SENDED);
    195              NEED_SEND_SYNC = false;
    196              TIC_SetRXState(SYNC_TS, false);
    197            }
    198            
    199            // Ждем начала точного времени начала передачи сигнала заранее
    200            // Время в тактах сети
    201            NT_WaitTime(SYNC_ACCURATE_NETWORK_TIME - SYNC_TIME_DRIFT);
    202           
    203            RI_SetChannel(CONFIG.sync_channel);
    204            // Время в мс
    205            frame_s *fr_SYNC = get_sync(SYNC_RECV_TIMEOUT); 
    206            
    207            if (!fr_SYNC)
    208              return;
    209            
    210            SYNC_s *sync;
    211            sync = (SYNC_s*)fr_SYNC->payload;
    212            
    213            // Проверяем принадлежность пакета
    214            if (( sync->panid != CONFIG.panid) && (sync->magic != MAGIC))
    215            {
    216              frame_delete(fr_SYNC);
    217              return;
    218            }
    219            
    220            // Синхронизируемся
    221            // Время прошедшее с момента приема пакета в тактах сети
    222            uint16_t delta = TIC_GetTimer() - fr_SYNC->meta.TIMESTAMP;
    223            TIC_SetTimer(SYNC_ACCURATE_NETWORK_TIME + delta);
    224            
    225            LAST_SYNC_TIME = TIC_GetUptime();
    226            NEXT_SYNC_TIME = LAST_SYNC_TIME + RAND_SYNC_RX_DELAY; 
    227            TIC_SetRXState(SYNC_TS, false);
    228            LOG_ON("Node Synced. TS=%d, AT=%d, DEL=%d, AD=%d, RTC=%d, NRTC=%d",
    229                   fr_SYNC->meta.TIMESTAMP,SYNC_ACCURATE_NETWORK_TIME, delta,
    230                   SYNC_ACCURATE_NETWORK_TIME - fr_SYNC->meta.TIMESTAMP, 
    231                   (uint16_t)LAST_SYNC_TIME,
    232                   (uint16_t)NEXT_SYNC_TIME);
    233            frame_delete(fr_SYNC);
    234            // После приема нужно ретранслировать синхропакет
    235            NEED_SEND_SYNC = true; 
    236          P1_0 = !false; // ОТЛАДКА
    237          }
    238          
    239          /**
    240          @brief Вызывает при активносм TS1 RX или TX
    241          @detail Формирует кадр синхронизации и передает его в строго определенное время
    242          */
    243          static void SY_TS1_HNDL_MASTER(void)
                             ^
Warning[Pe177]: function "SY_TS1_HNDL_MASTER" was declared but never referenced
          detected during compilation of secondary translation unit
                    "\\vmware-host\Shared
                    Folders\Projects\WMNU\IAR\SHARE_PRJ_SRC\sync.c"

  static void SY_TIME_ALLOC_MASTER(void)
              ^
"\\vmware-host\Shared Folders\Projects\WMNU\IAR\SHARE_PRJ_SRC\sync.c",157  Warning[Pe177]: 
          function "SY_TIME_ALLOC_MASTER" was declared but never referenced
          detected during compilation of secondary translation unit
                    "\\vmware-host\Shared
                    Folders\Projects\WMNU\IAR\SHARE_PRJ_SRC\sync.c"
    244          {
    245            if (!SY_ENABLE_MODULE) // Модуль отключен
    246              return;  
    247             
    248          P1_0 = !true; //ОТЛАДКА  
    249            if (send_sync())
    250              SYNC_SENDED++;
    251            
    252            LOG_ON("Sync send."); 
    253          P1_0 = !false; //ОТЛАДКА
    254            
    255            TIC_SetTXState(SYNC_TS, false);
    256          }
    257          
    258          /**
    259          @brief Создать и отправить синхропакет
    260          */
    261          static bool send_sync(void)
    262          {
    263            SYNC_s sync;
    264            sync.panid = CONFIG.panid;
    265            sync.magic = MAGIC;
    266            
    267            frame_s *fr_SYNC = frame_create();
    268            frame_addHeader(fr_SYNC, &sync, sizeof(SYNC_s));
    269            fr_SYNC->meta.SEND_TIME = SYNC_ACCURATE_NETWORK_TIME; // время в тактах сети. ((1/32768)*164)*1000
    270              
    271          #ifdef RARIO_STREAM_ENCRYPT
    272            BitRawCrypt(fr_SYNC->payload, fr_SYNC->len);
    273          #endif
    274            
    275            RI_SetChannel(CONFIG.sync_channel);
    276            bool res = RI_Send(fr_SYNC);
    277            
    278            frame_delete(fr_SYNC);
    279            return res;
    280          }
    281          
    282          /**
    283          @brief Прием пакет синхронизации
    284          @param[in] Время ожидания в мс
    285          @return Указатель на пакет или NULL
    286          */
    287          static frame_s* get_sync(uint16_t timeout)
    288          {
    289            RI_SetChannel(CONFIG.sync_channel);
    290            frame_s *fr_SYNC = RI_Receive(timeout);
    291            
    292            // Если пакета нет, выходим из обработчика
    293            if (fr_SYNC == NULL)
    294              return NULL;
    295            
    296            // Проверим размер пакета
    297            if (fr_SYNC->len != sizeof(SYNC_s))
    298            {
    299              frame_delete(fr_SYNC);
    300              return NULL;
    301            }
    302            
    303            #ifdef RARIO_STREAM_ENCRYPT
    304            BitRawDecrypt(fr_SYNC->payload, fr_SYNC->len);
    305            #endif
    306            return fr_SYNC;
    307          }
    308          
    309          /**
    310          @brief Процедура синхронизации с сетью
    311          @detail Процедура изет сеть в течении времени timeout и синхронизируется с ней
    312          @param[in] timeout время в милисекундах
    313          @param[out] panid указатель на идентификатор найденой сети
    314          @return true если сеть найдета
    315          */
    316          bool SY_SYNC_NETWORK(uint16_t *panid,uint16_t timeout)
    317          {
    318            // TODO Нужно обнулить настройки всех модулей
    319            // Или об этом будет заботиться верхний уровень?
    320            TIC_CloseAllState();
    321            
    322            RI_SetChannel(CONFIG.sync_channel);
    323            
    324            TimeStamp_s begin, end;
    325            TIM_TimeStamp(&begin);
    326            TIM_TimeStamp(&end);
    327            
    328            bool net_found = false;
    329            uint32_t passed = 0;
    330            frame_s *fr_SYNC;
    331            SYNC_s *sync;
    332            uint32_t timeout_us = timeout * 1000;
    333            
    334            while (passed < timeout_us)
    335            {
    336              fr_SYNC = get_sync(timeout);
    337              if (fr_SYNC == NULL)
    338              {
    339                passed = TIM_passedTime(&begin, &end);
    340                continue;
    341              }
    342              
    343              // Приняли какойто пакет, декодируем.
    344              sync = (SYNC_s*)fr_SYNC->payload;
    345              
    346              if (sync->magic != MAGIC)
    347              { // Проверим что пакет именно тот а не эфирный мусор
    348                frame_delete(fr_SYNC);
    349                passed = TIM_passedTime(&begin, &end);
    350                continue;
    351              }   
    352              
    353              // Возвращаем результат
    354              *panid = sync->panid;
    355              CONFIG.panid = sync->panid;
    356              net_found = true;
    357              
    358              // Синхронизируемся с сетью
    359              // Время прошедшее с момента приема пакета в тактах сети
    360              uint16_t delta = TIC_GetTimer() - fr_SYNC->meta.TIMESTAMP;
    361              TIC_SetTimer(SYNC_ACCURATE_NETWORK_TIME + delta);
    362              
    363              LAST_SYNC_TIME = TIC_GetUptime();
    364              NEXT_SYNC_TIME = LAST_SYNC_TIME + RAND_SYNC_RX_DELAY; 
    365              frame_delete(fr_SYNC);
    366              break;
    367            } 
    368            
    369            return net_found;
    370          }
    371          
    372          /*!
    373          \brief Расшифровка область памяти
    374          \param[in,out] *src Указатель на начало области дешифрования
    375          \param[in] size Размер расшифруемых данных
    376          */
    377          static void BitRawDecrypt(uint8_t *src, uint8_t size)
    378          {
    379            AES_StreamCoder(false, src, src, KEY, IV, size);
    380          }
    381          
    382          /*!
    383          \brief Шифрует область памяти
    384          \param[in,out] *src Указатель на начало области шифрования
    385          \param[in] size Размер шифруемых данных
    386          */
    387          static void BitRawCrypt(uint8_t *src, uint8_t size)
    388          {
    389            AES_StreamCoder(true, src, src, KEY, IV, size);
    390          }
    391          
\\vmware-host\Shared Folders\Projects\WMNU\IAR\SHARE_PRJ_SRC\TIC.c
      1          #include "TIC.h"
      2          #include "NTMR.h"
      3          #include "stdlib.h"
      4          #include "nwdebuger.h"
      5          #include "delays.h"
      6          #include "basic.h"
      7          #include "ioCC2530.h" // ОТЛАДДКА
      8          
      9          /**
     10          @file 
     11          @brief 
     12          @details
     13          */
     14          
     15          // Публичные методы
     16          void TIC_Init(void);
     17          void TIC_Reset(void);
     18          
     19          // Методы класса
     20          void TIC_SetTimer(uint16_t ticks);
     21          uint16_t TIC_GetTimer(void);
     22          bool TIC_SetTXState(uint8_t TS, bool state);
     23          bool TIC_SetRXState(uint8_t TS, bool state);
     24          bool TIC_GetTXState(uint8_t TS);
     25          bool TIC_GetRXState(uint8_t TS);
     26          void TIC_CloseAllState();
     27          void TIC_SetRXCallback(void (*fn)(uint8_t TS));
     28          void TIC_SetTXCallback(void (*fn)(uint8_t TS));
     29          void TIC_SetSECallback(void (*fn)(uint8_t TS));
     30          void TIC_SetTS1Callback(void (*fn)(void));
     31          void TIC_SetSyncTimeAllocCallback(void (*fn)(void));
     32          uint32_t TIC_GetUptime(void);
     33          uint32_t TIC_GetRTC(void);
     34          bool TIC_SetRTC(uint32_t RTC);
     35          void TIC_SetNonce(uint32_t nonce);
     36          uint32_t TIC_GetNonce(void);
     37          uint32_t TIC_TimeUsFromTS0();
     38          TimeStamp_s* TIC_GetTimeStampTS0(void);
     39          uint16_t TIC_SleepTime(void);
     40          uint16_t TIC_SlotActivityTime(void);
     41          uint16_t TIC_SlotTime(uint8_t TS);
     42          
     43          // Приватные методы
     44          static uint8_t TIC_getCurrentTS(uint16_t ticks);
     45          static void TIC_TDMAShelduler(uint8_t TS);
     46          static void TIC_HW_Timer_IRQ(uint16_t ticks);
     47          static inline void set_capture_time(uint8_t TS);
     48          static inline void Callback_execution(void (*fn)(uint8_t TS), uint8_t TS);
     49          static inline void incrementTS(uint8_t *TS);
     50          static void clocks_update(void);
     51          
     52          // Переменные модуля
     53          
     54          // Всего 50 слотов. (50 активных и 50 слотов сна)
     55          // Кварц имеет 32768 тактов в секунду. После 100 слотов
     56          // Остается 68 неучтеных тактов. Их нужно учитывать.
     57          #define MAX_TS (uint8_t)50
     58          #define TS_ACTIVE (uint16_t)327 // 9.979 мс
     59          #define TS_SLEEP (uint16_t)327  // 2.075 мс
     60          #define TS_UNACCOUNTED 68
     61          // Целый цикл-это сумма времени активного периода и сна
     62          #define FULL_SLOT  (TS_ACTIVE+TS_SLEEP)
     63          #define NO_TIME_SLOT 0xFF
     64          
     65          #define TS_RX (uint8_t)(1<<0)
     66          #define TS_TX (uint8_t)(1<<1)
     67          #define DAILY_SEC (uint32_t)86400
     68          #define MAX_TICKS (uint16_t)32768
     69          
     70          static uint32_t NODE_UPTIME = 0;
     71          static uint32_t NODE_RTC = 0;
     72          static uint32_t NODE_NONCE = 0;
     73          static void (*RXCallback)(uint8_t TS);
     74          static void (*TXCallback)(uint8_t TS);
     75          static void (*SECallback)(uint8_t TS);
     76          static void (*SyncTimeAllocCallback)(void);
     77          static void (*TS1Callback)(void);
     78          static uint8_t TSStateTable[MAX_TS];
     79          static TimeStamp_s TimeStampTS0;
     80          
     81          
     82          TimeStamp_s* TIC_GetTimeStampTS0(void)
     83          {
     84            return &TimeStampTS0;
     85          }
     86          
     87          void TIC_Init(void)
     88          {    
     89            TIC_CloseAllState();
     90            // Устанавливаем обработчик прерываний таймера
     91            NT_SetEventCallback(TIC_HW_Timer_IRQ);
     92            // Запускаем процесс планировщика
     93            NT_SetCompare(0); 
     94            TIC_SetTimer(0);
     95            TIM_TimeStamp(&TimeStampTS0);
     96          }
     97          
     98          /**
     99          @brief Сброс настроек. 
    100          @detail Модуль генерирует только SECallback и считает время RTC, UPTIME, NONCE.
    101          Так как была переустановка времени, значение RTC не верное на 1с (плюс, минус)
    102          */
    103          void TIC_Reset(void)
    104          {
    105          #ifdef GATEWAY
    106            NODE_RTC = 0;
    107            NODE_NONCE = 0;
    108            NODE_UPTIME = 0;
    109          #endif
    110            TIC_CloseAllState();  
    111            NT_SetCompare(0); 
    112            TIC_SetTimer(0);
    113            TIM_TimeStamp(&TimeStampTS0);
    114          }
    115          
    116          void TIC_CloseAllState()
    117          {
    118            for (uint8_t i = 0 ; i < 50; i++)
    119            {
    120              TIC_SetTXState(i, false);
    121              TIC_SetRXState(i, false);
    122            }
    123          }
    124          uint32_t TIC_TimeUsFromTS0()
    125          {
    126            uint32_t passed;
    127            TimeStamp_s now;
    128            TIM_TimeStamp(&now);
    129            passed = TIM_passedTime(&TimeStampTS0, &now);
    130            return passed;
    131          }
    132          
    133          void TIC_SetTimer(uint16_t ticks)
    134          {
    135            ASSERT(ticks < MAX_TICKS);
    136            if (ticks >= MAX_TICKS)
    137              return ;
    138            
    139            NT_SetTime(ticks);
    140          }
    141          
    142          uint16_t TIC_GetTimer(void)
    143          {
    144            return NT_GetTime();
    145          }
    146          
    147          bool TIC_SetTXState(uint8_t TS, bool state)
    148          {
    149            if (TS>=MAX_TS)
    150            {
    151              return false;
    152            }
    153            ASSERT(TS<MAX_TS);
    154            
    155            if (state)
    156              TSStateTable[TS] |= TS_TX;
    157            else
    158              TSStateTable[TS] &= ~TS_TX;
    159            
    160            return true;
    161          }
    162          
    163          bool TIC_SetRXState(uint8_t TS, bool state)
    164          {
    165            if (TS>=MAX_TS)
    166            {
    167              return false;
    168            }
    169            ASSERT(TS<MAX_TS);
    170            
    171            if (state)
    172              TSStateTable[TS] |= TS_RX;
    173            else
    174              TSStateTable[TS] &= ~TS_RX;
    175            
    176            return true;
    177          }
    178          
    179          bool TIC_GetTXState(uint8_t TS)
    180          {
    181              if (TS>=MAX_TS)
    182            {
    183              return false;
    184            }
    185            ASSERT(TS<MAX_TS);
    186            
    187            return (TSStateTable[TS] & TS_TX) ;
    188          }
    189          
    190          bool TIC_GetRXState(uint8_t TS)
    191          {
    192              if (TS>=MAX_TS)
    193            {
    194              return false;
    195            }
    196            ASSERT(TS<MAX_TS);
    197            
    198            return (TSStateTable[TS] & TS_RX) ;
    199          }
    200          
    201          void TIC_SetTS1Callback(void (*fn)(void))
    202          {
    203            ASSERT (fn != NULL);
    204            TS1Callback = fn;
    205          }
    206          
    207          void TIC_SetRXCallback(void (*fn)(uint8_t TS))
    208          {
    209            ASSERT(fn != NULL);
    210            RXCallback = fn;
    211          }
    212          
    213          void TIC_SetSyncTimeAllocCallback(void (*fn)(void))
    214          {
    215            ASSERT(fn != NULL);
    216            SyncTimeAllocCallback = fn;
    217          }
    218          
    219          void TIC_SetTXCallback(void (*fn)(uint8_t TS))
    220          {
    221            ASSERT(fn != NULL);
    222            TXCallback = fn;
    223          }
    224          
    225          void TIC_SetSECallback(void (*fn)(uint8_t TS))
    226          {
    227            ASSERT(fn != NULL);
    228            SECallback = fn;
    229          }
    230          
    231          uint32_t TIC_GetUptime(void)
    232          {
    233            return NODE_UPTIME;
    234          }
    235          
    236          uint32_t TIC_GetRTC(void)
    237          {
    238            return NODE_RTC;
    239          }
    240          
    241          bool TIC_SetRTC(uint32_t RTC)
    242          {
    243            if (RTC >= DAILY_SEC)
    244              return false;
    245            
    246            NODE_RTC = RTC;
    247            return true;
    248          }
    249          
    250          static uint8_t TIC_getCurrentTS(uint16_t ticks)
    251          {
    252            //uint16_t ticks = nt->NT_GetTime();
    253            // Вычисляем количество целых циклов
    254            uint8_t full_slot_num = ticks/FULL_SLOT;
    255            
    256            // Вычисляем остаток от деления. Остаток - смещение внутри
    257            // временного слота.
    258            uint16_t time_remainder = ticks % FULL_SLOT; 
    259            // Если значение внутри интервала 0..TS_ACTIVE. 
    260            if (time_remainder < TS_ACTIVE)
    261              return full_slot_num;
    262            
    263            return NO_TIME_SLOT;
    264          }
    265          
    266          static inline void incrementTS(uint8_t *TS)
    267          {
    268            // Выбираем следующий тайм слот
    269            (*TS)++;
    270            if (*TS >= MAX_TS)
    271              *TS = 0;
    272          }
    273          
    274          /**
    275          @brief Время активного слота в тактах сети
    276          @return время в тактах сети
    277          */
    278          uint16_t TIC_SlotActivityTime(void)
    279          {
    280            return TS_ACTIVE;
    281          }
    282          
    283          /**
    284          @brief Время неактивного слота в тактах сети
    285          @return время в тактах сети
    286          */
    287          uint16_t TIC_SleepTime(void)
    288          {
    289            return TS_SLEEP;
    290          }
    291          
    292          /**
    293          @brief Время начала временного слота в тактах сети
    294          @param[in] TS номер слота
    295          @return время в тактах сети
    296          */
    297          uint16_t TIC_SlotTime(uint8_t TS)
    298          {
    299            return FULL_SLOT*(uint16_t)TS;
    300          }
    301          
    302          static inline void set_capture_time(uint8_t TS)
    303          {
    304            //uint16_t ct = FULL_SLOT*(uint16_t)TS;
    305            
    306            LOG_OFF("Set compare = %d, TS = %d \r\n", ct, TS);
    307            // Установка прерывания на нужный слот
    308            NT_SetCompare(FULL_SLOT*(uint16_t)TS);
    309          }
    310          
    311          static void TIC_TDMAShelduler(uint8_t TS)
    312          {
    313            // Устанавливает прерывание на ближайший активный слот
    314            // Если слот 0 ближе, то на него. 
    315            // Cлот - обработка секундных таймеров 
    316            
    317            // Ищем следующий активный слот или слот 0
    318            incrementTS(&TS);
    319            while ((TS != 0) && !TSStateTable[TS])  
    320              incrementTS(&TS); 
    321            
    322            set_capture_time(TS);
    323          }
    324          
    325          static inline void Callback_execution(void (*fn)(uint8_t TS), uint8_t TS)
    326          {
    327            // Помошник вызова функций. Упрощает проверки
    328            ASSERT(fn != NULL);
    329            if (fn == NULL)
    330              return;
    331            fn(TS);
    332          }
    333          
    334          static void TIC_HW_Timer_IRQ(uint16_t ticks)
    335          {
    336            // TODO Обработка TS=0xFF
    337            // Номер текущего слота 
    338            uint8_t c_TS = TIC_getCurrentTS(ticks);
    339            
    340            // Обновляем часы NODE_RTC и NODE_UPTIME
    341            if (c_TS == 0)
    342            {
    343              TIM_TimeStamp(&TimeStampTS0); // Первым делом обновим отметку точного времени
    344              clocks_update();
    345           //   P1_0 = !true;
    346              LOG_OFF("TS0");
    347           //   P1_0 = !false;;
    348            }
    349            // Если что то пошло не так и мы промахнулись мимо слота
    350            // запускаем планировщик заново
    351            if (c_TS == NO_TIME_SLOT)
    352            {
    353              TIC_TDMAShelduler(c_TS);
    354              LOG_ON("TS = 255 \r\n");
    355              return;
    356            }
    357              
    358            // Вызываем один из указанных обработчиков.
    359            // Передача имеет приоритет над приемом.
    360            if (c_TS != 1)
    361            {
    362              if (TSStateTable[c_TS] & TS_TX) 
    363                Callback_execution(TXCallback, c_TS);
    364              else if (TSStateTable[c_TS] & TS_RX)
    365                Callback_execution(RXCallback, c_TS);
    366            }  
    367            else // Для TS1 свой обработчик слота
    368            {
    369              if (TS1Callback != NULL)
    370                TS1Callback();
    371            }
    372            
    373            // Выделяем время протоколу синхронизации
    374            if (SyncTimeAllocCallback)
    375              SyncTimeAllocCallback();
    376            
    377            Callback_execution(SECallback, c_TS); // Вызываем обработчик завершения слота
    378            
    379            // Запускаем планировщик таймера
    380            TIC_TDMAShelduler(c_TS);
    381          }
    382          
    383          static void clocks_update(void)
    384          {
    385            NODE_UPTIME++;
    386            NODE_RTC++;
    387            NODE_NONCE++;
    388            if (NODE_RTC >= DAILY_SEC)
    389              NODE_RTC = 0;
    390          }
    391          
    392          void TIC_SetNonce(uint32_t nonce)
    393          {
    394            NODE_NONCE = nonce;
    395          }
    396          
    397          uint32_t TIC_GetNonce(void)
    398          {
    399            return NODE_NONCE;
    400          }
\\vmware-host\Shared Folders\Projects\WMNU\IAR\PRJ_UNITEST\src\utest.c
      1          #include "utest_suite.h"
      2          #include "nwdebuger.h"
      3          #include "assert.h"
      4          #include "basic.h"
      5          
      6          extern void suite_GW(void);
      7          extern void suite_NODE(void);
      8          
      9          int main()
     10          {
     11            nwDebugerInit();
     12            utestSigTraceInit();
     13            LOG_OFF("");
     14            LOG_OFF("Test start");
     15          
     16          #ifdef GATEWAY
     17            suite_GW();
     18          #else
     19            suite_NODE();
     20          #endif
     21          // Добавляем результаты тестов
     22          	umsg_summary();
     23           //     while(1);
     24          	return 0;
     25          }
\\vmware-host\Shared Folders\Projects\WMNU\IAR\PRJ_UNITEST\src\utest_GW.c
      1          #include "utest_suite.h"
      2          #include "manager.h"
      3          #include "nwdebuger.h"
      4          
      5          // Собирать проект с ключем GATEWAY в файле basic.h
      6          
      7          
      8          
      9          void suite_GW(void)
     10          {
     11            bool con = MG_Connect();
     12            if (con)
     13            {
     14              LOG_ON("Network created\r\n");
     15            }  
     16            else
     17            {
     18              LOG_ON("Network creation failed\r\n");
     19            }
     20            
     21            while(1);
     22          }
\\vmware-host\Shared Folders\Projects\WMNU\IAR\PRJ_UNITEST\src\utest_NODE.c
      1          #include "utest_suite.h"
      2          #include "manager.h"
      3          #include "nwdebuger.h"
      4          
      5          // Собирать проект без ключем GATEWAY в файле basic.h
      6          
      7          void suite_NODE(void)
      8          {
      9             bool con = MG_Connect();
     10            if (con)
     11            {
     12              LOG_ON("Network sycronized");
     13            }  
     14            else
     15            {
     16              LOG_ON("Network connect faild");
     17            }
     18            
     19            while(1);
     20          }
\\vmware-host\Shared Folders\Projects\WMNU\IAR\PRJ_UNITEST\src\utest_suite.c
      1          #include "stdio.h"
      2          #include "utest_suite.h"
      3          #include "ioCC2530.h"
      4          
      5          /**
      6          @brief Иницилизируем выводы светодидов
      7          */
      8          void utestSigTraceInit(void)
      9          {
     10            P1DIR = 0x13; // Включаем светодиоды
     11          }
     12          
     13          void LED(uint8_t led, bool state)
     14          {
     15            switch(led)
     16            {
     17              case D1:
     18                P1_0 = !state;
     19                break;
     20              case D2:
     21                P1_1 = !state;
     22                break;
     23              case D3:
     24                P1_4 = !state;
     25                break;
     26            }
     27          }
     28          
     29          
     30          static struct utest_summary_s
     31          {
     32          	uint16_t passed;
     33          	uint16_t failed;
     34          } utest_summary = {.passed =0, .failed = 0};;
     35          
     36          //utest_summary_s utest_summary = {.passed =0, .failed = 0};
     37          
     38          // Требует много програмной памяти
     39          size_t heap_size(void)
     40          { 
     41            return 0;
     42          }
     43          
     44          bool memory_compare(char* area1, char* area2, uint16_t size)
     45          {
     46          	while (size > 0)
     47          	{
     48          		if (*area1 != *area2)
     49          			return false;
     50          		area1++;
     51          		area2++;
     52                  size--;
     53          	} 
     54          	return true;
     55          }
     56          
     57          void umsg(char* module, char* name, bool status)
     58          {
     59          	if (status){
     60          		utest_summary.passed++;
     61          		printf("Module: %-15s Name: %-50s Status: %-10s\r\n", module, name, "PASSED");
     62          		}
     63          	else{
     64          		utest_summary.failed++;
     65          		printf("Module: %-15s Name: %-50s Status: %-10s\r\n", module, name, "FAILED <----");
     66          		}
     67          }
     68          
     69          void umsg_line(char* name)
     70          {
     71          	printf("**************************************\r\n");
     72          	printf("%s\r\n", name);
     73          	printf("**************************************\r\n");
     74          }
     75          
     76          void umsg_summary()
     77          {
     78          	umsg_line("Unit test symmary");
     79          	printf("PASSED: %d\r\n", utest_summary.passed);
     80          	printf("FAILD : %d\r\n", utest_summary.failed);
     81          	if (utest_summary.failed == 0)
     82                printf("Tests PASSED\r\n");
     83          	else
     84          		printf("Tests FAILED\r\n");
     85          }

   Maximum stack usage in bytes:

   ISTACK XSTACK Function
   ------ ------ --------
      1     77   AES_CCMDecrypt
        0     67   -> CBCMAC_buf_encrypt
        0     71   -> CTR_enc_decrypt
        0     69   -> generateAuthData
        0     69   -> memcpy
        0     69   -> memset
      1     61   AES_CCMEncrypt
        0     51   -> CBCMAC_buf_encrypt
        0     55   -> CTR_enc_decrypt
        0     53   -> generateAuthData
        0     53   -> memcpy
        0     53   -> memset
      0     62   AES_StreamCoder
        0     36   -> memcpy
        0     36   -> memset
      2     12   AES_init
      0    111   CBCMAC_buf_encrypt
      0     24   CF_init
        0     12   -> memcpy
      0    107   CTR_enc_decrypt
        0     36   -> memcpy
        0     36   -> memset
      0     28   Callback_execution
        0     10   -> printf
        0     16   -> printf
      0     16   ETH_Init
        0     10   -> printf
        0     16   -> printf
      0     22   ETH_RX_HNDL
        0     16   -> __xdata_malloc
        0     16   -> frame_delete
        0     16   -> printf
        0     22   -> printf
        0     16   -> re_free
      0     16   ETH_Set_RXCallback
        0     10   -> printf
        0     16   -> printf
      0      0   LED
      1     26   LLC_AddTask
        0     16   -> __xdata_malloc
        0     16   -> printf
        0     22   -> printf
        0     26   -> printf
      2      0   LLC_GetTaskLen
      0     28   LLC_Init
        0     10   -> printf
        0     16   -> printf
      0     16   LLC_RX_HNDL
        0     10   -> printf
        0     16   -> printf
      0      9   LLC_Reset
        0      9   -> __xdata_free
      0      9   LLC_SE_HNDL
        0      9   -> LLC_Shelduler
      0     16   LLC_SetRXCallback
        0     10   -> printf
        0     16   -> printf
      0     28   LLC_Shelduler
        0     13   -> MAC_Send
        0     13   -> __xdata_free
        0     13   -> printf
        0     19   -> printf
      0     18   LLC_TimeAlloc
        0     12   -> __xdata_malloc
        0     12   -> printf
        0     18   -> printf
      1      9   MAC_CloseRXSlot
        0      9   -> TIC_SetRXState
      2      0   MAC_Enable
      2      0   MAC_GetRXState
      2      0   MAC_GetTXState
      0     24   MAC_Init
        0     10   -> TIC_SetRXCallback
        0     10   -> TIC_SetTXCallback
        0     12   -> memset
      1      9   MAC_OpenRXSlot
        0      9   -> TIC_SetRXState
      0     18   MAC_RX_HNDL
        0     18   -> AES_StreamCoder
        0     14   -> RI_Receive
        0     14   -> RI_Send
        0     14   -> frame_addHeader
        0     14   -> frame_create
        0     14   -> frame_delete
        0     14   -> xor_calc
      0     24   MAC_Reset
        0     10   -> frame_delete
        0     12   -> memset
      1     29   MAC_Send
        0     14   -> AES_StreamCoder
        0     10   -> TIC_SetTXState
        0     10   -> printf
        0     16   -> printf
      2      0   MAC_SetRXCallback
      1     18   MAC_TX_HNDL
        0     18   -> RI_Receive
        0     18   -> RI_Send
        0     18   -> TIC_SetTXState
        0     18   -> frame_delete
        0     18   -> xor_calc
      0     12   MAC_setIV
        0     12   -> memcpy
      0     12   MAC_setKEY
        0     12   -> memcpy
      0     28   MG_Connect
        0     12   -> AES_init
        0     12   -> CF_init
        0     12   -> LLC_Init
        0     12   -> MAC_Init
        0     12   -> MAC_Reset
        0     12   -> NT_Init
        0     12   -> NT_SetCompare
        0     12   -> NT_SetTime
        0     12   -> RI_init
        0     12   -> SY_Init
        0     12   -> SY_Reset
        0     12   -> SY_SYNC_NETWORK
        0     12   -> TIC_CloseAllState
        0     12   -> TIC_Init
        0     12   -> TIM_TimeStamp
        0     12   -> TIM_init
        0     12   -> __xdata_free
        0     14   -> memcpy
        0     12   -> printf
        0     14   -> printf
        0     18   -> printf
      0      0   MyLowLevelPutchar
      0     12   NT_GetTime
      2     12   NT_Init
      0     42   NT_SetCompare
        0     24   -> ReadTimer
        0     24   -> printf
        0     30   -> printf
      2      0   NT_SetEventCallback
      0     30   NT_SetTime
        0     12   -> NT_SetCompare
        0     12   -> ReadTimer
        0     12   -> printf
        0     18   -> printf
      0     34   NT_WaitTime
      2      0   RI_GetCCAReject
      2      0   RI_GetCRCError
      2      0   RI_GetUptime
      2     79   RI_Receive
        0     61   -> RI_cfg
        0     61   -> ReadTimer
        0     61   -> __xdata_malloc
        0     61   -> frame_addHeader
        0     61   -> frame_create
        0     61   -> re_free
      1     60   RI_Send
        0     32   -> RI_cfg
        0     32   -> SendData
        0     32   -> printf
        0     38   -> printf
      2      0   RI_SetChannel
      0     77   RI_cfg
        0     10   -> printf
        0     16   -> printf
      0     21   RI_init
        0      9   -> RI_cfg
        0      9   -> rand
        0      9   -> readRandom
        0      9   -> srand
      2     61   ReadTimer
      0     16   STACK_FAILURE
        0     10   -> printf
        0     16   -> printf
      2      0   SY_Enable
      0     28   SY_Init
        0     10   -> printf
        0     16   -> printf
      2     12   SY_Reset
      2     60   SY_SYNC_NETWORK
        0     48   -> TIC_CloseAllState
        0     48   -> TIC_SetTimer
        0     48   -> frame_delete
        0     48   -> get_sync
      2     18   SY_TIME_ALLOC_SLAVE
        0     12   -> printf
        0     18   -> printf
      2     34   SY_TS1_HNDL_SLAVE
        0     26   -> AES_StreamCoder
        0     22   -> NT_WaitTime
        0     22   -> RI_Send
        0     22   -> TIC_SetTimer
        0     22   -> frame_addHeader
        0     22   -> frame_create
        0     22   -> frame_delete
        0     22   -> get_sync
        0     22   -> printf
        0     24   -> printf
        0     28   -> printf
        0     34   -> printf
      0     12   SY_setIV
        0     12   -> memcpy
      0     12   SY_setKEY
        0     12   -> memcpy
      2      0   SY_sync_sended
      0     45   SendData
        0     13   -> NT_WaitTime
      2     48   TIC_CloseAllState
      2      0   TIC_GetNonce
      2      0   TIC_GetRTC
      2      0   TIC_GetRXState
      2      0   TIC_GetTXState
      0      0   TIC_GetTimeStampTS0
      0     12   TIC_GetTimer
      2      0   TIC_GetUptime
      0     18   TIC_HW_Timer_IRQ
        0     12   -> Callback_execution
        0     12   -> TIC_TDMAShelduler
        0     12   -> TIM_TimeStamp
        0     12   -> printf
        0     18   -> printf
      2     12   TIC_Init
        2      0   -> NT_SetCompare
        2      0   -> NT_SetTime
        2      0   -> TIC_CloseAllState
        2      0   -> TIM_TimeStamp
      2      0   TIC_Reset
        2      0   -> NT_SetCompare
        2      0   -> NT_SetTime
        2      0   -> TIC_CloseAllState
        2      0   -> TIM_TimeStamp
      0     12   TIC_SetNonce
      0     12   TIC_SetRTC
      0     26   TIC_SetRXCallback
        0     10   -> printf
        0     16   -> printf
      2      9   TIC_SetRXState
      0     16   TIC_SetSECallback
        0     10   -> printf
        0     16   -> printf
      0     16   TIC_SetSyncTimeAllocCallback
        0     10   -> printf
        0     16   -> printf
      0     16   TIC_SetTS1Callback
        0     10   -> printf
        0     16   -> printf
      0     26   TIC_SetTXCallback
        0     10   -> printf
        0     16   -> printf
      2     18   TIC_SetTXState
      0     64   TIC_SetTimer
        0     10   -> NT_SetTime
        0     10   -> printf
        0     16   -> printf
      0      0   TIC_SleepTime
      0      0   TIC_SlotActivityTime
      0      0   TIC_SlotTime
      0     21   TIC_TDMAShelduler
        0      9   -> NT_SetCompare
      1     24   TIC_TimeUsFromTS0
      3     12   TIM_TimeStamp
      0     12   TIM_copy
        0     12   -> memcpy
      1     64   TIM_delay
      1     44   TIM_init
        0     32   -> TIM_delay
      0     20   TIM_passedTime
      0     17   TimerCompareInterrupt
      0     11   __write
      1     88   frame_addHeader
        0     21   -> __xdata_malloc
        0     21   -> printf
        0     27   -> printf
        0     21   -> re_free
        0     23   -> re_memcpy
      0     79   frame_create
        0     12   -> __xdata_malloc
        0     14   -> memset
        0     12   -> printf
        0     18   -> printf
      1     21   frame_delHeader
        0     15   -> __xdata_malloc
        0     15   -> printf
        0     21   -> printf
        0     15   -> re_free
        0     17   -> re_memcpy
      0     58   frame_delete
        0     10   -> re_free
      2      0   frame_getCount
      2      0   frame_len
      0     85   generateAuthData
        0     16   -> memcpy
      0     62   get_sync
        0     14   -> AES_StreamCoder
        0     10   -> RI_Receive
        0     10   -> frame_delete
      0     12   heap_ptr
        0     12   -> __xdata_free
        0     12   -> __xdata_malloc
      0      0   heap_size
      0      0   main
        0      0   -> nwDebugerInit
        0      0   -> suite_NODE
        0      0   -> umsg_summary
      0     11   memory_compare
      0      0   nwDebugerInit
      0     70   re_free
        0      9   -> __xdata_free
      0     10   re_malloc
        0     10   -> __xdata_malloc
      0     34   re_memcpy
        0     11   -> memcpy
      2      9   readRandom
      0     16   suite_GW
        0     10   -> MG_Connect
        0     10   -> printf
        0     16   -> printf
      0     16   suite_NODE
        0     10   -> MG_Connect
        0     10   -> printf
        0     16   -> printf
      0     16   umsg
        0     16   -> printf
      0     12   umsg_line
        0     10   -> printf
        0     12   -> printf
      0     12   umsg_summary
        0     10   -> printf
        0     12   -> printf
      0      0   utestSigTraceInit
      0     27   xor_calc


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
       5  ?<Constant "%s\r\n">
      41  ?<Constant "*********************...">
      22  ?<Constant "*ASSERT* %s:%d:%s -> ">
      22  ?<Constant "*ASSERT* %s:%d:%s -> ">_1
      22  ?<Constant "*ASSERT* %s:%d:%s -> ">_2
      22  ?<Constant "*ASSERT* %s:%d:%s -> ">_3
      22  ?<Constant "*ASSERT* %s:%d:%s -> ">_4
      22  ?<Constant "*ASSERT* %s:%d:%s -> ">_5
      22  ?<Constant "*ASSERT* %s:%d:%s -> ">_6
      19  ?<Constant "*LOG* %s:%d:%s -> ">
      19  ?<Constant "*LOG* %s:%d:%s -> ">_1
      19  ?<Constant "*LOG* %s:%d:%s -> ">_2
      19  ?<Constant "*LOG* %s:%d:%s -> ">_3
      19  ?<Constant "*LOG* %s:%d:%s -> ">_4
      19  ?<Constant "*LOG* %s:%d:%s -> ">_5
      19  ?<Constant "*LOG* %s:%d:%s -> ">_6
      51  ?<Constant "Add task = %u, CH = %...">
      13  ?<Constant "Begin resync">
      13  ?<Constant "FAILD : %d\r\n">
      13  ?<Constant "FAILED <----">
      21  ?<Constant "Frame_s count: %d \r\n">
       6  ?<Constant "LLC.c">
       6  ?<Constant "MAC.c">
      42  ?<Constant "Module: %-15s Name: %...">
       7  ?<Constant "NTMR.c">
      22  ?<Constant "Network connect faild">
      18  ?<Constant "Network created\r\n">
      26  ?<Constant "Network creation fail...">
      21  ?<Constant "Network out of sync.">
      19  ?<Constant "Network sycronized">
      58  ?<Constant "Node Synced. TS=%d, A...">
       7  ?<Constant "PASSED">
      13  ?<Constant "PASSED: %d\r\n">
       8  ?<Constant "RADIO.c">
      18  ?<Constant "Resync TX. CNT=%d">
      20  ?<Constant "STACK FAILURE. HALT">
       6  ?<Constant "TIC.c">
      12  ?<Constant "TS = 255 \r\n">
      15  ?<Constant "Tests FAILED\r\n">
      15  ?<Constant "Tests PASSED\r\n">
      18  ?<Constant "Unit test symmary">
       3  ?<Constant "\r\n">
       3  ?<Constant "\r\n">_1
       3  ?<Constant "\r\n">_10
       3  ?<Constant "\r\n">_11
       3  ?<Constant "\r\n">_2
       3  ?<Constant "\r\n">_3
       3  ?<Constant "\r\n">_4
       3  ?<Constant "\r\n">_5
       3  ?<Constant "\r\n">_6
       3  ?<Constant "\r\n">_7
       3  ?<Constant "\r\n">_8
       3  ?<Constant "\r\n">_9
      11  ?<Constant "ethernet.c">
       8  ?<Constant "frame.c">
      10  ?<Constant "manager.c">
      12  ?<Constant "nwdebuger.c">
       7  ?<Constant "sync.c">
      11  ?<Constant "utest_GW.c">
      13  ?<Constant "utest_NODE.c">
       5  ?<Initializer for <Constant "%s\r\n">>
      41  ?<Initializer for <Constant "*****************
      22  ?<Initializer for <Constant "*ASSERT* %s:%d:%s
      22  ?<Initializer for <Constant "*ASSERT* %s:%d:%s_1
      22  ?<Initializer for <Constant "*ASSERT* %s:%d:%s_2
      22  ?<Initializer for <Constant "*ASSERT* %s:%d:%s_3
      22  ?<Initializer for <Constant "*ASSERT* %s:%d:%s_4
      22  ?<Initializer for <Constant "*ASSERT* %s:%d:%s_5
      22  ?<Initializer for <Constant "*ASSERT* %s:%d:%s_6
      19  ?<Initializer for <Constant "*LOG* %s:%d:%s ->
      19  ?<Initializer for <Constant "*LOG* %s:%d:%s ->_1
      19  ?<Initializer for <Constant "*LOG* %s:%d:%s ->_2
      19  ?<Initializer for <Constant "*LOG* %s:%d:%s ->_3
      19  ?<Initializer for <Constant "*LOG* %s:%d:%s ->_4
      19  ?<Initializer for <Constant "*LOG* %s:%d:%s ->_5
      19  ?<Initializer for <Constant "*LOG* %s:%d:%s ->_6
      51  ?<Initializer for <Constant "Add task = %u, CH
      13  ?<Initializer for <Constant "Begin resync">>
      13  ?<Initializer for <Constant "FAILD : %d\r\n">>
      13  ?<Initializer for <Constant "FAILED <----">>
      21  ?<Initializer for <Constant "Frame_s count: %d
       6  ?<Initializer for <Constant "LLC.c">>
       6  ?<Initializer for <Constant "MAC.c">>
      42  ?<Initializer for <Constant "Module: %-15s Nam
       7  ?<Initializer for <Constant "NTMR.c">>
      22  ?<Initializer for <Constant "Network connect f
      18  ?<Initializer for <Constant "Network created\r
      26  ?<Initializer for <Constant "Network creation
      21  ?<Initializer for <Constant "Network out of sy
      19  ?<Initializer for <Constant "Network sycronize
      58  ?<Initializer for <Constant "Node Synced. TS=%
       7  ?<Initializer for <Constant "PASSED">>
      13  ?<Initializer for <Constant "PASSED: %d\r\n">>
       8  ?<Initializer for <Constant "RADIO.c">>
      18  ?<Initializer for <Constant "Resync TX. CNT=%d
      20  ?<Initializer for <Constant "STACK FAILURE. HA
       6  ?<Initializer for <Constant "TIC.c">>
      12  ?<Initializer for <Constant "TS = 255 \r\n">>
      15  ?<Initializer for <Constant "Tests FAILED\r\n"
      15  ?<Initializer for <Constant "Tests PASSED\r\n"
      18  ?<Initializer for <Constant "Unit test symmary
       3  ?<Initializer for <Constant "\r\n">>
       3  ?<Initializer for <Constant "\r\n">>_1
       3  ?<Initializer for <Constant "\r\n">>_10
       3  ?<Initializer for <Constant "\r\n">>_11
       3  ?<Initializer for <Constant "\r\n">>_2
       3  ?<Initializer for <Constant "\r\n">>_3
       3  ?<Initializer for <Constant "\r\n">>_4
       3  ?<Initializer for <Constant "\r\n">>_5
       3  ?<Initializer for <Constant "\r\n">>_6
       3  ?<Initializer for <Constant "\r\n">>_7
       3  ?<Initializer for <Constant "\r\n">>_8
       3  ?<Initializer for <Constant "\r\n">>_9
      11  ?<Initializer for <Constant "ethernet.c">>
       8  ?<Initializer for <Constant "frame.c">>
      10  ?<Initializer for <Constant "manager.c">>
      12  ?<Initializer for <Constant "nwdebuger.c">>
       7  ?<Initializer for <Constant "sync.c">>
      11  ?<Initializer for <Constant "utest_GW.c">>
      13  ?<Initializer for <Constant "utest_NODE.c">>
      16  ?<Initializer for IV>
      16  ?<Initializer for IV>_1
      16  ?<Initializer for KEY>
      16  ?<Initializer for KEY>_1
       4  ?<Initializer for __Constant_15180>
       4  ?<Initializer for __Constant_19833891>
       4  ?<Initializer for __Constant_1>
       4  ?<Initializer for __Constant_1f4>
       4  ?<Initializer for __Constant_3d000000>
       4  ?<Initializer for __Constant_3e8>
       4  ?<Initializer for __Constant_447a0000>
       4  ?<Initializer for __Constant_6f>
       4  ?<Initializer for __Constant_7fff>
       4  ?<Initializer for __Constant_8000>
       4  ?<Initializer for __Constant_9>
       4  ?<Initializer for __Constant_ffff8000>
       4  ?<Initializer for __Constant_fffffe0c>
       4  ?<Initializer for __Constant_ffffff>
      19  ?<Initializer for __FUNCTION__>
      12  ?<Initializer for __FUNCTION__>_1
      12  ?<Initializer for __FUNCTION__>_10
       9  ?<Initializer for __FUNCTION__>_11
      11  ?<Initializer for __FUNCTION__>_12
      11  ?<Initializer for __FUNCTION__>_13
      14  ?<Initializer for __FUNCTION__>_14
      14  ?<Initializer for __FUNCTION__>_15
       8  ?<Initializer for __FUNCTION__>_16
       8  ?<Initializer for __FUNCTION__>_17
      20  ?<Initializer for __FUNCTION__>_18
      18  ?<Initializer for __FUNCTION__>_19
      15  ?<Initializer for __FUNCTION__>_2
      13  ?<Initializer for __FUNCTION__>_20
      15  ?<Initializer for __FUNCTION__>_21
      15  ?<Initializer for __FUNCTION__>_22
      15  ?<Initializer for __FUNCTION__>_23
      15  ?<Initializer for __FUNCTION__>_24
      19  ?<Initializer for __FUNCTION__>_25
      18  ?<Initializer for __FUNCTION__>_26
      29  ?<Initializer for __FUNCTION__>_27
      18  ?<Initializer for __FUNCTION__>_28
      18  ?<Initializer for __FUNCTION__>_29
      16  ?<Initializer for __FUNCTION__>_3
      19  ?<Initializer for __FUNCTION__>_30
      17  ?<Initializer for __FUNCTION__>_31
       9  ?<Initializer for __FUNCTION__>_32
      11  ?<Initializer for __FUNCTION__>_33
      16  ?<Initializer for __FUNCTION__>_4
      13  ?<Initializer for __FUNCTION__>_5
      18  ?<Initializer for __FUNCTION__>_6
      14  ?<Initializer for __FUNCTION__>_7
      12  ?<Initializer for __FUNCTION__>_8
      14  ?<Initializer for __FUNCTION__>_9
      16  ?<Initializer for default_iv>
      16  ?<Initializer for default_key>
       4  ??Subroutine100_0
       6  ??Subroutine101_0
       2  ??Subroutine77_0
      19  ??Subroutine78_0
       8  ??Subroutine79_0
       4  ??Subroutine80_0
       6  ??Subroutine81_0
       8  ??Subroutine82_0
       6  ??Subroutine83_0
       2  ??Subroutine84_0
       3  ??Subroutine85_0
       5  ??Subroutine86_0
       4  ??Subroutine87_0
       3  ??Subroutine88_0
       5  ??Subroutine89_0
       5  ??Subroutine90_0
       1  ??Subroutine91_0
       5  ??Subroutine92_0
       8  ??Subroutine93_0
       1  ??Subroutine94_0
       4  ??Subroutine95_0
       6  ??Subroutine96_0
       7  ??Subroutine97_0
       9  ??Subroutine98_0
       4  ??Subroutine99_0
      21  ?Subroutine0
       7  ?Subroutine1
       4  ?Subroutine10
       6  ?Subroutine11
       5  ?Subroutine12
       5  ?Subroutine13
       5  ?Subroutine14
       4  ?Subroutine15
       5  ?Subroutine16
       6  ?Subroutine17
       5  ?Subroutine18
       5  ?Subroutine19
       7  ?Subroutine2
       7  ?Subroutine20
       6  ?Subroutine21
       5  ?Subroutine22
      20  ?Subroutine23
       3  ?Subroutine24
      47  ?Subroutine25
      25  ?Subroutine26
      18  ?Subroutine27
      16  ?Subroutine28
      14  ?Subroutine29
       2  ?Subroutine3
       5  ?Subroutine30
      21  ?Subroutine31
       1  ?Subroutine32
      10  ?Subroutine33
       6  ?Subroutine34
      17  ?Subroutine35
      11  ?Subroutine36
      11  ?Subroutine37
       6  ?Subroutine38
       3  ?Subroutine39
       9  ?Subroutine4
       9  ?Subroutine40
       3  ?Subroutine41
      10  ?Subroutine42
      14  ?Subroutine43
       6  ?Subroutine44
       9  ?Subroutine45
       3  ?Subroutine46
       7  ?Subroutine47
      10  ?Subroutine48
       5  ?Subroutine49
       5  ?Subroutine5
       8  ?Subroutine50
      12  ?Subroutine51
       6  ?Subroutine52
       3  ?Subroutine53
      10  ?Subroutine54
       7  ?Subroutine55
       6  ?Subroutine56
      11  ?Subroutine57
       9  ?Subroutine58
       9  ?Subroutine59
      22  ?Subroutine6
       9  ?Subroutine60
      19  ?Subroutine61
      14  ?Subroutine62
      12  ?Subroutine63
      13  ?Subroutine64
       7  ?Subroutine65
       5  ?Subroutine66
       9  ?Subroutine67
       8  ?Subroutine68
       3  ?Subroutine69
       5  ?Subroutine7
      10  ?Subroutine70
      13  ?Subroutine71
       6  ?Subroutine72
      13  ?Subroutine73
      12  ?Subroutine74
       9  ?Subroutine75
      11  ?Subroutine76
       5  ?Subroutine8
       9  ?Subroutine9
     355  AES_CCMDecrypt
       6  AES_CCMDecrypt::?relay
     349  AES_CCMEncrypt
       6  AES_CCMEncrypt::?relay
     270  AES_StreamCoder
       6  AES_StreamCoder::?relay
      76  AES_init
       6  AES_init::?relay
     260  CBCMAC_buf_encrypt
       6  CBCMAC_buf_encrypt::?relay
      75  CF_init
       6  CF_init::?relay
       1  CLKCONCMD
       1  CLKCONSTA
       4  COMPARE_TIME
      36  CONFIG
     270  CTR_enc_decrypt
       6  CTR_enc_decrypt::?relay
      70  Callback_execution
       6  Callback_execution::?relay
       4  DELAY_CALIBRATE_TICS
       1  DMA0CFGH
       1  DMA0CFGL
       1  DMA1CFGH
       1  DMA1CFGL
       1  DMAARM
       1  DMAREQ
       8  DMA_AES_DW
       8  DMA_AES_UP
       1  ENCCS
      84  ETH_Init
       6  ETH_Init::?relay
     363  ETH_RX_HNDL
       6  ETH_RX_HNDL::?relay
      69  ETH_Set_RXCallback
       6  ETH_Set_RXCallback::?relay
       2  EventCallback
       2  FirstTask
       4  HeadAllocFunc
      16  IV
      16  IV
      16  KEY
      16  KEY
       4  LAST_SYNC_TIME
      33  LED
       6  LED::?relay
     398  LLC_AddTask
       6  LLC_AddTask::?relay
      10  LLC_GetTaskLen
       6  LLC_GetTaskLen::?relay
     102  LLC_Init
       6  LLC_Init::?relay
      70  LLC_RX_HNDL
       6  LLC_RX_HNDL::?relay
      35  LLC_Reset
       6  LLC_Reset::?relay
      45  LLC_SE_HNDL
       6  LLC_SE_HNDL::?relay
      69  LLC_SetRXCallback
       6  LLC_SetRXCallback::?relay
     231  LLC_Shelduler
       6  LLC_Shelduler::?relay
     137  LLC_TimeAlloc
       6  LLC_TimeAlloc::?relay
     350  MACSlotTable
      36  MAC_CloseRXSlot
       6  MAC_CloseRXSlot::?relay
       1  MAC_ENABLE_MODULE
      14  MAC_Enable
       6  MAC_Enable::?relay
      21  MAC_GetRXState
       6  MAC_GetRXState::?relay
      19  MAC_GetTXState
       6  MAC_GetTXState::?relay
      26  MAC_Init
       6  MAC_Init::?relay
      54  MAC_OpenRXSlot
       6  MAC_OpenRXSlot::?relay
     185  MAC_RX_HNDL
       6  MAC_RX_HNDL::?relay
      37  MAC_Reset
       6  MAC_Reset::?relay
     298  MAC_Send
       6  MAC_Send::?relay
      10  MAC_SetRXCallback
       6  MAC_SetRXCallback::?relay
     234  MAC_TX_HNDL
       6  MAC_TX_HNDL::?relay
      26  MAC_setIV
       6  MAC_setIV::?relay
      24  MAC_setKEY
       6  MAC_setKEY::?relay
     314  MG_Connect
       6  MG_Connect::?relay
       1  MG_MODULES_INITED
      12  MyLowLevelPutchar
       6  MyLowLevelPutchar::?relay
       1  NBR_FRAME
       1  NEED_SEND_SYNC
       4  NEXT_SYNC_TIME
       4  NODE_NONCE
       4  NODE_RTC
       4  NODE_UPTIME
      17  NT_GetTime
       6  NT_GetTime::?relay
      48  NT_Init
       6  NT_Init::?relay
     262  NT_SetCompare
       6  NT_SetCompare::?relay
      10  NT_SetEventCallback
       6  NT_SetEventCallback::?relay
     114  NT_SetTime
       6  NT_SetTime::?relay
      94  NT_WaitTime
       6  NT_WaitTime::?relay
       1  P0SEL
       1  P1DIR
       1  PERCFG
       3  RADIO_CFG
       1  RFD
       1  RFIRQF0
       1  RFIRQF1
       1  RFST
       4  RI_CCA_REJECT
       4  RI_CRC_ERROR
      10  RI_GetCCAReject
       6  RI_GetCCAReject::?relay
      10  RI_GetCRCError
       6  RI_GetCRCError::?relay
      10  RI_GetUptime
       6  RI_GetUptime::?relay
     893  RI_Receive
       6  RI_Receive::?relay
     349  RI_Send
       6  RI_Send::?relay
      24  RI_SetChannel
       6  RI_SetChannel::?relay
       4  RI_UPTIME
     124  RI_cfg
       6  RI_cfg::?relay
      67  RI_init
       6  RI_init::?relay
       2  RXCallback
       2  RXCallback
       2  RXCallback
       2  RXCallback
      22  ReadTimer
       6  ReadTimer::?relay
       2  SECallback
       1  SLEEPSTA
       1  ST0
       1  ST1
       1  ST2
      66  STACK_FAILURE
       6  STACK_FAILURE::?relay
       1  STLOAD
       2  SYNC_ACCURATE_NETWORK_TIME
       4  SYNC_SENDED
       1  SY_ENABLE_MODULE
      10  SY_Enable
       6  SY_Enable::?relay
     164  SY_Init
       6  SY_Init::?relay
       7  SY_Reset
       6  SY_Reset::?relay
     572  SY_SYNC_NETWORK
       6  SY_SYNC_NETWORK::?relay
     211  SY_TIME_ALLOC_SLAVE
       6  SY_TIME_ALLOC_SLAVE::?relay
     637  SY_TS1_HNDL_SLAVE
       6  SY_TS1_HNDL_SLAVE::?relay
      27  SY_setIV
       6  SY_setIV::?relay
      27  SY_setKEY
       6  SY_setKEY::?relay
       7  SY_sync_sended
       6  SY_sync_sended::?relay
     155  SendData
       6  SendData::?relay
       2  SyncTimeAllocCallback
       1  T2CTRL
       1  T2M0
       1  T2M1
       1  T2MOVF0
       1  T2MOVF1
      27  TIC_CloseAllState
       6  TIC_CloseAllState::?relay
      10  TIC_GetNonce
       6  TIC_GetNonce::?relay
      10  TIC_GetRTC
       6  TIC_GetRTC::?relay
      21  TIC_GetRXState
       6  TIC_GetRXState::?relay
      21  TIC_GetTXState
       6  TIC_GetTXState::?relay
       7  TIC_GetTimeStampTS0
       6  TIC_GetTimeStampTS0::?relay
      17  TIC_GetTimer
       6  TIC_GetTimer::?relay
      10  TIC_GetUptime
       6  TIC_GetUptime::?relay
     286  TIC_HW_Timer_IRQ
       6  TIC_HW_Timer_IRQ::?relay
      20  TIC_Init
       6  TIC_Init::?relay
      10  TIC_Reset
       6  TIC_Reset::?relay
      24  TIC_SetNonce
       6  TIC_SetNonce::?relay
      38  TIC_SetRTC
       6  TIC_SetRTC::?relay
      69  TIC_SetRXCallback
       6  TIC_SetRXCallback::?relay
      29  TIC_SetRXState
       6  TIC_SetRXState::?relay
      66  TIC_SetSECallback
       6  TIC_SetSECallback::?relay
      69  TIC_SetSyncTimeAllocCallback
       6  TIC_SetSyncTimeAllocCallback::?relay
      69  TIC_SetTS1Callback
       6  TIC_SetTS1Callback::?relay
      68  TIC_SetTXCallback
       6  TIC_SetTXCallback::?relay
      29  TIC_SetTXState
       6  TIC_SetTXState::?relay
      71  TIC_SetTimer
       6  TIC_SetTimer::?relay
       2  TIC_SleepTime
       6  TIC_SleepTime::?relay
       0  TIC_SlotActivityTime
       6  TIC_SlotActivityTime::?relay
      18  TIC_SlotTime
       6  TIC_SlotTime::?relay
      61  TIC_TDMAShelduler
       6  TIC_TDMAShelduler::?relay
     164  TIC_TimeUsFromTS0
       6  TIC_TimeUsFromTS0::?relay
      35  TIM_TimeStamp
       6  TIM_TimeStamp::?relay
      19  TIM_copy
       6  TIM_copy::?relay
     230  TIM_delay
       6  TIM_delay::?relay
     248  TIM_init
       6  TIM_init::?relay
     136  TIM_passedTime
       6  TIM_passedTime::?relay
       2  TOFFSET
       2  TS1Callback
      50  TSStateTable
       2  TXCallback
       8  TimeStampTS0
     101  TimerCompareInterrupt
       3  TimerCompareInterrupt::??INTVEC 43
       1  U0BAUD
       1  U0CSR
       1  U0DBUF
       1  U0GCR
       1  _A_IEN0
       1  _A_IRCON
       1  _A_P1
       4  __Constant_1
       4  __Constant_15180
       4  __Constant_19833891
       4  __Constant_1f4
       4  __Constant_3d000000
       4  __Constant_3e8
       4  __Constant_447a0000
       4  __Constant_6f
       4  __Constant_7fff
       4  __Constant_8000
       4  __Constant_9
       4  __Constant_ffff8000
       4  __Constant_fffffe0c
       4  __Constant_ffffff
      97  __write
       6  __write::?relay
     162  buf
      16  default_iv
      16  default_key
     342  frame_addHeader
       6  frame_addHeader::?relay
     156  frame_create
       6  frame_create::?relay
     209  frame_delHeader
       6  frame_delHeader::?relay
      46  frame_delete
       6  frame_delete::?relay
       7  frame_getCount
       6  frame_getCount::?relay
      13  frame_len
       6  frame_len::?relay
     183  generateAuthData
       6  generateAuthData::?relay
     102  get_sync
       6  get_sync::?relay
      55  heap_ptr
       6  heap_ptr::?relay
       3  heap_size
       6  heap_size::?relay
      12  main
       6  main::?relay
      67  memory_compare
       6  memory_compare::?relay
       1  nbrTasks
      18  nwDebugerInit
       6  nwDebugerInit::?relay
       2  pACK
      14  re_free
       6  re_free::?relay
      18  re_malloc
       6  re_malloc::?relay
      25  re_memcpy
       6  re_memcpy::?relay
      64  readRandom
       6  readRandom::?relay
       4  ret_val
     114  suite_GW
       6  suite_GW::?relay
     114  suite_NODE
       6  suite_NODE::?relay
       1  tasksBLOCK
      70  umsg
       6  umsg::?relay
      37  umsg_line
       6  umsg_line::?relay
      98  umsg_summary
       6  umsg_summary::?relay
       6  utestSigTraceInit
       6  utestSigTraceInit::?relay
       4  utest_summary
       4  val
      56  xor_calc
       6  xor_calc::?relay
     505  -- Other

 
 13 287 bytes in segment BANKED_CODE
    708 bytes in segment BANK_RELAYS
      3 bytes in segment INTVEC
    101 bytes in segment NEAR_CODE
     33 bytes in segment SFR_AN
  1 566 bytes in segment XDATA_I
  1 566 bytes in segment XDATA_ID
    718 bytes in segment XDATA_Z
 
  2 313 bytes of CODE     memory (+ 65 bytes shared)
      0 bytes of DATA     memory (+ 33 bytes shared)
 13 221 bytes of HUGECODE memory (+ 66 bytes shared)
  2 228 bytes of XDATA    memory (+ 56 bytes shared)

Errors: none
Warnings: 7
